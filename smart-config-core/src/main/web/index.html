<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Smart-Config</title>
  <script type="module" crossorigin>var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_9657b14c = __commonJS({
  "index.9657b14c.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(script) {
        const fetchOpts = {};
        if (script.integrity)
          fetchOpts.integrity = script.integrity;
        if (script.referrerpolicy)
          fetchOpts.referrerPolicy = script.referrerpolicy;
        if (script.crossorigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (script.crossorigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    function makeMap(str, expectsLowerCase) {
      const map = /* @__PURE__ */ Object.create(null);
      const list = str.split(",");
      for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
      }
      return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function normalizeStyle(value) {
      if (isArray$4(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString$3(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString$3(value)) {
        return value;
      } else if (isObject$4(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:(.+)/;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$3(value)) {
        res = value;
      } else if (isArray$4(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$4(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style: style2 } = props;
      if (klass && !isString$3(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style2) {
        props.style = normalizeStyle(style2);
      }
      return props;
    }
    function looseCompareArrays(a2, b2) {
      if (a2.length !== b2.length)
        return false;
      let equal = true;
      for (let i = 0; equal && i < a2.length; i++) {
        equal = looseEqual(a2[i], b2[i]);
      }
      return equal;
    }
    function looseEqual(a2, b2) {
      if (a2 === b2)
        return true;
      let aValidType = isDate$2(a2);
      let bValidType = isDate$2(b2);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
      }
      aValidType = isSymbol$1(a2);
      bValidType = isSymbol$1(b2);
      if (aValidType || bValidType) {
        return a2 === b2;
      }
      aValidType = isArray$4(a2);
      bValidType = isArray$4(b2);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
      }
      aValidType = isObject$4(a2);
      bValidType = isObject$4(b2);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a2).length;
        const bKeysCount = Object.keys(b2).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a2) {
          const aHasKey = a2.hasOwnProperty(key);
          const bHasKey = b2.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
            return false;
          }
        }
      }
      return String(a2) === String(b2);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    const toDisplayString$1 = (val) => {
      return isString$3(val) ? val : val == null ? "" : isArray$4(val) || isObject$4(val) && (val.toString === objectToString$2 || !isFunction$4(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap$2(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
            entries[`${key} =>`] = val2;
            return entries;
          }, {})
        };
      } else if (isSet$2(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()]
        };
      } else if (isObject$4(val) && !isArray$4(val) && !isPlainObject$2(val)) {
        return String(val);
      }
      return val;
    };
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO = () => false;
    const onRE = /^on[^a-z]/;
    const isOn = (key) => onRE.test(key);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend$1 = Object.assign;
    const remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    const hasOwnProperty$e = Object.prototype.hasOwnProperty;
    const hasOwn$1 = (val, key) => hasOwnProperty$e.call(val, key);
    const isArray$4 = Array.isArray;
    const isMap$2 = (val) => toTypeString$1(val) === "[object Map]";
    const isSet$2 = (val) => toTypeString$1(val) === "[object Set]";
    const isDate$2 = (val) => toTypeString$1(val) === "[object Date]";
    const isFunction$4 = (val) => typeof val === "function";
    const isString$3 = (val) => typeof val === "string";
    const isSymbol$1 = (val) => typeof val === "symbol";
    const isObject$4 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return isObject$4(val) && isFunction$4(val.then) && isFunction$4(val.catch);
    };
    const objectToString$2 = Object.prototype.toString;
    const toTypeString$1 = (value) => objectToString$2.call(value);
    const toRawType = (value) => {
      return toTypeString$1(value).slice(8, -1);
    };
    const isPlainObject$2 = (val) => toTypeString$1(val) === "[object Object]";
    const isIntegerKey = (key) => isString$3(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn2) => {
      const cache2 = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache2[str];
        return hit || (cache2[str] = fn2(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
    const capitalize$1 = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
    const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize$1(str)}` : ``);
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
      }
    };
    const def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    const toNumber$1 = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    let _globalThis$1;
    const getGlobalThis$1 = () => {
      return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.active = true;
        this.effects = [];
        this.cleanups = [];
        if (!detached && activeEffectScope) {
          this.parent = activeEffectScope;
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
      }
      run(fn2) {
        if (this.active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn2();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      on() {
        activeEffectScope = this;
      }
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this.active) {
          let i, l2;
          for (i = 0, l2 = this.effects.length; i < l2; i++) {
            this.effects[i].stop();
          }
          for (i = 0, l2 = this.cleanups.length; i < l2; i++) {
            this.cleanups[i]();
          }
          if (this.scopes) {
            for (i = 0, l2 = this.scopes.length; i < l2; i++) {
              this.scopes[i].stop(true);
            }
          }
          if (this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.active = false;
        }
      }
    }
    function effectScope(detached) {
      return new EffectScope(detached);
    }
    function recordEffectScope(effect, scope = activeEffectScope) {
      if (scope && scope.active) {
        scope.effects.push(effect);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    function onScopeDispose(fn2) {
      if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn2);
      }
    }
    const createDep = (effects) => {
      const dep = new Set(effects);
      dep.w = 0;
      dep.n = 0;
      return dep;
    };
    const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
    const newTracked = (dep) => (dep.n & trackOpBit) > 0;
    const initDepMarkers = ({ deps }) => {
      if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
          deps[i].w |= trackOpBit;
        }
      }
    };
    const finalizeDepMarkers = (effect) => {
      const { deps } = effect;
      if (deps.length) {
        let ptr = 0;
        for (let i = 0; i < deps.length; i++) {
          const dep = deps[i];
          if (wasTracked(dep) && !newTracked(dep)) {
            dep.delete(effect);
          } else {
            deps[ptr++] = dep;
          }
          dep.w &= ~trackOpBit;
          dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
      }
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    let effectTrackDepth = 0;
    let trackOpBit = 1;
    const maxMarkerBits = 30;
    let activeEffect;
    const ITERATE_KEY = Symbol("");
    const MAP_KEY_ITERATE_KEY = Symbol("");
    class ReactiveEffect {
      constructor(fn2, scheduler = null, scope) {
        this.fn = fn2;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = void 0;
        recordEffectScope(this, scope);
      }
      run() {
        if (!this.active) {
          return this.fn();
        }
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while (parent) {
          if (parent === this) {
            return;
          }
          parent = parent.parent;
        }
        try {
          this.parent = activeEffect;
          activeEffect = this;
          shouldTrack = true;
          trackOpBit = 1 << ++effectTrackDepth;
          if (effectTrackDepth <= maxMarkerBits) {
            initDepMarkers(this);
          } else {
            cleanupEffect(this);
          }
          return this.fn();
        } finally {
          if (effectTrackDepth <= maxMarkerBits) {
            finalizeDepMarkers(this);
          }
          trackOpBit = 1 << --effectTrackDepth;
          activeEffect = this.parent;
          shouldTrack = lastShouldTrack;
          this.parent = void 0;
          if (this.deferStop) {
            this.stop();
          }
        }
      }
      stop() {
        if (activeEffect === this) {
          this.deferStop = true;
        } else if (this.active) {
          cleanupEffect(this);
          if (this.onStop) {
            this.onStop();
          }
          this.active = false;
        }
      }
    }
    function cleanupEffect(effect) {
      const { deps } = effect;
      if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
          deps[i].delete(effect);
        }
        deps.length = 0;
      }
    }
    let shouldTrack = true;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function track(target, type2, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep());
        }
        trackEffects(dep);
      }
    }
    function trackEffects(dep, debuggerEventExtraInfo) {
      let shouldTrack2 = false;
      if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
          dep.n |= trackOpBit;
          shouldTrack2 = !wasTracked(dep);
        }
      } else {
        shouldTrack2 = !dep.has(activeEffect);
      }
      if (shouldTrack2) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
      }
    }
    function trigger(target, type2, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type2 === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && isArray$4(target)) {
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 >= newValue) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type2) {
          case "add":
            if (!isArray$4(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$2(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$4(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$2(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap$2(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      if (deps.length === 1) {
        if (deps[0]) {
          {
            triggerEffects(deps[0]);
          }
        }
      } else {
        const effects = [];
        for (const dep of deps) {
          if (dep) {
            effects.push(...dep);
          }
        }
        {
          triggerEffects(createDep(effects));
        }
      }
    }
    function triggerEffects(dep, debuggerEventExtraInfo) {
      const effects = isArray$4(dep) ? dep : [...dep];
      for (const effect of effects) {
        if (effect.computed) {
          triggerEffect(effect);
        }
      }
      for (const effect of effects) {
        if (!effect.computed) {
          triggerEffect(effect);
        }
      }
    }
    function triggerEffect(effect, debuggerEventExtraInfo) {
      if (effect !== activeEffect || effect.allowRecurse) {
        if (effect.scheduler) {
          effect.scheduler();
        } else {
          effect.run();
        }
      }
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
    );
    const get$1 = /* @__PURE__ */ createGetter();
    const shallowGet = /* @__PURE__ */ createGetter(false, true);
    const readonlyGet = /* @__PURE__ */ createGetter(true);
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i = 0, l2 = this.length; i < l2; i++) {
            track(arr, "get", i + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          const res = toRaw(this)[key].apply(this, args);
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function createGetter(isReadonly2 = false, shallow = false) {
      return function get2(target, key, receiver) {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return shallow;
        } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
          return target;
        }
        const targetIsArray = isArray$4(target);
        if (!isReadonly2 && targetIsArray && hasOwn$1(arrayInstrumentations, key)) {
          return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (shallow) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$4(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      };
    }
    const set$1 = /* @__PURE__ */ createSetter();
    const shallowSet = /* @__PURE__ */ createSetter(true);
    function createSetter(shallow = false) {
      return function set2(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
          return false;
        }
        if (!shallow) {
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$4(target) && isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          }
        }
        const hadKey = isArray$4(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value);
          }
        }
        return result;
      };
    }
    function deleteProperty(target, key) {
      const hadKey = hasOwn$1(target, key);
      target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    function has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    function ownKeys(target) {
      track(target, "iterate", isArray$4(target) ? "length" : ITERATE_KEY);
      return Reflect.ownKeys(target);
    }
    const mutableHandlers = {
      get: get$1,
      set: set$1,
      deleteProperty,
      has,
      ownKeys
    };
    const readonlyHandlers = {
      get: readonlyGet,
      set(target, key) {
        return true;
      },
      deleteProperty(target, key) {
        return true;
      }
    };
    const shallowReactiveHandlers = /* @__PURE__ */ extend$1({}, mutableHandlers, {
      get: shallowGet,
      set: shallowSet
    });
    const toShallow = (value) => value;
    const getProto = (v2) => Reflect.getPrototypeOf(v2);
    function get$1$1(target, key, isReadonly2 = false, isShallow2 = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (key !== rawKey) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has$1(key, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (key !== rawKey) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto = getProto(target);
      const hadKey = proto.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
      }
      return this;
    }
    function set$1$1(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      const oldValue = get2.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      get2 ? get2.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const result = target.clear();
      if (hadItems) {
        trigger(target, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach2(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method2, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap$2(rawTarget);
        const isPair = method2 === "entries" || method2 === Symbol.iterator && targetIsMap;
        const isKeyOnly = method2 === "keys" && targetIsMap;
        const innerIterator = target[method2](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        return {
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type2) {
      return function(...args) {
        return type2 === "delete" ? false : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get$1$1(this, key);
        },
        get size() {
          return size(this);
        },
        has: has$1,
        add,
        set: set$1$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get$1$1(this, key, false, true);
        },
        get size() {
          return size(this);
        },
        has: has$1,
        add,
        set: set$1$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get$1$1(this, key, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get$1$1(this, key, true, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
      iteratorMethods.forEach((method2) => {
        mutableInstrumentations2[method2] = createIterableMethod(method2, false, false);
        readonlyInstrumentations2[method2] = createIterableMethod(method2, true, false);
        shallowInstrumentations2[method2] = createIterableMethod(method2, false, true);
        shallowReadonlyInstrumentations2[method2] = createIterableMethod(method2, true, true);
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(hasOwn$1(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
    }
    function shallowReactive(target) {
      return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
    }
    function readonly(target) {
      return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$4(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return isReactive(value) || isReadonly(value);
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      def(value, "__v_skip", true);
      return value;
    }
    const toReactive = (value) => isObject$4(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$4(value) ? readonly(value) : value;
    function trackRefValue(ref2) {
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        {
          trackEffects(ref2.dep || (ref2.dep = createDep()));
        }
      }
    }
    function triggerRefValue(ref2, newVal) {
      ref2 = toRaw(ref2);
      if (ref2.dep) {
        {
          triggerEffects(ref2.dep);
        }
      }
    }
    function isRef(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
          this._rawValue = newVal;
          this._value = useDirectValue ? newVal : toReactive(newVal);
          triggerRefValue(this);
        }
      }
    }
    function triggerRef(ref2) {
      triggerRefValue(ref2);
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    function toRefs(object2) {
      const ret = isArray$4(object2) ? new Array(object2.length) : {};
      for (const key in object2) {
        ret[key] = toRef(object2, key);
      }
      return ret;
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
    }
    function toRef(object2, key, defaultValue) {
      const val = object2[key];
      return isRef(val) ? val : new ObjectRefImpl(object2, key, defaultValue);
    }
    var _a$1;
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this[_a$1] = false;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, () => {
          if (!this._dirty) {
            this._dirty = true;
            triggerRefValue(this);
          }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        trackRefValue(self2);
        if (self2._dirty || !self2._cacheable) {
          self2._dirty = false;
          self2._value = self2.effect.run();
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
    }
    _a$1 = "__v_isReadonly";
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$4(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    const stack = [];
    function warn$1(msg, ...args) {
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(appWarnHandler, instance, 11, [
          msg + args.join(""),
          instance && instance.proxy,
          trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
          trace
        ]);
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i) => {
        logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
      const close2 = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close2] : [open + close2];
    }
    function formatProps(props) {
      const res = [];
      const keys2 = Object.keys(props);
      keys2.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys2.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString$3(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$4(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function callWithErrorHandling(fn2, instance, type2, args) {
      let res;
      try {
        res = args ? fn2(...args) : fn2();
      } catch (err) {
        handleError(err, instance, type2);
      }
      return res;
    }
    function callWithAsyncErrorHandling(fn2, instance, type2, args) {
      if (isFunction$4(fn2)) {
        const res = callWithErrorHandling(fn2, instance, type2, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type2);
          });
        }
        return res;
      }
      const values = [];
      for (let i = 0; i < fn2.length; i++) {
        values.push(callWithAsyncErrorHandling(fn2[i], instance, type2, args));
      }
      return values;
    }
    function handleError(err, instance, type2, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = type2;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i = 0; i < errorCapturedHooks.length; i++) {
              if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
          return;
        }
      }
      logError(err, type2, contextVNode, throwInDev);
    }
    function logError(err, type2, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn2) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
    }
    function findInsertionIndex(id2) {
      let start = flushIndex + 1;
      let end2 = queue.length;
      while (start < end2) {
        const middle = start + end2 >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id2 ? start = middle + 1 : end2 = middle;
      }
      return start;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i = queue.indexOf(job);
      if (i > flushIndex) {
        queue.splice(i, 1);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$4(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
          pendingPostFlushCbs.push(cb);
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
      for (; i < queue.length; i++) {
        const cb = queue[i];
        if (cb && cb.pre) {
          queue.splice(i, 1);
          i--;
          cb();
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        activePostFlushCbs.sort((a2, b2) => getId(a2) - getId(b2));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    const comparator = (a2, b2) => {
      const diff = getId(a2) - getId(b2);
      if (diff === 0) {
        if (a2.pre && !b2.pre)
          return -1;
        if (b2.pre && !a2.pre)
          return 1;
      }
      return diff;
    };
    function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      queue.sort(comparator);
      const check = NOOP;
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (false)
              ;
            callWithErrorHandling(job, null, 14);
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    function emit$1(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modelArg = isModelListener2 && event.slice(7);
      if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number: number2, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
        if (trim2) {
          args = rawArgs.map((a2) => a2.trim());
        }
        if (number2) {
          args = rawArgs.map(toNumber$1);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(handler, instance, 6, args);
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6, args);
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache2 = appContext.emitsCache;
      const cached = cache2.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$4(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend$1(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$4(comp)) {
          cache2.set(comp, null);
        }
        return null;
      }
      if (isArray$4(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend$1(normalized, raw);
      }
      if (isObject$4(comp)) {
        cache2.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx)
        return fn2;
      if (fn2._n) {
        return fn2;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        const res = fn2(...args);
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render: render2, renderCache, data, setupState, ctx, inheritAttrs } = instance;
      let result;
      let fallthroughAttrs;
      const prev = setCurrentRenderingInstance(instance);
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          result = normalizeVNode(render2.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
          fallthroughAttrs = attrs;
        } else {
          const render3 = Component;
          if (false)
            ;
          result = normalizeVNode(render3.length > 1 ? render3(props, false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit
          } : { attrs, slots, emit }) : render3(props, null));
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root2 = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
            }
            root2 = cloneVNode(root2, fallthroughAttrs);
          }
        }
      }
      if (vnode.dirs) {
        root2 = cloneVNode(root2);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        root2.transition = vnode.transition;
      }
      {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component: component2 } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component2.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i = 0; i < dynamicProps.length; i++) {
            const key = dynamicProps[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      }
    }
    const isSuspense = (type2) => type2.__isSuspense;
    function queueEffectWithSuspense(fn2, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$4(fn2)) {
          suspense.effects.push(...fn2);
        } else {
          suspense.effects.push(fn2);
        }
      } else {
        queuePostFlushCb(fn2);
      }
    }
    function provide(key, value) {
      if (!currentInstance)
        ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance) {
        const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$4(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
        } else
          ;
      }
    }
    function watchEffect(effect, options) {
      return doWatch(effect, null, options);
    }
    const INITIAL_WATCHER_VALUE = {};
    function watch(source, cb, options) {
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
      const instance = currentInstance;
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => source;
        deep = true;
      } else if (isArray$4(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
        getter = () => source.map((s2) => {
          if (isRef(s2)) {
            return s2.value;
          } else if (isReactive(s2)) {
            return traverse(s2);
          } else if (isFunction$4(s2)) {
            return callWithErrorHandling(s2, instance, 2);
          } else
            ;
        });
      } else if (isFunction$4(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(source, instance, 2);
        } else {
          getter = () => {
            if (instance && instance.isUnmounted) {
              return;
            }
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn2) => {
        cleanup = effect.onStop = () => {
          callWithErrorHandling(fn2, instance, 4);
        };
      };
      if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        return NOOP;
      }
      let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect.active) {
          return;
        }
        if (cb) {
          const newValue = effect.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i) => hasChanged(v2, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler = () => queueJob(job);
      }
      const effect = new ReactiveEffect(getter, scheduler);
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
      } else {
        effect.run();
      }
      return () => {
        effect.stop();
        if (instance && instance.scope) {
          remove(instance.scope.effects, effect);
        }
      };
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$3(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$4(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const cur = currentInstance;
      setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      if (cur) {
        setCurrentInstance(cur);
      } else {
        unsetCurrentInstance();
      }
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
          cur = cur[segments[i]];
        }
        return cur;
      };
    }
    function traverse(value, seen) {
      if (!isObject$4(value) || value["__v_skip"]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      if (isRef(value)) {
        traverse(value.value, seen);
      } else if (isArray$4(value)) {
        for (let i = 0; i < value.length; i++) {
          traverse(value[i], seen);
        }
      } else if (isSet$2(value) || isMap$2(value)) {
        value.forEach((v2) => {
          traverse(v2, seen);
        });
      } else if (isPlainObject$2(value)) {
        for (const key in value) {
          traverse(value[key], seen);
        }
      }
      return value;
    }
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
      },
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          let child = children[0];
          if (children.length > 1) {
            for (const c2 of children) {
              if (c2.type !== Comment) {
                child = c2;
                break;
              }
            }
          }
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getKeepAliveChild(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          let transitionKeyChanged = false;
          const { getTransitionKey } = innerChild.type;
          if (getTransitionKey) {
            const key = getTransitionKey();
            if (prevTransitionKey === void 0) {
              prevTransitionKey = key;
            } else if (key !== prevTransitionKey) {
              prevTransitionKey = key;
              transitionKeyChanged = true;
            }
          }
          if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
            const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in") {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                instance.update();
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el._leaveCb = () => {
                  earlyRemove();
                  el._leaveCb = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child;
        };
      }
    };
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance) {
      const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(hook, instance, 9, args);
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$4(hook)) {
          if (hook.every((hook2) => hook2.length <= 1))
            done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el._leaveCb) {
            el._leaveCb(true);
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
            leavingVNode.el._leaveCb();
          }
          callHook2(hook, [el]);
        },
        enter(el) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el._enterCb = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el._enterCb = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove2) {
          const key2 = String(vnode.key);
          if (el._enterCb) {
            el._enterCb(true);
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el._leaveCb = (cancelled) => {
            if (called)
              return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el._leaveCb = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          return resolveTransitionHooks(vnode2, props, state, instance);
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getKeepAliveChild(vnode) {
      return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
          if (child.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
          ret[i].patchFlag = -2;
        }
      }
      return ret;
    }
    function defineComponent(options) {
      return isFunction$4(options) ? { setup: options, name: options.name } : options;
    }
    const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type2, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type2, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type2, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
      const injected = injectHook(type2, hook, keepAliveRoot, true);
      onUnmounted(() => {
        remove(keepAliveRoot[type2], injected);
      }, target);
    }
    function injectHook(type2, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type2] || (target[type2] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          if (target.isUnmounted) {
            return;
          }
          pauseTracking();
          setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type2, args);
          unsetCurrentInstance();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook("bu");
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook("bum");
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook("sp");
    const onRenderTriggered = createHook("rtg");
    const onRenderTracked = createHook("rtc");
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    function withDirectives(vnode, directives) {
      const internalInstance = currentRenderingInstance;
      if (internalInstance === null) {
        return vnode;
      }
      const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
        if (isFunction$4(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
          binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const COMPONENTS = "components";
    const DIRECTIVES = "directives";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol();
    function resolveDynamicComponent(component2) {
      if (isString$3(component2)) {
        return resolveAsset(COMPONENTS, component2, false) || component2;
      } else {
        return component2 || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
    }
    function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type2 === COMPONENTS) {
          const selfName = getComponentName(Component, false);
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
            return Component;
          }
        }
        const res = resolve(instance[type2] || Component[type2], name) || resolve(instance.appContext[type2], name);
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
    }
    function renderList(source, renderItem, cache2, index2) {
      let ret;
      const cached = cache2 && cache2[index2];
      if (isArray$4(source) || isString$3(source)) {
        ret = new Array(source.length);
        for (let i = 0, l2 = source.length; i < l2; i++) {
          ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
          ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
        }
      } else if (isObject$4(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(source, (item, i) => renderItem(item, i, void 0, cached && cached[i]));
        } else {
          const keys2 = Object.keys(source);
          ret = new Array(keys2.length);
          for (let i = 0, l2 = keys2.length; i < l2; i++) {
            const key = keys2[i];
            ret[i] = renderItem(source[key], key, i, cached && cached[i]);
          }
        }
      } else {
        ret = [];
      }
      if (cache2) {
        cache2[index2] = ret;
      }
      return ret;
    }
    function createSlots(slots, dynamicSlots) {
      for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        if (isArray$4(slot)) {
          for (let j = 0; j < slot.length; j++) {
            slots[slot[j].name] = slot[j].fn;
          }
        } else if (slot) {
          slots[slot.name] = slot.key ? (...args) => {
            const res = slot.fn(...args);
            res.key = slot.key;
            return res;
          } : slot.fn;
        }
      }
      return slots;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        return createVNode("slot", name === "default" ? null : { name }, fallback && fallback());
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const rendered = createBlock(Fragment, {
        key: props.key || validSlotContent && validSlotContent.key || `_${name}`
      }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode$1(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    function toHandlers(obj, preserveCaseIfNecessary) {
      const ret = {};
      for (const key in obj) {
        ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
      }
      return ret;
    }
    const getPublicInstance = (i) => {
      if (!i)
        return null;
      if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
      return getPublicInstance(i.parent);
    };
    const publicPropertiesMap = /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => i.props,
      $attrs: (i) => i.attrs,
      $slots: (i) => i.slots,
      $refs: (i) => i.refs,
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $emit: (i) => i.emit,
      $options: (i) => resolveMergedOptions(i),
      $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
      $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: (i) => instanceWatch.bind(i)
    });
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (setupState !== EMPTY_OBJ && hasOwn$1(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if ((cssModule = type2.__cssModules) && (cssModule = cssModule[key])) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)) {
          {
            return globalProperties[key];
          }
        } else
          ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (setupState !== EMPTY_OBJ && hasOwn$1(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn$1(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$1(data, key) || setupState !== EMPTY_OBJ && hasOwn$1(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn$1(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render: render2,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        expose,
        inheritAttrs,
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$4(methodHandler)) {
            {
              ctx[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$4(data))
          ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$4(opt) ? opt.bind(publicThis, publicThis) : isFunction$4(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set2 = !isFunction$4(opt) && isFunction$4(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c2 = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c2.value,
            set: (v2) => c2.value = v2
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$4(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$4(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$4(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render2 && instance.render === NOOP) {
        instance.render = render2;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components)
        instance.components = components;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
      if (isArray$4(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$4(opt)) {
          if ("default" in opt) {
            injected = inject(opt.from || key, opt.default, true);
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          if (unwrapRef) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => injected.value,
              set: (v2) => injected.value = v2
            });
          } else {
            ctx[key] = injected;
          }
        } else {
          ctx[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type2) {
      callWithAsyncErrorHandling(isArray$4(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type2);
    }
    function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString$3(raw)) {
        const handler = ctx[raw];
        if (isFunction$4(handler)) {
          watch(getter, handler);
        }
      } else if (isFunction$4(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (isObject$4(raw)) {
        if (isArray$4(raw)) {
          raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
          const handler = isFunction$4(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$4(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else
        ;
    }
    function resolveMergedOptions(instance) {
      const base2 = instance.type;
      const { mixins, extends: extendsOptions } = base2;
      const { mixins: globalMixins, optionsCache: cache2, config: { optionMergeStrategies } } = instance.appContext;
      const cached = cache2.get(base2);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base2;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach((m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true));
        }
        mergeOptions$1(resolved, base2, optionMergeStrategies);
      }
      if (isObject$4(base2)) {
        cache2.set(base2, resolved);
      }
      return resolved;
    }
    function mergeOptions$1(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions$1(to, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach((m2) => mergeOptions$1(to, m2, strats, true));
      }
      for (const key in from) {
        if (asMixin && key === "expose")
          ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
      }
      return to;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeObjectOptions,
      emits: mergeObjectOptions,
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      watch: mergeWatchOptions,
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to, from) {
      if (!from) {
        return to;
      }
      if (!to) {
        return from;
      }
      return function mergedDataFn() {
        return extend$1(isFunction$4(to) ? to.call(this, this) : to, isFunction$4(from) ? from.call(this, this) : from);
      };
    }
    function mergeInject(to, from) {
      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$4(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
          res[raw[i]] = raw[i];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
    }
    function mergeObjectOptions(to, from) {
      return to ? extend$1(extend$1(/* @__PURE__ */ Object.create(null), to), from) : from;
    }
    function mergeWatchOptions(to, from) {
      if (!to)
        return from;
      if (!from)
        return to;
      const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
      for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
      }
      return merged;
    }
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = {};
      def(attrs, InternalObjectKey, 1);
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const { props, attrs, vnode: { patchFlag } } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            let key = propsToUpdate[i];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn$1(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || !hasOwn$1(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn$1(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance, "set", "$attrs");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn$1(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
          const key = needCastKeys[i];
          props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn$1(castValues, key));
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent2) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn$1(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && isFunction$4(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(null, props);
              unsetCurrentInstance();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[0]) {
          if (isAbsent2 && !hasDefault) {
            value = false;
          } else if (opt[1] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache2 = appContext.propsCache;
      const cached = cache2.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$4(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend$1(normalized, props);
          if (keys2)
            needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$4(comp)) {
          cache2.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$4(raw)) {
        for (let i = 0; i < raw.length; i++) {
          const normalizedKey = camelize(raw[i]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$4(opt) || isFunction$4(opt) ? { type: opt } : opt;
            if (prop) {
              const booleanIndex = getTypeIndex(Boolean, prop.type);
              const stringIndex = getTypeIndex(String, prop.type);
              prop[0] = booleanIndex > -1;
              prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
              if (booleanIndex > -1 || hasOwn$1(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$4(comp)) {
        cache2.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$") {
        return true;
      }
      return false;
    }
    function getType(ctor) {
      const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
      return match ? match[1] : ctor === null ? "null" : "";
    }
    function isSameType(a2, b2) {
      return getType(a2) === getType(b2);
    }
    function getTypeIndex(type2, expectedTypes) {
      if (isArray$4(expectedTypes)) {
        return expectedTypes.findIndex((t) => isSameType(t, type2));
      } else if (isFunction$4(expectedTypes)) {
        return isSameType(expectedTypes, type2) ? 0 : -1;
      }
      return -1;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$4(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (isFunction$4(value)) {
          slots[key] = normalizeSlot(key, value, ctx);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const initSlots = (instance, children) => {
      if (instance.vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          instance.slots = toRaw(children);
          def(children, "_", type2);
        } else {
          normalizeObjectSlots(children, instance.slots = {});
        }
      } else {
        instance.slots = {};
        if (children) {
          normalizeVNodeSlots(instance, children);
        }
      }
      def(instance.slots, InternalObjectKey, 1);
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type2 = children._;
        if (type2) {
          if (optimized && type2 === 1) {
            needDeletionCheck = false;
          } else {
            extend$1(slots, children);
            if (!optimized && type2 === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
            delete slots[key];
          }
        }
      }
    };
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render2, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$4(rootComponent)) {
          rootComponent = Object.assign({}, rootComponent);
        }
        if (rootProps != null && !isObject$4(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new Set();
        let isMounted = false;
        const app2 = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version: version$1,
          get config() {
            return context.config;
          },
          set config(v2) {
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin))
              ;
            else if (plugin && isFunction$4(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app2, ...options);
            } else if (isFunction$4(plugin)) {
              installedPlugins.add(plugin);
              plugin(app2, ...options);
            } else
              ;
            return app2;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app2;
          },
          component(name, component2) {
            if (!component2) {
              return context.components[name];
            }
            context.components[name] = component2;
            return app2;
          },
          directive(name, directive) {
            if (!directive) {
              return context.directives[name];
            }
            context.directives[name] = directive;
            return app2;
          },
          mount(rootContainer, isHydrate, isSVG) {
            if (!isMounted) {
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (isHydrate && hydrate) {
                hydrate(vnode, rootContainer);
              } else {
                render2(vnode, rootContainer, isSVG);
              }
              isMounted = true;
              app2._container = rootContainer;
              rootContainer.__vue_app__ = app2;
              return getExposeProxy(vnode.component) || vnode.component.proxy;
            }
          },
          unmount() {
            if (isMounted) {
              render2(null, app2._container);
              delete app2._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app2;
          }
        };
        return app2;
      };
    }
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$4(rawRef)) {
        rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray$4(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref2 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref2) {
        if (isString$3(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn$1(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$4(ref2)) {
        callWithErrorHandling(ref2, owner, 12, [value, refs]);
      } else {
        const _isString = isString$3(ref2);
        const _isRef = isRef(ref2);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? refs[ref2] : ref2.value;
              if (isUnmount) {
                isArray$4(existing) && remove(existing, refValue);
              } else {
                if (!isArray$4(existing)) {
                  if (_isString) {
                    refs[ref2] = [refValue];
                    if (hasOwn$1(setupState, ref2)) {
                      setupState[ref2] = refs[ref2];
                    }
                  } else {
                    ref2.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref2.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref2] = value;
              if (hasOwn$1(setupState, ref2)) {
                setupState[ref2] = value;
              }
            } else if (_isRef) {
              ref2.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else
              ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis$1();
      target.__VUE__ = true;
      const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type: type2, ref: ref2, shapeFlag } = n2;
        switch (type2) {
          case Text:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, isSVG);
            }
            break;
          case Fragment:
            processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            break;
          default:
            if (shapeFlag & 1) {
              processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else if (shapeFlag & 6) {
              processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else if (shapeFlag & 64) {
              type2.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
            } else if (shapeFlag & 128) {
              type2.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
            } else
              ;
        }
        if (ref2 != null && parentComponent) {
          setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, isSVG) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        isSVG = isSVG || n2.type === "svg";
        if (n1 == null) {
          mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { type: type2, props, shapeFlag, transition, patchFlag, dirs } = vnode;
        if (vnode.el && hostCloneNode !== void 0 && patchFlag === -1) {
          el = vnode.el = hostCloneNode(vnode.el);
        } else {
          el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
          if (shapeFlag & 8) {
            hostSetElementText(el, vnode.children);
          } else if (shapeFlag & 16) {
            mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type2 !== "foreignObject", slotScopeIds, optimized);
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          if (props) {
            for (const key in props) {
              if (key !== "value" && !isReservedProp(key)) {
                hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
            if ("value" in props) {
              hostPatchProp(el, "value", null, props.value);
            }
            if (vnodeHook = props.onVnodeBeforeMount) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
          }
          setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i = 0; i < slotScopeIds.length; i++) {
            hostSetScopeId(el, slotScopeIds[i]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
          const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
          patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        const areChildrenSVG = isSVG && n2.type !== "foreignObject";
        if (dynamicChildren) {
          patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
        } else if (!optimized) {
          patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, isSVG);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
          const oldVNode = oldChildren[i];
          const newVNode = newChildren[i];
          const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
          patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
      };
      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
        if (oldProps !== newProps) {
          for (const key in newProps) {
            if (isReservedProp(key))
              continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
            if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
              traverseStaticChildren(n1, n2, true);
            }
          } else {
            patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
          } else {
            mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
          return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m: m2, parent } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                instance.subTree = renderComponentRoot(instance);
                hydrateNode(el, instance.subTree, instance, parentSuspense, null);
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(
                  () => !instance.isUnmounted && hydrateSubTree()
                );
              } else {
                hydrateSubTree();
              }
            } else {
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
              initialVNode.el = subTree.el;
            }
            if (m2) {
              queuePostRenderEffect(m2, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u: u2, parent, vnode } = instance;
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              hostParentNode(prevTree.el),
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              isSVG
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u2) {
              queuePostRenderEffect(u2, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
            }
          }
        };
        const effect = instance.effect = new ReactiveEffect(
          componentUpdateFn,
          () => queueJob(update),
          instance.scope
        );
        const update = instance.update = () => effect.run();
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs();
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) {
          unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        } else {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i <= e1 && i <= e2) {
          const n1 = c1[i];
          const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (isSameVNodeType(n1, n2)) {
            patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else {
            break;
          }
          i++;
        }
        while (i <= e1 && i <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i > e1) {
          if (i <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i <= e2) {
              patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              i++;
            }
          }
        } else if (i > e2) {
          while (i <= e1) {
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
          }
        } else {
          const s1 = i;
          const s2 = i;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i = 0; i < toBePatched; i++)
            newIndexToOldIndexMap[i] = 0;
          for (i = s1; i <= e1; i++) {
            const prevChild = c1[i];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i] === 0) {
              patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else if (moved) {
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type: type2, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type2.move(vnode, container, anchor, internals);
          return;
        }
        if (type2 === Fragment) {
          hostInsert(el, container, anchor);
          for (let i = 0; i < children.length; i++) {
            move(children[i], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type2 === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove3 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove3();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove3, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const { type: type2, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        if (ref2 != null) {
          setRef(ref2, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
          } else if (dynamicChildren && (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
          } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type: type2, el, anchor, transition } = vnode;
        if (type2 === Fragment) {
          {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type2 === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end2) => {
        let next;
        while (cur !== end2) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end2);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, update, subTree, um } = instance;
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (update) {
          update.active = false;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
          unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        return hostNextSibling(vnode.anchor || vnode.el);
      };
      const render2 = (vnode, container, isSVG) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        }
        flushPreFlushCbs();
        flushPostFlushCbs();
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(internals);
      }
      return {
        render: render2,
        hydrate,
        createApp: createAppAPI(render2, hydrate)
      };
    }
    function toggleRecurse({ effect, update }, allowed) {
      effect.allowRecurse = update.allowRecurse = allowed;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$4(ch1) && isArray$4(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
          const c1 = ch1[i];
          let c2 = ch2[i];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i] = cloneIfMounted(ch2[i]);
              c2.el = c1.el;
            }
            if (!shallow)
              traverseStaticChildren(c1, c2);
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i, j, u2, v2, c2;
      const len = arr.length;
      for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i] = j;
            result.push(i);
            continue;
          }
          u2 = 0;
          v2 = result.length - 1;
          while (u2 < v2) {
            c2 = u2 + v2 >> 1;
            if (arr[result[c2]] < arrI) {
              u2 = c2 + 1;
            } else {
              v2 = c2;
            }
          }
          if (arrI < arr[result[u2]]) {
            if (u2 > 0) {
              p2[i] = result[u2 - 1];
            }
            result[u2] = i;
          }
        }
      }
      u2 = result.length;
      v2 = result[u2 - 1];
      while (u2-- > 0) {
        result[u2] = v2;
        v2 = p2[v2];
      }
      return result;
    }
    const isTeleport = (type2) => type2.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString$3(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target = select(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      __isTeleport: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n1 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = n2.targetAnchor = createText("");
          if (target) {
            insert(targetAnchor, target);
            isSVG = isSVG || isTargetSVG(target);
          }
          const mount = (container2, anchor2) => {
            if (shapeFlag & 16) {
              mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
          };
          if (disabled) {
            mount(container, mainAnchor);
          } else if (target) {
            mount(target, targetAnchor);
          }
        } else {
          n2.el = n1.el;
          const mainAnchor = n2.anchor = n1.anchor;
          const target = n2.target = n1.target;
          const targetAnchor = n2.targetAnchor = n1.targetAnchor;
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          isSVG = isSVG || isTargetSVG(target);
          if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(n2, container, mainAnchor, internals, 1);
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
              if (nextTarget) {
                moveTeleport(n2, nextTarget, null, internals, 0);
              }
            } else if (wasDisabled) {
              moveTeleport(n2, target, targetAnchor, internals, 1);
            }
          }
        }
      },
      remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
          hostRemove(targetAnchor);
        }
        if (doRemove || !isTeleportDisabled(props)) {
          hostRemove(anchor);
          if (shapeFlag & 16) {
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
            }
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i = 0; i < children.length; i++) {
            move(children[i], container, parentAnchor, 2);
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
      const target = vnode.target = resolveTarget(vnode.props, querySelector);
      if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (isTeleportDisabled(vnode.props)) {
            vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
            vnode.targetAnchor = targetNode;
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              targetAnchor = nextSibling(targetAnchor);
              if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        }
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    const Fragment = Symbol(void 0);
    const Text = Symbol(void 0);
    const Comment = Symbol(void 0);
    const Static = Symbol(void 0);
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(createBaseVNode(type2, props, children, patchFlag, dynamicProps, shapeFlag, true));
    }
    function createBlock(type2, props, children, patchFlag, dynamicProps) {
      return setupBlock(createVNode(type2, props, children, patchFlag, dynamicProps, true));
    }
    function isVNode$1(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      return n1.type === n2.type && n1.key === n2.key;
    }
    const InternalObjectKey = `__vInternal`;
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
      return ref2 != null ? isString$3(ref2) || isRef(ref2) || isFunction$4(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
    };
    function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type: type2,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type2.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString$3(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
        type2 = Comment;
      }
      if (isVNode$1(type2)) {
        const cloned = cloneVNode(type2, props, true);
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type2)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag |= -2;
        return cloned;
      }
      if (isClassComponent(type2)) {
        type2 = type2.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style: style2 } = props;
        if (klass && !isString$3(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$4(style2)) {
          if (isProxy(style2) && !isArray$4(style2)) {
            style2 = extend$1({}, style2);
          }
          props.style = normalizeStyle(style2);
        }
      }
      const shapeFlag = isString$3(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject$4(type2) ? 4 : isFunction$4(type2) ? 2 : 0;
      return createBaseVNode(type2, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || InternalObjectKey in props ? extend$1({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false) {
      const { props, ref: ref2, patchFlag, children } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$4(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor
      };
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$4(child)) {
        return createVNode(
          Fragment,
          null,
          child.slice()
        );
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type2 = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$4(children)) {
        type2 = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type2 = 32;
          const slotFlag = children._;
          if (!slotFlag && !(InternalObjectKey in children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$4(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type2 = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type2 = 16;
          children = [createTextVNode(children)];
        } else {
          type2 = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type2;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$4(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid$1$1 = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type2 = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid$1$1++,
        vnode,
        type: type2,
        parent,
        appContext,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new EffectScope(true),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: normalizePropsOptions(type2, appContext),
        emitsOptions: normalizeEmitsOptions(type2, appContext),
        emit: null,
        emitted: null,
        propsDefaults: EMPTY_OBJ,
        inheritAttrs: type2.inheritAttrs,
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit$1.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    const setCurrentInstance = (instance) => {
      currentInstance = instance;
      instance.scope.on();
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      currentInstance = null;
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false) {
      isInSSRComponentSetup = isSSR;
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isInSSRComponentSetup = false;
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
      const { setup } = Component;
      if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
        resetTracking();
        unsetCurrentInstance();
        if (isPromise(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$4(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$4(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else
        ;
      finishComponentSetup(instance, isSSR);
    }
    let compile;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend$1(extend$1({
              isCustomElement,
              delimiters
            }, compilerOptions), componentCompilerOptions);
            Component.render = compile(template, finalCompilerOptions);
          }
        }
        instance.render = Component.render || NOOP;
      }
      {
        setCurrentInstance(instance);
        pauseTracking();
        applyOptions(instance);
        resetTracking();
        unsetCurrentInstance();
      }
    }
    function createAttrsProxy(instance) {
      return new Proxy(instance.attrs, {
        get(target, key) {
          track(instance, "get", "$attrs");
          return target[key];
        }
      });
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      let attrs;
      {
        return {
          get attrs() {
            return attrs || (attrs = createAttrsProxy(instance));
          },
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getExposeProxy(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          }
        }));
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$4(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$4(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    };
    function useSlots() {
      return getContext().slots;
    }
    function useAttrs$1() {
      return getContext().attrs;
    }
    function getContext() {
      const i = getCurrentInstance();
      return i.setupContext || (i.setupContext = createSetupContext(i));
    }
    function h$1(type2, propsOrChildren, children) {
      const l2 = arguments.length;
      if (l2 === 2) {
        if (isObject$4(propsOrChildren) && !isArray$4(propsOrChildren)) {
          if (isVNode$1(propsOrChildren)) {
            return createVNode(type2, null, [propsOrChildren]);
          }
          return createVNode(type2, propsOrChildren);
        } else {
          return createVNode(type2, null, propsOrChildren);
        }
      } else {
        if (l2 > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l2 === 3 && isVNode$1(children)) {
          children = [children];
        }
        return createVNode(type2, propsOrChildren, children);
      }
    }
    const version$1 = "3.2.39";
    const svgNS = "http://www.w3.org/2000/svg";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, isSVG, is, props) => {
        const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id2) {
        el.setAttribute(id2, "");
      },
      cloneNode(el) {
        const cloned = el.cloneNode(true);
        if (`_value` in el) {
          cloned._value = el._value;
        }
        return cloned;
      },
      insertStaticContent(content, parent, anchor, isSVG, start, end2) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end2 || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end2 || !(start = start.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
          const template = templateContainer.content;
          if (isSVG) {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          before ? before.nextSibling : parent.firstChild,
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    function patchClass(el, value, isSVG) {
      const transitionClasses = el._vtc;
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    function patchStyle(el, prev, next) {
      const style2 = el.style;
      const isCssString = isString$3(next);
      if (next && !isCssString) {
        for (const key in next) {
          setStyle(style2, key, next[key]);
        }
        if (prev && !isString$3(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style2, key, "");
            }
          }
        }
      } else {
        const currentDisplay = style2.display;
        if (isCssString) {
          if (prev !== next) {
            style2.cssText = next;
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
        if ("_vod" in el) {
          style2.display = currentDisplay;
        }
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style2, name, val) {
      if (isArray$4(val)) {
        val.forEach((v2) => setStyle(style2, name, v2));
      } else {
        if (val == null)
          val = "";
        if (name.startsWith("--")) {
          style2.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style2, name);
          if (importantRE.test(val)) {
            style2.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
          } else {
            style2[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style2, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style2) {
        return prefixCache[rawName] = name;
      }
      name = capitalize$1(name);
      for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style2) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG, instance) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        const isBoolean2 = isSpecialBooleanAttr(key);
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(key, isBoolean2 ? "" : value);
        }
      }
    }
    function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) {
          unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? "" : value;
        return;
      }
      if (key === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
        el._value = value;
        const newValue = value == null ? "" : value;
        if (el.value !== newValue || el.tagName === "OPTION") {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type2 = typeof el[key];
        if (type2 === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type2 === "string") {
          value = "";
          needRemove = true;
        } else if (type2 === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e) {
      }
      needRemove && el.removeAttribute(key);
    }
    const [_getNow, skipTimestampCheck] = /* @__PURE__ */ (() => {
      let _getNow2 = Date.now;
      let skipTimestampCheck2 = false;
      if (typeof window !== "undefined") {
        if (Date.now() > document.createEvent("Event").timeStamp) {
          _getNow2 = performance.now.bind(performance);
        }
        const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
        skipTimestampCheck2 = !!(ffMatch && Number(ffMatch[1]) <= 53);
      }
      return [_getNow2, skipTimestampCheck2];
    })();
    let cachedNow = 0;
    const p$1 = /* @__PURE__ */ Promise.resolve();
    const reset = () => {
      cachedNow = 0;
    };
    const getNow = () => cachedNow || (p$1.then(reset), cachedNow = _getNow());
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el._vei || (el._vei = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(nextValue, instance);
          addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m2;
        while (m2 = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m2[0].length);
          options[m2[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        const timeStamp = e.timeStamp || _getNow();
        if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
          callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
        }
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$4(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map((fn2) => (e2) => !e2._stopped && fn2 && fn2(e2));
      } else {
        return value;
      }
    }
    const nativeOnRE = /^on[a-z]/;
    const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      if (key === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && nativeOnRE.test(key) && isFunction$4(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (nativeOnRE.test(key) && isString$3(value)) {
        return false;
      }
      return key in el;
    }
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const Transition = (props, { slots }) => h$1(BaseTransition, resolveTransitionProps(props), slots);
    Transition.displayName = "Transition";
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$1({}, BaseTransition.props, DOMTransitionPropsValidators);
    const callHook = (hook, args = []) => {
      if (isArray$4(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$4(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const { name = "v", type: type2, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
      const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el, isAppear, done);
          callHook(hook, [el, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el, type2, enterDuration, resolve2);
            }
          });
        };
      };
      return extend$1(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve2 = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          forceReflow();
          addTransitionClass(el, leaveActiveClass);
          nextFrame(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type2, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el, resolve2]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject$4(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber$1(val);
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
      (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
      const { _vtc } = el;
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el._vtc = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
      const id2 = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id2 === el._endId) {
          resolve2();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type: type2, timeout, propCount } = getTransitionInfo(el, expectedType);
      if (!type2) {
        return resolve2();
      }
      const endEvent = type2 + "end";
      let ended = 0;
      const end2 = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
          end2();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end2();
        }
      }, timeout + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(TRANSITION + "Delay");
      const transitionDurations = getStyleProperties(TRANSITION + "Duration");
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(ANIMATION + "Delay");
      const animationDurations = getStyleProperties(ANIMATION + "Duration");
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type2 = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type2 = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type2 = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type2 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type2 ? type2 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type2 === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + "Property"]);
      return {
        type: type2,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d2, i) => toMs(d2) + toMs(delays[i])));
    }
    function toMs(s2) {
      return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const TransitionGroupImpl = {
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c2) => {
            const el = c2.el;
            const style2 = el.style;
            addTransitionClass(el, moveClass);
            style2.transform = style2.webkitTransform = style2.transitionDuration = "";
            const cb = el._moveCb = (e) => {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener("transitionend", cb);
                el._moveCb = null;
                removeTransitionClass(el, moveClass);
              }
            };
            el.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = children;
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.key != null) {
              setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
            }
          }
          if (prevChildren) {
            for (let i = 0; i < prevChildren.length; i++) {
              const child = prevChildren[i];
              setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
              positionMap.set(child, child.el.getBoundingClientRect());
            }
          }
          return createVNode(tag, null, children);
        };
      }
    };
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c2) {
      const el = c2.el;
      if (el._moveCb) {
        el._moveCb();
      }
      if (el._enterCb) {
        el._enterCb();
      }
    }
    function recordPosition(c2) {
      newPositionMap.set(c2, c2.el.getBoundingClientRect());
    }
    function applyTranslation(c2) {
      const oldPos = positionMap.get(c2);
      const newPos = newPositionMap.get(c2);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s2 = c2.el.style;
        s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
        s2.transitionDuration = "0s";
        return c2;
      }
    }
    function hasCSSTransform(el, root2, moveClass) {
      const clone2 = el.cloneNode();
      if (el._vtc) {
        el._vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c2) => c2 && clone2.classList.remove(c2));
        });
      }
      moveClass.split(/\s+/).forEach((c2) => c2 && clone2.classList.add(c2));
      clone2.style.display = "none";
      const container = root2.nodeType === 1 ? root2 : root2.parentNode;
      container.appendChild(clone2);
      const { hasTransform } = getTransitionInfo(clone2);
      container.removeChild(clone2);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn2 = vnode.props["onUpdate:modelValue"] || false;
      return isArray$4(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const vModelText = {
      created(el, { modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number2 || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e) => {
          if (e.target.composing)
            return;
          let domValue = el.value;
          if (trim2) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = toNumber$1(domValue);
          }
          el._assign(domValue);
        });
        if (trim2) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (el.composing)
          return;
        if (document.activeElement === el && el.type !== "range") {
          if (lazy) {
            return;
          }
          if (trim2 && el.value.trim() === value) {
            return;
          }
          if ((number2 || el.type === "number") && toNumber$1(el.value) === value) {
            return;
          }
        }
        const newValue = value == null ? "" : value;
        if (el.value !== newValue) {
          el.value = newValue;
        }
      }
    };
    const vModelCheckbox = {
      deep: true,
      created(el, _2, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          const modelValue = el._modelValue;
          const elementValue = getValue$2(el);
          const checked = el.checked;
          const assign2 = el._assign;
          if (isArray$4(modelValue)) {
            const index2 = looseIndexOf(modelValue, elementValue);
            const found = index2 !== -1;
            if (checked && !found) {
              assign2(modelValue.concat(elementValue));
            } else if (!checked && found) {
              const filtered = [...modelValue];
              filtered.splice(index2, 1);
              assign2(filtered);
            }
          } else if (isSet$2(modelValue)) {
            const cloned = new Set(modelValue);
            if (checked) {
              cloned.add(elementValue);
            } else {
              cloned.delete(elementValue);
            }
            assign2(cloned);
          } else {
            assign2(getCheckboxValue(el, checked));
          }
        });
      },
      mounted: setChecked,
      beforeUpdate(el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
      }
    };
    function setChecked(el, { value, oldValue }, vnode) {
      el._modelValue = value;
      if (isArray$4(value)) {
        el.checked = looseIndexOf(value, vnode.props.value) > -1;
      } else if (isSet$2(value)) {
        el.checked = value.has(vnode.props.value);
      } else if (value !== oldValue) {
        el.checked = looseEqual(value, getCheckboxValue(el, true));
      }
    }
    const vModelRadio = {
      created(el, { value }, vnode) {
        el.checked = looseEqual(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          el._assign(getValue$2(el));
        });
      },
      beforeUpdate(el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) {
          el.checked = looseEqual(value, vnode.props.value);
        }
      }
    };
    function getValue$2(el) {
      return "_value" in el ? el._value : el.value;
    }
    function getCheckboxValue(el, checked) {
      const key = checked ? "_trueValue" : "_falseValue";
      return key in el ? el[key] : checked;
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m2) => e[`${m2}Key`] && !modifiers.includes(m2))
    };
    const withModifiers = (fn2, modifiers) => {
      return (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
          const guard = modifierGuards[modifiers[i]];
          if (guard && guard(event, modifiers))
            return;
        }
        return fn2(event, ...args);
      };
    };
    const keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    const withKeys = (fn2, modifiers) => {
      return (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
          return fn2(event);
        }
      };
    };
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    function setDisplay(el, value) {
      el.style.display = value ? el._vod : "none";
    }
    const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const render = (...args) => {
      ensureRenderer().render(...args);
    };
    const createApp = (...args) => {
      const app2 = ensureRenderer().createApp(...args);
      const { mount } = app2;
      app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component2 = app2._component;
        if (!isFunction$4(component2) && !component2.render && !component2.template) {
          component2.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app2;
    };
    function normalizeContainer(container) {
      if (isString$3(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    const style = "";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    const freeGlobal$1 = freeGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal$1 || freeSelf || Function("return this")();
    const root$1 = root;
    var Symbol$1 = root$1.Symbol;
    const Symbol$2 = Symbol$1;
    var objectProto$e = Object.prototype;
    var hasOwnProperty$d = objectProto$e.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$e.toString;
    var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$d.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$d = Object.prototype;
    var nativeObjectToString = objectProto$d.toString;
    function objectToString$1(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var symbolTag$3 = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
    }
    function arrayMap(array2, iteratee) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    var isArray$2 = Array.isArray;
    const isArray$3 = isArray$2;
    var INFINITY$3 = 1 / 0;
    var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray$3(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
    }
    var reWhitespace = /\s/;
    function trimmedEndIndex(string2) {
      var index2 = string2.length;
      while (index2-- && reWhitespace.test(string2.charAt(index2))) {
      }
      return index2;
    }
    var reTrimStart = /^\s+/;
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
    }
    function isObject$3(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject$3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject$3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function identity$1(value) {
      return value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction$3(value) {
      if (!isObject$3(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root$1["__core-js_shared__"];
    const coreJsData$1 = coreJsData;
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$1 = Function.prototype;
    var funcToString$1 = funcProto$1.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype, objectProto$c = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$c = objectProto$c.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty$c).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject$3(value) || isMasked(value)) {
        return false;
      }
      var pattern2 = isFunction$3(value) ? reIsNative : reIsHostCtor;
      return pattern2.test(toSource(value));
    }
    function getValue$1(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function getNative(object2, key) {
      var value = getValue$1(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var WeakMap$1 = getNative(root$1, "WeakMap");
    const WeakMap$2 = WeakMap$1;
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object2() {
      }
      return function(proto) {
        if (!isObject$3(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object2.prototype = proto;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    const baseCreate$1 = baseCreate;
    function apply$1(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function noop$2() {
    }
    function copyArray(source, array2) {
      var index2 = -1, length = source.length;
      array2 || (array2 = Array(length));
      while (++index2 < length) {
        array2[index2] = source[index2];
      }
      return array2;
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    const defineProperty$1 = defineProperty;
    var baseSetToString = !defineProperty$1 ? identity$1 : function(func, string2) {
      return defineProperty$1(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    const baseSetToString$1 = baseSetToString;
    var setToString = shortOut(baseSetToString$1);
    const setToString$1 = setToString;
    function arrayEach(array2, iteratee) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (iteratee(array2[index2], index2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    function baseFindIndex(array2, predicate, fromIndex, fromRight) {
      var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array2[index2], index2, array2)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function strictIndexOf(array2, value, fromIndex) {
      var index2 = fromIndex - 1, length = array2.length;
      while (++index2 < length) {
        if (array2[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array2, value, fromIndex) {
      return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    function arrayIncludes(array2, value) {
      var length = array2 == null ? 0 : array2.length;
      return !!length && baseIndexOf(array2, value, 0) > -1;
    }
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type2 = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty$1) {
        defineProperty$1(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$b = Object.prototype;
    var hasOwnProperty$b = objectProto$b.hasOwnProperty;
    function assignValue(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty$b.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function copyObject(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index2 = -1, length = props.length;
      while (++index2 < length) {
        var key = props[index2];
        var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object2, key, newValue);
        } else {
          assignValue(object2, key, newValue);
        }
      }
      return object2;
    }
    var nativeMax$1 = Math.max;
    function overRest(func, start, transform2) {
      start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index2 = -1, length = nativeMax$1(args.length - start, 0), array2 = Array(length);
        while (++index2 < length) {
          array2[index2] = args[start + index2];
        }
        index2 = -1;
        var otherArgs = Array(start + 1);
        while (++index2 < start) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start] = transform2(array2);
        return apply$1(func, this, otherArgs);
      };
    }
    function baseRest(func, start) {
      return setToString$1(overRest(func, start, identity$1), func + "");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction$3(value);
    }
    var objectProto$a = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
      return value === proto;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    var argsTag$3 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$3;
    }
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$a = objectProto$9.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$a.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    const isArguments$1 = isArguments;
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0;
    var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
    var isBuffer$1 = nativeIsBuffer || stubFalse;
    const isBuffer$2 = isBuffer$1;
    var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
    var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal$1.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    const nodeUtil$1 = nodeUtil;
    var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
    var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    const isTypedArray$2 = isTypedArray$1;
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$9 = objectProto$8.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray$3(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$9.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    var nativeKeys = overArg(Object.keys, Object);
    const nativeKeys$1 = nativeKeys;
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$8 = objectProto$7.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys$1(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty$8.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function nativeKeysIn(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$7 = objectProto$6.hasOwnProperty;
    function baseKeysIn(object2) {
      if (!isObject$3(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$7.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object2) {
      if (isArray$3(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    var nativeCreate = getNative(Object, "create");
    const nativeCreate$1 = nativeCreate;
    function hashClear() {
      this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$6 = objectProto$5.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate$1) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$6.call(data, key) ? data[key] : void 0;
    }
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$5 = objectProto$4.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$5.call(data, key);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
      return this;
    }
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root$1, "Map");
    const Map$2 = Map$1;
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$2 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT$2 = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$2);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
      });
      return result;
    });
    const stringToPath$1 = stringToPath;
    function toString$1(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object2) {
      if (isArray$3(value)) {
        return value;
      }
      return isKey(value, object2) ? [value] : stringToPath$1(toString$1(value));
    }
    var INFINITY$2 = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
    }
    function baseGet(object2, path) {
      path = castPath(path, object2);
      var index2 = 0, length = path.length;
      while (object2 != null && index2 < length) {
        object2 = object2[toKey(path[index2++])];
      }
      return index2 && index2 == length ? object2 : void 0;
    }
    function get(object2, path, defaultValue) {
      var result = object2 == null ? void 0 : baseGet(object2, path);
      return result === void 0 ? defaultValue : result;
    }
    function arrayPush(array2, values) {
      var index2 = -1, length = values.length, offset2 = array2.length;
      while (++index2 < length) {
        array2[offset2 + index2] = values[index2];
      }
      return array2;
    }
    var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray$3(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function baseFlatten(array2, depth, predicate, isStrict, result) {
      var index2 = -1, length = array2.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index2 < length) {
        var value = array2[index2];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function flatten(array2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseFlatten(array2, 1) : [];
    }
    function flatRest(func) {
      return setToString$1(overRest(func, void 0, flatten), func + "");
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    const getPrototype$1 = getPrototype;
    function castArray$1() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray$3(value) ? value : [value];
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var LARGE_ARRAY_SIZE$1 = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function baseAssign(object2, source) {
      return object2 && copyObject(source, keys(source), object2);
    }
    function baseAssignIn(object2, source) {
      return object2 && copyObject(source, keysIn(source), object2);
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function arrayFilter(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$3 = Object.prototype;
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    const getSymbols$1 = getSymbols;
    function copySymbols(source, object2) {
      return copyObject(source, getSymbols$1(source), object2);
    }
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
      var result = [];
      while (object2) {
        arrayPush(result, getSymbols$1(object2));
        object2 = getPrototype$1(object2);
      }
      return result;
    };
    const getSymbolsIn$1 = getSymbolsIn;
    function copySymbolsIn(source, object2) {
      return copyObject(source, getSymbolsIn$1(source), object2);
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray$3(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys, getSymbols$1);
    }
    function getAllKeysIn(object2) {
      return baseGetAllKeys(object2, keysIn, getSymbolsIn$1);
    }
    var DataView = getNative(root$1, "DataView");
    const DataView$1 = DataView;
    var Promise$1 = getNative(root$1, "Promise");
    const Promise$2 = Promise$1;
    var Set$1 = getNative(root$1, "Set");
    const Set$2 = Set$1;
    var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
    var dataViewTag$3 = "[object DataView]";
    var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
    var getTag = baseGetTag;
    if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$4 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$4 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$3;
            case mapCtorString:
              return mapTag$4;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$4;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }
    const getTag$1 = getTag;
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$4 = objectProto$2.hasOwnProperty;
    function initCloneArray(array2) {
      var length = array2.length, result = new array2.constructor(length);
      if (length && typeof array2[0] == "string" && hasOwnProperty$4.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    var Uint8Array$1 = root$1.Uint8Array;
    const Uint8Array$2 = Uint8Array$1;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    var reFlags = /\w*$/;
    function cloneRegExp(regexp2) {
      var result = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
      result.lastIndex = regexp2.lastIndex;
      return result;
    }
    var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    function initCloneByTag(object2, tag, isDeep) {
      var Ctor = object2.constructor;
      switch (tag) {
        case arrayBufferTag$2:
          return cloneArrayBuffer(object2);
        case boolTag$2:
        case dateTag$2:
          return new Ctor(+object2);
        case dataViewTag$2:
          return cloneDataView(object2, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return cloneTypedArray(object2, isDeep);
        case mapTag$3:
          return new Ctor();
        case numberTag$2:
        case stringTag$2:
          return new Ctor(object2);
        case regexpTag$2:
          return cloneRegExp(object2);
        case setTag$3:
          return new Ctor();
        case symbolTag$2:
          return cloneSymbol(object2);
      }
    }
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate$1(getPrototype$1(object2)) : {};
    }
    var mapTag$2 = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag$1(value) == mapTag$2;
    }
    var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    const isMap$1 = isMap;
    var setTag$2 = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag$1(value) == setTag$2;
    }
    var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    const isSet$1 = isSet;
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object2, stack2) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
      if (customizer) {
        result = object2 ? customizer(value, key, object2, stack2) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject$3(value)) {
        return value;
      }
      var isArr = isArray$3(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer$2(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object2) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object2 ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack2 || (stack2 = new Stack());
      var stacked = stack2.get(value);
      if (stacked) {
        return stacked;
      }
      stack2.set(value, result);
      if (isSet$1(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
        });
      } else if (isMap$1(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
      });
      return result;
    }
    var CLONE_SYMBOLS_FLAG = 4;
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    function SetCache(values) {
      var index2 = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arraySome(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack2.get(array2);
      var othStacked = stack2.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
      stack2.set(array2, other);
      stack2.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array2);
      stack2["delete"](other);
      return result;
    }
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
    var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack2) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object2), new Uint8Array$2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack2.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack2);
          stack2["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    var COMPARE_PARTIAL_FLAG$1 = 1;
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$3 = objectProto$1.hasOwnProperty;
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty$3.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack2.get(object2);
      var othStacked = stack2.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack2.set(object2, other);
      stack2.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack2) : customizer(objValue, othValue, key, object2, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object2);
      stack2["delete"](other);
      return result;
    }
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty$2 = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack2) {
      var objIsArr = isArray$3(object2), othIsArr = isArray$3(other), objTag = objIsArr ? arrayTag : getTag$1(object2), othTag = othIsArr ? arrayTag : getTag$1(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer$2(object2)) {
        if (!isBuffer$2(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack());
        return objIsArr || isTypedArray$2(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack2);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty$2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack2);
    }
    function baseIsEqual(value, other, bitmask, customizer, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
    }
    function baseHasIn(object2, key) {
      return object2 != null && key in Object(object2);
    }
    function hasPath(object2, path, hasFunc) {
      path = castPath(path, object2);
      var index2 = -1, length = path.length, result = false;
      while (++index2 < length) {
        var key = toKey(path[index2]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result || ++index2 != length) {
        return result;
      }
      length = object2 == null ? 0 : object2.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray$3(object2) || isArguments$1(object2));
    }
    function hasIn(object2, path) {
      return object2 != null && hasPath(object2, path, baseHasIn);
    }
    var now = function() {
      return root$1.Date.now();
    };
    const now$1 = now;
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    var nativeMax = Math.max, nativeMin = Math.min;
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      wait = toNumber(wait) || 0;
      if (isObject$3(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now$1();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now$1());
      }
      function debounced() {
        var time = now$1(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function arrayIncludesWith(array2, value, comparator2) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (comparator2(value, array2[index2])) {
          return true;
        }
      }
      return false;
    }
    var INFINITY$1 = 1 / 0;
    function flattenDeep(array2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseFlatten(array2, INFINITY$1) : [];
    }
    function fromPairs(pairs) {
      var index2 = -1, length = pairs == null ? 0 : pairs.length, result = {};
      while (++index2 < length) {
        var pair = pairs[index2];
        result[pair[0]] = pair[1];
      }
      return result;
    }
    function isEqual$1(value, other) {
      return baseIsEqual(value, other);
    }
    function isNil(value) {
      return value == null;
    }
    function baseSet(object2, path, value, customizer) {
      if (!isObject$3(object2)) {
        return object2;
      }
      path = castPath(path, object2);
      var index2 = -1, length = path.length, lastIndex = length - 1, nested = object2;
      while (nested != null && ++index2 < length) {
        var key = toKey(path[index2]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object2;
        }
        if (index2 != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject$3(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object2;
    }
    function basePickBy(object2, paths, predicate) {
      var index2 = -1, length = paths.length, result = {};
      while (++index2 < length) {
        var path = paths[index2], value = baseGet(object2, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object2), value);
        }
      }
      return result;
    }
    function basePick(object2, paths) {
      return basePickBy(object2, paths, function(value, path) {
        return hasIn(object2, path);
      });
    }
    var pick = flatRest(function(object2, paths) {
      return object2 == null ? {} : basePick(object2, paths);
    });
    const pick$1 = pick;
    function set(object2, path, value) {
      return object2 == null ? object2 : baseSet(object2, path, value);
    }
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject$3(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    var INFINITY = 1 / 0;
    var createSet = !(Set$2 && 1 / setToArray(new Set$2([, -0]))[1] == INFINITY) ? noop$2 : function(values) {
      return new Set$2(values);
    };
    const createSet$1 = createSet;
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array2, iteratee, comparator2) {
      var index2 = -1, includes = arrayIncludes, length = array2.length, isCommon = true, result = [], seen = result;
      if (comparator2) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set2 = iteratee ? null : createSet$1(array2);
        if (set2) {
          return setToArray(set2);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index2 < length) {
          var value = array2[index2], computed2 = iteratee ? iteratee(value) : value;
          value = comparator2 || value !== 0 ? value : 0;
          if (isCommon && computed2 === computed2) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed2) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed2);
            }
            result.push(value);
          } else if (!includes(seen, computed2, comparator2)) {
            if (seen !== result) {
              seen.push(computed2);
            }
            result.push(value);
          }
        }
      return result;
    }
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });
    const union$1 = union;
    const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
    const isVisible = (element) => {
      const computed2 = getComputedStyle(element);
      return computed2.position === "fixed" ? false : element.offsetParent !== null;
    };
    const obtainAllFocusableElements$1 = (element) => {
      return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item) => isFocusable(item) && isVisible(item));
    };
    const isFocusable = (element) => {
      if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
        return true;
      }
      if (element.disabled) {
        return false;
      }
      switch (element.nodeName) {
        case "A": {
          return !!element.href && element.rel !== "ignore";
        }
        case "INPUT": {
          return !(element.type === "hidden" || element.type === "file");
        }
        case "BUTTON":
        case "SELECT":
        case "TEXTAREA": {
          return true;
        }
        default: {
          return false;
        }
      }
    };
    const triggerEvent = function(elm, name, ...opts) {
      let eventName;
      if (name.includes("mouse") || name.includes("click")) {
        eventName = "MouseEvents";
      } else if (name.includes("key")) {
        eventName = "KeyboardEvent";
      } else {
        eventName = "HTMLEvents";
      }
      const evt = document.createEvent(eventName);
      evt.initEvent(name, ...opts);
      elm.dispatchEvent(evt);
      return elm;
    };
    const isLeaf = (el) => !el.getAttribute("aria-owns");
    const getSibling = (el, distance, elClass) => {
      const { parentNode } = el;
      if (!parentNode)
        return null;
      const siblings = parentNode.querySelectorAll(elClass);
      const index2 = Array.prototype.indexOf.call(siblings, el);
      return siblings[index2 + distance] || null;
    };
    const focusNode = (el) => {
      if (!el)
        return;
      el.focus();
      !isLeaf(el) && el.click();
    };
    const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
      const handleEvent = (event) => {
        const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
        if (checkForDefaultPrevented === false || !shouldPrevent) {
          return oursHandler == null ? void 0 : oursHandler(event);
        }
      };
      return handleEvent;
    };
    const whenMouse = (handler) => {
      return (e) => e.pointerType === "mouse" ? handler(e) : void 0;
    };
    var __defProp$9 = Object.defineProperty;
    var __defProps$6 = Object.defineProperties;
    var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
    var __hasOwnProp$b = Object.prototype.hasOwnProperty;
    var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
    var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues$9 = (a2, b2) => {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp$b.call(b2, prop))
          __defNormalProp$9(a2, prop, b2[prop]);
      if (__getOwnPropSymbols$b)
        for (var prop of __getOwnPropSymbols$b(b2)) {
          if (__propIsEnum$b.call(b2, prop))
            __defNormalProp$9(a2, prop, b2[prop]);
        }
      return a2;
    };
    var __spreadProps$6 = (a2, b2) => __defProps$6(a2, __getOwnPropDescs$6(b2));
    function computedEager(fn2, options) {
      var _a2;
      const result = shallowRef();
      watchEffect(() => {
        result.value = fn2();
      }, __spreadProps$6(__spreadValues$9({}, options), {
        flush: (_a2 = options == null ? void 0 : options.flush) != null ? _a2 : "sync"
      }));
      return readonly(result);
    }
    var _a;
    const isClient = typeof window !== "undefined";
    const isDef = (val) => typeof val !== "undefined";
    const isBoolean$2 = (val) => typeof val === "boolean";
    const isFunction$2 = (val) => typeof val === "function";
    const isNumber$2 = (val) => typeof val === "number";
    const isString$2 = (val) => typeof val === "string";
    const noop$1 = () => {
    };
    isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
    function resolveUnref(r) {
      return typeof r === "function" ? r() : unref(r);
    }
    function createFilterWrapper(filter, fn2) {
      function wrapper(...args) {
        filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args });
      }
      return wrapper;
    }
    function debounceFilter(ms, options = {}) {
      let timer;
      let maxTimer;
      const filter = (invoke) => {
        const duration = resolveUnref(ms);
        const maxDuration = resolveUnref(options.maxWait);
        if (timer)
          clearTimeout(timer);
        if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
          if (maxTimer) {
            clearTimeout(maxTimer);
            maxTimer = null;
          }
          return invoke();
        }
        if (maxDuration && !maxTimer) {
          maxTimer = setTimeout(() => {
            if (timer)
              clearTimeout(timer);
            maxTimer = null;
            invoke();
          }, maxDuration);
        }
        timer = setTimeout(() => {
          if (maxTimer)
            clearTimeout(maxTimer);
          maxTimer = null;
          invoke();
        }, duration);
      };
      return filter;
    }
    function throttleFilter(ms, trailing = true, leading = true) {
      let lastExec = 0;
      let timer;
      let isLeading = true;
      const clear2 = () => {
        if (timer) {
          clearTimeout(timer);
          timer = void 0;
        }
      };
      const filter = (invoke) => {
        const duration = resolveUnref(ms);
        const elapsed = Date.now() - lastExec;
        clear2();
        if (duration <= 0) {
          lastExec = Date.now();
          return invoke();
        }
        if (elapsed > duration && (leading || !isLeading)) {
          lastExec = Date.now();
          invoke();
        } else if (trailing) {
          timer = setTimeout(() => {
            lastExec = Date.now();
            isLeading = true;
            clear2();
            invoke();
          }, duration);
        }
        if (!leading && !timer)
          timer = setTimeout(() => isLeading = true, duration);
        isLeading = false;
      };
      return filter;
    }
    function identity(arg) {
      return arg;
    }
    function tryOnScopeDispose(fn2) {
      if (getCurrentScope()) {
        onScopeDispose(fn2);
        return true;
      }
      return false;
    }
    function useDebounceFn(fn2, ms = 200, options = {}) {
      return createFilterWrapper(debounceFilter(ms, options), fn2);
    }
    function refDebounced(value, ms = 200, options = {}) {
      if (ms <= 0)
        return value;
      const debounced = ref(value.value);
      const updater = useDebounceFn(() => {
        debounced.value = value.value;
      }, ms, options);
      watch(value, () => updater());
      return debounced;
    }
    function useThrottleFn(fn2, ms = 200, trailing = false, leading = true) {
      return createFilterWrapper(throttleFilter(ms, trailing, leading), fn2);
    }
    function tryOnMounted(fn2, sync = true) {
      if (getCurrentInstance())
        onMounted(fn2);
      else if (sync)
        fn2();
      else
        nextTick(fn2);
    }
    function useTimeoutFn(cb, interval, options = {}) {
      const {
        immediate = true
      } = options;
      const isPending = ref(false);
      let timer = null;
      function clear2() {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      }
      function stop() {
        isPending.value = false;
        clear2();
      }
      function start(...args) {
        clear2();
        isPending.value = true;
        timer = setTimeout(() => {
          isPending.value = false;
          timer = null;
          cb(...args);
        }, resolveUnref(interval));
      }
      if (immediate) {
        isPending.value = true;
        if (isClient)
          start();
      }
      tryOnScopeDispose(stop);
      return {
        isPending,
        start,
        stop
      };
    }
    function unrefElement(elRef) {
      var _a2;
      const plain = resolveUnref(elRef);
      return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
    }
    const defaultWindow = isClient ? window : void 0;
    const defaultDocument = isClient ? window.document : void 0;
    function useEventListener(...args) {
      let target;
      let event;
      let listener;
      let options;
      if (isString$2(args[0])) {
        [event, listener, options] = args;
        target = defaultWindow;
      } else {
        [target, event, listener, options] = args;
      }
      if (!target)
        return noop$1;
      let cleanup = noop$1;
      const stopWatch = watch(() => unrefElement(target), (el) => {
        cleanup();
        if (!el)
          return;
        el.addEventListener(event, listener, options);
        cleanup = () => {
          el.removeEventListener(event, listener, options);
          cleanup = noop$1;
        };
      }, { immediate: true, flush: "post" });
      const stop = () => {
        stopWatch();
        cleanup();
      };
      tryOnScopeDispose(stop);
      return stop;
    }
    function onClickOutside(target, handler, options = {}) {
      const { window: window2 = defaultWindow, ignore, capture = true, detectIframe = false } = options;
      if (!window2)
        return;
      const shouldListen = ref(true);
      let fallback;
      const listener = (event) => {
        window2.clearTimeout(fallback);
        const el = unrefElement(target);
        const composedPath = event.composedPath();
        if (!el || el === event.target || composedPath.includes(el) || !shouldListen.value)
          return;
        if (ignore && ignore.length > 0) {
          if (ignore.some((target2) => {
            const el2 = unrefElement(target2);
            return el2 && (event.target === el2 || composedPath.includes(el2));
          }))
            return;
        }
        handler(event);
      };
      const cleanup = [
        useEventListener(window2, "click", listener, { passive: true, capture }),
        useEventListener(window2, "pointerdown", (e) => {
          const el = unrefElement(target);
          shouldListen.value = !!el && !e.composedPath().includes(el);
        }, { passive: true }),
        useEventListener(window2, "pointerup", (e) => {
          if (e.button === 0) {
            const path = e.composedPath();
            e.composedPath = () => path;
            fallback = window2.setTimeout(() => listener(e), 50);
          }
        }, { passive: true }),
        detectIframe && useEventListener(window2, "blur", (event) => {
          var _a2;
          const el = unrefElement(target);
          if (((_a2 = document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(document.activeElement)))
            handler(event);
        })
      ].filter(Boolean);
      const stop = () => cleanup.forEach((fn2) => fn2());
      return stop;
    }
    function useSupported(callback, sync = false) {
      const isSupported = ref();
      const update = () => isSupported.value = Boolean(callback());
      update();
      tryOnMounted(update, sync);
      return isSupported;
    }
    function cloneFnJSON(source) {
      return JSON.parse(JSON.stringify(source));
    }
    const _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    const globalKey = "__vueuse_ssr_handlers__";
    _global$1[globalKey] = _global$1[globalKey] || {};
    _global$1[globalKey];
    function useDocumentVisibility({ document: document2 = defaultDocument } = {}) {
      if (!document2)
        return ref("visible");
      const visibility = ref(document2.visibilityState);
      useEventListener(document2, "visibilitychange", () => {
        visibility.value = document2.visibilityState;
      });
      return visibility;
    }
    var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
    var __hasOwnProp$f = Object.prototype.hasOwnProperty;
    var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
    var __objRest$2 = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp$f.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols$f)
        for (var prop of __getOwnPropSymbols$f(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum$f.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    function useResizeObserver(target, callback, options = {}) {
      const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
      let observer;
      const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
      const cleanup = () => {
        if (observer) {
          observer.disconnect();
          observer = void 0;
        }
      };
      const stopWatch = watch(() => unrefElement(target), (el) => {
        cleanup();
        if (isSupported.value && window2 && el) {
          observer = new ResizeObserver(callback);
          observer.observe(el, observerOptions);
        }
      }, { immediate: true, flush: "post" });
      const stop = () => {
        cleanup();
        stopWatch();
      };
      tryOnScopeDispose(stop);
      return {
        isSupported,
        stop
      };
    }
    function useElementBounding(target, options = {}) {
      const {
        reset: reset2 = true,
        windowResize = true,
        windowScroll = true,
        immediate = true
      } = options;
      const height = ref(0);
      const bottom = ref(0);
      const left2 = ref(0);
      const right2 = ref(0);
      const top = ref(0);
      const width = ref(0);
      const x2 = ref(0);
      const y = ref(0);
      function update() {
        const el = unrefElement(target);
        if (!el) {
          if (reset2) {
            height.value = 0;
            bottom.value = 0;
            left2.value = 0;
            right2.value = 0;
            top.value = 0;
            width.value = 0;
            x2.value = 0;
            y.value = 0;
          }
          return;
        }
        const rect = el.getBoundingClientRect();
        height.value = rect.height;
        bottom.value = rect.bottom;
        left2.value = rect.left;
        right2.value = rect.right;
        top.value = rect.top;
        width.value = rect.width;
        x2.value = rect.x;
        y.value = rect.y;
      }
      useResizeObserver(target, update);
      watch(() => unrefElement(target), (ele) => !ele && update());
      if (windowScroll)
        useEventListener("scroll", update, { passive: true });
      if (windowResize)
        useEventListener("resize", update, { passive: true });
      tryOnMounted(() => {
        if (immediate)
          update();
      });
      return {
        height,
        bottom,
        left: left2,
        right: right2,
        top,
        width,
        x: x2,
        y,
        update
      };
    }
    var SwipeDirection;
    (function(SwipeDirection2) {
      SwipeDirection2["UP"] = "UP";
      SwipeDirection2["RIGHT"] = "RIGHT";
      SwipeDirection2["DOWN"] = "DOWN";
      SwipeDirection2["LEFT"] = "LEFT";
      SwipeDirection2["NONE"] = "NONE";
    })(SwipeDirection || (SwipeDirection = {}));
    var __defProp = Object.defineProperty;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a2, b2) => {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp.call(b2, prop))
          __defNormalProp(a2, prop, b2[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b2)) {
          if (__propIsEnum.call(b2, prop))
            __defNormalProp(a2, prop, b2[prop]);
        }
      return a2;
    };
    const _TransitionPresets = {
      easeInSine: [0.12, 0, 0.39, 0],
      easeOutSine: [0.61, 1, 0.88, 1],
      easeInOutSine: [0.37, 0, 0.63, 1],
      easeInQuad: [0.11, 0, 0.5, 0],
      easeOutQuad: [0.5, 1, 0.89, 1],
      easeInOutQuad: [0.45, 0, 0.55, 1],
      easeInCubic: [0.32, 0, 0.67, 0],
      easeOutCubic: [0.33, 1, 0.68, 1],
      easeInOutCubic: [0.65, 0, 0.35, 1],
      easeInQuart: [0.5, 0, 0.75, 0],
      easeOutQuart: [0.25, 1, 0.5, 1],
      easeInOutQuart: [0.76, 0, 0.24, 1],
      easeInQuint: [0.64, 0, 0.78, 0],
      easeOutQuint: [0.22, 1, 0.36, 1],
      easeInOutQuint: [0.83, 0, 0.17, 1],
      easeInExpo: [0.7, 0, 0.84, 0],
      easeOutExpo: [0.16, 1, 0.3, 1],
      easeInOutExpo: [0.87, 0, 0.13, 1],
      easeInCirc: [0.55, 0, 1, 0.45],
      easeOutCirc: [0, 0.55, 0.45, 1],
      easeInOutCirc: [0.85, 0, 0.15, 1],
      easeInBack: [0.36, 0, 0.66, -0.56],
      easeOutBack: [0.34, 1.56, 0.64, 1],
      easeInOutBack: [0.68, -0.6, 0.32, 1.6]
    };
    __spreadValues({
      linear: identity
    }, _TransitionPresets);
    function useVModel(props, key, emit, options = {}) {
      var _a2, _b, _c;
      const {
        clone: clone2 = false,
        passive = false,
        eventName,
        deep = false,
        defaultValue
      } = options;
      const vm = getCurrentInstance();
      const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a2 = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a2.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
      let event = eventName;
      if (!key) {
        {
          key = "modelValue";
        }
      }
      event = eventName || event || `update:${key.toString()}`;
      const cloneFn = (val) => !clone2 ? val : isFunction$2(clone2) ? clone2(val) : cloneFnJSON(val);
      const getValue2 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
      if (passive) {
        const initialValue = getValue2();
        const proxy = ref(initialValue);
        watch(() => props[key], (v2) => proxy.value = cloneFn(v2));
        watch(proxy, (v2) => {
          if (v2 !== props[key] || deep)
            _emit(event, v2);
        }, { deep });
        return proxy;
      } else {
        return computed({
          get() {
            return getValue2();
          },
          set(value) {
            _emit(event, value);
          }
        });
      }
    }
    function useWindowFocus({ window: window2 = defaultWindow } = {}) {
      if (!window2)
        return ref(false);
      const focused = ref(window2.document.hasFocus());
      useEventListener(window2, "blur", () => {
        focused.value = false;
      });
      useEventListener(window2, "focus", () => {
        focused.value = true;
      });
      return focused;
    }
    function useWindowSize(options = {}) {
      const {
        window: window2 = defaultWindow,
        initialWidth = Infinity,
        initialHeight = Infinity,
        listenOrientation = true,
        includeScrollbar = true
      } = options;
      const width = ref(initialWidth);
      const height = ref(initialHeight);
      const update = () => {
        if (window2) {
          if (includeScrollbar) {
            width.value = window2.innerWidth;
            height.value = window2.innerHeight;
          } else {
            width.value = window2.document.documentElement.clientWidth;
            height.value = window2.document.documentElement.clientHeight;
          }
        }
      };
      update();
      tryOnMounted(update);
      useEventListener("resize", update, { passive: true });
      if (listenOrientation)
        useEventListener("orientationchange", update, { passive: true });
      return { width, height };
    }
    const isInContainer = (el, container) => {
      if (!isClient || !el || !container)
        return false;
      const elRect = el.getBoundingClientRect();
      let containerRect;
      if (container instanceof Element) {
        containerRect = container.getBoundingClientRect();
      } else {
        containerRect = {
          top: 0,
          right: window.innerWidth,
          bottom: window.innerHeight,
          left: 0
        };
      }
      return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
    };
    const getOffsetTop = (el) => {
      let offset2 = 0;
      let parent = el;
      while (parent) {
        offset2 += parent.offsetTop;
        parent = parent.offsetParent;
      }
      return offset2;
    };
    const getOffsetTopDistance = (el, containerEl) => {
      return Math.abs(getOffsetTop(el) - getOffsetTop(containerEl));
    };
    const getClientXY = (event) => {
      let clientX;
      let clientY;
      if (event.type === "touchend") {
        clientY = event.changedTouches[0].clientY;
        clientX = event.changedTouches[0].clientX;
      } else if (event.type.startsWith("touch")) {
        clientY = event.touches[0].clientY;
        clientX = event.touches[0].clientX;
      } else {
        clientY = event.clientY;
        clientX = event.clientX;
      }
      return {
        clientX,
        clientY
      };
    };
    const isUndefined$1 = (val) => val === void 0;
    const isEmpty = (val) => !val && val !== 0 || isArray$4(val) && val.length === 0 || isObject$4(val) && !Object.keys(val).length;
    const isElement$1 = (e) => {
      if (typeof Element === "undefined")
        return false;
      return e instanceof Element;
    };
    const isPropAbsent = (prop) => {
      return isNil(prop);
    };
    const escapeStringRegexp = (string2 = "") => string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    const keysOf = (arr) => Object.keys(arr);
    const entriesOf = (arr) => Object.entries(arr);
    const getProp = (obj, path, defaultValue) => {
      return {
        get value() {
          return get(obj, path, defaultValue);
        },
        set value(val) {
          set(obj, path, val);
        }
      };
    };
    class ElementPlusError extends Error {
      constructor(m2) {
        super(m2);
        this.name = "ElementPlusError";
      }
    }
    function throwError(scope, m2) {
      throw new ElementPlusError(`[${scope}] ${m2}`);
    }
    function debugWarn(scope, message2) {
    }
    const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
    const hasClass = (el, cls) => {
      if (!el || !cls)
        return false;
      if (cls.includes(" "))
        throw new Error("className should not contain space.");
      return el.classList.contains(cls);
    };
    const addClass = (el, cls) => {
      if (!el || !cls.trim())
        return;
      el.classList.add(...classNameToArray(cls));
    };
    const removeClass = (el, cls) => {
      if (!el || !cls.trim())
        return;
      el.classList.remove(...classNameToArray(cls));
    };
    const getStyle = (element, styleName) => {
      var _a2;
      if (!isClient || !element || !styleName)
        return "";
      let key = camelize(styleName);
      if (key === "float")
        key = "cssFloat";
      try {
        const style2 = element.style[key];
        if (style2)
          return style2;
        const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
        return computed2 ? computed2[key] : "";
      } catch (e) {
        return element.style[key];
      }
    };
    function addUnit(value, defaultUnit = "px") {
      if (!value)
        return "";
      if (isString$3(value)) {
        return value;
      } else if (isNumber$2(value)) {
        return `${value}${defaultUnit}`;
      }
    }
    const isScroll = (el, isVertical) => {
      if (!isClient)
        return false;
      const key = {
        undefined: "overflow",
        true: "overflow-y",
        false: "overflow-x"
      }[String(isVertical)];
      const overflow = getStyle(el, key);
      return ["scroll", "auto", "overlay"].some((s2) => overflow.includes(s2));
    };
    const getScrollContainer = (el, isVertical) => {
      if (!isClient)
        return;
      let parent = el;
      while (parent) {
        if ([window, document, document.documentElement].includes(parent))
          return window;
        if (isScroll(parent, isVertical))
          return parent;
        parent = parent.parentNode;
      }
      return parent;
    };
    let scrollBarWidth;
    const getScrollBarWidth = (namespace) => {
      var _a2;
      if (!isClient)
        return 0;
      if (scrollBarWidth !== void 0)
        return scrollBarWidth;
      const outer = document.createElement("div");
      outer.className = `${namespace}-scrollbar__wrap`;
      outer.style.visibility = "hidden";
      outer.style.width = "100px";
      outer.style.position = "absolute";
      outer.style.top = "-9999px";
      document.body.appendChild(outer);
      const widthNoScroll = outer.offsetWidth;
      outer.style.overflow = "scroll";
      const inner = document.createElement("div");
      inner.style.width = "100%";
      outer.appendChild(inner);
      const widthWithScroll = inner.offsetWidth;
      (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
      scrollBarWidth = widthNoScroll - widthWithScroll;
      return scrollBarWidth;
    };
    function scrollIntoView(container, selected) {
      if (!isClient)
        return;
      if (!selected) {
        container.scrollTop = 0;
        return;
      }
      const offsetParents = [];
      let pointer = selected.offsetParent;
      while (pointer !== null && container !== pointer && container.contains(pointer)) {
        offsetParents.push(pointer);
        pointer = pointer.offsetParent;
      }
      const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
      const bottom = top + selected.offsetHeight;
      const viewRectTop = container.scrollTop;
      const viewRectBottom = viewRectTop + container.clientHeight;
      if (top < viewRectTop) {
        container.scrollTop = top;
      } else if (bottom > viewRectBottom) {
        container.scrollTop = bottom - container.clientHeight;
      }
    }
    /*! Element Plus Icons Vue v2.0.9 */
    var export_helper_default = (sfc, props) => {
      let target = sfc.__vccOpts || sfc;
      for (let [key, val] of props)
        target[key] = val;
      return target;
    };
    var _sfc_main6 = {
      name: "ArrowDown"
    }, _hoisted_16$2 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_26 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
    }, null, -1), _hoisted_36 = [
      _hoisted_26
    ];
    function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_16$2, _hoisted_36);
    }
    var arrow_down_default = /* @__PURE__ */ export_helper_default(_sfc_main6, [["render", _sfc_render6], ["__file", "arrow-down.vue"]]);
    var _sfc_main8 = {
      name: "ArrowLeft"
    }, _hoisted_18$2 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_28 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
    }, null, -1), _hoisted_38 = [
      _hoisted_28
    ];
    function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_18$2, _hoisted_38);
    }
    var arrow_left_default = /* @__PURE__ */ export_helper_default(_sfc_main8, [["render", _sfc_render8], ["__file", "arrow-left.vue"]]);
    var _sfc_main10 = {
      name: "ArrowRight"
    }, _hoisted_110 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_210 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
    }, null, -1), _hoisted_310 = [
      _hoisted_210
    ];
    function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_110, _hoisted_310);
    }
    var arrow_right_default = /* @__PURE__ */ export_helper_default(_sfc_main10, [["render", _sfc_render10], ["__file", "arrow-right.vue"]]);
    var _sfc_main12 = {
      name: "ArrowUp"
    }, _hoisted_112 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_212 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
    }, null, -1), _hoisted_312 = [
      _hoisted_212
    ];
    function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_112, _hoisted_312);
    }
    var arrow_up_default = /* @__PURE__ */ export_helper_default(_sfc_main12, [["render", _sfc_render12], ["__file", "arrow-up.vue"]]);
    var _sfc_main14 = {
      name: "Back"
    }, _hoisted_114 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_214 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64z"
    }, null, -1), _hoisted_314 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312L237.248 512z"
    }, null, -1), _hoisted_44 = [
      _hoisted_214,
      _hoisted_314
    ];
    function _sfc_render14(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_114, _hoisted_44);
    }
    var back_default = /* @__PURE__ */ export_helper_default(_sfc_main14, [["render", _sfc_render14], ["__file", "back.vue"]]);
    var _sfc_main29 = {
      name: "Calendar"
    }, _hoisted_129 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_229 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64H128zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0v32zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64z"
    }, null, -1), _hoisted_328 = [
      _hoisted_229
    ];
    function _sfc_render29(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_129, _hoisted_328);
    }
    var calendar_default = /* @__PURE__ */ export_helper_default(_sfc_main29, [["render", _sfc_render29], ["__file", "calendar.vue"]]);
    var _sfc_main34 = {
      name: "CaretRight"
    }, _hoisted_134 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_234 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M384 192v640l384-320.064z"
    }, null, -1), _hoisted_333 = [
      _hoisted_234
    ];
    function _sfc_render34(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_134, _hoisted_333);
    }
    var caret_right_default = /* @__PURE__ */ export_helper_default(_sfc_main34, [["render", _sfc_render34], ["__file", "caret-right.vue"]]);
    var _sfc_main35 = {
      name: "CaretTop"
    }, _hoisted_135 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_235 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M512 320 192 704h639.936z"
    }, null, -1), _hoisted_334 = [
      _hoisted_235
    ];
    function _sfc_render35(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_135, _hoisted_334);
    }
    var caret_top_default = /* @__PURE__ */ export_helper_default(_sfc_main35, [["render", _sfc_render35], ["__file", "caret-top.vue"]]);
    var _sfc_main43 = {
      name: "Check"
    }, _hoisted_143 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_243 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
    }, null, -1), _hoisted_342 = [
      _hoisted_243
    ];
    function _sfc_render43(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_143, _hoisted_342);
    }
    var check_default = /* @__PURE__ */ export_helper_default(_sfc_main43, [["render", _sfc_render43], ["__file", "check.vue"]]);
    var _sfc_main48 = {
      name: "CircleCheckFilled"
    }, _hoisted_148 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_248 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
    }, null, -1), _hoisted_347 = [
      _hoisted_248
    ];
    function _sfc_render48(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_148, _hoisted_347);
    }
    var circle_check_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main48, [["render", _sfc_render48], ["__file", "circle-check-filled.vue"]]);
    var _sfc_main49 = {
      name: "CircleCheck"
    }, _hoisted_149 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_249 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
    }, null, -1), _hoisted_348 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
    }, null, -1), _hoisted_415 = [
      _hoisted_249,
      _hoisted_348
    ];
    function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_149, _hoisted_415);
    }
    var circle_check_default = /* @__PURE__ */ export_helper_default(_sfc_main49, [["render", _sfc_render49], ["__file", "circle-check.vue"]]);
    var _sfc_main50 = {
      name: "CircleCloseFilled"
    }, _hoisted_150 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_250 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
    }, null, -1), _hoisted_349 = [
      _hoisted_250
    ];
    function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_150, _hoisted_349);
    }
    var circle_close_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main50, [["render", _sfc_render50], ["__file", "circle-close-filled.vue"]]);
    var _sfc_main51 = {
      name: "CircleClose"
    }, _hoisted_151 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_251 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
    }, null, -1), _hoisted_350 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
    }, null, -1), _hoisted_416 = [
      _hoisted_251,
      _hoisted_350
    ];
    function _sfc_render51(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_151, _hoisted_416);
    }
    var circle_close_default = /* @__PURE__ */ export_helper_default(_sfc_main51, [["render", _sfc_render51], ["__file", "circle-close.vue"]]);
    var _sfc_main54 = {
      name: "Clock"
    }, _hoisted_154 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_254 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
    }, null, -1), _hoisted_353 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32z"
    }, null, -1), _hoisted_418 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32z"
    }, null, -1), _hoisted_56 = [
      _hoisted_254,
      _hoisted_353,
      _hoisted_418
    ];
    function _sfc_render54(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_154, _hoisted_56);
    }
    var clock_default = /* @__PURE__ */ export_helper_default(_sfc_main54, [["render", _sfc_render54], ["__file", "clock.vue"]]);
    var _sfc_main56 = {
      name: "Close"
    }, _hoisted_156 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_256 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
    }, null, -1), _hoisted_355 = [
      _hoisted_256
    ];
    function _sfc_render56(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_156, _hoisted_355);
    }
    var close_default = /* @__PURE__ */ export_helper_default(_sfc_main56, [["render", _sfc_render56], ["__file", "close.vue"]]);
    var _sfc_main72 = {
      name: "DArrowLeft"
    }, _hoisted_172 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_272 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
    }, null, -1), _hoisted_371 = [
      _hoisted_272
    ];
    function _sfc_render72(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_172, _hoisted_371);
    }
    var d_arrow_left_default = /* @__PURE__ */ export_helper_default(_sfc_main72, [["render", _sfc_render72], ["__file", "d-arrow-left.vue"]]);
    var _sfc_main73 = {
      name: "DArrowRight"
    }, _hoisted_173 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_273 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688zm-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
    }, null, -1), _hoisted_372 = [
      _hoisted_273
    ];
    function _sfc_render73(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_173, _hoisted_372);
    }
    var d_arrow_right_default = /* @__PURE__ */ export_helper_default(_sfc_main73, [["render", _sfc_render73], ["__file", "d-arrow-right.vue"]]);
    var _sfc_main80 = {
      name: "Delete"
    }, _hoisted_180 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_280 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
    }, null, -1), _hoisted_379 = [
      _hoisted_280
    ];
    function _sfc_render80(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_180, _hoisted_379);
    }
    var delete_default = /* @__PURE__ */ export_helper_default(_sfc_main80, [["render", _sfc_render80], ["__file", "delete.vue"]]);
    var _sfc_main90 = {
      name: "Document"
    }, _hoisted_190 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_290 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"
    }, null, -1), _hoisted_389 = [
      _hoisted_290
    ];
    function _sfc_render90(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_190, _hoisted_389);
    }
    var document_default = /* @__PURE__ */ export_helper_default(_sfc_main90, [["render", _sfc_render90], ["__file", "document.vue"]]);
    var _sfc_main94 = {
      name: "Edit"
    }, _hoisted_194 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_294 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M832 512a32 32 0 1 1 64 0v352a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h352a32 32 0 0 1 0 64H192v640h640V512z"
    }, null, -1), _hoisted_393 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "m469.952 554.24 52.8-7.552L847.104 222.4a32 32 0 1 0-45.248-45.248L477.44 501.44l-7.552 52.8zm422.4-422.4a96 96 0 0 1 0 135.808l-331.84 331.84a32 32 0 0 1-18.112 9.088L436.8 623.68a32 32 0 0 1-36.224-36.224l15.104-105.6a32 32 0 0 1 9.024-18.112l331.904-331.84a96 96 0 0 1 135.744 0z"
    }, null, -1), _hoisted_431 = [
      _hoisted_294,
      _hoisted_393
    ];
    function _sfc_render94(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_194, _hoisted_431);
    }
    var edit_default = /* @__PURE__ */ export_helper_default(_sfc_main94, [["render", _sfc_render94], ["__file", "edit.vue"]]);
    var _sfc_main118 = {
      name: "FullScreen"
    }, _hoisted_1118 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2118 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64l-192 .192zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64v-.064z"
    }, null, -1), _hoisted_3117 = [
      _hoisted_2118
    ];
    function _sfc_render118(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1118, _hoisted_3117);
    }
    var full_screen_default = /* @__PURE__ */ export_helper_default(_sfc_main118, [["render", _sfc_render118], ["__file", "full-screen.vue"]]);
    var _sfc_main133 = {
      name: "Hide"
    }, _hoisted_1133 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2133 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z",
      fill: "currentColor"
    }, null, -1), _hoisted_3132 = /* @__PURE__ */ createBaseVNode("path", {
      d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z",
      fill: "currentColor"
    }, null, -1), _hoisted_438 = [
      _hoisted_2133,
      _hoisted_3132
    ];
    function _sfc_render133(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1133, _hoisted_438);
    }
    var hide_default = /* @__PURE__ */ export_helper_default(_sfc_main133, [["render", _sfc_render133], ["__file", "hide.vue"]]);
    var _sfc_main143 = {
      name: "InfoFilled"
    }, _hoisted_1143 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2143 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
    }, null, -1), _hoisted_3142 = [
      _hoisted_2143
    ];
    function _sfc_render143(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1143, _hoisted_3142);
    }
    var info_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main143, [["render", _sfc_render143], ["__file", "info-filled.vue"]]);
    var _sfc_main150 = {
      name: "Loading"
    }, _hoisted_1150 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2150 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
    }, null, -1), _hoisted_3149 = [
      _hoisted_2150
    ];
    function _sfc_render150(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1150, _hoisted_3149);
    }
    var loading_default = /* @__PURE__ */ export_helper_default(_sfc_main150, [["render", _sfc_render150], ["__file", "loading.vue"]]);
    var _sfc_main169 = {
      name: "Minus"
    }, _hoisted_1169 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2169 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z"
    }, null, -1), _hoisted_3168 = [
      _hoisted_2169
    ];
    function _sfc_render169(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1169, _hoisted_3168);
    }
    var minus_default = /* @__PURE__ */ export_helper_default(_sfc_main169, [["render", _sfc_render169], ["__file", "minus.vue"]]);
    var _sfc_main174 = {
      name: "MoreFilled"
    }, _hoisted_1174 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2174 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224z"
    }, null, -1), _hoisted_3173 = [
      _hoisted_2174
    ];
    function _sfc_render174(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1174, _hoisted_3173);
    }
    var more_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main174, [["render", _sfc_render174], ["__file", "more-filled.vue"]]);
    var _sfc_main175 = {
      name: "More"
    }, _hoisted_1175 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2175 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96z"
    }, null, -1), _hoisted_3174 = [
      _hoisted_2175
    ];
    function _sfc_render175(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1175, _hoisted_3174);
    }
    var more_default = /* @__PURE__ */ export_helper_default(_sfc_main175, [["render", _sfc_render175], ["__file", "more.vue"]]);
    var _sfc_main195 = {
      name: "PictureFilled"
    }, _hoisted_1195 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2195 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32H96zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112zM256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384z"
    }, null, -1), _hoisted_3194 = [
      _hoisted_2195
    ];
    function _sfc_render195(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1195, _hoisted_3194);
    }
    var picture_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main195, [["render", _sfc_render195], ["__file", "picture-filled.vue"]]);
    var _sfc_main201 = {
      name: "Plus"
    }, _hoisted_1201 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2201 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z"
    }, null, -1), _hoisted_3200 = [
      _hoisted_2201
    ];
    function _sfc_render201(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1201, _hoisted_3200);
    }
    var plus_default = /* @__PURE__ */ export_helper_default(_sfc_main201, [["render", _sfc_render201], ["__file", "plus.vue"]]);
    var _sfc_main211 = {
      name: "QuestionFilled"
    }, _hoisted_1211 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2211 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
    }, null, -1), _hoisted_3210 = [
      _hoisted_2211
    ];
    function _sfc_render211(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1211, _hoisted_3210);
    }
    var question_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main211, [["render", _sfc_render211], ["__file", "question-filled.vue"]]);
    var _sfc_main215 = {
      name: "RefreshLeft"
    }, _hoisted_1215 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2215 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
    }, null, -1), _hoisted_3214 = [
      _hoisted_2215
    ];
    function _sfc_render215(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1215, _hoisted_3214);
    }
    var refresh_left_default = /* @__PURE__ */ export_helper_default(_sfc_main215, [["render", _sfc_render215], ["__file", "refresh-left.vue"]]);
    var _sfc_main216 = {
      name: "RefreshRight"
    }, _hoisted_1216 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2216 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
    }, null, -1), _hoisted_3215 = [
      _hoisted_2216
    ];
    function _sfc_render216(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1216, _hoisted_3215);
    }
    var refresh_right_default = /* @__PURE__ */ export_helper_default(_sfc_main216, [["render", _sfc_render216], ["__file", "refresh-right.vue"]]);
    var _sfc_main222 = {
      name: "ScaleToOriginal"
    }, _hoisted_1222 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2222 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zM512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412zM512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512z"
    }, null, -1), _hoisted_3221 = [
      _hoisted_2222
    ];
    function _sfc_render222(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1222, _hoisted_3221);
    }
    var scale_to_original_default = /* @__PURE__ */ export_helper_default(_sfc_main222, [["render", _sfc_render222], ["__file", "scale-to-original.vue"]]);
    var _sfc_main225 = {
      name: "Search"
    }, _hoisted_1225 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2225 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704z"
    }, null, -1), _hoisted_3224 = [
      _hoisted_2225
    ];
    function _sfc_render225(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1225, _hoisted_3224);
    }
    var search_default = /* @__PURE__ */ export_helper_default(_sfc_main225, [["render", _sfc_render225], ["__file", "search.vue"]]);
    var _sfc_main242 = {
      name: "SortDown"
    }, _hoisted_1242 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2242 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0z"
    }, null, -1), _hoisted_3241 = [
      _hoisted_2242
    ];
    function _sfc_render242(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1242, _hoisted_3241);
    }
    var sort_down_default = /* @__PURE__ */ export_helper_default(_sfc_main242, [["render", _sfc_render242], ["__file", "sort-down.vue"]]);
    var _sfc_main243 = {
      name: "SortUp"
    }, _hoisted_1243 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2243 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248z"
    }, null, -1), _hoisted_3242 = [
      _hoisted_2243
    ];
    function _sfc_render243(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1243, _hoisted_3242);
    }
    var sort_up_default = /* @__PURE__ */ export_helper_default(_sfc_main243, [["render", _sfc_render243], ["__file", "sort-up.vue"]]);
    var _sfc_main246 = {
      name: "StarFilled"
    }, _hoisted_1246 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2246 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M283.84 867.84 512 747.776l228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72z"
    }, null, -1), _hoisted_3245 = [
      _hoisted_2246
    ];
    function _sfc_render246(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1246, _hoisted_3245);
    }
    var star_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main246, [["render", _sfc_render246], ["__file", "star-filled.vue"]]);
    var _sfc_main247 = {
      name: "Star"
    }, _hoisted_1247 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2247 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72L512 747.84zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
    }, null, -1), _hoisted_3246 = [
      _hoisted_2247
    ];
    function _sfc_render247(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1247, _hoisted_3246);
    }
    var star_default = /* @__PURE__ */ export_helper_default(_sfc_main247, [["render", _sfc_render247], ["__file", "star.vue"]]);
    var _sfc_main249 = {
      name: "SuccessFilled"
    }, _hoisted_1249 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2249 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
    }, null, -1), _hoisted_3248 = [
      _hoisted_2249
    ];
    function _sfc_render249(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1249, _hoisted_3248);
    }
    var success_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main249, [["render", _sfc_render249], ["__file", "success-filled.vue"]]);
    var _sfc_main283 = {
      name: "View"
    }, _hoisted_1283 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2283 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
    }, null, -1), _hoisted_3282 = [
      _hoisted_2283
    ];
    function _sfc_render283(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1283, _hoisted_3282);
    }
    var view_default = /* @__PURE__ */ export_helper_default(_sfc_main283, [["render", _sfc_render283], ["__file", "view.vue"]]);
    var _sfc_main287 = {
      name: "WarningFilled"
    }, _hoisted_1287 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2287 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
    }, null, -1), _hoisted_3286 = [
      _hoisted_2287
    ];
    function _sfc_render287(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1287, _hoisted_3286);
    }
    var warning_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main287, [["render", _sfc_render287], ["__file", "warning-filled.vue"]]);
    var _sfc_main292 = {
      name: "ZoomIn"
    }, _hoisted_1292 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2292 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z"
    }, null, -1), _hoisted_3291 = [
      _hoisted_2292
    ];
    function _sfc_render292(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1292, _hoisted_3291);
    }
    var zoom_in_default = /* @__PURE__ */ export_helper_default(_sfc_main292, [["render", _sfc_render292], ["__file", "zoom-in.vue"]]);
    var _sfc_main293 = {
      name: "ZoomOut"
    }, _hoisted_1293 = {
      viewBox: "0 0 1024 1024",
      xmlns: "http://www.w3.org/2000/svg"
    }, _hoisted_2293 = /* @__PURE__ */ createBaseVNode("path", {
      fill: "currentColor",
      d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zM352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64z"
    }, null, -1), _hoisted_3292 = [
      _hoisted_2293
    ];
    function _sfc_render293(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1293, _hoisted_3292);
    }
    var zoom_out_default = /* @__PURE__ */ export_helper_default(_sfc_main293, [["render", _sfc_render293], ["__file", "zoom-out.vue"]]);
    const epPropKey = "__epPropKey";
    const definePropType = (val) => val;
    const isEpProp = (val) => isObject$4(val) && !!val[epPropKey];
    const buildProp = (prop, key) => {
      if (!isObject$4(prop) || isEpProp(prop))
        return prop;
      const { values, required: required2, default: defaultValue, type: type2, validator: validator2 } = prop;
      const _validator = values || validator2 ? (val) => {
        let valid = false;
        let allowedValues = [];
        if (values) {
          allowedValues = Array.from(values);
          if (hasOwn$1(prop, "default")) {
            allowedValues.push(defaultValue);
          }
          valid || (valid = allowedValues.includes(val));
        }
        if (validator2)
          valid || (valid = validator2(val));
        if (!valid && allowedValues.length > 0) {
          const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
          warn$1(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
        }
        return valid;
      } : void 0;
      const epProp = {
        type: type2,
        required: !!required2,
        validator: _validator,
        [epPropKey]: true
      };
      if (hasOwn$1(prop, "default"))
        epProp.default = defaultValue;
      return epProp;
    };
    const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
      key,
      buildProp(option, key)
    ]));
    const iconPropType = definePropType([
      String,
      Object,
      Function
    ]);
    const CloseComponents = {
      Close: close_default
    };
    const TypeComponents = {
      Close: close_default,
      SuccessFilled: success_filled_default,
      InfoFilled: info_filled_default,
      WarningFilled: warning_filled_default,
      CircleCloseFilled: circle_close_filled_default
    };
    const TypeComponentsMap = {
      success: success_filled_default,
      warning: warning_filled_default,
      error: circle_close_filled_default,
      info: info_filled_default
    };
    const ValidateComponentsMap = {
      validating: loading_default,
      success: circle_check_default,
      error: circle_close_default
    };
    const withInstall = (main, extra) => {
      main.install = (app2) => {
        for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
          app2.component(comp.name, comp);
        }
      };
      if (extra) {
        for (const [key, comp] of Object.entries(extra)) {
          main[key] = comp;
        }
      }
      return main;
    };
    const withInstallFunction = (fn2, name) => {
      fn2.install = (app2) => {
        fn2._context = app2._context;
        app2.config.globalProperties[name] = fn2;
      };
      return fn2;
    };
    const withInstallDirective = (directive, name) => {
      directive.install = (app2) => {
        app2.directive(name, directive);
      };
      return directive;
    };
    const withNoopInstall = (component2) => {
      component2.install = NOOP;
      return component2;
    };
    const composeRefs = (...refs) => {
      return (el) => {
        refs.forEach((ref2) => {
          if (isFunction$4(ref2)) {
            ref2(el);
          } else {
            ref2.value = el;
          }
        });
      };
    };
    const EVENT_CODE = {
      tab: "Tab",
      enter: "Enter",
      space: "Space",
      left: "ArrowLeft",
      up: "ArrowUp",
      right: "ArrowRight",
      down: "ArrowDown",
      esc: "Escape",
      delete: "Delete",
      backspace: "Backspace",
      numpadEnter: "NumpadEnter",
      pageUp: "PageUp",
      pageDown: "PageDown",
      home: "Home",
      end: "End"
    };
    const datePickTypes = [
      "year",
      "month",
      "date",
      "dates",
      "week",
      "datetime",
      "datetimerange",
      "daterange",
      "monthrange"
    ];
    const WEEK_DAYS = [
      "sun",
      "mon",
      "tue",
      "wed",
      "thu",
      "fri",
      "sat"
    ];
    const UPDATE_MODEL_EVENT = "update:modelValue";
    const CHANGE_EVENT = "change";
    const INPUT_EVENT = "input";
    const INSTALLED_KEY = Symbol("INSTALLED_KEY");
    const componentSizes = ["", "default", "small", "large"];
    const componentSizeMap = {
      large: 40,
      default: 32,
      small: 24
    };
    const getComponentSize = (size2) => {
      return componentSizeMap[size2 || "default"];
    };
    const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
    var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
      PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
      PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
      PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
      PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
      PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
      PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
      PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
      PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
      PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
      PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
      PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
      PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
      PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
      return PatchFlags2;
    })(PatchFlags || {});
    function isFragment(node) {
      return isVNode$1(node) && node.type === Fragment;
    }
    function isComment(node) {
      return isVNode$1(node) && node.type === Comment;
    }
    function isValidElementNode(node) {
      return isVNode$1(node) && !isFragment(node) && !isComment(node);
    }
    const getNormalizedProps = (node) => {
      if (!isVNode$1(node)) {
        return {};
      }
      const raw = node.props || {};
      const type2 = (isVNode$1(node.type) ? node.type.props : void 0) || {};
      const props = {};
      Object.keys(type2).forEach((key) => {
        if (hasOwn$1(type2[key], "default")) {
          props[key] = type2[key].default;
        }
      });
      Object.keys(raw).forEach((key) => {
        props[camelize(key)] = raw[key];
      });
      return props;
    };
    const ensureOnlyChild = (children) => {
      if (!isArray$4(children) || children.length > 1) {
        throw new Error("expect to receive a single Vue element child");
      }
      return children[0];
    };
    const cubic = (value) => {
      return value ** 3;
    };
    const easeInOutCubic = (value) => value < 0.5 ? cubic(value * 2) / 2 : 1 - cubic((1 - value) * 2) / 2;
    const unique = (arr) => [...new Set(arr)];
    const castArray = (arr) => {
      if (!arr && arr !== 0)
        return [];
      return Array.isArray(arr) ? arr : [arr];
    };
    const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
    const isKorean = (text) => /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi.test(text);
    const rAF = (fn2) => isClient ? window.requestAnimationFrame(fn2) : setTimeout(fn2, 16);
    const cAF = (handle) => isClient ? window.cancelAnimationFrame(handle) : clearTimeout(handle);
    const generateId = () => Math.floor(Math.random() * 1e4);
    const mutable = (val) => val;
    const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
    const LISTENER_PREFIX = /^on[A-Z]/;
    const useAttrs = (params = {}) => {
      const { excludeListeners = false, excludeKeys } = params;
      const allExcludeKeys = computed(() => {
        return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
      });
      const instance = getCurrentInstance();
      if (!instance) {
        return computed(() => ({}));
      }
      return computed(() => {
        var _a2;
        return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
      });
    };
    const breadcrumbKey = Symbol("breadcrumbKey");
    const buttonGroupContextKey = Symbol("buttonGroupContextKey");
    const carouselContextKey = Symbol("carouselContextKey");
    const collapseContextKey = Symbol("collapseContextKey");
    const configProviderContextKey = Symbol();
    const dialogInjectionKey = Symbol("dialogInjectionKey");
    const formContextKey = Symbol("formContextKey");
    const formItemContextKey = Symbol("formItemContextKey");
    const elPaginationKey = Symbol("elPaginationKey");
    const radioGroupKey = Symbol("radioGroupKey");
    const rowContextKey = Symbol("rowContextKey");
    const scrollbarContextKey = Symbol("scrollbarContextKey");
    const sliderContextKey = Symbol("sliderContextKey");
    const tabsRootContextKey = Symbol("tabsRootContextKey");
    const uploadContextKey = Symbol("uploadContextKey");
    const POPPER_INJECTION_KEY = Symbol("popper");
    const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
    const tooltipV2RootKey = Symbol("tooltipV2");
    const tooltipV2ContentKey = Symbol("tooltipV2Content");
    const TOOLTIP_V2_OPEN = "tooltip_v2.open";
    const ROOT_PICKER_INJECTION_KEY = Symbol();
    const useProp = (name) => {
      const vm = getCurrentInstance();
      return computed(() => {
        var _a2, _b;
        return (_b = ((_a2 = vm.proxy) == null ? void 0 : _a2.$props)[name]) != null ? _b : void 0;
      });
    };
    const globalConfig = ref();
    function useGlobalConfig(key, defaultValue = void 0) {
      const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
      if (key) {
        return computed(() => {
          var _a2, _b;
          return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
        });
      } else {
        return config;
      }
    }
    const provideGlobalConfig = (config, app2, global2 = false) => {
      var _a2;
      const inSetup = !!getCurrentInstance();
      const oldConfig = inSetup ? useGlobalConfig() : void 0;
      const provideFn = (_a2 = app2 == null ? void 0 : app2.provide) != null ? _a2 : inSetup ? provide : void 0;
      if (!provideFn) {
        return;
      }
      const context = computed(() => {
        const cfg = unref(config);
        if (!(oldConfig == null ? void 0 : oldConfig.value))
          return cfg;
        return mergeConfig$1(oldConfig.value, cfg);
      });
      provideFn(configProviderContextKey, context);
      if (global2 || !globalConfig.value) {
        globalConfig.value = context.value;
      }
      return context;
    };
    const mergeConfig$1 = (a2, b2) => {
      var _a2;
      const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a2), ...keysOf(b2)])];
      const obj = {};
      for (const key of keys2) {
        obj[key] = (_a2 = b2[key]) != null ? _a2 : a2[key];
      }
      return obj;
    };
    const useSizeProp = buildProp({
      type: String,
      values: componentSizes,
      required: false
    });
    const useSize = (fallback, ignore = {}) => {
      const emptyRef = ref(void 0);
      const size2 = ignore.prop ? emptyRef : useProp("size");
      const globalConfig2 = ignore.global ? emptyRef : useGlobalConfig("size");
      const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
      const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
      return computed(() => size2.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
    };
    const useDisabled$1 = (fallback) => {
      const disabled = useProp("disabled");
      const form = inject(formContextKey, void 0);
      return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
    };
    const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type: type2 = "API" }, condition) => {
      watch(() => unref(condition), (val) => {
      }, {
        immediate: true
      });
    };
    const useDraggable = (targetRef, dragRef, draggable2) => {
      let transform2 = {
        offsetX: 0,
        offsetY: 0
      };
      const onMousedown = (e) => {
        const downX = e.clientX;
        const downY = e.clientY;
        const { offsetX, offsetY } = transform2;
        const targetRect = targetRef.value.getBoundingClientRect();
        const targetLeft = targetRect.left;
        const targetTop = targetRect.top;
        const targetWidth = targetRect.width;
        const targetHeight = targetRect.height;
        const clientWidth = document.documentElement.clientWidth;
        const clientHeight = document.documentElement.clientHeight;
        const minLeft = -targetLeft + offsetX;
        const minTop = -targetTop + offsetY;
        const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
        const maxTop = clientHeight - targetTop - targetHeight + offsetY;
        const onMousemove = (e2) => {
          const moveX = Math.min(Math.max(offsetX + e2.clientX - downX, minLeft), maxLeft);
          const moveY = Math.min(Math.max(offsetY + e2.clientY - downY, minTop), maxTop);
          transform2 = {
            offsetX: moveX,
            offsetY: moveY
          };
          targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
        };
        const onMouseup = () => {
          document.removeEventListener("mousemove", onMousemove);
          document.removeEventListener("mouseup", onMouseup);
        };
        document.addEventListener("mousemove", onMousemove);
        document.addEventListener("mouseup", onMouseup);
      };
      const onDraggable = () => {
        if (dragRef.value && targetRef.value) {
          dragRef.value.addEventListener("mousedown", onMousedown);
        }
      };
      const offDraggable = () => {
        if (dragRef.value && targetRef.value) {
          dragRef.value.removeEventListener("mousedown", onMousedown);
        }
      };
      onMounted(() => {
        watchEffect(() => {
          if (draggable2.value) {
            onDraggable();
          } else {
            offDraggable();
          }
        });
      });
      onBeforeUnmount(() => {
        offDraggable();
      });
    };
    const useFocus = (el) => {
      return {
        focus: () => {
          var _a2, _b;
          (_b = (_a2 = el.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
        }
      };
    };
    const defaultNamespace = "el";
    const statePrefix = "is-";
    const _bem = (namespace, block, blockSuffix, element, modifier) => {
      let cls = `${namespace}-${block}`;
      if (blockSuffix) {
        cls += `-${blockSuffix}`;
      }
      if (element) {
        cls += `__${element}`;
      }
      if (modifier) {
        cls += `--${modifier}`;
      }
      return cls;
    };
    const useNamespace = (block) => {
      const namespace = useGlobalConfig("namespace", defaultNamespace);
      const b2 = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
      const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
      const m2 = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
      const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
      const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
      const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
      const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
      const is = (name, ...args) => {
        const state = args.length >= 1 ? args[0] : true;
        return name && state ? `${statePrefix}${name}` : "";
      };
      const cssVar = (object2) => {
        const styles = {};
        for (const key in object2) {
          if (object2[key]) {
            styles[`--${namespace.value}-${key}`] = object2[key];
          }
        }
        return styles;
      };
      const cssVarBlock = (object2) => {
        const styles = {};
        for (const key in object2) {
          if (object2[key]) {
            styles[`--${namespace.value}-${block}-${key}`] = object2[key];
          }
        }
        return styles;
      };
      const cssVarName = (name) => `--${namespace.value}-${name}`;
      const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
      return {
        namespace,
        b: b2,
        e,
        m: m2,
        be: be2,
        em,
        bm,
        bem,
        is,
        cssVar,
        cssVarName,
        cssVarBlock,
        cssVarBlockName
      };
    };
    const defaultIdInjection = {
      prefix: Math.floor(Math.random() * 1e4),
      current: 0
    };
    const ID_INJECTION_KEY = Symbol("elIdInjection");
    const useId = (deterministicId) => {
      const idInjection = inject(ID_INJECTION_KEY, defaultIdInjection);
      const namespace = useGlobalConfig("namespace", defaultNamespace);
      const idRef = computed(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
      return idRef;
    };
    const useFormItem = () => {
      const form = inject(formContextKey, void 0);
      const formItem = inject(formItemContextKey, void 0);
      return {
        form,
        formItem
      };
    };
    const useFormItemInputId = (props, {
      formItemContext,
      disableIdGeneration,
      disableIdManagement
    }) => {
      if (!disableIdGeneration) {
        disableIdGeneration = ref(false);
      }
      if (!disableIdManagement) {
        disableIdManagement = ref(false);
      }
      const inputId = ref();
      let idUnwatch = void 0;
      const isLabeledByFormItem = computed(() => {
        var _a2;
        return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
      });
      onMounted(() => {
        idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id2, disableIdGeneration2]) => {
          const newId = id2 != null ? id2 : !disableIdGeneration2 ? useId().value : void 0;
          if (newId !== inputId.value) {
            if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
              inputId.value && formItemContext.removeInputId(inputId.value);
              if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                formItemContext.addInputId(newId);
              }
            }
            inputId.value = newId;
          }
        }, { immediate: true });
      });
      onUnmounted(() => {
        idUnwatch && idUnwatch();
        if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
          inputId.value && formItemContext.removeInputId(inputId.value);
        }
      });
      return {
        isLabeledByFormItem,
        inputId
      };
    };
    var English = {
      name: "en",
      el: {
        colorpicker: {
          confirm: "OK",
          clear: "Clear",
          defaultLabel: "color picker",
          description: "current color is {color}. press enter to select a new color."
        },
        datepicker: {
          now: "Now",
          today: "Today",
          cancel: "Cancel",
          clear: "Clear",
          confirm: "OK",
          dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
          monthTablePrompt: "Use the arrow keys and enter to select the month",
          yearTablePrompt: "Use the arrow keys and enter to select the year",
          selectedDate: "Selected date",
          selectDate: "Select date",
          selectTime: "Select time",
          startDate: "Start Date",
          startTime: "Start Time",
          endDate: "End Date",
          endTime: "End Time",
          prevYear: "Previous Year",
          nextYear: "Next Year",
          prevMonth: "Previous Month",
          nextMonth: "Next Month",
          year: "",
          month1: "January",
          month2: "February",
          month3: "March",
          month4: "April",
          month5: "May",
          month6: "June",
          month7: "July",
          month8: "August",
          month9: "September",
          month10: "October",
          month11: "November",
          month12: "December",
          week: "week",
          weeks: {
            sun: "Sun",
            mon: "Mon",
            tue: "Tue",
            wed: "Wed",
            thu: "Thu",
            fri: "Fri",
            sat: "Sat"
          },
          weeksFull: {
            sun: "Sunday",
            mon: "Monday",
            tue: "Tuesday",
            wed: "Wednesday",
            thu: "Thursday",
            fri: "Friday",
            sat: "Saturday"
          },
          months: {
            jan: "Jan",
            feb: "Feb",
            mar: "Mar",
            apr: "Apr",
            may: "May",
            jun: "Jun",
            jul: "Jul",
            aug: "Aug",
            sep: "Sep",
            oct: "Oct",
            nov: "Nov",
            dec: "Dec"
          }
        },
        inputNumber: {
          decrease: "decrease number",
          increase: "increase number"
        },
        select: {
          loading: "Loading",
          noMatch: "No matching data",
          noData: "No data",
          placeholder: "Select"
        },
        dropdown: {
          toggleDropdown: "Toggle Dropdown"
        },
        cascader: {
          noMatch: "No matching data",
          loading: "Loading",
          placeholder: "Select",
          noData: "No data"
        },
        pagination: {
          goto: "Go to",
          pagesize: "/page",
          total: "Total {total}",
          pageClassifier: "",
          deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
        },
        dialog: {
          close: "Close this dialog"
        },
        drawer: {
          close: "Close this dialog"
        },
        messagebox: {
          title: "Message",
          confirm: "OK",
          cancel: "Cancel",
          error: "Illegal input",
          close: "Close this dialog"
        },
        upload: {
          deleteTip: "press delete to remove",
          delete: "Delete",
          preview: "Preview",
          continue: "Continue"
        },
        slider: {
          defaultLabel: "slider between {min} and {max}",
          defaultRangeStartLabel: "pick start value",
          defaultRangeEndLabel: "pick end value"
        },
        table: {
          emptyText: "No Data",
          confirmFilter: "Confirm",
          resetFilter: "Reset",
          clearFilter: "All",
          sumText: "Sum"
        },
        tree: {
          emptyText: "No Data"
        },
        transfer: {
          noMatch: "No matching data",
          noData: "No data",
          titles: ["List 1", "List 2"],
          filterPlaceholder: "Enter keyword",
          noCheckedFormat: "{total} items",
          hasCheckedFormat: "{checked}/{total} checked"
        },
        image: {
          error: "FAILED"
        },
        pageHeader: {
          title: "Back"
        },
        popconfirm: {
          confirmButtonText: "Yes",
          cancelButtonText: "No"
        }
      }
    };
    const buildTranslator = (locale) => (path, option) => translate$1(path, option, unref(locale));
    const translate$1 = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
      var _a2;
      return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
    });
    const buildLocaleContext = (locale) => {
      const lang = computed(() => unref(locale).name);
      const localeRef = isRef(locale) ? locale : ref(locale);
      return {
        lang,
        locale: localeRef,
        t: buildTranslator(locale)
      };
    };
    const useLocale = () => {
      const locale = useGlobalConfig("locale");
      return buildLocaleContext(computed(() => locale.value || English));
    };
    const useLockscreen = (trigger2) => {
      if (!isRef(trigger2)) {
        throwError("[useLockscreen]", "You need to pass a ref param to this function");
      }
      const ns2 = useNamespace("popup");
      const hiddenCls = computed$1(() => ns2.bm("parent", "hidden"));
      if (!isClient || hasClass(document.body, hiddenCls.value)) {
        return;
      }
      let scrollBarWidth2 = 0;
      let withoutHiddenClass = false;
      let bodyWidth = "0";
      const cleanup = () => {
        removeClass(document.body, hiddenCls.value);
        if (withoutHiddenClass) {
          document.body.style.width = bodyWidth;
        }
      };
      watch(trigger2, (val) => {
        if (!val) {
          cleanup();
          return;
        }
        withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
        if (withoutHiddenClass) {
          bodyWidth = document.body.style.width;
        }
        scrollBarWidth2 = getScrollBarWidth(ns2.namespace.value);
        const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
        const bodyOverflowY = getStyle(document.body, "overflowY");
        if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
          document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
        }
        addClass(document.body, hiddenCls.value);
      });
      onScopeDispose(() => cleanup());
    };
    const _prop = buildProp({
      type: definePropType(Boolean),
      default: null
    });
    const _event = buildProp({
      type: definePropType(Function)
    });
    const createModelToggleComposable = (name) => {
      const updateEventKey = `update:${name}`;
      const updateEventKeyRaw = `onUpdate:${name}`;
      const useModelToggleEmits2 = [updateEventKey];
      const useModelToggleProps2 = {
        [name]: _prop,
        [updateEventKeyRaw]: _event
      };
      const useModelToggle2 = ({
        indicator,
        toggleReason,
        shouldHideWhenRouteChanges,
        shouldProceed,
        onShow,
        onHide
      }) => {
        const instance = getCurrentInstance();
        const { emit } = instance;
        const props = instance.props;
        const hasUpdateHandler = computed(() => isFunction$4(props[updateEventKeyRaw]));
        const isModelBindingAbsent = computed(() => props[name] === null);
        const doShow = (event) => {
          if (indicator.value === true) {
            return;
          }
          indicator.value = true;
          if (toggleReason) {
            toggleReason.value = event;
          }
          if (isFunction$4(onShow)) {
            onShow(event);
          }
        };
        const doHide = (event) => {
          if (indicator.value === false) {
            return;
          }
          indicator.value = false;
          if (toggleReason) {
            toggleReason.value = event;
          }
          if (isFunction$4(onHide)) {
            onHide(event);
          }
        };
        const show = (event) => {
          if (props.disabled === true || isFunction$4(shouldProceed) && !shouldProceed())
            return;
          const shouldEmit = hasUpdateHandler.value && isClient;
          if (shouldEmit) {
            emit(updateEventKey, true);
          }
          if (isModelBindingAbsent.value || !shouldEmit) {
            doShow(event);
          }
        };
        const hide = (event) => {
          if (props.disabled === true || !isClient)
            return;
          const shouldEmit = hasUpdateHandler.value && isClient;
          if (shouldEmit) {
            emit(updateEventKey, false);
          }
          if (isModelBindingAbsent.value || !shouldEmit) {
            doHide(event);
          }
        };
        const onChange = (val) => {
          if (!isBoolean$2(val))
            return;
          if (props.disabled && val) {
            if (hasUpdateHandler.value) {
              emit(updateEventKey, false);
            }
          } else if (indicator.value !== val) {
            if (val) {
              doShow();
            } else {
              doHide();
            }
          }
        };
        const toggle = () => {
          if (indicator.value) {
            hide();
          } else {
            show();
          }
        };
        watch(() => props[name], onChange);
        if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
          watch(() => ({
            ...instance.proxy.$route
          }), () => {
            if (shouldHideWhenRouteChanges.value && indicator.value) {
              hide();
            }
          });
        }
        onMounted(() => {
          onChange(props[name]);
        });
        return {
          hide,
          show,
          toggle,
          hasUpdateHandler
        };
      };
      return {
        useModelToggle: useModelToggle2,
        useModelToggleProps: useModelToggleProps2,
        useModelToggleEmits: useModelToggleEmits2
      };
    };
    const useRestoreActive = (toggle, initialFocus) => {
      let previousActive;
      watch(() => toggle.value, (val) => {
        var _a2, _b;
        if (val) {
          previousActive = document.activeElement;
          if (isRef(initialFocus)) {
            (_b = (_a2 = initialFocus.value).focus) == null ? void 0 : _b.call(_a2);
          }
        } else {
          {
            previousActive.focus();
          }
        }
      });
    };
    const useSameTarget = (handleClick) => {
      if (!handleClick) {
        return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
      }
      let mousedownTarget = false;
      let mouseupTarget = false;
      const onClick = (e) => {
        if (mousedownTarget && mouseupTarget) {
          handleClick(e);
        }
        mousedownTarget = mouseupTarget = false;
      };
      const onMousedown = (e) => {
        mousedownTarget = e.target === e.currentTarget;
      };
      const onMouseup = (e) => {
        mouseupTarget = e.target === e.currentTarget;
      };
      return { onClick, onMousedown, onMouseup };
    };
    const useThrottleRender = (loading, throttle2 = 0) => {
      if (throttle2 === 0)
        return loading;
      const throttled = ref(false);
      let timeoutHandle = 0;
      const dispatchThrottling = () => {
        if (timeoutHandle) {
          clearTimeout(timeoutHandle);
        }
        timeoutHandle = window.setTimeout(() => {
          throttled.value = loading.value;
        }, throttle2);
      };
      onMounted(dispatchThrottling);
      watch(() => loading.value, (val) => {
        if (val) {
          dispatchThrottling();
        } else {
          throttled.value = val;
        }
      });
      return throttled;
    };
    function useTimeout() {
      let timeoutHandle;
      const registerTimeout = (fn2, delay) => {
        cancelTimeout();
        timeoutHandle = window.setTimeout(fn2, delay);
      };
      const cancelTimeout = () => window.clearTimeout(timeoutHandle);
      tryOnScopeDispose(() => cancelTimeout());
      return {
        registerTimeout,
        cancelTimeout
      };
    }
    let registeredEscapeHandlers = [];
    const cachedHandler = (e) => {
      const event = e;
      if (event.key === EVENT_CODE.esc) {
        registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
      }
    };
    const useEscapeKeydown = (handler) => {
      onMounted(() => {
        if (registeredEscapeHandlers.length === 0) {
          document.addEventListener("keydown", cachedHandler);
        }
        if (isClient)
          registeredEscapeHandlers.push(handler);
      });
      onBeforeUnmount(() => {
        registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
        if (registeredEscapeHandlers.length === 0) {
          if (isClient)
            document.removeEventListener("keydown", cachedHandler);
        }
      });
    };
    let cachedContainer;
    const POPPER_CONTAINER_ID = `el-popper-container-${generateId()}`;
    const POPPER_CONTAINER_SELECTOR = `#${POPPER_CONTAINER_ID}`;
    const createContainer = () => {
      const container = document.createElement("div");
      container.id = POPPER_CONTAINER_ID;
      document.body.appendChild(container);
      return container;
    };
    const usePopperContainer = () => {
      onBeforeMount(() => {
        if (!isClient)
          return;
        if (!cachedContainer || !document.body.querySelector(POPPER_CONTAINER_SELECTOR)) {
          cachedContainer = createContainer();
        }
      });
    };
    const useDelayedToggleProps = buildProps({
      showAfter: {
        type: Number,
        default: 0
      },
      hideAfter: {
        type: Number,
        default: 200
      }
    });
    const useDelayedToggle = ({
      showAfter,
      hideAfter,
      open,
      close: close2
    }) => {
      const { registerTimeout } = useTimeout();
      const onOpen = (event) => {
        registerTimeout(() => {
          open(event);
        }, unref(showAfter));
      };
      const onClose = (event) => {
        registerTimeout(() => {
          close2(event);
        }, unref(hideAfter));
      };
      return {
        onOpen,
        onClose
      };
    };
    const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
    const useForwardRef = (forwardRef) => {
      const setForwardRef = (el) => {
        forwardRef.value = el;
      };
      provide(FORWARD_REF_INJECTION_KEY, {
        setForwardRef
      });
    };
    const useForwardRefDirective = (setForwardRef) => {
      return {
        mounted(el) {
          setForwardRef(el);
        },
        updated(el) {
          setForwardRef(el);
        },
        unmounted() {
          setForwardRef(null);
        }
      };
    };
    const zIndex = ref(0);
    const useZIndex = () => {
      const initialZIndex = useGlobalConfig("zIndex", 2e3);
      const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
      const nextZIndex = () => {
        zIndex.value++;
        return currentZIndex.value;
      };
      return {
        initialZIndex,
        currentZIndex,
        nextZIndex
      };
    };
    function getSide(placement) {
      return placement.split("-")[0];
    }
    function getAlignment(placement) {
      return placement.split("-")[1];
    }
    function getMainAxisFromPlacement(placement) {
      return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
    }
    function getLengthFromAxis(axis) {
      return axis === "y" ? "height" : "width";
    }
    function computeCoordsFromPlacement(_ref, placement, rtl) {
      let {
        reference,
        floating
      } = _ref;
      const commonX = reference.x + reference.width / 2 - floating.width / 2;
      const commonY = reference.y + reference.height / 2 - floating.height / 2;
      const mainAxis = getMainAxisFromPlacement(placement);
      const length = getLengthFromAxis(mainAxis);
      const commonAlign = reference[length] / 2 - floating[length] / 2;
      const side = getSide(placement);
      const isVertical = mainAxis === "x";
      let coords;
      switch (side) {
        case "top":
          coords = {
            x: commonX,
            y: reference.y - floating.height
          };
          break;
        case "bottom":
          coords = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;
        case "right":
          coords = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;
        case "left":
          coords = {
            x: reference.x - floating.width,
            y: commonY
          };
          break;
        default:
          coords = {
            x: reference.x,
            y: reference.y
          };
      }
      switch (getAlignment(placement)) {
        case "start":
          coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
          break;
        case "end":
          coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
          break;
      }
      return coords;
    }
    const computePosition$1 = async (reference, floating, config) => {
      const {
        placement = "bottom",
        strategy = "absolute",
        middleware = [],
        platform: platform2
      } = config;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
      let rects = await platform2.getElementRects({
        reference,
        floating,
        strategy
      });
      let {
        x: x2,
        y
      } = computeCoordsFromPlacement(rects, placement, rtl);
      let statefulPlacement = placement;
      let middlewareData = {};
      let resetCount = 0;
      for (let i = 0; i < middleware.length; i++) {
        const {
          name,
          fn: fn2
        } = middleware[i];
        const {
          x: nextX,
          y: nextY,
          data,
          reset: reset2
        } = await fn2({
          x: x2,
          y,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform: platform2,
          elements: {
            reference,
            floating
          }
        });
        x2 = nextX != null ? nextX : x2;
        y = nextY != null ? nextY : y;
        middlewareData = {
          ...middlewareData,
          [name]: {
            ...middlewareData[name],
            ...data
          }
        };
        if (reset2 && resetCount <= 50) {
          resetCount++;
          if (typeof reset2 === "object") {
            if (reset2.placement) {
              statefulPlacement = reset2.placement;
            }
            if (reset2.rects) {
              rects = reset2.rects === true ? await platform2.getElementRects({
                reference,
                floating,
                strategy
              }) : reset2.rects;
            }
            ({
              x: x2,
              y
            } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
          }
          i = -1;
          continue;
        }
      }
      return {
        x: x2,
        y,
        placement: statefulPlacement,
        strategy,
        middlewareData
      };
    };
    function expandPaddingObject(padding) {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...padding
      };
    }
    function getSideObjectFromPadding(padding) {
      return typeof padding !== "number" ? expandPaddingObject(padding) : {
        top: padding,
        right: padding,
        bottom: padding,
        left: padding
      };
    }
    function rectToClientRect(rect) {
      return {
        ...rect,
        top: rect.y,
        left: rect.x,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      };
    }
    const min$2 = Math.min;
    const max$2 = Math.max;
    function within(min$12, value, max$12) {
      return max$2(min$12, min$2(value, max$12));
    }
    const arrow = (options) => ({
      name: "arrow",
      options,
      async fn(middlewareArguments) {
        const {
          element,
          padding = 0
        } = options != null ? options : {};
        const {
          x: x2,
          y,
          placement,
          rects,
          platform: platform2
        } = middlewareArguments;
        if (element == null) {
          return {};
        }
        const paddingObject = getSideObjectFromPadding(padding);
        const coords = {
          x: x2,
          y
        };
        const axis = getMainAxisFromPlacement(placement);
        const alignment = getAlignment(placement);
        const length = getLengthFromAxis(axis);
        const arrowDimensions = await platform2.getDimensions(element);
        const minProp = axis === "y" ? "top" : "left";
        const maxProp = axis === "y" ? "bottom" : "right";
        const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
        let clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
        if (clientSize === 0) {
          clientSize = rects.floating[length];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;
        const min2 = paddingObject[minProp];
        const max2 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
        const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
        const offset2 = within(min2, center, max2);
        const alignmentPadding = alignment === "start" ? paddingObject[minProp] : paddingObject[maxProp];
        const shouldAddOffset = alignmentPadding > 0 && center !== offset2 && rects.reference[length] <= rects.floating[length];
        const alignmentOffset = shouldAddOffset ? center < min2 ? min2 - center : max2 - center : 0;
        return {
          [axis]: coords[axis] - alignmentOffset,
          data: {
            [axis]: offset2,
            centerOffset: center - offset2
          }
        };
      }
    });
    async function convertValueToCoords(middlewareArguments, value) {
      const {
        placement,
        platform: platform2,
        elements
      } = middlewareArguments;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isVertical = getMainAxisFromPlacement(placement) === "x";
      const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
      const crossAxisMulti = rtl && isVertical ? -1 : 1;
      const rawValue = typeof value === "function" ? value(middlewareArguments) : value;
      let {
        mainAxis,
        crossAxis,
        alignmentAxis
      } = typeof rawValue === "number" ? {
        mainAxis: rawValue,
        crossAxis: 0,
        alignmentAxis: null
      } : {
        mainAxis: 0,
        crossAxis: 0,
        alignmentAxis: null,
        ...rawValue
      };
      if (alignment && typeof alignmentAxis === "number") {
        crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
      }
      return isVertical ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti
      } : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti
      };
    }
    const offset = function(value) {
      if (value === void 0) {
        value = 0;
      }
      return {
        name: "offset",
        options: value,
        async fn(middlewareArguments) {
          const {
            x: x2,
            y
          } = middlewareArguments;
          const diffCoords = await convertValueToCoords(middlewareArguments, value);
          return {
            x: x2 + diffCoords.x,
            y: y + diffCoords.y,
            data: diffCoords
          };
        }
      };
    };
    function isWindow(value) {
      return value && value.document && value.location && value.alert && value.setInterval;
    }
    function getWindow(node) {
      if (node == null) {
        return window;
      }
      if (!isWindow(node)) {
        const ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }
      return node;
    }
    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function getNodeName(node) {
      return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
    }
    function getUAString() {
      const uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands) {
        return uaData.brands.map((item) => item.brand + "/" + item.version).join(" ");
      }
      return navigator.userAgent;
    }
    function isHTMLElement(value) {
      return value instanceof getWindow(value).HTMLElement;
    }
    function isElement(value) {
      return value instanceof getWindow(value).Element;
    }
    function isNode(value) {
      return value instanceof getWindow(value).Node;
    }
    function isShadowRoot(node) {
      if (typeof ShadowRoot === "undefined") {
        return false;
      }
      const OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }
    function isOverflowElement(element) {
      const {
        overflow,
        overflowX,
        overflowY
      } = getComputedStyle$1(element);
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    function isTableElement(element) {
      return ["table", "td", "th"].includes(getNodeName(element));
    }
    function isContainingBlock(element) {
      const isFirefox2 = /firefox/i.test(getUAString());
      const css = getComputedStyle$1(element);
      return css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || isFirefox2 && css.willChange === "filter" || isFirefox2 && (css.filter ? css.filter !== "none" : false);
    }
    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }
    const min$1 = Math.min;
    const max$1 = Math.max;
    const round = Math.round;
    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      const clientRect = element.getBoundingClientRect();
      let scaleX = 1;
      let scaleY = 1;
      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
      }
      const win = isElement(element) ? getWindow(element) : window;
      const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      const x2 = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
      const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
      const width = clientRect.width / scaleX;
      const height = clientRect.height / scaleY;
      return {
        width,
        height,
        top: y,
        right: x2 + width,
        bottom: y + height,
        left: x2,
        x: x2,
        y
      };
    }
    function getDocumentElement(node) {
      return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
    }
    function getNodeScroll(element) {
      if (isElement(element)) {
        return {
          scrollLeft: element.scrollLeft,
          scrollTop: element.scrollTop
        };
      }
      return {
        scrollLeft: element.pageXOffset,
        scrollTop: element.pageYOffset
      };
    }
    function getWindowScrollBarX(element) {
      return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
    }
    function isScaled(element) {
      const rect = getBoundingClientRect(element);
      return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
    }
    function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
      const isOffsetParentAnElement = isHTMLElement(offsetParent);
      const documentElement = getDocumentElement(offsetParent);
      const rect = getBoundingClientRect(
        element,
        isOffsetParentAnElement && isScaled(offsetParent),
        strategy === "fixed"
      );
      let scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      const offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
        if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          const offsetRect = getBoundingClientRect(offsetParent, true);
          offsets.x = offsetRect.x + offsetParent.clientLeft;
          offsets.y = offsetRect.y + offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    function getParentNode(node) {
      if (getNodeName(node) === "html") {
        return node;
      }
      return node.assignedSlot || node.parentNode || (isShadowRoot(node) ? node.host : null) || getDocumentElement(node);
    }
    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
        return null;
      }
      return composedOffsetParent(element);
    }
    function composedOffsetParent(element) {
      let {
        offsetParent
      } = element;
      let ancestor = element;
      let foundInsideSlot = false;
      while (ancestor && ancestor !== offsetParent) {
        const {
          assignedSlot
        } = ancestor;
        if (assignedSlot) {
          let newOffsetParent = assignedSlot.offsetParent;
          if (getComputedStyle$1(assignedSlot).display === "contents") {
            const hadStyleAttribute = assignedSlot.hasAttribute("style");
            const oldDisplay = assignedSlot.style.display;
            assignedSlot.style.display = getComputedStyle$1(ancestor).display;
            newOffsetParent = assignedSlot.offsetParent;
            assignedSlot.style.display = oldDisplay;
            if (!hadStyleAttribute) {
              assignedSlot.removeAttribute("style");
            }
          }
          ancestor = assignedSlot;
          if (offsetParent !== newOffsetParent) {
            offsetParent = newOffsetParent;
            foundInsideSlot = true;
          }
        } else if (isShadowRoot(ancestor) && ancestor.host && foundInsideSlot) {
          break;
        }
        ancestor = isShadowRoot(ancestor) && ancestor.host || ancestor.parentNode;
      }
      return offsetParent;
    }
    function getContainingBlock(element) {
      let currentNode = getParentNode(element);
      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }
      while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
        if (isContainingBlock(currentNode)) {
          return currentNode;
        } else {
          const parent = currentNode.parentNode;
          currentNode = isShadowRoot(parent) ? parent.host : parent;
        }
      }
      return null;
    }
    function getOffsetParent(element) {
      const window2 = getWindow(element);
      let offsetParent = getTrueOffsetParent(element);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
        return window2;
      }
      return offsetParent || getContainingBlock(element) || window2;
    }
    function getDimensions(element) {
      if (isHTMLElement(element)) {
        return {
          width: element.offsetWidth,
          height: element.offsetHeight
        };
      }
      const rect = getBoundingClientRect(element);
      return {
        width: rect.width,
        height: rect.height
      };
    }
    function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
      let {
        rect,
        offsetParent,
        strategy
      } = _ref;
      const isOffsetParentAnElement = isHTMLElement(offsetParent);
      const documentElement = getDocumentElement(offsetParent);
      if (offsetParent === documentElement) {
        return rect;
      }
      let scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      const offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
        if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          const offsetRect = getBoundingClientRect(offsetParent, true);
          offsets.x = offsetRect.x + offsetParent.clientLeft;
          offsets.y = offsetRect.y + offsetParent.clientTop;
        }
      }
      return {
        ...rect,
        x: rect.x - scroll.scrollLeft + offsets.x,
        y: rect.y - scroll.scrollTop + offsets.y
      };
    }
    function getViewportRect(element, strategy) {
      const win = getWindow(element);
      const html = getDocumentElement(element);
      const visualViewport = win.visualViewport;
      let width = html.clientWidth;
      let height = html.clientHeight;
      let x2 = 0;
      let y = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        const layoutViewport = isLayoutViewport();
        if (layoutViewport || !layoutViewport && strategy === "fixed") {
          x2 = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }
      return {
        width,
        height,
        x: x2,
        y
      };
    }
    function getDocumentRect(element) {
      var _element$ownerDocumen;
      const html = getDocumentElement(element);
      const scroll = getNodeScroll(element);
      const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      const width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      const height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
      const y = -scroll.scrollTop;
      if (getComputedStyle$1(body || html).direction === "rtl") {
        x2 += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
      }
      return {
        width,
        height,
        x: x2,
        y
      };
    }
    function getNearestOverflowAncestor(node) {
      const parentNode = getParentNode(node);
      if (["html", "body", "#document"].includes(getNodeName(parentNode))) {
        return node.ownerDocument.body;
      }
      if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
        return parentNode;
      }
      return getNearestOverflowAncestor(parentNode);
    }
    function getOverflowAncestors(node, list) {
      var _node$ownerDocument;
      if (list === void 0) {
        list = [];
      }
      const scrollableAncestor = getNearestOverflowAncestor(node);
      const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
      const win = getWindow(scrollableAncestor);
      const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
      const updatedList = list.concat(target);
      return isBody ? updatedList : updatedList.concat(getOverflowAncestors(target));
    }
    function contains(parent, child) {
      const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
      if (parent.contains(child)) {
        return true;
      } else if (rootNode && isShadowRoot(rootNode)) {
        let next = child;
        do {
          if (next && parent === next) {
            return true;
          }
          next = next.parentNode || next.host;
        } while (next);
      }
      return false;
    }
    function getInnerBoundingClientRect(element, strategy) {
      const clientRect = getBoundingClientRect(element, false, strategy === "fixed");
      const top = clientRect.top + element.clientTop;
      const left2 = clientRect.left + element.clientLeft;
      return {
        top,
        left: left2,
        x: left2,
        y: top,
        right: left2 + element.clientWidth,
        bottom: top + element.clientHeight,
        width: element.clientWidth,
        height: element.clientHeight
      };
    }
    function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
      if (clippingParent === "viewport") {
        return rectToClientRect(getViewportRect(element, strategy));
      }
      if (isElement(clippingParent)) {
        return getInnerBoundingClientRect(clippingParent, strategy);
      }
      return rectToClientRect(getDocumentRect(getDocumentElement(element)));
    }
    function getClippingAncestors(element) {
      const clippingAncestors = getOverflowAncestors(element);
      const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1(element).position);
      const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
      if (!isElement(clipperElement)) {
        return [];
      }
      return clippingAncestors.filter((clippingAncestors2) => isElement(clippingAncestors2) && contains(clippingAncestors2, clipperElement) && getNodeName(clippingAncestors2) !== "body");
    }
    function getClippingRect(_ref) {
      let {
        element,
        boundary,
        rootBoundary,
        strategy
      } = _ref;
      const mainClippingAncestors = boundary === "clippingAncestors" ? getClippingAncestors(element) : [].concat(boundary);
      const clippingAncestors = [...mainClippingAncestors, rootBoundary];
      const firstClippingAncestor = clippingAncestors[0];
      const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
        accRect.top = max$1(rect.top, accRect.top);
        accRect.right = min$1(rect.right, accRect.right);
        accRect.bottom = min$1(rect.bottom, accRect.bottom);
        accRect.left = max$1(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
      return {
        width: clippingRect.right - clippingRect.left,
        height: clippingRect.bottom - clippingRect.top,
        x: clippingRect.left,
        y: clippingRect.top
      };
    }
    const platform$1 = {
      getClippingRect,
      convertOffsetParentRelativeRectToViewportRelativeRect,
      isElement,
      getDimensions,
      getOffsetParent,
      getDocumentElement,
      getElementRects: (_ref) => {
        let {
          reference,
          floating,
          strategy
        } = _ref;
        return {
          reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
          floating: {
            ...getDimensions(floating),
            x: 0,
            y: 0
          }
        };
      },
      getClientRects: (element) => Array.from(element.getClientRects()),
      isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
    };
    const computePosition = (reference, floating, options) => computePosition$1(reference, floating, {
      platform: platform$1,
      ...options
    });
    buildProps({});
    const unrefReference = (elRef) => {
      if (!isClient)
        return;
      if (!elRef)
        return elRef;
      const unrefEl = unrefElement(elRef);
      if (unrefEl)
        return unrefEl;
      return isRef(elRef) ? unrefEl : elRef;
    };
    const useFloating = ({
      middleware,
      placement,
      strategy
    }) => {
      const referenceRef = ref();
      const contentRef = ref();
      const x2 = ref();
      const y = ref();
      const middlewareData = ref({});
      const states = {
        x: x2,
        y,
        placement,
        strategy,
        middlewareData
      };
      const update = async () => {
        if (!isClient)
          return;
        const referenceEl = unrefReference(referenceRef);
        const contentEl = unrefElement(contentRef);
        if (!referenceEl || !contentEl)
          return;
        const data = await computePosition(referenceEl, contentEl, {
          placement: unref(placement),
          strategy: unref(strategy),
          middleware: unref(middleware)
        });
        keysOf(states).forEach((key) => {
          states[key].value = data[key];
        });
      };
      onMounted(() => {
        watchEffect(() => {
          update();
        });
      });
      return {
        ...states,
        update,
        referenceRef,
        contentRef
      };
    };
    const arrowMiddleware = ({
      arrowRef,
      padding
    }) => {
      return {
        name: "arrow",
        options: {
          element: arrowRef,
          padding
        },
        fn(args) {
          const arrowEl = unref(arrowRef);
          if (!arrowEl)
            return {};
          return arrow({
            element: arrowEl,
            padding
          }).fn(args);
        }
      };
    };
    function useCursor(input) {
      const selectionRef = ref();
      function recordCursor() {
        if (input.value == void 0)
          return;
        const { selectionStart, selectionEnd, value } = input.value;
        if (selectionStart == null || selectionEnd == null)
          return;
        const beforeTxt = value.slice(0, Math.max(0, selectionStart));
        const afterTxt = value.slice(Math.max(0, selectionEnd));
        selectionRef.value = {
          selectionStart,
          selectionEnd,
          value,
          beforeTxt,
          afterTxt
        };
      }
      function setCursor() {
        if (input.value == void 0 || selectionRef.value == void 0)
          return;
        const { value } = input.value;
        const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
        if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
          return;
        let startPos = value.length;
        if (value.endsWith(afterTxt)) {
          startPos = value.length - afterTxt.length;
        } else if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else {
          const beforeLastChar = beforeTxt[selectionStart - 1];
          const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        input.value.setSelectionRange(startPos, startPos);
      }
      return [recordCursor, setCursor];
    }
    const version = "2.2.16";
    const makeInstaller = (components = []) => {
      const install = (app2, options) => {
        if (app2[INSTALLED_KEY])
          return;
        app2[INSTALLED_KEY] = true;
        components.forEach((c2) => app2.use(c2));
        if (options)
          provideGlobalConfig(options, app2, true);
      };
      return {
        version,
        install
      };
    };
    const affixProps = buildProps({
      zIndex: {
        type: definePropType([Number, String]),
        default: 100
      },
      target: {
        type: String,
        default: ""
      },
      offset: {
        type: Number,
        default: 0
      },
      position: {
        type: String,
        values: ["top", "bottom"],
        default: "top"
      }
    });
    const affixEmits = {
      scroll: ({ scrollTop, fixed }) => isNumber$2(scrollTop) && isBoolean$2(fixed),
      [CHANGE_EVENT]: (fixed) => isBoolean$2(fixed)
    };
    var _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const __default__$1q = {
      name: "ElAffix"
    };
    const _sfc_main$2i = /* @__PURE__ */ defineComponent({
      ...__default__$1q,
      props: affixProps,
      emits: affixEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const COMPONENT_NAME2 = "ElAffix";
        const ns2 = useNamespace("affix");
        const target = shallowRef();
        const root2 = shallowRef();
        const scrollContainer = shallowRef();
        const { height: windowHeight } = useWindowSize();
        const {
          height: rootHeight,
          width: rootWidth,
          top: rootTop,
          bottom: rootBottom,
          update: updateRoot
        } = useElementBounding(root2);
        const targetRect = useElementBounding(target);
        const fixed = ref(false);
        const scrollTop = ref(0);
        const transform2 = ref(0);
        const rootStyle = computed(() => {
          return {
            height: fixed.value ? `${rootHeight.value}px` : "",
            width: fixed.value ? `${rootWidth.value}px` : ""
          };
        });
        const affixStyle = computed(() => {
          if (!fixed.value)
            return {};
          const offset2 = props.offset ? `${props.offset}px` : 0;
          return {
            height: `${rootHeight.value}px`,
            width: `${rootWidth.value}px`,
            top: props.position === "top" ? offset2 : "",
            bottom: props.position === "bottom" ? offset2 : "",
            transform: transform2.value ? `translateY(${transform2.value}px)` : "",
            zIndex: props.zIndex
          };
        });
        const update = () => {
          if (!scrollContainer.value)
            return;
          scrollTop.value = scrollContainer.value instanceof Window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop || 0;
          if (props.position === "top") {
            if (props.target) {
              const difference = targetRect.bottom.value - props.offset - rootHeight.value;
              fixed.value = props.offset > rootTop.value && targetRect.bottom.value > 0;
              transform2.value = difference < 0 ? difference : 0;
            } else {
              fixed.value = props.offset > rootTop.value;
            }
          } else if (props.target) {
            const difference = windowHeight.value - targetRect.top.value - props.offset - rootHeight.value;
            fixed.value = windowHeight.value - props.offset < rootBottom.value && windowHeight.value > targetRect.top.value;
            transform2.value = difference < 0 ? -difference : 0;
          } else {
            fixed.value = windowHeight.value - props.offset < rootBottom.value;
          }
        };
        const handleScroll2 = () => {
          emit("scroll", {
            scrollTop: scrollTop.value,
            fixed: fixed.value
          });
        };
        watch(fixed, (val) => emit("change", val));
        onMounted(() => {
          var _a2;
          if (props.target) {
            target.value = (_a2 = document.querySelector(props.target)) != null ? _a2 : void 0;
            if (!target.value)
              throwError(COMPONENT_NAME2, `Target is not existed: ${props.target}`);
          } else {
            target.value = document.documentElement;
          }
          scrollContainer.value = getScrollContainer(root2.value, true);
          updateRoot();
        });
        useEventListener(scrollContainer, "scroll", handleScroll2);
        watchEffect(update);
        expose({
          update,
          updateRoot
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "root",
            ref: root2,
            class: normalizeClass(unref(ns2).b()),
            style: normalizeStyle(unref(rootStyle))
          }, [
            createBaseVNode("div", {
              class: normalizeClass({ [unref(ns2).m("fixed")]: fixed.value }),
              style: normalizeStyle(unref(affixStyle))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6)
          ], 6);
        };
      }
    });
    var Affix = /* @__PURE__ */ _export_sfc(_sfc_main$2i, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/affix/src/affix.vue"]]);
    const ElAffix = withInstall(Affix);
    const iconProps = buildProps({
      size: {
        type: definePropType([Number, String])
      },
      color: {
        type: String
      }
    });
    const __default__$1p = {
      name: "ElIcon",
      inheritAttrs: false
    };
    const _sfc_main$2h = /* @__PURE__ */ defineComponent({
      ...__default__$1p,
      props: iconProps,
      setup(__props) {
        const props = __props;
        const ns2 = useNamespace("icon");
        const style2 = computed(() => {
          const { size: size2, color } = props;
          if (!size2 && !color)
            return {};
          return {
            fontSize: isUndefined$1(size2) ? void 0 : addUnit(size2),
            "--color": color
          };
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("i", mergeProps({
            class: unref(ns2).b(),
            style: unref(style2)
          }, _ctx.$attrs), [
            renderSlot(_ctx.$slots, "default")
          ], 16);
        };
      }
    });
    var Icon = /* @__PURE__ */ _export_sfc(_sfc_main$2h, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
    const ElIcon = withInstall(Icon);
    const alertEffects = ["light", "dark"];
    const alertProps = buildProps({
      title: {
        type: String,
        default: ""
      },
      description: {
        type: String,
        default: ""
      },
      type: {
        type: String,
        values: keysOf(TypeComponentsMap),
        default: "info"
      },
      closable: {
        type: Boolean,
        default: true
      },
      closeText: {
        type: String,
        default: ""
      },
      showIcon: Boolean,
      center: Boolean,
      effect: {
        type: String,
        values: alertEffects,
        default: "light"
      }
    });
    const alertEmits = {
      close: (evt) => evt instanceof MouseEvent
    };
    const __default__$1o = {
      name: "ElAlert"
    };
    const _sfc_main$2g = /* @__PURE__ */ defineComponent({
      ...__default__$1o,
      props: alertProps,
      emits: alertEmits,
      setup(__props, { emit }) {
        const props = __props;
        const { Close } = TypeComponents;
        const slots = useSlots();
        const ns2 = useNamespace("alert");
        const visible = ref(true);
        const iconComponent = computed(() => TypeComponentsMap[props.type]);
        const iconClass = computed(() => [
          ns2.e("icon"),
          { [ns2.is("big")]: !!props.description || !!slots.default }
        ]);
        const isBoldTitle = computed(() => props.description || { [ns2.is("bold")]: slots.default });
        const close2 = (evt) => {
          visible.value = false;
          emit("close", evt);
        };
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition, {
            name: unref(ns2).b("fade"),
            persisted: ""
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                class: normalizeClass([unref(ns2).b(), unref(ns2).m(_ctx.type), unref(ns2).is("center", _ctx.center), unref(ns2).is(_ctx.effect)]),
                role: "alert"
              }, [
                _ctx.showIcon && unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(iconClass))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns2).e("content"))
                }, [
                  _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass([unref(ns2).e("title"), unref(isBoldTitle)])
                  }, [
                    renderSlot(_ctx.$slots, "title", {}, () => [
                      createTextVNode(toDisplayString$1(_ctx.title), 1)
                    ])
                  ], 2)) : createCommentVNode("v-if", true),
                  _ctx.$slots.default || _ctx.description ? (openBlock(), createElementBlock("p", {
                    key: 1,
                    class: normalizeClass(unref(ns2).e("description"))
                  }, [
                    renderSlot(_ctx.$slots, "default", {}, () => [
                      createTextVNode(toDisplayString$1(_ctx.description), 1)
                    ])
                  ], 2)) : createCommentVNode("v-if", true),
                  _ctx.closable ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    _ctx.closeText ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass([unref(ns2).e("close-btn"), unref(ns2).is("customed")]),
                      onClick: close2
                    }, toDisplayString$1(_ctx.closeText), 3)) : (openBlock(), createBlock(unref(ElIcon), {
                      key: 1,
                      class: normalizeClass(unref(ns2).e("close-btn")),
                      onClick: close2
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(Close))
                      ]),
                      _: 1
                    }, 8, ["class"]))
                  ], 64)) : createCommentVNode("v-if", true)
                ], 2)
              ], 2), [
                [vShow, visible.value]
              ])
            ]),
            _: 3
          }, 8, ["name"]);
        };
      }
    });
    var Alert = /* @__PURE__ */ _export_sfc(_sfc_main$2g, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/alert/src/alert.vue"]]);
    const ElAlert = withInstall(Alert);
    let hiddenTextarea = void 0;
    const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
    const CONTEXT_STYLE = [
      "letter-spacing",
      "line-height",
      "padding-top",
      "padding-bottom",
      "font-family",
      "font-weight",
      "font-size",
      "text-rendering",
      "text-transform",
      "width",
      "text-indent",
      "padding-left",
      "padding-right",
      "border-width",
      "box-sizing"
    ];
    function calculateNodeStyling(targetElement) {
      const style2 = window.getComputedStyle(targetElement);
      const boxSizing = style2.getPropertyValue("box-sizing");
      const paddingSize = Number.parseFloat(style2.getPropertyValue("padding-bottom")) + Number.parseFloat(style2.getPropertyValue("padding-top"));
      const borderSize = Number.parseFloat(style2.getPropertyValue("border-bottom-width")) + Number.parseFloat(style2.getPropertyValue("border-top-width"));
      const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style2.getPropertyValue(name)}`).join(";");
      return { contextStyle, paddingSize, borderSize, boxSizing };
    }
    function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
      var _a2;
      if (!hiddenTextarea) {
        hiddenTextarea = document.createElement("textarea");
        document.body.appendChild(hiddenTextarea);
      }
      const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
      hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
      hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
      let height = hiddenTextarea.scrollHeight;
      const result = {};
      if (boxSizing === "border-box") {
        height = height + borderSize;
      } else if (boxSizing === "content-box") {
        height = height - paddingSize;
      }
      hiddenTextarea.value = "";
      const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
      if (isNumber$2(minRows)) {
        let minHeight = singleRowHeight * minRows;
        if (boxSizing === "border-box") {
          minHeight = minHeight + paddingSize + borderSize;
        }
        height = Math.max(minHeight, height);
        result.minHeight = `${minHeight}px`;
      }
      if (isNumber$2(maxRows)) {
        let maxHeight = singleRowHeight * maxRows;
        if (boxSizing === "border-box") {
          maxHeight = maxHeight + paddingSize + borderSize;
        }
        height = Math.min(maxHeight, height);
      }
      result.height = `${height}px`;
      (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
      hiddenTextarea = void 0;
      return result;
    }
    const inputProps = buildProps({
      id: {
        type: String,
        default: void 0
      },
      size: useSizeProp,
      disabled: Boolean,
      modelValue: {
        type: definePropType([
          String,
          Number,
          Object
        ]),
        default: ""
      },
      type: {
        type: String,
        default: "text"
      },
      resize: {
        type: String,
        values: ["none", "both", "horizontal", "vertical"]
      },
      autosize: {
        type: definePropType([Boolean, Object]),
        default: false
      },
      autocomplete: {
        type: String,
        default: "off"
      },
      formatter: {
        type: Function
      },
      parser: {
        type: Function
      },
      placeholder: {
        type: String
      },
      form: {
        type: String,
        default: ""
      },
      readonly: {
        type: Boolean,
        default: false
      },
      clearable: {
        type: Boolean,
        default: false
      },
      showPassword: {
        type: Boolean,
        default: false
      },
      showWordLimit: {
        type: Boolean,
        default: false
      },
      suffixIcon: {
        type: iconPropType
      },
      prefixIcon: {
        type: iconPropType
      },
      containerRole: {
        type: String,
        default: void 0
      },
      label: {
        type: String,
        default: void 0
      },
      tabindex: {
        type: [String, Number],
        default: 0
      },
      validateEvent: {
        type: Boolean,
        default: true
      },
      inputStyle: {
        type: definePropType([Object, Array, String]),
        default: () => mutable({})
      }
    });
    const inputEmits = {
      [UPDATE_MODEL_EVENT]: (value) => isString$3(value),
      input: (value) => isString$3(value),
      change: (value) => isString$3(value),
      focus: (evt) => evt instanceof FocusEvent,
      blur: (evt) => evt instanceof FocusEvent,
      clear: () => true,
      mouseleave: (evt) => evt instanceof MouseEvent,
      mouseenter: (evt) => evt instanceof MouseEvent,
      keydown: (evt) => evt instanceof Event,
      compositionstart: (evt) => evt instanceof CompositionEvent,
      compositionupdate: (evt) => evt instanceof CompositionEvent,
      compositionend: (evt) => evt instanceof CompositionEvent
    };
    const _hoisted_1$16 = ["role"];
    const _hoisted_2$I = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder"];
    const _hoisted_3$o = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder"];
    const __default__$1n = {
      name: "ElInput",
      inheritAttrs: false
    };
    const _sfc_main$2f = /* @__PURE__ */ defineComponent({
      ...__default__$1n,
      props: inputProps,
      emits: inputEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const PENDANT_MAP = {
          suffix: "append",
          prefix: "prepend"
        };
        const instance = getCurrentInstance();
        const rawAttrs = useAttrs$1();
        const slots = useSlots();
        const containerAttrs = computed(() => {
          const comboBoxAttrs = {};
          if (props.containerRole === "combobox") {
            comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
            comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
            comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
          }
          return comboBoxAttrs;
        });
        const attrs = useAttrs({
          excludeKeys: computed(() => {
            return Object.keys(containerAttrs.value);
          })
        });
        const { form, formItem } = useFormItem();
        const { inputId } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const inputSize = useSize();
        const inputDisabled = useDisabled$1();
        const nsInput = useNamespace("input");
        const nsTextarea = useNamespace("textarea");
        const input = shallowRef();
        const textarea = shallowRef();
        const focused = ref(false);
        const hovering = ref(false);
        const isComposing = ref(false);
        const passwordVisible = ref(false);
        const countStyle = ref();
        const textareaCalcStyle = shallowRef(props.inputStyle);
        const _ref = computed(() => input.value || textarea.value);
        const needStatusIcon = computed(() => {
          var _a2;
          return (_a2 = form == null ? void 0 : form.statusIcon) != null ? _a2 : false;
        });
        const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
        const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
        const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
        const containerStyle = computed(() => [
          rawAttrs.style,
          props.inputStyle
        ]);
        const textareaStyle = computed(() => [
          props.inputStyle,
          textareaCalcStyle.value,
          { resize: props.resize }
        ]);
        const nativeInputValue = computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
        const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (focused.value || hovering.value));
        const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || focused.value));
        const isWordLimitVisible = computed(() => props.showWordLimit && !!attrs.value.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
        const textLength = computed(() => Array.from(nativeInputValue.value).length);
        const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));
        const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
        const [recordCursor, setCursor] = useCursor(input);
        useResizeObserver(textarea, (entries) => {
          if (!isWordLimitVisible.value || props.resize !== "both")
            return;
          const entry = entries[0];
          const { width } = entry.contentRect;
          countStyle.value = {
            right: `calc(100% - ${width + 15 + 6}px)`
          };
        });
        const resizeTextarea = () => {
          const { type: type2, autosize } = props;
          if (!isClient || type2 !== "textarea")
            return;
          if (autosize) {
            const minRows = isObject$4(autosize) ? autosize.minRows : void 0;
            const maxRows = isObject$4(autosize) ? autosize.maxRows : void 0;
            textareaCalcStyle.value = {
              ...calcTextareaHeight(textarea.value, minRows, maxRows)
            };
          } else {
            textareaCalcStyle.value = {
              minHeight: calcTextareaHeight(textarea.value).minHeight
            };
          }
        };
        const setNativeInputValue = () => {
          const input2 = _ref.value;
          if (!input2 || input2.value === nativeInputValue.value)
            return;
          input2.value = nativeInputValue.value;
        };
        const calcIconOffset = (place) => {
          const { el } = instance.vnode;
          if (!el)
            return;
          const elList = Array.from(el.querySelectorAll(`.${nsInput.e(place)}`));
          const target = elList.find((item) => item.parentNode === el);
          if (!target)
            return;
          const pendant = PENDANT_MAP[place];
          if (slots[pendant]) {
            target.style.transform = `translateX(${place === "suffix" ? "-" : ""}${el.querySelector(`.${nsInput.be("group", pendant)}`).offsetWidth}px)`;
          } else {
            target.removeAttribute("style");
          }
        };
        const updateIconOffset = () => {
          calcIconOffset("prefix");
          calcIconOffset("suffix");
        };
        const handleInput = async (event) => {
          recordCursor();
          let { value } = event.target;
          if (props.formatter) {
            value = props.parser ? props.parser(value) : value;
            value = props.formatter(value);
          }
          if (isComposing.value)
            return;
          if (value === nativeInputValue.value) {
            setNativeInputValue();
            return;
          }
          emit(UPDATE_MODEL_EVENT, value);
          emit("input", value);
          await nextTick();
          setNativeInputValue();
          setCursor();
        };
        const handleChange = (event) => {
          emit("change", event.target.value);
        };
        const handleCompositionStart = (event) => {
          emit("compositionstart", event);
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          var _a2;
          emit("compositionupdate", event);
          const text = (_a2 = event.target) == null ? void 0 : _a2.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          emit("compositionend", event);
          if (isComposing.value) {
            isComposing.value = false;
            handleInput(event);
          }
        };
        const handlePasswordVisible = () => {
          passwordVisible.value = !passwordVisible.value;
          focus();
        };
        const focus = async () => {
          var _a2;
          await nextTick();
          (_a2 = _ref.value) == null ? void 0 : _a2.focus();
        };
        const blur = () => {
          var _a2;
          return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
        };
        const handleFocus = (event) => {
          focused.value = true;
          emit("focus", event);
        };
        const handleBlur = (event) => {
          var _a2;
          focused.value = false;
          emit("blur", event);
          if (props.validateEvent) {
            (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
          }
        };
        const handleMouseLeave = (evt) => {
          hovering.value = false;
          emit("mouseleave", evt);
        };
        const handleMouseEnter = (evt) => {
          hovering.value = true;
          emit("mouseenter", evt);
        };
        const handleKeydown = (evt) => {
          emit("keydown", evt);
        };
        const select = () => {
          var _a2;
          (_a2 = _ref.value) == null ? void 0 : _a2.select();
        };
        const clear2 = () => {
          emit(UPDATE_MODEL_EVENT, "");
          emit("change", "");
          emit("clear");
          emit("input", "");
        };
        watch(() => props.modelValue, () => {
          var _a2;
          nextTick(() => resizeTextarea());
          if (props.validateEvent) {
            (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
          }
        });
        watch(nativeInputValue, () => setNativeInputValue());
        watch(() => props.type, async () => {
          await nextTick();
          setNativeInputValue();
          resizeTextarea();
          updateIconOffset();
        });
        onMounted(async () => {
          if (!props.formatter && props.parser)
            ;
          setNativeInputValue();
          updateIconOffset();
          await nextTick();
          resizeTextarea();
        });
        onUpdated(async () => {
          await nextTick();
          updateIconOffset();
        });
        expose({
          input,
          textarea,
          ref: _ref,
          textareaStyle,
          autosize: toRef(props, "autosize"),
          focus,
          blur,
          select,
          clear: clear2,
          resizeTextarea
        });
        return (_ctx, _cache) => {
          return withDirectives((openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
            class: [
              _ctx.type === "textarea" ? unref(nsTextarea).b() : unref(nsInput).b(),
              unref(nsInput).m(unref(inputSize)),
              unref(nsInput).is("disabled", unref(inputDisabled)),
              unref(nsInput).is("exceed", unref(inputExceed)),
              {
                [unref(nsInput).b("group")]: _ctx.$slots.prepend || _ctx.$slots.append,
                [unref(nsInput).bm("group", "append")]: _ctx.$slots.append,
                [unref(nsInput).bm("group", "prepend")]: _ctx.$slots.prepend,
                [unref(nsInput).m("prefix")]: _ctx.$slots.prefix || _ctx.prefixIcon,
                [unref(nsInput).m("suffix")]: _ctx.$slots.suffix || _ctx.suffixIcon || _ctx.clearable || _ctx.showPassword,
                [unref(nsInput).bm("suffix", "password-clear")]: unref(showClear) && unref(showPwdVisible)
              },
              _ctx.$attrs.class
            ],
            style: unref(containerStyle),
            role: _ctx.containerRole,
            onMouseenter: handleMouseEnter,
            onMouseleave: handleMouseLeave
          }), [
            createCommentVNode(" input "),
            _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createCommentVNode(" prepend slot "),
              _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(nsInput).be("group", "prepend"))
              }, [
                renderSlot(_ctx.$slots, "prepend")
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                class: normalizeClass([unref(nsInput).e("wrapper"), unref(nsInput).is("focus", focused.value)])
              }, [
                createCommentVNode(" prefix slot "),
                _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).e("prefix"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(nsInput).e("prefix-inner"))
                  }, [
                    renderSlot(_ctx.$slots, "prefix"),
                    _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(nsInput).e("icon"))
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("input", mergeProps({
                  id: unref(inputId),
                  ref_key: "input",
                  ref: input,
                  class: unref(nsInput).e("inner")
                }, unref(attrs), {
                  type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                  disabled: unref(inputDisabled),
                  formatter: _ctx.formatter,
                  parser: _ctx.parser,
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  tabindex: _ctx.tabindex,
                  "aria-label": _ctx.label,
                  placeholder: _ctx.placeholder,
                  style: _ctx.inputStyle,
                  onCompositionstart: handleCompositionStart,
                  onCompositionupdate: handleCompositionUpdate,
                  onCompositionend: handleCompositionEnd,
                  onInput: handleInput,
                  onFocus: handleFocus,
                  onBlur: handleBlur,
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, _hoisted_2$I),
                createCommentVNode(" suffix slot "),
                unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).e("suffix"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(nsInput).e("suffix-inner"))
                  }, [
                    !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      renderSlot(_ctx.$slots, "suffix"),
                      _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 64)) : createCommentVNode("v-if", true),
                    unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 1,
                      class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                      onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                      onClick: clear2
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(circle_close_default))
                      ]),
                      _: 1
                    }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                    unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 2,
                      class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                      onClick: handlePasswordVisible
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true),
                    unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                      key: 3,
                      class: normalizeClass(unref(nsInput).e("count"))
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(unref(nsInput).e("count-inner"))
                      }, toDisplayString$1(unref(textLength)) + " / " + toDisplayString$1(unref(attrs).maxlength), 3)
                    ], 2)) : createCommentVNode("v-if", true),
                    unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 4,
                      class: normalizeClass([
                        unref(nsInput).e("icon"),
                        unref(nsInput).e("validateIcon"),
                        unref(nsInput).is("loading", unref(validateState) === "validating")
                      ])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true)
              ], 2),
              createCommentVNode(" append slot "),
              _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(nsInput).be("group", "append"))
              }, [
                renderSlot(_ctx.$slots, "append")
              ], 2)) : createCommentVNode("v-if", true)
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createCommentVNode(" textarea "),
              createBaseVNode("textarea", mergeProps({
                id: unref(inputId),
                ref_key: "textarea",
                ref: textarea,
                class: unref(nsTextarea).e("inner")
              }, unref(attrs), {
                tabindex: _ctx.tabindex,
                disabled: unref(inputDisabled),
                readonly: _ctx.readonly,
                autocomplete: _ctx.autocomplete,
                style: unref(textareaStyle),
                "aria-label": _ctx.label,
                placeholder: _ctx.placeholder,
                onCompositionstart: handleCompositionStart,
                onCompositionupdate: handleCompositionUpdate,
                onCompositionend: handleCompositionEnd,
                onInput: handleInput,
                onFocus: handleFocus,
                onBlur: handleBlur,
                onChange: handleChange,
                onKeydown: handleKeydown
              }), null, 16, _hoisted_3$o),
              unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                key: 0,
                style: normalizeStyle(countStyle.value),
                class: normalizeClass(unref(nsInput).e("count"))
              }, toDisplayString$1(unref(textLength)) + " / " + toDisplayString$1(unref(attrs).maxlength), 7)) : createCommentVNode("v-if", true)
            ], 64))
          ], 16, _hoisted_1$16)), [
            [vShow, _ctx.type !== "hidden"]
          ]);
        };
      }
    });
    var Input = /* @__PURE__ */ _export_sfc(_sfc_main$2f, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
    const ElInput = withInstall(Input);
    const GAP = 4;
    const BAR_MAP = {
      vertical: {
        offset: "offsetHeight",
        scroll: "scrollTop",
        scrollSize: "scrollHeight",
        size: "height",
        key: "vertical",
        axis: "Y",
        client: "clientY",
        direction: "top"
      },
      horizontal: {
        offset: "offsetWidth",
        scroll: "scrollLeft",
        scrollSize: "scrollWidth",
        size: "width",
        key: "horizontal",
        axis: "X",
        client: "clientX",
        direction: "left"
      }
    };
    const renderThumbStyle$1 = ({
      move,
      size: size2,
      bar
    }) => ({
      [bar.size]: size2,
      transform: `translate${bar.axis}(${move}%)`
    });
    const thumbProps = buildProps({
      vertical: Boolean,
      size: String,
      move: Number,
      ratio: {
        type: Number,
        required: true
      },
      always: Boolean
    });
    const _sfc_main$2e = /* @__PURE__ */ defineComponent({
      __name: "thumb",
      props: thumbProps,
      setup(__props) {
        const props = __props;
        const COMPONENT_NAME2 = "Thumb";
        const scrollbar = inject(scrollbarContextKey);
        const ns2 = useNamespace("scrollbar");
        if (!scrollbar)
          throwError(COMPONENT_NAME2, "can not inject scrollbar context");
        const instance = ref();
        const thumb = ref();
        const thumbState = ref({});
        const visible = ref(false);
        let cursorDown = false;
        let cursorLeave = false;
        let originalOnSelectStart = isClient ? document.onselectstart : null;
        const bar = computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
        const thumbStyle = computed(() => renderThumbStyle$1({
          size: props.size,
          move: props.move,
          bar: bar.value
        }));
        const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
        const clickThumbHandler = (e) => {
          var _a2;
          e.stopPropagation();
          if (e.ctrlKey || [1, 2].includes(e.button))
            return;
          (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
          startDrag(e);
          const el = e.currentTarget;
          if (!el)
            return;
          thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
        };
        const clickTrackHandler = (e) => {
          if (!thumb.value || !instance.value || !scrollbar.wrapElement)
            return;
          const offset2 = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
          const thumbHalf = thumb.value[bar.value.offset] / 2;
          const thumbPositionPercentage = (offset2 - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
          scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
        };
        const startDrag = (e) => {
          e.stopImmediatePropagation();
          cursorDown = true;
          document.addEventListener("mousemove", mouseMoveDocumentHandler);
          document.addEventListener("mouseup", mouseUpDocumentHandler);
          originalOnSelectStart = document.onselectstart;
          document.onselectstart = () => false;
        };
        const mouseMoveDocumentHandler = (e) => {
          if (!instance.value || !thumb.value)
            return;
          if (cursorDown === false)
            return;
          const prevPage = thumbState.value[bar.value.axis];
          if (!prevPage)
            return;
          const offset2 = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
          const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
          const thumbPositionPercentage = (offset2 - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
          scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
        };
        const mouseUpDocumentHandler = () => {
          cursorDown = false;
          thumbState.value[bar.value.axis] = 0;
          document.removeEventListener("mousemove", mouseMoveDocumentHandler);
          document.removeEventListener("mouseup", mouseUpDocumentHandler);
          restoreOnselectstart();
          if (cursorLeave)
            visible.value = false;
        };
        const mouseMoveScrollbarHandler = () => {
          cursorLeave = false;
          visible.value = !!props.size;
        };
        const mouseLeaveScrollbarHandler = () => {
          cursorLeave = true;
          visible.value = cursorDown;
        };
        onBeforeUnmount(() => {
          restoreOnselectstart();
          document.removeEventListener("mouseup", mouseUpDocumentHandler);
        });
        const restoreOnselectstart = () => {
          if (document.onselectstart !== originalOnSelectStart)
            document.onselectstart = originalOnSelectStart;
        };
        useEventListener(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
        useEventListener(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition, {
            name: unref(ns2).b("fade"),
            persisted: ""
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                ref_key: "instance",
                ref: instance,
                class: normalizeClass([unref(ns2).e("bar"), unref(ns2).is(unref(bar).key)]),
                onMousedown: clickTrackHandler
              }, [
                createBaseVNode("div", {
                  ref_key: "thumb",
                  ref: thumb,
                  class: normalizeClass(unref(ns2).e("thumb")),
                  style: normalizeStyle(unref(thumbStyle)),
                  onMousedown: clickThumbHandler
                }, null, 38)
              ], 34), [
                [vShow, _ctx.always || visible.value]
              ])
            ]),
            _: 1
          }, 8, ["name"]);
        };
      }
    });
    var Thumb = /* @__PURE__ */ _export_sfc(_sfc_main$2e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
    const barProps = buildProps({
      always: {
        type: Boolean,
        default: true
      },
      width: String,
      height: String,
      ratioX: {
        type: Number,
        default: 1
      },
      ratioY: {
        type: Number,
        default: 1
      }
    });
    const _sfc_main$2d = /* @__PURE__ */ defineComponent({
      __name: "bar",
      props: barProps,
      setup(__props, { expose }) {
        const props = __props;
        const moveX = ref(0);
        const moveY = ref(0);
        const handleScroll2 = (wrap) => {
          if (wrap) {
            const offsetHeight = wrap.offsetHeight - GAP;
            const offsetWidth = wrap.offsetWidth - GAP;
            moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
            moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
          }
        };
        expose({
          handleScroll: handleScroll2
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(Thumb, {
              move: moveX.value,
              ratio: _ctx.ratioX,
              size: _ctx.width,
              always: _ctx.always
            }, null, 8, ["move", "ratio", "size", "always"]),
            createVNode(Thumb, {
              move: moveY.value,
              ratio: _ctx.ratioY,
              size: _ctx.height,
              vertical: "",
              always: _ctx.always
            }, null, 8, ["move", "ratio", "size", "always"])
          ], 64);
        };
      }
    });
    var Bar = /* @__PURE__ */ _export_sfc(_sfc_main$2d, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
    const scrollbarProps = buildProps({
      height: {
        type: [String, Number],
        default: ""
      },
      maxHeight: {
        type: [String, Number],
        default: ""
      },
      native: Boolean,
      wrapStyle: {
        type: definePropType([String, Object, Array]),
        default: ""
      },
      wrapClass: {
        type: [String, Array],
        default: ""
      },
      viewClass: {
        type: [String, Array],
        default: ""
      },
      viewStyle: {
        type: [String, Array, Object],
        default: ""
      },
      noresize: Boolean,
      tag: {
        type: String,
        default: "div"
      },
      always: Boolean,
      minSize: {
        type: Number,
        default: 20
      }
    });
    const scrollbarEmits = {
      scroll: ({
        scrollTop,
        scrollLeft
      }) => [scrollTop, scrollLeft].every(isNumber$2)
    };
    const __default__$1m = {
      name: "ElScrollbar"
    };
    const _sfc_main$2c = /* @__PURE__ */ defineComponent({
      ...__default__$1m,
      props: scrollbarProps,
      emits: scrollbarEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const ns2 = useNamespace("scrollbar");
        let stopResizeObserver = void 0;
        let stopResizeListener = void 0;
        const scrollbar$ = ref();
        const wrap$ = ref();
        const resize$ = ref();
        const sizeWidth = ref("0");
        const sizeHeight = ref("0");
        const barRef = ref();
        const ratioY = ref(1);
        const ratioX = ref(1);
        const style2 = computed(() => {
          const style22 = {};
          if (props.height)
            style22.height = addUnit(props.height);
          if (props.maxHeight)
            style22.maxHeight = addUnit(props.maxHeight);
          return [props.wrapStyle, style22];
        });
        const handleScroll2 = () => {
          var _a2;
          if (wrap$.value) {
            (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrap$.value);
            emit("scroll", {
              scrollTop: wrap$.value.scrollTop,
              scrollLeft: wrap$.value.scrollLeft
            });
          }
        };
        function scrollTo(arg1, arg2) {
          if (isObject$4(arg1)) {
            wrap$.value.scrollTo(arg1);
          } else if (isNumber$2(arg1) && isNumber$2(arg2)) {
            wrap$.value.scrollTo(arg1, arg2);
          }
        }
        const setScrollTop = (value) => {
          if (!isNumber$2(value)) {
            return;
          }
          wrap$.value.scrollTop = value;
        };
        const setScrollLeft = (value) => {
          if (!isNumber$2(value)) {
            return;
          }
          wrap$.value.scrollLeft = value;
        };
        const update = () => {
          if (!wrap$.value)
            return;
          const offsetHeight = wrap$.value.offsetHeight - GAP;
          const offsetWidth = wrap$.value.offsetWidth - GAP;
          const originalHeight = offsetHeight ** 2 / wrap$.value.scrollHeight;
          const originalWidth = offsetWidth ** 2 / wrap$.value.scrollWidth;
          const height = Math.max(originalHeight, props.minSize);
          const width = Math.max(originalWidth, props.minSize);
          ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
          ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
          sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
          sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
        };
        watch(() => props.noresize, (noresize) => {
          if (noresize) {
            stopResizeObserver == null ? void 0 : stopResizeObserver();
            stopResizeListener == null ? void 0 : stopResizeListener();
          } else {
            ({ stop: stopResizeObserver } = useResizeObserver(resize$, update));
            stopResizeListener = useEventListener("resize", update);
          }
        }, { immediate: true });
        watch(() => [props.maxHeight, props.height], () => {
          if (!props.native)
            nextTick(() => {
              var _a2;
              update();
              if (wrap$.value) {
                (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrap$.value);
              }
            });
        });
        provide(scrollbarContextKey, reactive({
          scrollbarElement: scrollbar$,
          wrapElement: wrap$
        }));
        onMounted(() => {
          if (!props.native)
            nextTick(() => {
              update();
            });
        });
        onUpdated(() => update());
        expose({
          wrap$,
          update,
          scrollTo,
          setScrollTop,
          setScrollLeft,
          handleScroll: handleScroll2
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "scrollbar$",
            ref: scrollbar$,
            class: normalizeClass(unref(ns2).b())
          }, [
            createBaseVNode("div", {
              ref_key: "wrap$",
              ref: wrap$,
              class: normalizeClass([
                _ctx.wrapClass,
                unref(ns2).e("wrap"),
                { [unref(ns2).em("wrap", "hidden-default")]: !_ctx.native }
              ]),
              style: normalizeStyle(unref(style2)),
              onScroll: handleScroll2
            }, [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                ref_key: "resize$",
                ref: resize$,
                class: normalizeClass([unref(ns2).e("view"), _ctx.viewClass]),
                style: normalizeStyle(_ctx.viewStyle)
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["class", "style"]))
            ], 38),
            !_ctx.native ? (openBlock(), createBlock(Bar, {
              key: 0,
              ref_key: "barRef",
              ref: barRef,
              height: sizeHeight.value,
              width: sizeWidth.value,
              always: _ctx.always,
              "ratio-x": ratioX.value,
              "ratio-y": ratioY.value
            }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    });
    var Scrollbar = /* @__PURE__ */ _export_sfc(_sfc_main$2c, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
    const ElScrollbar = withInstall(Scrollbar);
    const Effect = {
      LIGHT: "light",
      DARK: "dark"
    };
    const roleTypes = [
      "dialog",
      "grid",
      "listbox",
      "menu",
      "tooltip",
      "tree"
    ];
    const usePopperProps = buildProps({
      role: {
        type: String,
        values: roleTypes,
        default: "tooltip"
      }
    });
    const __default__$1l = {
      name: "ElPopperRoot",
      inheritAttrs: false
    };
    const _sfc_main$2b = /* @__PURE__ */ defineComponent({
      ...__default__$1l,
      props: usePopperProps,
      setup(__props, { expose }) {
        const props = __props;
        const triggerRef2 = ref();
        const popperInstanceRef = ref();
        const contentRef = ref();
        const referenceRef = ref();
        const role = computed(() => props.role);
        const popperProvides = {
          triggerRef: triggerRef2,
          popperInstanceRef,
          contentRef,
          referenceRef,
          role
        };
        expose(popperProvides);
        provide(POPPER_INJECTION_KEY, popperProvides);
        return (_ctx, _cache) => {
          return renderSlot(_ctx.$slots, "default");
        };
      }
    });
    var Popper = /* @__PURE__ */ _export_sfc(_sfc_main$2b, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
    const usePopperArrowProps = buildProps({
      arrowOffset: {
        type: Number,
        default: 5
      }
    });
    const __default__$1k = {
      name: "ElPopperArrow",
      inheritAttrs: false
    };
    const _sfc_main$2a = /* @__PURE__ */ defineComponent({
      ...__default__$1k,
      props: usePopperArrowProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns2 = useNamespace("popper");
        const { arrowOffset, arrowRef } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
        watch(() => props.arrowOffset, (val) => {
          arrowOffset.value = val;
        });
        onBeforeUnmount(() => {
          arrowRef.value = void 0;
        });
        expose({
          arrowRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            ref_key: "arrowRef",
            ref: arrowRef,
            class: normalizeClass(unref(ns2).e("arrow")),
            "data-popper-arrow": ""
          }, null, 2);
        };
      }
    });
    var ElPopperArrow = /* @__PURE__ */ _export_sfc(_sfc_main$2a, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
    const NAME = "ElOnlyChild";
    const OnlyChild = defineComponent({
      name: NAME,
      setup(_2, {
        slots,
        attrs
      }) {
        var _a2;
        const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
        const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
        return () => {
          var _a22;
          const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
          if (!defaultSlot)
            return null;
          if (defaultSlot.length > 1) {
            return null;
          }
          const firstLegitNode = findFirstLegitChild(defaultSlot);
          if (!firstLegitNode) {
            return null;
          }
          return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
        };
      }
    });
    function findFirstLegitChild(node) {
      if (!node)
        return null;
      const children = node;
      for (const child of children) {
        if (isObject$4(child)) {
          switch (child.type) {
            case Comment:
              continue;
            case Text:
            case "svg":
              return wrapTextContent(child);
            case Fragment:
              return findFirstLegitChild(child.children);
            default:
              return child;
          }
        }
        return wrapTextContent(child);
      }
      return null;
    }
    function wrapTextContent(s2) {
      const ns2 = useNamespace("only-child");
      return createVNode("span", {
        "class": ns2.e("content")
      }, [s2]);
    }
    const usePopperTriggerProps = buildProps({
      virtualRef: {
        type: definePropType(Object)
      },
      virtualTriggering: Boolean,
      onMouseenter: Function,
      onMouseleave: Function,
      onClick: Function,
      onKeydown: Function,
      onFocus: Function,
      onBlur: Function,
      onContextmenu: Function,
      id: String,
      open: Boolean
    });
    const __default__$1j = {
      name: "ElPopperTrigger",
      inheritAttrs: false
    };
    const _sfc_main$29 = /* @__PURE__ */ defineComponent({
      ...__default__$1j,
      props: usePopperTriggerProps,
      setup(__props, { expose }) {
        const props = __props;
        const { role, triggerRef: triggerRef2 } = inject(POPPER_INJECTION_KEY, void 0);
        useForwardRef(triggerRef2);
        const ariaControls = computed(() => {
          return ariaHaspopup.value ? props.id : void 0;
        });
        const ariaDescribedby = computed(() => {
          if (role && role.value === "tooltip") {
            return props.open && props.id ? props.id : void 0;
          }
          return void 0;
        });
        const ariaHaspopup = computed(() => {
          if (role && role.value !== "tooltip") {
            return role.value;
          }
          return void 0;
        });
        const ariaExpanded = computed(() => {
          return ariaHaspopup.value ? `${props.open}` : void 0;
        });
        let virtualTriggerAriaStopWatch = void 0;
        onMounted(() => {
          watch(() => props.virtualRef, (virtualEl) => {
            if (virtualEl) {
              triggerRef2.value = unrefElement(virtualEl);
            }
          }, {
            immediate: true
          });
          watch(() => triggerRef2.value, (el, prevEl) => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
            if (isElement$1(el)) {
              [
                "onMouseenter",
                "onMouseleave",
                "onClick",
                "onKeydown",
                "onFocus",
                "onBlur",
                "onContextmenu"
              ].forEach((eventName) => {
                var _a2;
                const handler = props[eventName];
                if (handler) {
                  el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                  (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                }
              });
              virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key, idx) => {
                  isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                });
              }, { immediate: true });
            }
            if (isElement$1(prevEl)) {
              [
                "aria-controls",
                "aria-describedby",
                "aria-haspopup",
                "aria-expanded"
              ].forEach((key) => prevEl.removeAttribute(key));
            }
          }, {
            immediate: true
          });
        });
        onBeforeUnmount(() => {
          virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
          virtualTriggerAriaStopWatch = void 0;
        });
        expose({
          triggerRef: triggerRef2
        });
        return (_ctx, _cache) => {
          return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
            "aria-controls": unref(ariaControls),
            "aria-describedby": unref(ariaDescribedby),
            "aria-expanded": unref(ariaExpanded),
            "aria-haspopup": unref(ariaHaspopup)
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
        };
      }
    });
    var ElPopperTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$29, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
    var E$1 = "top", R = "bottom", W = "right", P$1 = "left", me = "auto", G = [E$1, R, W, P$1], U$1 = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
      return t.concat([e + "-" + U$1, e + "-" + J]);
    }, []), Ee = [].concat(G, [me]).reduce(function(t, e) {
      return t.concat([e, e + "-" + U$1, e + "-" + J]);
    }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
    function C(t) {
      return t ? (t.nodeName || "").toLowerCase() : null;
    }
    function H(t) {
      if (t == null)
        return window;
      if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument;
        return e && e.defaultView || window;
      }
      return t;
    }
    function Q(t) {
      var e = H(t).Element;
      return t instanceof e || t instanceof Element;
    }
    function B(t) {
      var e = H(t).HTMLElement;
      return t instanceof e || t instanceof HTMLElement;
    }
    function Pe(t) {
      if (typeof ShadowRoot == "undefined")
        return false;
      var e = H(t).ShadowRoot;
      return t instanceof e || t instanceof ShadowRoot;
    }
    function Mt(t) {
      var e = t.state;
      Object.keys(e.elements).forEach(function(n) {
        var r = e.styles[n] || {}, o2 = e.attributes[n] || {}, i = e.elements[n];
        !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o2).forEach(function(a2) {
          var s2 = o2[a2];
          s2 === false ? i.removeAttribute(a2) : i.setAttribute(a2, s2 === true ? "" : s2);
        }));
      });
    }
    function Rt(t) {
      var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
      return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
        Object.keys(e.elements).forEach(function(r) {
          var o2 = e.elements[r], i = e.attributes[r] || {}, a2 = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s2 = a2.reduce(function(f2, c2) {
            return f2[c2] = "", f2;
          }, {});
          !B(o2) || !C(o2) || (Object.assign(o2.style, s2), Object.keys(i).forEach(function(f2) {
            o2.removeAttribute(f2);
          }));
        });
      };
    }
    var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
    function q(t) {
      return t.split("-")[0];
    }
    var X$1 = Math.max, ve = Math.min, Z = Math.round;
    function ee(t, e) {
      e === void 0 && (e = false);
      var n = t.getBoundingClientRect(), r = 1, o2 = 1;
      if (B(t) && e) {
        var i = t.offsetHeight, a2 = t.offsetWidth;
        a2 > 0 && (r = Z(n.width) / a2 || 1), i > 0 && (o2 = Z(n.height) / i || 1);
      }
      return { width: n.width / r, height: n.height / o2, top: n.top / o2, right: n.right / r, bottom: n.bottom / o2, left: n.left / r, x: n.left / r, y: n.top / o2 };
    }
    function ke(t) {
      var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
      return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
    }
    function it(t, e) {
      var n = e.getRootNode && e.getRootNode();
      if (t.contains(e))
        return true;
      if (n && Pe(n)) {
        var r = e;
        do {
          if (r && t.isSameNode(r))
            return true;
          r = r.parentNode || r.host;
        } while (r);
      }
      return false;
    }
    function N$1(t) {
      return H(t).getComputedStyle(t);
    }
    function Wt(t) {
      return ["table", "td", "th"].indexOf(C(t)) >= 0;
    }
    function I$1(t) {
      return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
    }
    function ge(t) {
      return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I$1(t);
    }
    function at(t) {
      return !B(t) || N$1(t).position === "fixed" ? null : t.offsetParent;
    }
    function Bt(t) {
      var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
      if (n && B(t)) {
        var r = N$1(t);
        if (r.position === "fixed")
          return null;
      }
      var o2 = ge(t);
      for (Pe(o2) && (o2 = o2.host); B(o2) && ["html", "body"].indexOf(C(o2)) < 0; ) {
        var i = N$1(o2);
        if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
          return o2;
        o2 = o2.parentNode;
      }
      return null;
    }
    function se(t) {
      for (var e = H(t), n = at(t); n && Wt(n) && N$1(n).position === "static"; )
        n = at(n);
      return n && (C(n) === "html" || C(n) === "body" && N$1(n).position === "static") ? e : n || Bt(t) || e;
    }
    function Le(t) {
      return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
    }
    function fe(t, e, n) {
      return X$1(t, ve(e, n));
    }
    function St(t, e, n) {
      var r = fe(t, e, n);
      return r > n ? n : r;
    }
    function st() {
      return { top: 0, right: 0, bottom: 0, left: 0 };
    }
    function ft(t) {
      return Object.assign({}, st(), t);
    }
    function ct(t, e) {
      return e.reduce(function(n, r) {
        return n[r] = t, n;
      }, {});
    }
    var Tt = function(t, e) {
      return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
    };
    function Ht(t) {
      var e, n = t.state, r = t.name, o2 = t.options, i = n.elements.arrow, a2 = n.modifiersData.popperOffsets, s2 = q(n.placement), f2 = Le(s2), c2 = [P$1, W].indexOf(s2) >= 0, u2 = c2 ? "height" : "width";
      if (!(!i || !a2)) {
        var m2 = Tt(o2.padding, n), v2 = ke(i), l2 = f2 === "y" ? E$1 : P$1, h2 = f2 === "y" ? R : W, p2 = n.rects.reference[u2] + n.rects.reference[f2] - a2[f2] - n.rects.popper[u2], g = a2[f2] - n.rects.reference[f2], x2 = se(i), y = x2 ? f2 === "y" ? x2.clientHeight || 0 : x2.clientWidth || 0 : 0, $ = p2 / 2 - g / 2, d2 = m2[l2], b2 = y - v2[u2] - m2[h2], w2 = y / 2 - v2[u2] / 2 + $, O2 = fe(d2, w2, b2), j = f2;
        n.modifiersData[r] = (e = {}, e[j] = O2, e.centerOffset = O2 - w2, e);
      }
    }
    function Ct(t) {
      var e = t.state, n = t.options, r = n.element, o2 = r === void 0 ? "[data-popper-arrow]" : r;
      o2 != null && (typeof o2 == "string" && (o2 = e.elements.popper.querySelector(o2), !o2) || !it(e.elements.popper, o2) || (e.elements.arrow = o2));
    }
    var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
    function te(t) {
      return t.split("-")[1];
    }
    var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
    function Vt(t) {
      var e = t.x, n = t.y, r = window, o2 = r.devicePixelRatio || 1;
      return { x: Z(e * o2) / o2 || 0, y: Z(n * o2) / o2 || 0 };
    }
    function ut(t) {
      var e, n = t.popper, r = t.popperRect, o2 = t.placement, i = t.variation, a2 = t.offsets, s2 = t.position, f2 = t.gpuAcceleration, c2 = t.adaptive, u2 = t.roundOffsets, m2 = t.isFixed, v2 = a2.x, l2 = v2 === void 0 ? 0 : v2, h2 = a2.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u2 == "function" ? u2({ x: l2, y: p2 }) : { x: l2, y: p2 };
      l2 = g.x, p2 = g.y;
      var x2 = a2.hasOwnProperty("x"), y = a2.hasOwnProperty("y"), $ = P$1, d2 = E$1, b2 = window;
      if (c2) {
        var w2 = se(n), O2 = "clientHeight", j = "clientWidth";
        if (w2 === H(n) && (w2 = I$1(n), N$1(w2).position !== "static" && s2 === "absolute" && (O2 = "scrollHeight", j = "scrollWidth")), w2 = w2, o2 === E$1 || (o2 === P$1 || o2 === W) && i === J) {
          d2 = R;
          var A2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.height : w2[O2];
          p2 -= A2 - r.height, p2 *= f2 ? 1 : -1;
        }
        if (o2 === P$1 || (o2 === E$1 || o2 === R) && i === J) {
          $ = W;
          var k = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.width : w2[j];
          l2 -= k - r.width, l2 *= f2 ? 1 : -1;
        }
      }
      var D2 = Object.assign({ position: s2 }, c2 && qt), S2 = u2 === true ? Vt({ x: l2, y: p2 }) : { x: l2, y: p2 };
      if (l2 = S2.x, p2 = S2.y, f2) {
        var L;
        return Object.assign({}, D2, (L = {}, L[d2] = y ? "0" : "", L[$] = x2 ? "0" : "", L.transform = (b2.devicePixelRatio || 1) <= 1 ? "translate(" + l2 + "px, " + p2 + "px)" : "translate3d(" + l2 + "px, " + p2 + "px, 0)", L));
      }
      return Object.assign({}, D2, (e = {}, e[d2] = y ? p2 + "px" : "", e[$] = x2 ? l2 + "px" : "", e.transform = "", e));
    }
    function Nt(t) {
      var e = t.state, n = t.options, r = n.gpuAcceleration, o2 = r === void 0 ? true : r, i = n.adaptive, a2 = i === void 0 ? true : i, s2 = n.roundOffsets, f2 = s2 === void 0 ? true : s2, c2 = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o2, isFixed: e.options.strategy === "fixed" };
      e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c2, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a2, roundOffsets: f2 })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c2, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f2 })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
    }
    var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
    function It(t) {
      var e = t.state, n = t.instance, r = t.options, o2 = r.scroll, i = o2 === void 0 ? true : o2, a2 = r.resize, s2 = a2 === void 0 ? true : a2, f2 = H(e.elements.popper), c2 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
      return i && c2.forEach(function(u2) {
        u2.addEventListener("scroll", n.update, ye);
      }), s2 && f2.addEventListener("resize", n.update, ye), function() {
        i && c2.forEach(function(u2) {
          u2.removeEventListener("scroll", n.update, ye);
        }), s2 && f2.removeEventListener("resize", n.update, ye);
      };
    }
    var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
    }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
    function be(t) {
      return t.replace(/left|right|bottom|top/g, function(e) {
        return _t[e];
      });
    }
    var zt = { start: "end", end: "start" };
    function lt(t) {
      return t.replace(/start|end/g, function(e) {
        return zt[e];
      });
    }
    function We(t) {
      var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
      return { scrollLeft: n, scrollTop: r };
    }
    function Be(t) {
      return ee(I$1(t)).left + We(t).scrollLeft;
    }
    function Ft(t) {
      var e = H(t), n = I$1(t), r = e.visualViewport, o2 = n.clientWidth, i = n.clientHeight, a2 = 0, s2 = 0;
      return r && (o2 = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a2 = r.offsetLeft, s2 = r.offsetTop)), { width: o2, height: i, x: a2 + Be(t), y: s2 };
    }
    function Ut(t) {
      var e, n = I$1(t), r = We(t), o2 = (e = t.ownerDocument) == null ? void 0 : e.body, i = X$1(n.scrollWidth, n.clientWidth, o2 ? o2.scrollWidth : 0, o2 ? o2.clientWidth : 0), a2 = X$1(n.scrollHeight, n.clientHeight, o2 ? o2.scrollHeight : 0, o2 ? o2.clientHeight : 0), s2 = -r.scrollLeft + Be(t), f2 = -r.scrollTop;
      return N$1(o2 || n).direction === "rtl" && (s2 += X$1(n.clientWidth, o2 ? o2.clientWidth : 0) - i), { width: i, height: a2, x: s2, y: f2 };
    }
    function Se(t) {
      var e = N$1(t), n = e.overflow, r = e.overflowX, o2 = e.overflowY;
      return /auto|scroll|overlay|hidden/.test(n + o2 + r);
    }
    function dt(t) {
      return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
    }
    function ce(t, e) {
      var n;
      e === void 0 && (e = []);
      var r = dt(t), o2 = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a2 = o2 ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s2 = e.concat(a2);
      return o2 ? s2 : s2.concat(ce(ge(a2)));
    }
    function Te(t) {
      return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
    }
    function Xt(t) {
      var e = ee(t);
      return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
    }
    function ht(t, e) {
      return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I$1(t)));
    }
    function Yt(t) {
      var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N$1(t).position) >= 0, r = n && B(t) ? se(t) : t;
      return Q(r) ? e.filter(function(o2) {
        return Q(o2) && it(o2, r) && C(o2) !== "body";
      }) : [];
    }
    function Gt(t, e, n) {
      var r = e === "clippingParents" ? Yt(t) : [].concat(e), o2 = [].concat(r, [n]), i = o2[0], a2 = o2.reduce(function(s2, f2) {
        var c2 = ht(t, f2);
        return s2.top = X$1(c2.top, s2.top), s2.right = ve(c2.right, s2.right), s2.bottom = ve(c2.bottom, s2.bottom), s2.left = X$1(c2.left, s2.left), s2;
      }, ht(t, i));
      return a2.width = a2.right - a2.left, a2.height = a2.bottom - a2.top, a2.x = a2.left, a2.y = a2.top, a2;
    }
    function mt(t) {
      var e = t.reference, n = t.element, r = t.placement, o2 = r ? q(r) : null, i = r ? te(r) : null, a2 = e.x + e.width / 2 - n.width / 2, s2 = e.y + e.height / 2 - n.height / 2, f2;
      switch (o2) {
        case E$1:
          f2 = { x: a2, y: e.y - n.height };
          break;
        case R:
          f2 = { x: a2, y: e.y + e.height };
          break;
        case W:
          f2 = { x: e.x + e.width, y: s2 };
          break;
        case P$1:
          f2 = { x: e.x - n.width, y: s2 };
          break;
        default:
          f2 = { x: e.x, y: e.y };
      }
      var c2 = o2 ? Le(o2) : null;
      if (c2 != null) {
        var u2 = c2 === "y" ? "height" : "width";
        switch (i) {
          case U$1:
            f2[c2] = f2[c2] - (e[u2] / 2 - n[u2] / 2);
            break;
          case J:
            f2[c2] = f2[c2] + (e[u2] / 2 - n[u2] / 2);
            break;
        }
      }
      return f2;
    }
    function ne(t, e) {
      e === void 0 && (e = {});
      var n = e, r = n.placement, o2 = r === void 0 ? t.placement : r, i = n.boundary, a2 = i === void 0 ? Xe : i, s2 = n.rootBoundary, f2 = s2 === void 0 ? je : s2, c2 = n.elementContext, u2 = c2 === void 0 ? K : c2, m2 = n.altBoundary, v2 = m2 === void 0 ? false : m2, l2 = n.padding, h2 = l2 === void 0 ? 0 : l2, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u2 === K ? Ye : K, x2 = t.rects.popper, y = t.elements[v2 ? g : u2], $ = Gt(Q(y) ? y : y.contextElement || I$1(t.elements.popper), a2, f2), d2 = ee(t.elements.reference), b2 = mt({ reference: d2, element: x2, strategy: "absolute", placement: o2 }), w2 = Te(Object.assign({}, x2, b2)), O2 = u2 === K ? w2 : d2, j = { top: $.top - O2.top + p2.top, bottom: O2.bottom - $.bottom + p2.bottom, left: $.left - O2.left + p2.left, right: O2.right - $.right + p2.right }, A2 = t.modifiersData.offset;
      if (u2 === K && A2) {
        var k = A2[o2];
        Object.keys(j).forEach(function(D2) {
          var S2 = [W, R].indexOf(D2) >= 0 ? 1 : -1, L = [E$1, R].indexOf(D2) >= 0 ? "y" : "x";
          j[D2] += k[L] * S2;
        });
      }
      return j;
    }
    function Jt(t, e) {
      e === void 0 && (e = {});
      var n = e, r = n.placement, o2 = n.boundary, i = n.rootBoundary, a2 = n.padding, s2 = n.flipVariations, f2 = n.allowedAutoPlacements, c2 = f2 === void 0 ? Ee : f2, u2 = te(r), m2 = u2 ? s2 ? De : De.filter(function(h2) {
        return te(h2) === u2;
      }) : G, v2 = m2.filter(function(h2) {
        return c2.indexOf(h2) >= 0;
      });
      v2.length === 0 && (v2 = m2);
      var l2 = v2.reduce(function(h2, p2) {
        return h2[p2] = ne(t, { placement: p2, boundary: o2, rootBoundary: i, padding: a2 })[q(p2)], h2;
      }, {});
      return Object.keys(l2).sort(function(h2, p2) {
        return l2[h2] - l2[p2];
      });
    }
    function Kt(t) {
      if (q(t) === me)
        return [];
      var e = be(t);
      return [lt(t), e, lt(e)];
    }
    function Qt(t) {
      var e = t.state, n = t.options, r = t.name;
      if (!e.modifiersData[r]._skip) {
        for (var o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? true : a2, f2 = n.fallbackPlacements, c2 = n.padding, u2 = n.boundary, m2 = n.rootBoundary, v2 = n.altBoundary, l2 = n.flipVariations, h2 = l2 === void 0 ? true : l2, p2 = n.allowedAutoPlacements, g = e.options.placement, x2 = q(g), y = x2 === g, $ = f2 || (y || !h2 ? [be(g)] : Kt(g)), d2 = [g].concat($).reduce(function(z, V) {
          return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u2, rootBoundary: m2, padding: c2, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
        }, []), b2 = e.rects.reference, w2 = e.rects.popper, O2 = /* @__PURE__ */ new Map(), j = true, A2 = d2[0], k = 0; k < d2.length; k++) {
          var D2 = d2[k], S2 = q(D2), L = te(D2) === U$1, re = [E$1, R].indexOf(S2) >= 0, oe = re ? "width" : "height", M2 = ne(e, { placement: D2, boundary: u2, rootBoundary: m2, altBoundary: v2, padding: c2 }), T2 = re ? L ? W : P$1 : L ? R : E$1;
          b2[oe] > w2[oe] && (T2 = be(T2));
          var pe = be(T2), _2 = [];
          if (i && _2.push(M2[S2] <= 0), s2 && _2.push(M2[T2] <= 0, M2[pe] <= 0), _2.every(function(z) {
            return z;
          })) {
            A2 = D2, j = false;
            break;
          }
          O2.set(D2, _2);
        }
        if (j)
          for (var ue = h2 ? 3 : 1, xe = function(z) {
            var V = d2.find(function(de) {
              var ae = O2.get(de);
              if (ae)
                return ae.slice(0, z).every(function(Y2) {
                  return Y2;
                });
            });
            if (V)
              return A2 = V, "break";
          }, ie = ue; ie > 0; ie--) {
            var le = xe(ie);
            if (le === "break")
              break;
          }
        e.placement !== A2 && (e.modifiersData[r]._skip = true, e.placement = A2, e.reset = true);
      }
    }
    var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
    function gt(t, e, n) {
      return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
    }
    function yt(t) {
      return [E$1, W, R, P$1].some(function(e) {
        return t[e] >= 0;
      });
    }
    function Zt(t) {
      var e = t.state, n = t.name, r = e.rects.reference, o2 = e.rects.popper, i = e.modifiersData.preventOverflow, a2 = ne(e, { elementContext: "reference" }), s2 = ne(e, { altBoundary: true }), f2 = gt(a2, r), c2 = gt(s2, o2, i), u2 = yt(f2), m2 = yt(c2);
      e.modifiersData[n] = { referenceClippingOffsets: f2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: m2 }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": m2 });
    }
    var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
    function en$1(t, e, n) {
      var r = q(t), o2 = [P$1, E$1].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a2 = i[0], s2 = i[1];
      return a2 = a2 || 0, s2 = (s2 || 0) * o2, [P$1, W].indexOf(r) >= 0 ? { x: s2, y: a2 } : { x: a2, y: s2 };
    }
    function tn(t) {
      var e = t.state, n = t.options, r = t.name, o2 = n.offset, i = o2 === void 0 ? [0, 0] : o2, a2 = Ee.reduce(function(u2, m2) {
        return u2[m2] = en$1(m2, e.rects, i), u2;
      }, {}), s2 = a2[e.placement], f2 = s2.x, c2 = s2.y;
      e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f2, e.modifiersData.popperOffsets.y += c2), e.modifiersData[r] = a2;
    }
    var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
    function nn(t) {
      var e = t.state, n = t.name;
      e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
    }
    var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
    function rn(t) {
      return t === "x" ? "y" : "x";
    }
    function on(t) {
      var e = t.state, n = t.options, r = t.name, o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? false : a2, f2 = n.boundary, c2 = n.rootBoundary, u2 = n.altBoundary, m2 = n.padding, v2 = n.tether, l2 = v2 === void 0 ? true : v2, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f2, rootBoundary: c2, padding: m2, altBoundary: u2 }), x2 = q(e.placement), y = te(e.placement), $ = !y, d2 = Le(x2), b2 = rn(d2), w2 = e.modifiersData.popperOffsets, O2 = e.rects.reference, j = e.rects.popper, A2 = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k = typeof A2 == "number" ? { mainAxis: A2, altAxis: A2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, A2), D2 = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S2 = { x: 0, y: 0 };
      if (w2) {
        if (i) {
          var L, re = d2 === "y" ? E$1 : P$1, oe = d2 === "y" ? R : W, M2 = d2 === "y" ? "height" : "width", T2 = w2[d2], pe = T2 + g[re], _2 = T2 - g[oe], ue = l2 ? -j[M2] / 2 : 0, xe = y === U$1 ? O2[M2] : j[M2], ie = y === U$1 ? -j[M2] : -O2[M2], le = e.elements.arrow, z = l2 && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y2 = fe(0, O2[M2], z[M2]), jt = $ ? O2[M2] / 2 - ue - Y2 - de - k.mainAxis : xe - Y2 - de - k.mainAxis, Dt = $ ? -O2[M2] / 2 + ue + Y2 + ae + k.mainAxis : ie + Y2 + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d2 === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D2 == null ? void 0 : D2[d2]) != null ? L : 0, Pt = T2 + jt - Ce - Et, At = T2 + Dt - Ce, qe = fe(l2 ? ve(pe, Pt) : pe, T2, l2 ? X$1(_2, At) : _2);
          w2[d2] = qe, S2[d2] = qe - T2;
        }
        if (s2) {
          var Ve, kt = d2 === "x" ? E$1 : P$1, Lt = d2 === "x" ? R : W, F2 = w2[b2], he = b2 === "y" ? "height" : "width", Ne = F2 + g[kt], Ie = F2 - g[Lt], $e = [E$1, P$1].indexOf(x2) !== -1, _e = (Ve = D2 == null ? void 0 : D2[b2]) != null ? Ve : 0, ze = $e ? Ne : F2 - O2[he] - j[he] - _e + k.altAxis, Fe = $e ? F2 + O2[he] + j[he] - _e - k.altAxis : Ie, Ue = l2 && $e ? St(ze, F2, Fe) : fe(l2 ? ze : Ne, F2, l2 ? Fe : Ie);
          w2[b2] = Ue, S2[b2] = Ue - F2;
        }
        e.modifiersData[r] = S2;
      }
    }
    var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
    function an(t) {
      return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
    }
    function sn(t) {
      return t === H(t) || !B(t) ? We(t) : an(t);
    }
    function fn(t) {
      var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
      return n !== 1 || r !== 1;
    }
    function cn(t, e, n) {
      n === void 0 && (n = false);
      var r = B(e), o2 = B(e) && fn(e), i = I$1(e), a2 = ee(t, o2), s2 = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 0, y: 0 };
      return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s2 = sn(e)), B(e) ? (f2 = ee(e, true), f2.x += e.clientLeft, f2.y += e.clientTop) : i && (f2.x = Be(i))), { x: a2.left + s2.scrollLeft - f2.x, y: a2.top + s2.scrollTop - f2.y, width: a2.width, height: a2.height };
    }
    function pn(t) {
      var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
      t.forEach(function(i) {
        e.set(i.name, i);
      });
      function o2(i) {
        n.add(i.name);
        var a2 = [].concat(i.requires || [], i.requiresIfExists || []);
        a2.forEach(function(s2) {
          if (!n.has(s2)) {
            var f2 = e.get(s2);
            f2 && o2(f2);
          }
        }), r.push(i);
      }
      return t.forEach(function(i) {
        n.has(i.name) || o2(i);
      }), r;
    }
    function un(t) {
      var e = pn(t);
      return ot.reduce(function(n, r) {
        return n.concat(e.filter(function(o2) {
          return o2.phase === r;
        }));
      }, []);
    }
    function ln(t) {
      var e;
      return function() {
        return e || (e = new Promise(function(n) {
          Promise.resolve().then(function() {
            e = void 0, n(t());
          });
        })), e;
      };
    }
    function dn(t) {
      var e = t.reduce(function(n, r) {
        var o2 = n[r.name];
        return n[r.name] = o2 ? Object.assign({}, o2, r, { options: Object.assign({}, o2.options, r.options), data: Object.assign({}, o2.data, r.data) }) : r, n;
      }, {});
      return Object.keys(e).map(function(n) {
        return e[n];
      });
    }
    var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
    function $t() {
      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
        e[n] = arguments[n];
      return !e.some(function(r) {
        return !(r && typeof r.getBoundingClientRect == "function");
      });
    }
    function we(t) {
      t === void 0 && (t = {});
      var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o2 = e.defaultOptions, i = o2 === void 0 ? Ot : o2;
      return function(a2, s2, f2) {
        f2 === void 0 && (f2 = i);
        var c2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a2, popper: s2 }, attributes: {}, styles: {} }, u2 = [], m2 = false, v2 = { state: c2, setOptions: function(p2) {
          var g = typeof p2 == "function" ? p2(c2.options) : p2;
          h2(), c2.options = Object.assign({}, i, c2.options, g), c2.scrollParents = { reference: Q(a2) ? ce(a2) : a2.contextElement ? ce(a2.contextElement) : [], popper: ce(s2) };
          var x2 = un(dn([].concat(r, c2.options.modifiers)));
          return c2.orderedModifiers = x2.filter(function(y) {
            return y.enabled;
          }), l2(), v2.update();
        }, forceUpdate: function() {
          if (!m2) {
            var p2 = c2.elements, g = p2.reference, x2 = p2.popper;
            if ($t(g, x2)) {
              c2.rects = { reference: cn(g, se(x2), c2.options.strategy === "fixed"), popper: ke(x2) }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(j) {
                return c2.modifiersData[j.name] = Object.assign({}, j.data);
              });
              for (var y = 0; y < c2.orderedModifiers.length; y++) {
                if (c2.reset === true) {
                  c2.reset = false, y = -1;
                  continue;
                }
                var $ = c2.orderedModifiers[y], d2 = $.fn, b2 = $.options, w2 = b2 === void 0 ? {} : b2, O2 = $.name;
                typeof d2 == "function" && (c2 = d2({ state: c2, options: w2, name: O2, instance: v2 }) || c2);
              }
            }
          }
        }, update: ln(function() {
          return new Promise(function(p2) {
            v2.forceUpdate(), p2(c2);
          });
        }), destroy: function() {
          h2(), m2 = true;
        } };
        if (!$t(a2, s2))
          return v2;
        v2.setOptions(f2).then(function(p2) {
          !m2 && f2.onFirstUpdate && f2.onFirstUpdate(p2);
        });
        function l2() {
          c2.orderedModifiers.forEach(function(p2) {
            var g = p2.name, x2 = p2.options, y = x2 === void 0 ? {} : x2, $ = p2.effect;
            if (typeof $ == "function") {
              var d2 = $({ state: c2, name: g, instance: v2, options: y }), b2 = function() {
              };
              u2.push(d2 || b2);
            }
          });
        }
        function h2() {
          u2.forEach(function(p2) {
            return p2();
          }), u2 = [];
        }
        return v2;
      };
    }
    we();
    var mn = [Re, He, Me, Ae];
    we({ defaultModifiers: mn });
    var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
    const obtainAllFocusableElements = (element) => {
      const nodes = [];
      const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
        acceptNode: (node) => {
          const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
          if (node.disabled || node.hidden || isHiddenInput)
            return NodeFilter.FILTER_SKIP;
          return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
      });
      while (walker.nextNode())
        nodes.push(walker.currentNode);
      return nodes;
    };
    const getVisibleElement = (elements, container) => {
      for (const element of elements) {
        if (!isHidden(element, container))
          return element;
      }
    };
    const isHidden = (element, container) => {
      if (getComputedStyle(element).visibility === "hidden")
        return true;
      while (element) {
        if (container && element === container)
          return false;
        if (getComputedStyle(element).display === "none")
          return true;
        element = element.parentElement;
      }
      return false;
    };
    const getEdges = (container) => {
      const focusable = obtainAllFocusableElements(container);
      const first = getVisibleElement(focusable, container);
      const last = getVisibleElement(focusable.reverse(), container);
      return [first, last];
    };
    const isSelectable = (element) => {
      return element instanceof HTMLInputElement && "select" in element;
    };
    const tryFocus = (element, shouldSelect) => {
      if (element && element.focus) {
        const prevFocusedElement = document.activeElement;
        element.focus({ preventScroll: true });
        if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
          element.select();
        }
      }
    };
    function removeFromStack(list, item) {
      const copy = [...list];
      const idx = list.indexOf(item);
      if (idx !== -1) {
        copy.splice(idx, 1);
      }
      return copy;
    }
    const createFocusableStack = () => {
      let stack2 = [];
      const push = (layer) => {
        const currentLayer = stack2[0];
        if (currentLayer && layer !== currentLayer) {
          currentLayer.pause();
        }
        stack2 = removeFromStack(stack2, layer);
        stack2.unshift(layer);
      };
      const remove2 = (layer) => {
        var _a2, _b;
        stack2 = removeFromStack(stack2, layer);
        (_b = (_a2 = stack2[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
      };
      return {
        push,
        remove: remove2
      };
    };
    const focusFirstDescendant = (elements, shouldSelect = false) => {
      const prevFocusedElement = document.activeElement;
      for (const element of elements) {
        tryFocus(element, shouldSelect);
        if (document.activeElement !== prevFocusedElement)
          return;
      }
    };
    const focusableStack = createFocusableStack();
    const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
    const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
    const FOCUS_AFTER_TRAPPED_OPTS = {
      cancelable: true,
      bubbles: false
    };
    const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
    const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
    const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
    const _sfc_main$28 = defineComponent({
      name: "ElFocusTrap",
      inheritAttrs: false,
      props: {
        loop: Boolean,
        trapped: Boolean,
        focusTrapEl: Object,
        focusStartEl: {
          type: [Object, String],
          default: "first"
        }
      },
      emits: [
        ON_TRAP_FOCUS_EVT,
        ON_RELEASE_FOCUS_EVT,
        "focusin",
        "focusout",
        "focusout-prevented",
        "release-requested"
      ],
      setup(props, { emit }) {
        const forwardRef = ref();
        let lastFocusBeforeTrapped;
        let lastFocusAfterTrapped;
        useEscapeKeydown((event) => {
          if (props.trapped && !focusLayer.paused) {
            emit("release-requested", event);
          }
        });
        const focusLayer = {
          paused: false,
          pause() {
            this.paused = true;
          },
          resume() {
            this.paused = false;
          }
        };
        const onKeydown = (e) => {
          if (!props.loop && !props.trapped)
            return;
          if (focusLayer.paused)
            return;
          const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
          const { loop } = props;
          const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
          const currentFocusingEl = document.activeElement;
          if (isTabbing && currentFocusingEl) {
            const container = currentTarget;
            const [first, last] = getEdges(container);
            const isTabbable = first && last;
            if (!isTabbable) {
              if (currentFocusingEl === container) {
                e.preventDefault();
                emit("focusout-prevented");
              }
            } else {
              if (!shiftKey && currentFocusingEl === last) {
                e.preventDefault();
                if (loop)
                  tryFocus(first, true);
                emit("focusout-prevented");
              } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                e.preventDefault();
                if (loop)
                  tryFocus(last, true);
                emit("focusout-prevented");
              }
            }
          }
        };
        provide(FOCUS_TRAP_INJECTION_KEY, {
          focusTrapRef: forwardRef,
          onKeydown
        });
        watch(() => props.focusTrapEl, (focusTrapEl) => {
          if (focusTrapEl) {
            forwardRef.value = focusTrapEl;
          }
        }, { immediate: true });
        watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
          if (forwardRef2) {
            forwardRef2.addEventListener("keydown", onKeydown);
            forwardRef2.addEventListener("focusin", onFocusIn);
            forwardRef2.addEventListener("focusout", onFocusOut);
          }
          if (oldForwardRef) {
            oldForwardRef.removeEventListener("keydown", onKeydown);
            oldForwardRef.removeEventListener("focusin", onFocusIn);
            oldForwardRef.removeEventListener("focusout", onFocusOut);
          }
        });
        const trapOnFocus = (e) => {
          emit(ON_TRAP_FOCUS_EVT, e);
        };
        const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);
        const onFocusIn = (e) => {
          const trapContainer = unref(forwardRef);
          if (!trapContainer)
            return;
          const target = e.target;
          const isFocusedInTrap = target && trapContainer.contains(target);
          if (isFocusedInTrap)
            emit("focusin", e);
          if (focusLayer.paused)
            return;
          if (props.trapped) {
            if (isFocusedInTrap) {
              lastFocusAfterTrapped = target;
            } else {
              tryFocus(lastFocusAfterTrapped, true);
            }
          }
        };
        const onFocusOut = (e) => {
          const trapContainer = unref(forwardRef);
          if (focusLayer.paused || !trapContainer)
            return;
          if (props.trapped) {
            const relatedTarget = e.relatedTarget;
            if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
              setTimeout(() => {
                if (!focusLayer.paused && props.trapped) {
                  tryFocus(lastFocusAfterTrapped, true);
                }
              }, 0);
            }
          } else {
            const target = e.target;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!isFocusedInTrap)
              emit("focusout", e);
          }
        };
        async function startTrap() {
          await nextTick();
          const trapContainer = unref(forwardRef);
          if (trapContainer) {
            focusableStack.push(focusLayer);
            const prevFocusedElement = document.activeElement;
            lastFocusBeforeTrapped = prevFocusedElement;
            const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
            if (!isPrevFocusContained) {
              const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
              trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              trapContainer.dispatchEvent(focusEvent);
              if (!focusEvent.defaultPrevented) {
                nextTick(() => {
                  let focusStartEl = props.focusStartEl;
                  if (!isString$3(focusStartEl)) {
                    tryFocus(focusStartEl);
                    if (document.activeElement !== focusStartEl) {
                      focusStartEl = "first";
                    }
                  }
                  if (focusStartEl === "first") {
                    focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                  }
                  if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                    tryFocus(trapContainer);
                  }
                });
              }
            }
          }
        }
        function stopTrap() {
          const trapContainer = unref(forwardRef);
          if (trapContainer) {
            trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
            const releasedEvent = new Event(FOCUS_AFTER_RELEASED, FOCUS_AFTER_TRAPPED_OPTS);
            trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
            trapContainer.dispatchEvent(releasedEvent);
            if (!releasedEvent.defaultPrevented) {
              tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body, true);
            }
            trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus);
            focusableStack.remove(focusLayer);
          }
        }
        onMounted(() => {
          if (props.trapped) {
            startTrap();
          }
          watch(() => props.trapped, (trapped) => {
            if (trapped) {
              startTrap();
            } else {
              stopTrap();
            }
          });
        });
        onBeforeUnmount(() => {
          if (props.trapped) {
            stopTrap();
          }
        });
        return {
          onKeydown
        };
      }
    });
    function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
      return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
    }
    var ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main$28, [["render", _sfc_render$E], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
    const POSITIONING_STRATEGIES = ["fixed", "absolute"];
    const usePopperCoreConfigProps = buildProps({
      boundariesPadding: {
        type: Number,
        default: 0
      },
      fallbackPlacements: {
        type: definePropType(Array),
        default: () => []
      },
      gpuAcceleration: {
        type: Boolean,
        default: true
      },
      offset: {
        type: Number,
        default: 12
      },
      placement: {
        type: String,
        values: Ee,
        default: "bottom"
      },
      popperOptions: {
        type: definePropType(Object),
        default: () => ({})
      },
      strategy: {
        type: String,
        values: POSITIONING_STRATEGIES,
        default: "absolute"
      }
    });
    const usePopperContentProps = buildProps({
      ...usePopperCoreConfigProps,
      id: String,
      style: { type: definePropType([String, Array, Object]) },
      className: { type: definePropType([String, Array, Object]) },
      effect: {
        type: String,
        default: "dark"
      },
      visible: Boolean,
      enterable: {
        type: Boolean,
        default: true
      },
      pure: Boolean,
      focusOnShow: {
        type: Boolean,
        default: false
      },
      trapping: {
        type: Boolean,
        default: false
      },
      popperClass: {
        type: definePropType([String, Array, Object])
      },
      popperStyle: {
        type: definePropType([String, Array, Object])
      },
      referenceEl: {
        type: definePropType(Object)
      },
      triggerTargetEl: {
        type: definePropType(Object)
      },
      stopPopperMouseEvent: {
        type: Boolean,
        default: true
      },
      ariaLabel: {
        type: String,
        default: void 0
      },
      virtualTriggering: Boolean,
      zIndex: Number
    });
    const usePopperContentEmits = [
      "mouseenter",
      "mouseleave",
      "focus",
      "blur",
      "close"
    ];
    const buildPopperOptions = (props, arrowProps) => {
      const { placement, strategy, popperOptions: popperOptions2 } = props;
      const options = {
        placement,
        strategy,
        ...popperOptions2,
        modifiers: genModifiers(props)
      };
      attachArrow(options, arrowProps);
      deriveExtraModifiers(options, popperOptions2 == null ? void 0 : popperOptions2.modifiers);
      return options;
    };
    const unwrapMeasurableEl = ($el) => {
      if (!isClient)
        return;
      return unrefElement($el);
    };
    function genModifiers(options) {
      const { offset: offset2, gpuAcceleration, fallbackPlacements } = options;
      return [
        {
          name: "offset",
          options: {
            offset: [0, offset2 != null ? offset2 : 12]
          }
        },
        {
          name: "preventOverflow",
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        },
        {
          name: "flip",
          options: {
            padding: 5,
            fallbackPlacements: fallbackPlacements != null ? fallbackPlacements : []
          }
        },
        {
          name: "computeStyles",
          options: {
            gpuAcceleration,
            adaptive: gpuAcceleration
          }
        }
      ];
    }
    function attachArrow(options, { arrowEl, arrowOffset }) {
      options.modifiers.push({
        name: "arrow",
        options: {
          element: arrowEl,
          padding: arrowOffset != null ? arrowOffset : 5
        }
      });
    }
    function deriveExtraModifiers(options, modifiers) {
      if (modifiers) {
        options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
      }
    }
    const __default__$1i = {
      name: "ElPopperContent"
    };
    const _sfc_main$27 = /* @__PURE__ */ defineComponent({
      ...__default__$1i,
      props: usePopperContentProps,
      emits: usePopperContentEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const { popperInstanceRef, contentRef, triggerRef: triggerRef2, role } = inject(POPPER_INJECTION_KEY, void 0);
        const formItemContext = inject(formItemContextKey, void 0);
        const { nextZIndex } = useZIndex();
        const ns2 = useNamespace("popper");
        const popperContentRef = ref();
        const focusStartRef = ref("first");
        const arrowRef = ref();
        const arrowOffset = ref();
        provide(POPPER_CONTENT_INJECTION_KEY, {
          arrowRef,
          arrowOffset
        });
        if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
          provide(formItemContextKey, {
            ...formItemContext,
            addInputId: NOOP,
            removeInputId: NOOP
          });
        }
        const contentZIndex = ref(props.zIndex || nextZIndex());
        const trapped = ref(false);
        let triggerTargetAriaStopWatch = void 0;
        const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef2));
        const contentStyle = computed(() => [{ zIndex: unref(contentZIndex) }, props.popperStyle]);
        const contentClass = computed(() => [
          ns2.b(),
          ns2.is("pure", props.pure),
          ns2.is(props.effect),
          props.popperClass
        ]);
        const ariaModal = computed(() => {
          return role && role.value === "dialog" ? "false" : void 0;
        });
        const createPopperInstance = ({ referenceEl, popperContentEl, arrowEl }) => {
          const options = buildPopperOptions(props, {
            arrowEl,
            arrowOffset: unref(arrowOffset)
          });
          return yn(referenceEl, popperContentEl, options);
        };
        const updatePopper = (shouldUpdateZIndex = true) => {
          var _a2;
          (_a2 = unref(popperInstanceRef)) == null ? void 0 : _a2.update();
          shouldUpdateZIndex && (contentZIndex.value = props.zIndex || nextZIndex());
        };
        const togglePopperAlive = () => {
          var _a2, _b;
          const monitorable = { name: "eventListeners", enabled: props.visible };
          (_b = (_a2 = unref(popperInstanceRef)) == null ? void 0 : _a2.setOptions) == null ? void 0 : _b.call(_a2, (options) => ({
            ...options,
            modifiers: [...options.modifiers || [], monitorable]
          }));
          updatePopper(false);
          if (props.visible && props.focusOnShow) {
            trapped.value = true;
          } else if (props.visible === false) {
            trapped.value = false;
          }
        };
        const onFocusAfterTrapped = () => {
          emit("focus");
        };
        const onFocusAfterReleased = () => {
          focusStartRef.value = "first";
          emit("blur");
        };
        const onFocusInTrap = (event) => {
          var _a2;
          if (props.visible && !trapped.value) {
            if (event.target) {
              focusStartRef.value = event.target;
            }
            trapped.value = true;
            if (event.relatedTarget) {
              (_a2 = event.relatedTarget) == null ? void 0 : _a2.focus();
            }
          }
        };
        const onFocusoutPrevented = () => {
          if (!props.trapping) {
            trapped.value = false;
          }
        };
        const onReleaseRequested = () => {
          trapped.value = false;
          emit("close");
        };
        onMounted(() => {
          let updateHandle;
          watch(computedReference, (referenceEl) => {
            var _a2;
            updateHandle == null ? void 0 : updateHandle();
            const popperInstance = unref(popperInstanceRef);
            (_a2 = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a2.call(popperInstance);
            if (referenceEl) {
              const popperContentEl = unref(popperContentRef);
              contentRef.value = popperContentEl;
              popperInstanceRef.value = createPopperInstance({
                referenceEl,
                popperContentEl,
                arrowEl: unref(arrowRef)
              });
              updateHandle = watch(() => referenceEl.getBoundingClientRect(), () => updatePopper(), {
                immediate: true
              });
            } else {
              popperInstanceRef.value = void 0;
            }
          }, {
            immediate: true
          });
          watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
            const el = unref(triggerTargetEl || popperContentRef.value);
            const prevEl = unref(prevTriggerTargetEl || popperContentRef.value);
            if (isElement$1(el)) {
              const { ariaLabel, id: id2 } = toRefs(props);
              triggerTargetAriaStopWatch = watch([role, ariaLabel, ariaModal, id2], (watches) => {
                ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                  isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                });
              }, { immediate: true });
            }
            if (isElement$1(prevEl)) {
              ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                prevEl.removeAttribute(key);
              });
            }
          }, { immediate: true });
          watch(() => props.visible, togglePopperAlive, { immediate: true });
          watch(() => buildPopperOptions(props, {
            arrowEl: unref(arrowRef),
            arrowOffset: unref(arrowOffset)
          }), (option) => {
            var _a2;
            return (_a2 = popperInstanceRef.value) == null ? void 0 : _a2.setOptions(option);
          });
        });
        onBeforeUnmount(() => {
          triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
          triggerTargetAriaStopWatch = void 0;
        });
        expose({
          popperContentRef,
          popperInstanceRef,
          updatePopper,
          contentStyle
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "popperContentRef",
            ref: popperContentRef,
            style: normalizeStyle(unref(contentStyle)),
            class: normalizeClass(unref(contentClass)),
            tabindex: "-1",
            onMouseenter: _cache[0] || (_cache[0] = (e) => _ctx.$emit("mouseenter", e)),
            onMouseleave: _cache[1] || (_cache[1] = (e) => _ctx.$emit("mouseleave", e))
          }, [
            createVNode(unref(ElFocusTrap), {
              trapped: trapped.value,
              "trap-on-focus-in": true,
              "focus-trap-el": popperContentRef.value,
              "focus-start-el": focusStartRef.value,
              onFocusAfterTrapped,
              onFocusAfterReleased,
              onFocusin: onFocusInTrap,
              onFocusoutPrevented,
              onReleaseRequested
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el"])
          ], 38);
        };
      }
    });
    var ElPopperContent = /* @__PURE__ */ _export_sfc(_sfc_main$27, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
    const ElPopper = withInstall(Popper);
    const ns = useNamespace("tooltip");
    const useTooltipContentProps = buildProps({
      ...useDelayedToggleProps,
      ...usePopperContentProps,
      appendTo: {
        type: definePropType([String, Object]),
        default: POPPER_CONTAINER_SELECTOR
      },
      content: {
        type: String,
        default: ""
      },
      rawContent: {
        type: Boolean,
        default: false
      },
      persistent: Boolean,
      ariaLabel: String,
      visible: {
        type: definePropType(Boolean),
        default: null
      },
      transition: {
        type: String,
        default: `${ns.namespace.value}-fade-in-linear`
      },
      teleported: {
        type: Boolean,
        default: true
      },
      disabled: {
        type: Boolean
      }
    });
    const useTooltipTriggerProps = buildProps({
      ...usePopperTriggerProps,
      disabled: Boolean,
      trigger: {
        type: definePropType([String, Array]),
        default: "hover"
      },
      triggerKeys: {
        type: definePropType(Array),
        default: () => [EVENT_CODE.enter, EVENT_CODE.space]
      }
    });
    const useTooltipProps = buildProps({
      openDelay: {
        type: Number
      },
      visibleArrow: {
        type: Boolean,
        default: void 0
      },
      hideAfter: {
        type: Number,
        default: 200
      },
      showArrow: {
        type: Boolean,
        default: true
      }
    });
    const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
    const _sfc_main$26 = defineComponent({
      name: "ElTooltipContent",
      components: {
        ElPopperContent
      },
      inheritAttrs: false,
      props: useTooltipContentProps,
      setup(props) {
        const contentRef = ref(null);
        const intermediateOpen = ref(false);
        const entering = ref(false);
        const leaving = ref(false);
        const destroyed = ref(false);
        const {
          controlled,
          id: id2,
          open,
          trigger: trigger2,
          onClose,
          onOpen,
          onShow,
          onHide,
          onBeforeShow,
          onBeforeHide
        } = inject(TOOLTIP_INJECTION_KEY, void 0);
        const persistentRef = computed(() => {
          return props.persistent;
        });
        onBeforeUnmount(() => {
          destroyed.value = true;
        });
        const shouldRender = computed(() => {
          return unref(persistentRef) ? true : unref(open);
        });
        const shouldShow = computed(() => {
          return props.disabled ? false : unref(open);
        });
        const contentStyle = computed(() => {
          var _a2;
          return (_a2 = props.style) != null ? _a2 : {};
        });
        const ariaHidden = computed(() => !unref(open));
        const onTransitionLeave = () => {
          onHide();
        };
        const stopWhenControlled = () => {
          if (unref(controlled))
            return true;
        };
        const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
          if (props.enterable && unref(trigger2) === "hover") {
            onOpen();
          }
        });
        const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
          if (unref(trigger2) === "hover") {
            onClose();
          }
        });
        const onBeforeEnter = () => {
          var _a2, _b;
          (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          onBeforeShow == null ? void 0 : onBeforeShow();
        };
        const onBeforeLeave = () => {
          onBeforeHide == null ? void 0 : onBeforeHide();
        };
        const onAfterShow = () => {
          onShow();
          stopHandle = onClickOutside(computed(() => {
            var _a2;
            return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
          }), () => {
            if (unref(controlled))
              return;
            const $trigger = unref(trigger2);
            if ($trigger !== "hover") {
              onClose();
            }
          });
        };
        const onBlur = () => {
          if (!props.virtualTriggering) {
            onClose();
          }
        };
        let stopHandle;
        watch(() => unref(open), (val) => {
          if (!val) {
            stopHandle == null ? void 0 : stopHandle();
          }
        }, {
          flush: "post"
        });
        return {
          ariaHidden,
          entering,
          leaving,
          id: id2,
          intermediateOpen,
          contentStyle,
          contentRef,
          destroyed,
          shouldRender,
          shouldShow,
          onClose,
          open,
          onAfterShow,
          onBeforeEnter,
          onBeforeLeave,
          onContentEnter,
          onContentLeave,
          onTransitionLeave,
          onBlur
        };
      }
    });
    function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_popper_content = resolveComponent("el-popper-content");
      return openBlock(), createBlock(Teleport, {
        disabled: !_ctx.teleported,
        to: _ctx.appendTo
      }, [
        createVNode(Transition, {
          name: _ctx.transition,
          onAfterLeave: _ctx.onTransitionLeave,
          onBeforeEnter: _ctx.onBeforeEnter,
          onAfterEnter: _ctx.onAfterShow,
          onBeforeLeave: _ctx.onBeforeLeave
        }, {
          default: withCtx(() => [
            _ctx.shouldRender ? withDirectives((openBlock(), createBlock(_component_el_popper_content, mergeProps({
              key: 0,
              id: _ctx.id,
              ref: "contentRef"
            }, _ctx.$attrs, {
              "aria-label": _ctx.ariaLabel,
              "aria-hidden": _ctx.ariaHidden,
              "boundaries-padding": _ctx.boundariesPadding,
              "fallback-placements": _ctx.fallbackPlacements,
              "gpu-acceleration": _ctx.gpuAcceleration,
              offset: _ctx.offset,
              placement: _ctx.placement,
              "popper-options": _ctx.popperOptions,
              strategy: _ctx.strategy,
              effect: _ctx.effect,
              enterable: _ctx.enterable,
              pure: _ctx.pure,
              "popper-class": _ctx.popperClass,
              "popper-style": [_ctx.popperStyle, _ctx.contentStyle],
              "reference-el": _ctx.referenceEl,
              "trigger-target-el": _ctx.triggerTargetEl,
              visible: _ctx.shouldShow,
              "z-index": _ctx.zIndex,
              onMouseenter: _ctx.onContentEnter,
              onMouseleave: _ctx.onContentLeave,
              onBlur: _ctx.onBlur,
              onClose: _ctx.onClose
            }), {
              default: withCtx(() => [
                createCommentVNode(" Workaround bug #6378 "),
                !_ctx.destroyed ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onBlur", "onClose"])), [
              [vShow, _ctx.shouldShow]
            ]) : createCommentVNode("v-if", true)
          ]),
          _: 3
        }, 8, ["name", "onAfterLeave", "onBeforeEnter", "onAfterEnter", "onBeforeLeave"])
      ], 8, ["disabled", "to"]);
    }
    var ElTooltipContent = /* @__PURE__ */ _export_sfc(_sfc_main$26, [["render", _sfc_render$D], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
    const isTriggerType = (trigger2, type2) => {
      if (isArray$4(trigger2)) {
        return trigger2.includes(type2);
      }
      return trigger2 === type2;
    };
    const whenTrigger = (trigger2, type2, handler) => {
      return (e) => {
        isTriggerType(unref(trigger2), type2) && handler(e);
      };
    };
    const _sfc_main$25 = defineComponent({
      name: "ElTooltipTrigger",
      components: {
        ElPopperTrigger
      },
      props: useTooltipTriggerProps,
      setup(props) {
        const ns2 = useNamespace("tooltip");
        const { controlled, id: id2, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
        const triggerRef2 = ref(null);
        const stopWhenControlledOrDisabled = () => {
          if (unref(controlled) || props.disabled) {
            return true;
          }
        };
        const trigger2 = toRef(props, "trigger");
        const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
        const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
        const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e) => {
          if (e.button === 0) {
            onToggle(e);
          }
        }));
        const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
        const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
        const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e) => {
          e.preventDefault();
          onToggle(e);
        }));
        const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
          const { code: code2 } = e;
          if (props.triggerKeys.includes(code2)) {
            e.preventDefault();
            onToggle(e);
          }
        });
        return {
          onBlur,
          onContextMenu,
          onFocus,
          onMouseenter,
          onMouseleave,
          onClick,
          onKeydown,
          open,
          id: id2,
          triggerRef: triggerRef2,
          ns: ns2
        };
      }
    });
    function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_popper_trigger = resolveComponent("el-popper-trigger");
      return openBlock(), createBlock(_component_el_popper_trigger, {
        id: _ctx.id,
        "virtual-ref": _ctx.virtualRef,
        open: _ctx.open,
        "virtual-triggering": _ctx.virtualTriggering,
        class: normalizeClass(_ctx.ns.e("trigger")),
        onBlur: _ctx.onBlur,
        onClick: _ctx.onClick,
        onContextmenu: _ctx.onContextMenu,
        onFocus: _ctx.onFocus,
        onMouseenter: _ctx.onMouseenter,
        onMouseleave: _ctx.onMouseleave,
        onKeydown: _ctx.onKeydown
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
    }
    var ElTooltipTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$25, [["render", _sfc_render$C], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
    const { useModelToggleProps, useModelToggle, useModelToggleEmits } = createModelToggleComposable("visible");
    const _sfc_main$24 = defineComponent({
      name: "ElTooltip",
      components: {
        ElPopper,
        ElPopperArrow,
        ElTooltipContent,
        ElTooltipTrigger
      },
      props: {
        ...usePopperProps,
        ...useModelToggleProps,
        ...useTooltipContentProps,
        ...useTooltipTriggerProps,
        ...usePopperArrowProps,
        ...useTooltipProps
      },
      emits: [
        ...useModelToggleEmits,
        "before-show",
        "before-hide",
        "show",
        "hide",
        "open",
        "close"
      ],
      setup(props, { emit }) {
        usePopperContainer();
        const compatShowAfter = computed(() => {
          if (!isUndefined$1(props.openDelay))
            ;
          return props.openDelay || props.showAfter;
        });
        const compatShowArrow = computed(() => {
          if (!isUndefined$1(props.visibleArrow))
            ;
          return isBoolean$2(props.visibleArrow) ? props.visibleArrow : props.showArrow;
        });
        const id2 = useId();
        const popperRef = ref(null);
        const contentRef = ref(null);
        const updatePopper = () => {
          var _a2;
          const popperComponent = unref(popperRef);
          if (popperComponent) {
            (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
          }
        };
        const open = ref(false);
        const toggleReason = ref(void 0);
        const { show, hide, hasUpdateHandler } = useModelToggle({
          indicator: open,
          toggleReason
        });
        const { onOpen, onClose } = useDelayedToggle({
          showAfter: compatShowAfter,
          hideAfter: toRef(props, "hideAfter"),
          open: show,
          close: hide
        });
        const controlled = computed(() => isBoolean$2(props.visible) && !hasUpdateHandler.value);
        provide(TOOLTIP_INJECTION_KEY, {
          controlled,
          id: id2,
          open: readonly(open),
          trigger: toRef(props, "trigger"),
          onOpen: (event) => {
            onOpen(event);
          },
          onClose: (event) => {
            onClose(event);
          },
          onToggle: (event) => {
            if (unref(open)) {
              onClose(event);
            } else {
              onOpen(event);
            }
          },
          onShow: () => {
            emit("show", toggleReason.value);
          },
          onHide: () => {
            emit("hide", toggleReason.value);
          },
          onBeforeShow: () => {
            emit("before-show", toggleReason.value);
          },
          onBeforeHide: () => {
            emit("before-hide", toggleReason.value);
          },
          updatePopper
        });
        watch(() => props.disabled, (disabled) => {
          if (disabled && open.value) {
            open.value = false;
          }
        });
        const isFocusInsideContent = () => {
          var _a2, _b;
          const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
          return popperContent && popperContent.contains(document.activeElement);
        };
        onDeactivated(() => open.value && hide());
        return {
          compatShowAfter,
          compatShowArrow,
          popperRef,
          contentRef,
          open,
          hide,
          isFocusInsideContent,
          updatePopper,
          onOpen,
          onClose
        };
      }
    });
    const _hoisted_1$15 = ["innerHTML"];
    const _hoisted_2$H = { key: 1 };
    function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_tooltip_trigger = resolveComponent("el-tooltip-trigger");
      const _component_el_popper_arrow = resolveComponent("el-popper-arrow");
      const _component_el_tooltip_content = resolveComponent("el-tooltip-content");
      const _component_el_popper = resolveComponent("el-popper");
      return openBlock(), createBlock(_component_el_popper, {
        ref: "popperRef",
        role: _ctx.role
      }, {
        default: withCtx(() => [
          createVNode(_component_el_tooltip_trigger, {
            disabled: _ctx.disabled,
            trigger: _ctx.trigger,
            "trigger-keys": _ctx.triggerKeys,
            "virtual-ref": _ctx.virtualRef,
            "virtual-triggering": _ctx.virtualTriggering
          }, {
            default: withCtx(() => [
              _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
          createVNode(_component_el_tooltip_content, {
            ref: "contentRef",
            "aria-label": _ctx.ariaLabel,
            "boundaries-padding": _ctx.boundariesPadding,
            content: _ctx.content,
            disabled: _ctx.disabled,
            effect: _ctx.effect,
            enterable: _ctx.enterable,
            "fallback-placements": _ctx.fallbackPlacements,
            "hide-after": _ctx.hideAfter,
            "gpu-acceleration": _ctx.gpuAcceleration,
            offset: _ctx.offset,
            persistent: _ctx.persistent,
            "popper-class": _ctx.popperClass,
            "popper-style": _ctx.popperStyle,
            placement: _ctx.placement,
            "popper-options": _ctx.popperOptions,
            pure: _ctx.pure,
            "raw-content": _ctx.rawContent,
            "reference-el": _ctx.referenceEl,
            "trigger-target-el": _ctx.triggerTargetEl,
            "show-after": _ctx.compatShowAfter,
            strategy: _ctx.strategy,
            teleported: _ctx.teleported,
            transition: _ctx.transition,
            "virtual-triggering": _ctx.virtualTriggering,
            "z-index": _ctx.zIndex,
            "append-to": _ctx.appendTo
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "content", {}, () => [
                _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  innerHTML: _ctx.content
                }, null, 8, _hoisted_1$15)) : (openBlock(), createElementBlock("span", _hoisted_2$H, toDisplayString$1(_ctx.content), 1))
              ]),
              _ctx.compatShowArrow ? (openBlock(), createBlock(_component_el_popper_arrow, {
                key: 0,
                "arrow-offset": _ctx.arrowOffset
              }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
        ]),
        _: 3
      }, 8, ["role"]);
    }
    var Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$24, [["render", _sfc_render$B], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
    const ElTooltip = withInstall(Tooltip);
    const autocompleteProps = buildProps({
      valueKey: {
        type: String,
        default: "value"
      },
      modelValue: {
        type: [String, Number],
        default: ""
      },
      debounce: {
        type: Number,
        default: 300
      },
      placement: {
        type: definePropType(String),
        values: [
          "top",
          "top-start",
          "top-end",
          "bottom",
          "bottom-start",
          "bottom-end"
        ],
        default: "bottom-start"
      },
      fetchSuggestions: {
        type: definePropType([Function, Array]),
        default: NOOP
      },
      popperClass: {
        type: String,
        default: ""
      },
      triggerOnFocus: {
        type: Boolean,
        default: true
      },
      selectWhenUnmatched: {
        type: Boolean,
        default: false
      },
      hideLoading: {
        type: Boolean,
        default: false
      },
      label: {
        type: String
      },
      teleported: useTooltipContentProps.teleported,
      highlightFirstItem: {
        type: Boolean,
        default: false
      },
      fitInputWidth: {
        type: Boolean,
        default: false
      }
    });
    const autocompleteEmits = {
      [UPDATE_MODEL_EVENT]: (value) => isString$3(value),
      [INPUT_EVENT]: (value) => isString$3(value),
      [CHANGE_EVENT]: (value) => isString$3(value),
      focus: (evt) => evt instanceof FocusEvent,
      blur: (evt) => evt instanceof FocusEvent,
      clear: () => true,
      select: (item) => isObject$4(item)
    };
    const _hoisted_1$14 = ["aria-expanded", "aria-owns"];
    const _hoisted_2$G = { key: 0 };
    const _hoisted_3$n = ["id", "aria-selected", "onClick"];
    const __default__$1h = {
      name: "ElAutocomplete",
      inheritAttrs: false
    };
    const _sfc_main$23 = /* @__PURE__ */ defineComponent({
      ...__default__$1h,
      props: autocompleteProps,
      emits: autocompleteEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const COMPONENT_NAME2 = "ElAutocomplete";
        const attrs = useAttrs();
        const rawAttrs = useAttrs$1();
        const disabled = useDisabled$1();
        const ns2 = useNamespace("autocomplete");
        const inputRef = ref();
        const regionRef = ref();
        const popperRef = ref();
        const listboxRef = ref();
        let readonly2 = false;
        let ignoreFocusEvent = false;
        const suggestions = ref([]);
        const highlightedIndex = ref(-1);
        const dropdownWidth = ref("");
        const activated = ref(false);
        const suggestionDisabled = ref(false);
        const loading = ref(false);
        const listboxId = computed(() => ns2.b(String(generateId())));
        const styles = computed(() => rawAttrs.style);
        const suggestionVisible = computed(() => {
          const isValidData = suggestions.value.length > 0;
          return (isValidData || loading.value) && activated.value;
        });
        const suggestionLoading = computed(() => !props.hideLoading && loading.value);
        const refInput = computed(() => {
          if (inputRef.value) {
            return Array.from(inputRef.value.$el.querySelectorAll("input"));
          }
          return [];
        });
        const onSuggestionShow = async () => {
          await nextTick();
          if (suggestionVisible.value) {
            dropdownWidth.value = `${inputRef.value.$el.offsetWidth}px`;
          }
        };
        const onShow = () => {
          ignoreFocusEvent = true;
        };
        const onHide = () => {
          ignoreFocusEvent = false;
          highlightedIndex.value = -1;
        };
        const getData = async (queryString) => {
          if (suggestionDisabled.value)
            return;
          const cb = (suggestionList) => {
            loading.value = false;
            if (suggestionDisabled.value)
              return;
            if (isArray$4(suggestionList)) {
              suggestions.value = suggestionList;
              highlightedIndex.value = props.highlightFirstItem ? 0 : -1;
            } else {
              throwError(COMPONENT_NAME2, "autocomplete suggestions must be an array");
            }
          };
          loading.value = true;
          if (isArray$4(props.fetchSuggestions)) {
            cb(props.fetchSuggestions);
          } else {
            const result = await props.fetchSuggestions(queryString, cb);
            if (isArray$4(result))
              cb(result);
          }
        };
        const debouncedGetData = debounce(getData, props.debounce);
        const handleInput = (value) => {
          const valuePresented = !!value;
          emit(INPUT_EVENT, value);
          emit(UPDATE_MODEL_EVENT, value);
          suggestionDisabled.value = false;
          activated.value || (activated.value = valuePresented);
          if (!props.triggerOnFocus && !value) {
            suggestionDisabled.value = true;
            suggestions.value = [];
            return;
          }
          debouncedGetData(value);
        };
        const handleMouseDown = (event) => {
          var _a2;
          if (disabled.value)
            return;
          if (((_a2 = event.target) == null ? void 0 : _a2.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
            activated.value = true;
          }
        };
        const handleChange = (value) => {
          emit(CHANGE_EVENT, value);
        };
        const handleFocus = (evt) => {
          if (ignoreFocusEvent)
            return;
          activated.value = true;
          emit("focus", evt);
          if (props.triggerOnFocus && !readonly2) {
            debouncedGetData(String(props.modelValue));
          }
        };
        const handleBlur = (evt) => {
          if (ignoreFocusEvent)
            return;
          emit("blur", evt);
        };
        const handleClear = () => {
          activated.value = false;
          emit(UPDATE_MODEL_EVENT, "");
          emit("clear");
        };
        const handleKeyEnter = async () => {
          if (suggestionVisible.value && highlightedIndex.value >= 0 && highlightedIndex.value < suggestions.value.length) {
            handleSelect(suggestions.value[highlightedIndex.value]);
          } else if (props.selectWhenUnmatched) {
            emit("select", { value: props.modelValue });
            suggestions.value = [];
            highlightedIndex.value = -1;
          }
        };
        const handleKeyEscape = (evt) => {
          if (suggestionVisible.value) {
            evt.preventDefault();
            evt.stopPropagation();
            close2();
          }
        };
        const close2 = () => {
          activated.value = false;
        };
        const focus = () => {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
        };
        const blur = () => {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.blur();
        };
        const handleSelect = async (item) => {
          emit(INPUT_EVENT, item[props.valueKey]);
          emit(UPDATE_MODEL_EVENT, item[props.valueKey]);
          emit("select", item);
          suggestions.value = [];
          highlightedIndex.value = -1;
        };
        const highlight = (index2) => {
          if (!suggestionVisible.value || loading.value)
            return;
          if (index2 < 0) {
            highlightedIndex.value = -1;
            return;
          }
          if (index2 >= suggestions.value.length) {
            index2 = suggestions.value.length - 1;
          }
          const suggestion = regionRef.value.querySelector(`.${ns2.be("suggestion", "wrap")}`);
          const suggestionList = suggestion.querySelectorAll(`.${ns2.be("suggestion", "list")} li`);
          const highlightItem = suggestionList[index2];
          const scrollTop = suggestion.scrollTop;
          const { offsetTop, scrollHeight } = highlightItem;
          if (offsetTop + scrollHeight > scrollTop + suggestion.clientHeight) {
            suggestion.scrollTop += scrollHeight;
          }
          if (offsetTop < scrollTop) {
            suggestion.scrollTop -= scrollHeight;
          }
          highlightedIndex.value = index2;
          inputRef.value.ref.setAttribute("aria-activedescendant", `${listboxId.value}-item-${highlightedIndex.value}`);
        };
        onClickOutside(listboxRef, () => {
          suggestionVisible.value && close2();
        });
        onMounted(() => {
          inputRef.value.ref.setAttribute("role", "textbox");
          inputRef.value.ref.setAttribute("aria-autocomplete", "list");
          inputRef.value.ref.setAttribute("aria-controls", "id");
          inputRef.value.ref.setAttribute("aria-activedescendant", `${listboxId.value}-item-${highlightedIndex.value}`);
          readonly2 = inputRef.value.ref.hasAttribute("readonly");
        });
        expose({
          highlightedIndex,
          activated,
          loading,
          inputRef,
          popperRef,
          suggestions,
          handleSelect,
          handleKeyEnter,
          focus,
          blur,
          close: close2,
          highlight
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElTooltip), {
            ref_key: "popperRef",
            ref: popperRef,
            visible: unref(suggestionVisible),
            placement: _ctx.placement,
            "fallback-placements": ["bottom-start", "top-start"],
            "popper-class": [unref(ns2).e("popper"), _ctx.popperClass],
            teleported: _ctx.teleported,
            "gpu-acceleration": false,
            pure: "",
            "manual-mode": "",
            effect: "light",
            trigger: "click",
            transition: `${unref(ns2).namespace.value}-zoom-in-top`,
            persistent: "",
            onBeforeShow: onSuggestionShow,
            onShow,
            onHide
          }, {
            content: withCtx(() => [
              createBaseVNode("div", {
                ref_key: "regionRef",
                ref: regionRef,
                class: normalizeClass([unref(ns2).b("suggestion"), unref(ns2).is("loading", unref(suggestionLoading))]),
                style: normalizeStyle({
                  [_ctx.fitInputWidth ? "width" : "minWidth"]: dropdownWidth.value,
                  outline: "none"
                }),
                role: "region"
              }, [
                createVNode(unref(ElScrollbar), {
                  id: unref(listboxId),
                  tag: "ul",
                  "wrap-class": unref(ns2).be("suggestion", "wrap"),
                  "view-class": unref(ns2).be("suggestion", "list"),
                  role: "listbox"
                }, {
                  default: withCtx(() => [
                    unref(suggestionLoading) ? (openBlock(), createElementBlock("li", _hoisted_2$G, [
                      createVNode(unref(ElIcon), {
                        class: normalizeClass(unref(ns2).is("loading"))
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(loading_default))
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(suggestions.value, (item, index2) => {
                      return openBlock(), createElementBlock("li", {
                        id: `${unref(listboxId)}-item-${index2}`,
                        key: index2,
                        class: normalizeClass({ highlighted: highlightedIndex.value === index2 }),
                        role: "option",
                        "aria-selected": highlightedIndex.value === index2,
                        onClick: ($event) => handleSelect(item)
                      }, [
                        renderSlot(_ctx.$slots, "default", { item }, () => [
                          createTextVNode(toDisplayString$1(item[_ctx.valueKey]), 1)
                        ])
                      ], 10, _hoisted_3$n);
                    }), 128))
                  ]),
                  _: 3
                }, 8, ["id", "wrap-class", "view-class"])
              ], 6)
            ]),
            default: withCtx(() => [
              createBaseVNode("div", {
                ref_key: "listboxRef",
                ref: listboxRef,
                class: normalizeClass([unref(ns2).b(), _ctx.$attrs.class]),
                style: normalizeStyle(unref(styles)),
                role: "combobox",
                "aria-haspopup": "listbox",
                "aria-expanded": unref(suggestionVisible),
                "aria-owns": unref(listboxId)
              }, [
                createVNode(unref(ElInput), mergeProps({
                  ref_key: "inputRef",
                  ref: inputRef
                }, unref(attrs), {
                  "model-value": _ctx.modelValue,
                  onInput: handleInput,
                  onChange: handleChange,
                  onFocus: handleFocus,
                  onBlur: handleBlur,
                  onClear: handleClear,
                  onKeydown: [
                    _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => highlight(highlightedIndex.value - 1), ["prevent"]), ["up"])),
                    _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => highlight(highlightedIndex.value + 1), ["prevent"]), ["down"])),
                    withKeys(handleKeyEnter, ["enter"]),
                    withKeys(close2, ["tab"]),
                    withKeys(handleKeyEscape, ["esc"])
                  ],
                  onMousedown: handleMouseDown
                }), createSlots({ _: 2 }, [
                  _ctx.$slots.prepend ? {
                    name: "prepend",
                    fn: withCtx(() => [
                      renderSlot(_ctx.$slots, "prepend")
                    ])
                  } : void 0,
                  _ctx.$slots.append ? {
                    name: "append",
                    fn: withCtx(() => [
                      renderSlot(_ctx.$slots, "append")
                    ])
                  } : void 0,
                  _ctx.$slots.prefix ? {
                    name: "prefix",
                    fn: withCtx(() => [
                      renderSlot(_ctx.$slots, "prefix")
                    ])
                  } : void 0,
                  _ctx.$slots.suffix ? {
                    name: "suffix",
                    fn: withCtx(() => [
                      renderSlot(_ctx.$slots, "suffix")
                    ])
                  } : void 0
                ]), 1040, ["model-value", "onKeydown"])
              ], 14, _hoisted_1$14)
            ]),
            _: 3
          }, 8, ["visible", "placement", "popper-class", "teleported", "transition"]);
        };
      }
    });
    var Autocomplete = /* @__PURE__ */ _export_sfc(_sfc_main$23, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/autocomplete/src/autocomplete.vue"]]);
    const ElAutocomplete = withInstall(Autocomplete);
    const avatarProps = buildProps({
      size: {
        type: [Number, String],
        values: componentSizes,
        default: "",
        validator: (val) => isNumber$2(val)
      },
      shape: {
        type: String,
        values: ["circle", "square"],
        default: "circle"
      },
      icon: {
        type: iconPropType
      },
      src: {
        type: String,
        default: ""
      },
      alt: String,
      srcSet: String,
      fit: {
        type: definePropType(String),
        default: "cover"
      }
    });
    const avatarEmits = {
      error: (evt) => evt instanceof Event
    };
    const _hoisted_1$13 = ["src", "alt", "srcset"];
    const __default__$1g = {
      name: "ElAvatar"
    };
    const _sfc_main$22 = /* @__PURE__ */ defineComponent({
      ...__default__$1g,
      props: avatarProps,
      emits: avatarEmits,
      setup(__props, { emit }) {
        const props = __props;
        const ns2 = useNamespace("avatar");
        const hasLoadError = ref(false);
        const avatarClass = computed(() => {
          const { size: size2, icon, shape } = props;
          const classList = [ns2.b()];
          if (isString$3(size2))
            classList.push(ns2.m(size2));
          if (icon)
            classList.push(ns2.m("icon"));
          if (shape)
            classList.push(ns2.m(shape));
          return classList;
        });
        const sizeStyle = computed(() => {
          const { size: size2 } = props;
          return isNumber$2(size2) ? ns2.cssVarBlock({
            size: addUnit(size2) || ""
          }) : void 0;
        });
        const fitStyle = computed(() => ({
          objectFit: props.fit
        }));
        watch(() => props.src, () => hasLoadError.value = false);
        function handleError2(e) {
          hasLoadError.value = true;
          emit("error", e);
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            class: normalizeClass(unref(avatarClass)),
            style: normalizeStyle(unref(sizeStyle))
          }, [
            (_ctx.src || _ctx.srcSet) && !hasLoadError.value ? (openBlock(), createElementBlock("img", {
              key: 0,
              src: _ctx.src,
              alt: _ctx.alt,
              srcset: _ctx.srcSet,
              style: normalizeStyle(unref(fitStyle)),
              onError: handleError2
            }, null, 44, _hoisted_1$13)) : _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
              ]),
              _: 1
            })) : renderSlot(_ctx.$slots, "default", { key: 2 })
          ], 6);
        };
      }
    });
    var Avatar = /* @__PURE__ */ _export_sfc(_sfc_main$22, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/avatar/src/avatar.vue"]]);
    const ElAvatar = withInstall(Avatar);
    const backtopProps = {
      visibilityHeight: {
        type: Number,
        default: 200
      },
      target: {
        type: String,
        default: ""
      },
      right: {
        type: Number,
        default: 40
      },
      bottom: {
        type: Number,
        default: 40
      }
    };
    const backtopEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    const _hoisted_1$12 = ["onClick"];
    const __default__$1f = {
      name: "ElBacktop"
    };
    const _sfc_main$21 = /* @__PURE__ */ defineComponent({
      ...__default__$1f,
      props: backtopProps,
      emits: backtopEmits,
      setup(__props, { emit }) {
        const props = __props;
        const COMPONENT_NAME2 = "ElBacktop";
        const ns2 = useNamespace("backtop");
        const el = shallowRef();
        const container = shallowRef();
        const visible = ref(false);
        const backTopStyle = computed(() => ({
          right: `${props.right}px`,
          bottom: `${props.bottom}px`
        }));
        const scrollToTop = () => {
          if (!el.value)
            return;
          const beginTime = Date.now();
          const beginValue = el.value.scrollTop;
          const frameFunc = () => {
            if (!el.value)
              return;
            const progress = (Date.now() - beginTime) / 500;
            if (progress < 1) {
              el.value.scrollTop = beginValue * (1 - easeInOutCubic(progress));
              requestAnimationFrame(frameFunc);
            } else {
              el.value.scrollTop = 0;
            }
          };
          requestAnimationFrame(frameFunc);
        };
        const handleScroll2 = () => {
          if (el.value)
            visible.value = el.value.scrollTop >= props.visibilityHeight;
        };
        const handleClick = (event) => {
          scrollToTop();
          emit("click", event);
        };
        const handleScrollThrottled = useThrottleFn(handleScroll2, 300);
        useEventListener(container, "scroll", handleScrollThrottled);
        onMounted(() => {
          var _a2;
          container.value = document;
          el.value = document.documentElement;
          if (props.target) {
            el.value = (_a2 = document.querySelector(props.target)) != null ? _a2 : void 0;
            if (!el.value) {
              throwError(COMPONENT_NAME2, `target is not existed: ${props.target}`);
            }
            container.value = el.value;
          }
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition, {
            name: `${unref(ns2).namespace.value}-fade-in`
          }, {
            default: withCtx(() => [
              visible.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                style: normalizeStyle(unref(backTopStyle)),
                class: normalizeClass(unref(ns2).b()),
                onClick: withModifiers(handleClick, ["stop"])
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createVNode(unref(ElIcon), {
                    class: normalizeClass(unref(ns2).e("icon"))
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(caret_top_default))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ])
              ], 14, _hoisted_1$12)) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 8, ["name"]);
        };
      }
    });
    var Backtop = /* @__PURE__ */ _export_sfc(_sfc_main$21, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/backtop/src/backtop.vue"]]);
    const ElBacktop = withInstall(Backtop);
    const badgeProps = buildProps({
      value: {
        type: [String, Number],
        default: ""
      },
      max: {
        type: Number,
        default: 99
      },
      isDot: Boolean,
      hidden: Boolean,
      type: {
        type: String,
        values: ["primary", "success", "warning", "info", "danger"],
        default: "danger"
      }
    });
    const _hoisted_1$11 = ["textContent"];
    const __default__$1e = {
      name: "ElBadge"
    };
    const _sfc_main$20 = /* @__PURE__ */ defineComponent({
      ...__default__$1e,
      props: badgeProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns2 = useNamespace("badge");
        const content = computed(() => {
          if (props.isDot)
            return "";
          if (isNumber$2(props.value) && isNumber$2(props.max)) {
            return props.max < props.value ? `${props.max}+` : `${props.value}`;
          }
          return `${props.value}`;
        });
        expose({
          content
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(ns2).b())
          }, [
            renderSlot(_ctx.$slots, "default"),
            createVNode(Transition, {
              name: `${unref(ns2).namespace.value}-zoom-in-center`,
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("sup", {
                  class: normalizeClass([
                    unref(ns2).e("content"),
                    unref(ns2).em("content", _ctx.type),
                    unref(ns2).is("fixed", !!_ctx.$slots.default),
                    unref(ns2).is("dot", _ctx.isDot)
                  ]),
                  textContent: toDisplayString$1(unref(content))
                }, null, 10, _hoisted_1$11), [
                  [vShow, !_ctx.hidden && (unref(content) || _ctx.isDot)]
                ])
              ]),
              _: 1
            }, 8, ["name"])
          ], 2);
        };
      }
    });
    var Badge = /* @__PURE__ */ _export_sfc(_sfc_main$20, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);
    const ElBadge = withInstall(Badge);
    const breadcrumbProps = buildProps({
      separator: {
        type: String,
        default: "/"
      },
      separatorIcon: {
        type: iconPropType
      }
    });
    const __default__$1d = {
      name: "ElBreadcrumb"
    };
    const _sfc_main$1$ = /* @__PURE__ */ defineComponent({
      ...__default__$1d,
      props: breadcrumbProps,
      setup(__props) {
        const props = __props;
        const ns2 = useNamespace("breadcrumb");
        const breadcrumb = ref();
        provide(breadcrumbKey, props);
        onMounted(() => {
          const items = breadcrumb.value.querySelectorAll(`.${ns2.e("item")}`);
          if (items.length) {
            items[items.length - 1].setAttribute("aria-current", "page");
          }
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "breadcrumb",
            ref: breadcrumb,
            class: normalizeClass(unref(ns2).b()),
            "aria-label": "Breadcrumb",
            role: "navigation"
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var Breadcrumb = /* @__PURE__ */ _export_sfc(_sfc_main$1$, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb.vue"]]);
    const breadcrumbItemProps = buildProps({
      to: {
        type: definePropType([String, Object]),
        default: ""
      },
      replace: {
        type: Boolean,
        default: false
      }
    });
    const __default__$1c = {
      name: "ElBreadcrumbItem"
    };
    const _sfc_main$1_ = /* @__PURE__ */ defineComponent({
      ...__default__$1c,
      props: breadcrumbItemProps,
      setup(__props) {
        const props = __props;
        const instance = getCurrentInstance();
        const breadcrumbContext = inject(breadcrumbKey, void 0);
        const ns2 = useNamespace("breadcrumb");
        const { separator, separatorIcon } = toRefs(breadcrumbContext);
        const router = instance.appContext.config.globalProperties.$router;
        const link = ref();
        const onClick = () => {
          if (!props.to || !router)
            return;
          props.replace ? router.replace(props.to) : router.push(props.to);
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            class: normalizeClass(unref(ns2).e("item"))
          }, [
            createBaseVNode("span", {
              ref_key: "link",
              ref: link,
              class: normalizeClass([unref(ns2).e("inner"), unref(ns2).is("link", !!_ctx.to)]),
              role: "link",
              onClick
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2),
            unref(separatorIcon) ? (openBlock(), createBlock(unref(ElIcon), {
              key: 0,
              class: normalizeClass(unref(ns2).e("separator"))
            }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(unref(separatorIcon))))
              ]),
              _: 1
            }, 8, ["class"])) : (openBlock(), createElementBlock("span", {
              key: 1,
              class: normalizeClass(unref(ns2).e("separator")),
              role: "presentation"
            }, toDisplayString$1(unref(separator)), 3))
          ], 2);
        };
      }
    });
    var BreadcrumbItem = /* @__PURE__ */ _export_sfc(_sfc_main$1_, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb-item.vue"]]);
    const ElBreadcrumb = withInstall(Breadcrumb, {
      BreadcrumbItem
    });
    const ElBreadcrumbItem = withNoopInstall(BreadcrumbItem);
    const buttonTypes = [
      "default",
      "primary",
      "success",
      "warning",
      "info",
      "danger",
      "text",
      ""
    ];
    const buttonNativeTypes = ["button", "submit", "reset"];
    const buttonProps = buildProps({
      size: useSizeProp,
      disabled: Boolean,
      type: {
        type: String,
        values: buttonTypes,
        default: ""
      },
      icon: {
        type: iconPropType
      },
      nativeType: {
        type: String,
        values: buttonNativeTypes,
        default: "button"
      },
      loading: Boolean,
      loadingIcon: {
        type: iconPropType,
        default: () => loading_default
      },
      plain: Boolean,
      text: Boolean,
      link: Boolean,
      bg: Boolean,
      autofocus: Boolean,
      round: Boolean,
      circle: Boolean,
      color: String,
      dark: Boolean,
      autoInsertSpace: {
        type: Boolean,
        default: void 0
      }
    });
    const buttonEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    function bound01$1(n, max2) {
      if (isOnePointZero$1(n)) {
        n = "100%";
      }
      var isPercent = isPercentage$1(n);
      n = max2 === 360 ? n : Math.min(max2, Math.max(0, parseFloat(n)));
      if (isPercent) {
        n = parseInt(String(n * max2), 10) / 100;
      }
      if (Math.abs(n - max2) < 1e-6) {
        return 1;
      }
      if (max2 === 360) {
        n = (n < 0 ? n % max2 + max2 : n % max2) / parseFloat(String(max2));
      } else {
        n = n % max2 / parseFloat(String(max2));
      }
      return n;
    }
    function clamp01(val) {
      return Math.min(1, Math.max(0, val));
    }
    function isOnePointZero$1(n) {
      return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
    }
    function isPercentage$1(n) {
      return typeof n === "string" && n.indexOf("%") !== -1;
    }
    function boundAlpha(a2) {
      a2 = parseFloat(a2);
      if (isNaN(a2) || a2 < 0 || a2 > 1) {
        a2 = 1;
      }
      return a2;
    }
    function convertToPercentage(n) {
      if (n <= 1) {
        return "".concat(Number(n) * 100, "%");
      }
      return n;
    }
    function pad2(c2) {
      return c2.length === 1 ? "0" + c2 : String(c2);
    }
    function rgbToRgb(r, g, b2) {
      return {
        r: bound01$1(r, 255) * 255,
        g: bound01$1(g, 255) * 255,
        b: bound01$1(b2, 255) * 255
      };
    }
    function rgbToHsl(r, g, b2) {
      r = bound01$1(r, 255);
      g = bound01$1(g, 255);
      b2 = bound01$1(b2, 255);
      var max2 = Math.max(r, g, b2);
      var min2 = Math.min(r, g, b2);
      var h2 = 0;
      var s2 = 0;
      var l2 = (max2 + min2) / 2;
      if (max2 === min2) {
        s2 = 0;
        h2 = 0;
      } else {
        var d2 = max2 - min2;
        s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
        switch (max2) {
          case r:
            h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
            break;
          case g:
            h2 = (b2 - r) / d2 + 2;
            break;
          case b2:
            h2 = (r - g) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, l: l2 };
    }
    function hue2rgb(p2, q2, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p2 + (q2 - p2) * (6 * t);
      }
      if (t < 1 / 2) {
        return q2;
      }
      if (t < 2 / 3) {
        return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      }
      return p2;
    }
    function hslToRgb(h2, s2, l2) {
      var r;
      var g;
      var b2;
      h2 = bound01$1(h2, 360);
      s2 = bound01$1(s2, 100);
      l2 = bound01$1(l2, 100);
      if (s2 === 0) {
        g = l2;
        b2 = l2;
        r = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        var p2 = 2 * l2 - q2;
        r = hue2rgb(p2, q2, h2 + 1 / 3);
        g = hue2rgb(p2, q2, h2);
        b2 = hue2rgb(p2, q2, h2 - 1 / 3);
      }
      return { r: r * 255, g: g * 255, b: b2 * 255 };
    }
    function rgbToHsv(r, g, b2) {
      r = bound01$1(r, 255);
      g = bound01$1(g, 255);
      b2 = bound01$1(b2, 255);
      var max2 = Math.max(r, g, b2);
      var min2 = Math.min(r, g, b2);
      var h2 = 0;
      var v2 = max2;
      var d2 = max2 - min2;
      var s2 = max2 === 0 ? 0 : d2 / max2;
      if (max2 === min2) {
        h2 = 0;
      } else {
        switch (max2) {
          case r:
            h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
            break;
          case g:
            h2 = (b2 - r) / d2 + 2;
            break;
          case b2:
            h2 = (r - g) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, v: v2 };
    }
    function hsvToRgb(h2, s2, v2) {
      h2 = bound01$1(h2, 360) * 6;
      s2 = bound01$1(s2, 100);
      v2 = bound01$1(v2, 100);
      var i = Math.floor(h2);
      var f2 = h2 - i;
      var p2 = v2 * (1 - s2);
      var q2 = v2 * (1 - f2 * s2);
      var t = v2 * (1 - (1 - f2) * s2);
      var mod = i % 6;
      var r = [v2, q2, p2, p2, t, v2][mod];
      var g = [t, v2, v2, q2, p2, p2][mod];
      var b2 = [p2, p2, t, v2, v2, q2][mod];
      return { r: r * 255, g: g * 255, b: b2 * 255 };
    }
    function rgbToHex(r, g, b2, allow3Char) {
      var hex = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b2).toString(16))
      ];
      if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r, g, b2, a2, allow4Char) {
      var hex = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b2).toString(16)),
        pad2(convertDecimalToHex(a2))
      ];
      if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function convertDecimalToHex(d2) {
      return Math.round(parseFloat(d2) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function numberInputToObject(color) {
      return {
        r: color >> 16,
        g: (color & 65280) >> 8,
        b: color & 255
      };
    }
    var names = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      goldenrod: "#daa520",
      gold: "#ffd700",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavenderblush: "#fff0f5",
      lavender: "#e6e6fa",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    function inputToRGB(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a2 = 1;
      var s2 = null;
      var v2 = null;
      var l2 = null;
      var ok = false;
      var format2 = false;
      if (typeof color === "string") {
        color = stringInputToObject(color);
      }
      if (typeof color === "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s2 = convertToPercentage(color.s);
          v2 = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s2, v2);
          ok = true;
          format2 = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s2 = convertToPercentage(color.s);
          l2 = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s2, l2);
          ok = true;
          format2 = "hsl";
        }
        if (Object.prototype.hasOwnProperty.call(color, "a")) {
          a2 = color.a;
        }
      }
      a2 = boundAlpha(a2);
      return {
        ok,
        format: color.format || format2,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a: a2
      };
    }
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var matchers = {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
    function stringInputToObject(color) {
      color = color.trim().toLowerCase();
      if (color.length === 0) {
        return false;
      }
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color === "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match = matchers.rgb.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3] };
      }
      match = matchers.rgba.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      match = matchers.hsl.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3] };
      }
      match = matchers.hsla.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      match = matchers.hsv.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3] };
      }
      match = matchers.hsva.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      match = matchers.hex8.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex6.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      match = matchers.hex4.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          a: convertHexToDecimal(match[4] + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex3.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function isValidCSSUnit(color) {
      return Boolean(matchers.CSS_UNIT.exec(String(color)));
    }
    var TinyColor = function() {
      function TinyColor2(color, opts) {
        if (color === void 0) {
          color = "";
        }
        if (opts === void 0) {
          opts = {};
        }
        var _a2;
        if (color instanceof TinyColor2) {
          return color;
        }
        if (typeof color === "number") {
          color = numberInputToObject(color);
        }
        this.originalInput = color;
        var rgb = inputToRGB(color);
        this.originalInput = color;
        this.r = rgb.r;
        this.g = rgb.g;
        this.b = rgb.b;
        this.a = rgb.a;
        this.roundA = Math.round(100 * this.a) / 100;
        this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
        this.gradientType = opts.gradientType;
        if (this.r < 1) {
          this.r = Math.round(this.r);
        }
        if (this.g < 1) {
          this.g = Math.round(this.g);
        }
        if (this.b < 1) {
          this.b = Math.round(this.b);
        }
        this.isValid = rgb.ok;
      }
      TinyColor2.prototype.isDark = function() {
        return this.getBrightness() < 128;
      };
      TinyColor2.prototype.isLight = function() {
        return !this.isDark();
      };
      TinyColor2.prototype.getBrightness = function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      };
      TinyColor2.prototype.getLuminance = function() {
        var rgb = this.toRgb();
        var R2;
        var G2;
        var B2;
        var RsRGB = rgb.r / 255;
        var GsRGB = rgb.g / 255;
        var BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) {
          R2 = RsRGB / 12.92;
        } else {
          R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G2 = GsRGB / 12.92;
        } else {
          G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B2 = BsRGB / 12.92;
        } else {
          B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
      };
      TinyColor2.prototype.getAlpha = function() {
        return this.a;
      };
      TinyColor2.prototype.setAlpha = function(alpha) {
        this.a = boundAlpha(alpha);
        this.roundA = Math.round(100 * this.a) / 100;
        return this;
      };
      TinyColor2.prototype.toHsv = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
      };
      TinyColor2.prototype.toHsvString = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        var h2 = Math.round(hsv.h * 360);
        var s2 = Math.round(hsv.s * 100);
        var v2 = Math.round(hsv.v * 100);
        return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHsl = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
      };
      TinyColor2.prototype.toHslString = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        var h2 = Math.round(hsl.h * 360);
        var s2 = Math.round(hsl.s * 100);
        var l2 = Math.round(hsl.l * 100);
        return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHex = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return rgbToHex(this.r, this.g, this.b, allow3Char);
      };
      TinyColor2.prototype.toHexString = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return "#" + this.toHex(allow3Char);
      };
      TinyColor2.prototype.toHex8 = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
      };
      TinyColor2.prototype.toHex8String = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return "#" + this.toHex8(allow4Char);
      };
      TinyColor2.prototype.toRgb = function() {
        return {
          r: Math.round(this.r),
          g: Math.round(this.g),
          b: Math.round(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toRgbString = function() {
        var r = Math.round(this.r);
        var g = Math.round(this.g);
        var b2 = Math.round(this.b);
        return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b2, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b2, ", ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toPercentageRgb = function() {
        var fmt = function(x2) {
          return "".concat(Math.round(bound01$1(x2, 255) * 100), "%");
        };
        return {
          r: fmt(this.r),
          g: fmt(this.g),
          b: fmt(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toPercentageRgbString = function() {
        var rnd = function(x2) {
          return Math.round(bound01$1(x2, 255) * 100);
        };
        return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toName = function() {
        if (this.a === 0) {
          return "transparent";
        }
        if (this.a < 1) {
          return false;
        }
        var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
        for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
          var _b = _a2[_i], key = _b[0], value = _b[1];
          if (hex === value) {
            return key;
          }
        }
        return false;
      };
      TinyColor2.prototype.toString = function(format2) {
        var formatSet = Boolean(format2);
        format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
        var formattedString = false;
        var hasAlpha = this.a < 1 && this.a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
        if (needsAlphaFormat) {
          if (format2 === "name" && this.a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format2 === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format2 === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format2 === "hex" || format2 === "hex6") {
          formattedString = this.toHexString();
        }
        if (format2 === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format2 === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format2 === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format2 === "name") {
          formattedString = this.toName();
        }
        if (format2 === "hsl") {
          formattedString = this.toHslString();
        }
        if (format2 === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      };
      TinyColor2.prototype.toNumber = function() {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
      };
      TinyColor2.prototype.clone = function() {
        return new TinyColor2(this.toString());
      };
      TinyColor2.prototype.lighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.brighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var rgb = this.toRgb();
        rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
        rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
        rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
        return new TinyColor2(rgb);
      };
      TinyColor2.prototype.darken = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.tint = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("white", amount);
      };
      TinyColor2.prototype.shade = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("black", amount);
      };
      TinyColor2.prototype.desaturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.saturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.greyscale = function() {
        return this.desaturate(100);
      };
      TinyColor2.prototype.spin = function(amount) {
        var hsl = this.toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.mix = function(color, amount) {
        if (amount === void 0) {
          amount = 50;
        }
        var rgb1 = this.toRgb();
        var rgb2 = new TinyColor2(color).toRgb();
        var p2 = amount / 100;
        var rgba = {
          r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
          g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
          b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
          a: (rgb2.a - rgb1.a) * p2 + rgb1.a
        };
        return new TinyColor2(rgba);
      };
      TinyColor2.prototype.analogous = function(results, slices) {
        if (results === void 0) {
          results = 6;
        }
        if (slices === void 0) {
          slices = 30;
        }
        var hsl = this.toHsl();
        var part = 360 / slices;
        var ret = [this];
        for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl.h = (hsl.h + part) % 360;
          ret.push(new TinyColor2(hsl));
        }
        return ret;
      };
      TinyColor2.prototype.complement = function() {
        var hsl = this.toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.monochromatic = function(results) {
        if (results === void 0) {
          results = 6;
        }
        var hsv = this.toHsv();
        var h2 = hsv.h;
        var s2 = hsv.s;
        var v2 = hsv.v;
        var res = [];
        var modification = 1 / results;
        while (results--) {
          res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
          v2 = (v2 + modification) % 1;
        }
        return res;
      };
      TinyColor2.prototype.splitcomplement = function() {
        var hsl = this.toHsl();
        var h2 = hsl.h;
        return [
          this,
          new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
          new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
        ];
      };
      TinyColor2.prototype.onBackground = function(background) {
        var fg = this.toRgb();
        var bg = new TinyColor2(background).toRgb();
        return new TinyColor2({
          r: bg.r + (fg.r - bg.r) * fg.a,
          g: bg.g + (fg.g - bg.g) * fg.a,
          b: bg.b + (fg.b - bg.b) * fg.a
        });
      };
      TinyColor2.prototype.triad = function() {
        return this.polyad(3);
      };
      TinyColor2.prototype.tetrad = function() {
        return this.polyad(4);
      };
      TinyColor2.prototype.polyad = function(n) {
        var hsl = this.toHsl();
        var h2 = hsl.h;
        var result = [this];
        var increment = 360 / n;
        for (var i = 1; i < n; i++) {
          result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
        }
        return result;
      };
      TinyColor2.prototype.equals = function(color) {
        return this.toRgbString() === new TinyColor2(color).toRgbString();
      };
      return TinyColor2;
    }();
    function darken(color, amount = 20) {
      return color.mix("#141414", amount).toString();
    }
    function useButtonCustomStyle(props) {
      const _disabled = useDisabled$1();
      const ns2 = useNamespace("button");
      return computed(() => {
        let styles = {};
        const buttonColor = props.color;
        if (buttonColor) {
          const color = new TinyColor(buttonColor);
          const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
          if (props.plain) {
            styles = ns2.cssVarBlock({
              "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
              "text-color": buttonColor,
              "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
              "hover-text-color": `var(${ns2.cssVarName("color-white")})`,
              "hover-bg-color": buttonColor,
              "hover-border-color": buttonColor,
              "active-bg-color": activeBgColor,
              "active-text-color": `var(${ns2.cssVarName("color-white")})`,
              "active-border-color": activeBgColor
            });
            if (_disabled.value) {
              styles[ns2.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
              styles[ns2.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
              styles[ns2.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
            }
          } else {
            const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
            const textColor = color.isDark() ? `var(${ns2.cssVarName("color-white")})` : `var(${ns2.cssVarName("color-black")})`;
            styles = ns2.cssVarBlock({
              "bg-color": buttonColor,
              "text-color": textColor,
              "border-color": buttonColor,
              "hover-bg-color": hoverBgColor,
              "hover-text-color": textColor,
              "hover-border-color": hoverBgColor,
              "active-bg-color": activeBgColor,
              "active-border-color": activeBgColor
            });
            if (_disabled.value) {
              const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
              styles[ns2.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
              styles[ns2.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns2.cssVarName("color-white")})`;
              styles[ns2.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
            }
          }
        }
        return styles;
      });
    }
    const _hoisted_1$10 = ["aria-disabled", "disabled", "autofocus", "type"];
    const __default__$1b = {
      name: "ElButton"
    };
    const _sfc_main$1Z = /* @__PURE__ */ defineComponent({
      ...__default__$1b,
      props: buttonProps,
      emits: buttonEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const slots = useSlots();
        useDeprecated({
          from: "type.text",
          replacement: "type.link",
          version: "3.0.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
        }, computed(() => props.type === "text"));
        const buttonGroupContext = inject(buttonGroupContextKey, void 0);
        const globalConfig2 = useGlobalConfig("button");
        const ns2 = useNamespace("button");
        const { form } = useFormItem();
        const _size = useSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
        const _disabled = useDisabled$1();
        const _ref = ref();
        const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
        const autoInsertSpace = computed(() => {
          var _a2, _b, _c;
          return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
        });
        const shouldAddSpace = computed(() => {
          var _a2;
          const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
            const slot = defaultSlot[0];
            if ((slot == null ? void 0 : slot.type) === Text) {
              const text = slot.children;
              return /^\p{Unified_Ideograph}{2}$/u.test(text.trim());
            }
          }
          return false;
        });
        const buttonStyle = useButtonCustomStyle(props);
        const handleClick = (evt) => {
          if (props.nativeType === "reset") {
            form == null ? void 0 : form.resetFields();
          }
          emit("click", evt);
        };
        expose({
          ref: _ref,
          size: _size,
          type: _type,
          disabled: _disabled,
          shouldAddSpace
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("button", {
            ref_key: "_ref",
            ref: _ref,
            class: normalizeClass([
              unref(ns2).b(),
              unref(ns2).m(unref(_type)),
              unref(ns2).m(unref(_size)),
              unref(ns2).is("disabled", unref(_disabled)),
              unref(ns2).is("loading", _ctx.loading),
              unref(ns2).is("plain", _ctx.plain),
              unref(ns2).is("round", _ctx.round),
              unref(ns2).is("circle", _ctx.circle),
              unref(ns2).is("text", _ctx.text),
              unref(ns2).is("link", _ctx.link),
              unref(ns2).is("has-bg", _ctx.bg)
            ]),
            "aria-disabled": unref(_disabled) || _ctx.loading,
            disabled: unref(_disabled) || _ctx.loading,
            autofocus: _ctx.autofocus,
            type: _ctx.nativeType,
            style: normalizeStyle(unref(buttonStyle)),
            onClick: handleClick
          }, [
            _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                key: 1,
                class: normalizeClass(unref(ns2).is("loading"))
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                ]),
                _: 1
              }, 8, ["class"]))
            ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
              default: withCtx(() => [
                _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
              ]),
              _: 3
            })) : createCommentVNode("v-if", true),
            _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
              key: 2,
              class: normalizeClass({ [unref(ns2).em("text", "expand")]: unref(shouldAddSpace) })
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)) : createCommentVNode("v-if", true)
          ], 14, _hoisted_1$10);
        };
      }
    });
    var Button = /* @__PURE__ */ _export_sfc(_sfc_main$1Z, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
    const buttonGroupProps = {
      size: buttonProps.size,
      type: buttonProps.type
    };
    const __default__$1a = {
      name: "ElButtonGroup"
    };
    const _sfc_main$1Y = /* @__PURE__ */ defineComponent({
      ...__default__$1a,
      props: buttonGroupProps,
      setup(__props) {
        const props = __props;
        provide(buttonGroupContextKey, reactive({
          size: toRef(props, "size"),
          type: toRef(props, "type")
        }));
        const ns2 = useNamespace("button");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(`${unref(ns2).b("group")}`)
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$1Y, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
    const ElButton = withInstall(Button, {
      ButtonGroup
    });
    const ElButtonGroup$1 = withNoopInstall(ButtonGroup);
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getAugmentedNamespace(n) {
      var f2 = n.default;
      if (typeof f2 == "function") {
        var a2 = function() {
          return f2.apply(this, arguments);
        };
        a2.prototype = f2.prototype;
      } else
        a2 = {};
      Object.defineProperty(a2, "__esModule", { value: true });
      Object.keys(n).forEach(function(k) {
        var d2 = Object.getOwnPropertyDescriptor(n, k);
        Object.defineProperty(a2, k, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return n[k];
          }
        });
      });
      return a2;
    }
    var dayjs_min = { exports: {} };
    (function(module2, exports2) {
      !function(t, e) {
        module2.exports = e();
      }(commonjsGlobal, function() {
        var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", f2 = "month", h2 = "quarter", c2 = "year", d2 = "date", $ = "Invalid Date", l2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m2 = function(t2, e2, n2) {
          var r2 = String(t2);
          return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
        }, g = { s: m2, z: function(t2) {
          var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
          return (e2 <= 0 ? "+" : "-") + m2(r2, 2, "0") + ":" + m2(i2, 2, "0");
        }, m: function t2(e2, n2) {
          if (e2.date() < n2.date())
            return -t2(n2, e2);
          var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f2), s3 = n2 - i2 < 0, u3 = e2.clone().add(r2 + (s3 ? -1 : 1), f2);
          return +(-(r2 + (n2 - i2) / (s3 ? i2 - u3 : u3 - i2)) || 0);
        }, a: function(t2) {
          return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
        }, p: function(t2) {
          return { M: f2, y: c2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i, ms: r, Q: h2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t2) {
          return void 0 === t2;
        } }, v2 = "en", D2 = {};
        D2[v2] = M2;
        var p2 = function(t2) {
          return t2 instanceof _2;
        }, S2 = function t2(e2, n2, r2) {
          var i2;
          if (!e2)
            return v2;
          if ("string" == typeof e2) {
            var s3 = e2.toLowerCase();
            D2[s3] && (i2 = s3), n2 && (D2[s3] = n2, i2 = s3);
            var u3 = e2.split("-");
            if (!i2 && u3.length > 1)
              return t2(u3[0]);
          } else {
            var a3 = e2.name;
            D2[a3] = e2, i2 = a3;
          }
          return !r2 && i2 && (v2 = i2), i2 || !r2 && v2;
        }, w2 = function(t2, e2) {
          if (p2(t2))
            return t2.clone();
          var n2 = "object" == typeof e2 ? e2 : {};
          return n2.date = t2, n2.args = arguments, new _2(n2);
        }, O2 = g;
        O2.l = S2, O2.i = p2, O2.w = function(t2, e2) {
          return w2(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
        };
        var _2 = function() {
          function M3(t2) {
            this.$L = S2(t2.locale, null, true), this.parse(t2);
          }
          var m3 = M3.prototype;
          return m3.parse = function(t2) {
            this.$d = function(t3) {
              var e2 = t3.date, n2 = t3.utc;
              if (null === e2)
                return new Date(NaN);
              if (O2.u(e2))
                return new Date();
              if (e2 instanceof Date)
                return new Date(e2);
              if ("string" == typeof e2 && !/Z$/i.test(e2)) {
                var r2 = e2.match(l2);
                if (r2) {
                  var i2 = r2[2] - 1 || 0, s3 = (r2[7] || "0").substring(0, 3);
                  return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3);
                }
              }
              return new Date(e2);
            }(t2), this.$x = t2.x || {}, this.init();
          }, m3.init = function() {
            var t2 = this.$d;
            this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
          }, m3.$utils = function() {
            return O2;
          }, m3.isValid = function() {
            return !(this.$d.toString() === $);
          }, m3.isSame = function(t2, e2) {
            var n2 = w2(t2);
            return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
          }, m3.isAfter = function(t2, e2) {
            return w2(t2) < this.startOf(e2);
          }, m3.isBefore = function(t2, e2) {
            return this.endOf(e2) < w2(t2);
          }, m3.$g = function(t2, e2, n2) {
            return O2.u(t2) ? this[e2] : this.set(n2, t2);
          }, m3.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m3.valueOf = function() {
            return this.$d.getTime();
          }, m3.startOf = function(t2, e2) {
            var n2 = this, r2 = !!O2.u(e2) || e2, h3 = O2.p(t2), $2 = function(t3, e3) {
              var i2 = O2.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
              return r2 ? i2 : i2.endOf(a2);
            }, l3 = function(t3, e3) {
              return O2.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
            }, y2 = this.$W, M4 = this.$M, m4 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
            switch (h3) {
              case c2:
                return r2 ? $2(1, 0) : $2(31, 11);
              case f2:
                return r2 ? $2(1, M4) : $2(0, M4 + 1);
              case o2:
                var v3 = this.$locale().weekStart || 0, D3 = (y2 < v3 ? y2 + 7 : y2) - v3;
                return $2(r2 ? m4 - D3 : m4 + (6 - D3), M4);
              case a2:
              case d2:
                return l3(g2 + "Hours", 0);
              case u2:
                return l3(g2 + "Minutes", 1);
              case s2:
                return l3(g2 + "Seconds", 2);
              case i:
                return l3(g2 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m3.endOf = function(t2) {
            return this.startOf(t2, false);
          }, m3.$set = function(t2, e2) {
            var n2, o3 = O2.p(t2), h3 = "set" + (this.$u ? "UTC" : ""), $2 = (n2 = {}, n2[a2] = h3 + "Date", n2[d2] = h3 + "Date", n2[f2] = h3 + "Month", n2[c2] = h3 + "FullYear", n2[u2] = h3 + "Hours", n2[s2] = h3 + "Minutes", n2[i] = h3 + "Seconds", n2[r] = h3 + "Milliseconds", n2)[o3], l3 = o3 === a2 ? this.$D + (e2 - this.$W) : e2;
            if (o3 === f2 || o3 === c2) {
              var y2 = this.clone().set(d2, 1);
              y2.$d[$2](l3), y2.init(), this.$d = y2.set(d2, Math.min(this.$D, y2.daysInMonth())).$d;
            } else
              $2 && this.$d[$2](l3);
            return this.init(), this;
          }, m3.set = function(t2, e2) {
            return this.clone().$set(t2, e2);
          }, m3.get = function(t2) {
            return this[O2.p(t2)]();
          }, m3.add = function(r2, h3) {
            var d3, $2 = this;
            r2 = Number(r2);
            var l3 = O2.p(h3), y2 = function(t2) {
              var e2 = w2($2);
              return O2.w(e2.date(e2.date() + Math.round(t2 * r2)), $2);
            };
            if (l3 === f2)
              return this.set(f2, this.$M + r2);
            if (l3 === c2)
              return this.set(c2, this.$y + r2);
            if (l3 === a2)
              return y2(1);
            if (l3 === o2)
              return y2(7);
            var M4 = (d3 = {}, d3[s2] = e, d3[u2] = n, d3[i] = t, d3)[l3] || 1, m4 = this.$d.getTime() + r2 * M4;
            return O2.w(m4, this);
          }, m3.subtract = function(t2, e2) {
            return this.add(-1 * t2, e2);
          }, m3.format = function(t2) {
            var e2 = this, n2 = this.$locale();
            if (!this.isValid())
              return n2.invalidDate || $;
            var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n2.weekdays, f3 = n2.months, h3 = function(t3, n3, i3, s4) {
              return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s4);
            }, c3 = function(t3) {
              return O2.s(s3 % 12 || 12, t3, "0");
            }, d3 = n2.meridiem || function(t3, e3, n3) {
              var r3 = t3 < 12 ? "AM" : "PM";
              return n3 ? r3.toLowerCase() : r3;
            }, l3 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O2.s(a3 + 1, 2, "0"), MMM: h3(n2.monthsShort, a3, f3, 3), MMMM: h3(f3, a3), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n2.weekdaysMin, this.$W, o3, 2), ddd: h3(n2.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O2.s(s3, 2, "0"), h: c3(1), hh: c3(2), a: d3(s3, u3, true), A: d3(s3, u3, false), m: String(u3), mm: O2.s(u3, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i2 };
            return r2.replace(y, function(t3, e3) {
              return e3 || l3[t3] || i2.replace(":", "");
            });
          }, m3.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m3.diff = function(r2, d3, $2) {
            var l3, y2 = O2.p(d3), M4 = w2(r2), m4 = (M4.utcOffset() - this.utcOffset()) * e, g2 = this - M4, v3 = O2.m(this, M4);
            return v3 = (l3 = {}, l3[c2] = v3 / 12, l3[f2] = v3, l3[h2] = v3 / 3, l3[o2] = (g2 - m4) / 6048e5, l3[a2] = (g2 - m4) / 864e5, l3[u2] = g2 / n, l3[s2] = g2 / e, l3[i] = g2 / t, l3)[y2] || g2, $2 ? v3 : O2.a(v3);
          }, m3.daysInMonth = function() {
            return this.endOf(f2).$D;
          }, m3.$locale = function() {
            return D2[this.$L];
          }, m3.locale = function(t2, e2) {
            if (!t2)
              return this.$L;
            var n2 = this.clone(), r2 = S2(t2, e2, true);
            return r2 && (n2.$L = r2), n2;
          }, m3.clone = function() {
            return O2.w(this.$d, this);
          }, m3.toDate = function() {
            return new Date(this.valueOf());
          }, m3.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m3.toISOString = function() {
            return this.$d.toISOString();
          }, m3.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), T2 = _2.prototype;
        return w2.prototype = T2, [["$ms", r], ["$s", i], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", f2], ["$y", c2], ["$D", d2]].forEach(function(t2) {
          T2[t2[1]] = function(e2) {
            return this.$g(e2, t2[0], t2[1]);
          };
        }), w2.extend = function(t2, e2) {
          return t2.$i || (t2(e2, _2, w2), t2.$i = true), w2;
        }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t2) {
          return w2(1e3 * t2);
        }, w2.en = D2[v2], w2.Ls = D2, w2.p = {}, w2;
      });
    })(dayjs_min);
    const dayjs = dayjs_min.exports;
    var localeData$1 = { exports: {} };
    (function(module2, exports2) {
      !function(n, e) {
        module2.exports = e();
      }(commonjsGlobal, function() {
        return function(n, e, t) {
          var r = e.prototype, o2 = function(n2) {
            return n2 && (n2.indexOf ? n2 : n2.s);
          }, u2 = function(n2, e2, t2, r2, u3) {
            var i2 = n2.name ? n2 : n2.$locale(), a3 = o2(i2[e2]), s3 = o2(i2[t2]), f2 = a3 || s3.map(function(n3) {
              return n3.slice(0, r2);
            });
            if (!u3)
              return f2;
            var d2 = i2.weekStart;
            return f2.map(function(n3, e3) {
              return f2[(e3 + (d2 || 0)) % 7];
            });
          }, i = function() {
            return t.Ls[t.locale()];
          }, a2 = function(n2, e2) {
            return n2.formats[e2] || function(n3) {
              return n3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n4, e3, t2) {
                return e3 || t2.slice(1);
              });
            }(n2.formats[e2.toUpperCase()]);
          }, s2 = function() {
            var n2 = this;
            return { months: function(e2) {
              return e2 ? e2.format("MMMM") : u2(n2, "months");
            }, monthsShort: function(e2) {
              return e2 ? e2.format("MMM") : u2(n2, "monthsShort", "months", 3);
            }, firstDayOfWeek: function() {
              return n2.$locale().weekStart || 0;
            }, weekdays: function(e2) {
              return e2 ? e2.format("dddd") : u2(n2, "weekdays");
            }, weekdaysMin: function(e2) {
              return e2 ? e2.format("dd") : u2(n2, "weekdaysMin", "weekdays", 2);
            }, weekdaysShort: function(e2) {
              return e2 ? e2.format("ddd") : u2(n2, "weekdaysShort", "weekdays", 3);
            }, longDateFormat: function(e2) {
              return a2(n2.$locale(), e2);
            }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
          };
          r.localeData = function() {
            return s2.bind(this)();
          }, t.localeData = function() {
            var n2 = i();
            return { firstDayOfWeek: function() {
              return n2.weekStart || 0;
            }, weekdays: function() {
              return t.weekdays();
            }, weekdaysShort: function() {
              return t.weekdaysShort();
            }, weekdaysMin: function() {
              return t.weekdaysMin();
            }, months: function() {
              return t.months();
            }, monthsShort: function() {
              return t.monthsShort();
            }, longDateFormat: function(e2) {
              return a2(n2, e2);
            }, meridiem: n2.meridiem, ordinal: n2.ordinal };
          }, t.months = function() {
            return u2(i(), "months");
          }, t.monthsShort = function() {
            return u2(i(), "monthsShort", "months", 3);
          }, t.weekdays = function(n2) {
            return u2(i(), "weekdays", null, null, n2);
          }, t.weekdaysShort = function(n2) {
            return u2(i(), "weekdaysShort", "weekdays", 3, n2);
          }, t.weekdaysMin = function(n2) {
            return u2(i(), "weekdaysMin", "weekdays", 2, n2);
          };
        };
      });
    })(localeData$1);
    const localeData = localeData$1.exports;
    var customParseFormat$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal, function() {
        var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o2 = {}, s2 = function(e2) {
          return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
        };
        var a2 = function(e2) {
          return function(t2) {
            this[e2] = +t2;
          };
        }, f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
          (this.zone || (this.zone = {})).offset = function(e3) {
            if (!e3)
              return 0;
            if ("Z" === e3)
              return 0;
            var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
            return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
          }(e2);
        }], h2 = function(e2) {
          var t2 = o2[e2];
          return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
        }, u2 = function(e2, t2) {
          var n2, r2 = o2.meridiem;
          if (r2) {
            for (var i2 = 1; i2 <= 24; i2 += 1)
              if (e2.indexOf(r2(i2, 0, t2)) > -1) {
                n2 = i2 > 12;
                break;
              }
          } else
            n2 = e2 === (t2 ? "pm" : "PM");
          return n2;
        }, d2 = { A: [i, function(e2) {
          this.afternoon = u2(e2, false);
        }], a: [i, function(e2) {
          this.afternoon = u2(e2, true);
        }], S: [/\d/, function(e2) {
          this.milliseconds = 100 * +e2;
        }], SS: [n, function(e2) {
          this.milliseconds = 10 * +e2;
        }], SSS: [/\d{3}/, function(e2) {
          this.milliseconds = +e2;
        }], s: [r, a2("seconds")], ss: [r, a2("seconds")], m: [r, a2("minutes")], mm: [r, a2("minutes")], H: [r, a2("hours")], h: [r, a2("hours")], HH: [r, a2("hours")], hh: [r, a2("hours")], D: [r, a2("day")], DD: [n, a2("day")], Do: [i, function(e2) {
          var t2 = o2.ordinal, n2 = e2.match(/\d+/);
          if (this.day = n2[0], t2)
            for (var r2 = 1; r2 <= 31; r2 += 1)
              t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
        }], M: [r, a2("month")], MM: [n, a2("month")], MMM: [i, function(e2) {
          var t2 = h2("months"), n2 = (h2("monthsShort") || t2.map(function(e3) {
            return e3.slice(0, 3);
          })).indexOf(e2) + 1;
          if (n2 < 1)
            throw new Error();
          this.month = n2 % 12 || n2;
        }], MMMM: [i, function(e2) {
          var t2 = h2("months").indexOf(e2) + 1;
          if (t2 < 1)
            throw new Error();
          this.month = t2 % 12 || t2;
        }], Y: [/[+-]?\d+/, a2("year")], YY: [n, function(e2) {
          this.year = s2(e2);
        }], YYYY: [/\d{4}/, a2("year")], Z: f2, ZZ: f2 };
        function c2(n2) {
          var r2, i2;
          r2 = n2, i2 = o2 && o2.formats;
          for (var s3 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
            var o3 = r3 && r3.toUpperCase();
            return n3 || i2[r3] || e[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
              return t3 || n4.slice(1);
            });
          })).match(t), a3 = s3.length, f3 = 0; f3 < a3; f3 += 1) {
            var h3 = s3[f3], u3 = d2[h3], c3 = u3 && u3[0], l2 = u3 && u3[1];
            s3[f3] = l2 ? { regex: c3, parser: l2 } : h3.replace(/^\[|\]$/g, "");
          }
          return function(e2) {
            for (var t2 = {}, n3 = 0, r3 = 0; n3 < a3; n3 += 1) {
              var i3 = s3[n3];
              if ("string" == typeof i3)
                r3 += i3.length;
              else {
                var o3 = i3.regex, f4 = i3.parser, h4 = e2.slice(r3), u4 = o3.exec(h4)[0];
                f4.call(t2, u4), e2 = e2.replace(u4, "");
              }
            }
            return function(e3) {
              var t3 = e3.afternoon;
              if (void 0 !== t3) {
                var n4 = e3.hours;
                t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
              }
            }(t2), t2;
          };
        }
        return function(e2, t2, n2) {
          n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (s2 = e2.parseTwoDigitYear);
          var r2 = t2.prototype, i2 = r2.parse;
          r2.parse = function(e3) {
            var t3 = e3.date, r3 = e3.utc, s3 = e3.args;
            this.$u = r3;
            var a3 = s3[1];
            if ("string" == typeof a3) {
              var f3 = true === s3[2], h3 = true === s3[3], u3 = f3 || h3, d3 = s3[2];
              h3 && (d3 = s3[2]), o2 = this.$locale(), !f3 && d3 && (o2 = n2.Ls[d3]), this.$d = function(e4, t4, n3) {
                try {
                  if (["x", "X"].indexOf(t4) > -1)
                    return new Date(("X" === t4 ? 1e3 : 1) * e4);
                  var r4 = c2(t4)(e4), i3 = r4.year, o3 = r4.month, s4 = r4.day, a4 = r4.hours, f4 = r4.minutes, h4 = r4.seconds, u4 = r4.milliseconds, d4 = r4.zone, l3 = new Date(), m3 = s4 || (i3 || o3 ? 1 : l3.getDate()), M3 = i3 || l3.getFullYear(), Y2 = 0;
                  i3 && !o3 || (Y2 = o3 > 0 ? o3 - 1 : l3.getMonth());
                  var p2 = a4 || 0, v2 = f4 || 0, D2 = h4 || 0, g = u4 || 0;
                  return d4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g + 60 * d4.offset * 1e3)) : n3 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g)) : new Date(M3, Y2, m3, p2, v2, D2, g);
                } catch (e5) {
                  return new Date("");
                }
              }(t3, a3, r3), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t3 != this.format(a3) && (this.$d = new Date("")), o2 = {};
            } else if (a3 instanceof Array)
              for (var l2 = a3.length, m2 = 1; m2 <= l2; m2 += 1) {
                s3[1] = a3[m2 - 1];
                var M2 = n2.apply(this, s3);
                if (M2.isValid()) {
                  this.$d = M2.$d, this.$L = M2.$L, this.init();
                  break;
                }
                m2 === l2 && (this.$d = new Date(""));
              }
            else
              i2.call(this, e3);
          };
        };
      });
    })(customParseFormat$1);
    const customParseFormat = customParseFormat$1.exports;
    const timeUnits = ["hours", "minutes", "seconds"];
    const DEFAULT_FORMATS_TIME = "HH:mm:ss";
    const DEFAULT_FORMATS_DATE = "YYYY-MM-DD";
    const DEFAULT_FORMATS_DATEPICKER = {
      date: DEFAULT_FORMATS_DATE,
      dates: DEFAULT_FORMATS_DATE,
      week: "gggg[w]ww",
      year: "YYYY",
      month: "YYYY-MM",
      datetime: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`,
      monthrange: "YYYY-MM",
      daterange: DEFAULT_FORMATS_DATE,
      datetimerange: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`
    };
    const buildTimeList = (value, bound) => {
      return [
        value > 0 ? value - 1 : void 0,
        value,
        value < bound ? value + 1 : void 0
      ];
    };
    const rangeArr = (n) => Array.from(Array.from({ length: n }).keys());
    const extractDateFormat = (format2) => {
      return format2.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim();
    };
    const extractTimeFormat = (format2) => {
      return format2.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim();
    };
    const dateEquals = function(a2, b2) {
      const aIsDate = isDate$2(a2);
      const bIsDate = isDate$2(b2);
      if (aIsDate && bIsDate) {
        return a2.getTime() === b2.getTime();
      }
      if (!aIsDate && !bIsDate) {
        return a2 === b2;
      }
      return false;
    };
    const valueEquals = function(a2, b2) {
      const aIsArray = isArray$4(a2);
      const bIsArray = isArray$4(b2);
      if (aIsArray && bIsArray) {
        if (a2.length !== b2.length) {
          return false;
        }
        return a2.every((item, index2) => dateEquals(item, b2[index2]));
      }
      if (!aIsArray && !bIsArray) {
        return dateEquals(a2, b2);
      }
      return false;
    };
    const parseDate = function(date2, format2, lang) {
      const day = isEmpty(format2) || format2 === "x" ? dayjs(date2).locale(lang) : dayjs(date2, format2).locale(lang);
      return day.isValid() ? day : void 0;
    };
    const formatter = function(date2, format2, lang) {
      if (isEmpty(format2))
        return date2;
      if (format2 === "x")
        return +date2;
      return dayjs(date2).locale(lang).format(format2);
    };
    const makeList = (total2, method2) => {
      var _a2;
      const arr = [];
      const disabledArr = method2 == null ? void 0 : method2();
      for (let i = 0; i < total2; i++) {
        arr.push((_a2 = disabledArr == null ? void 0 : disabledArr.includes(i)) != null ? _a2 : false);
      }
      return arr;
    };
    const disabledTimeListsProps = buildProps({
      disabledHours: {
        type: definePropType(Function)
      },
      disabledMinutes: {
        type: definePropType(Function)
      },
      disabledSeconds: {
        type: definePropType(Function)
      }
    });
    const timePanelSharedProps = buildProps({
      visible: Boolean,
      actualVisible: {
        type: Boolean,
        default: void 0
      },
      format: {
        type: String,
        default: ""
      }
    });
    const timePickerDefaultProps = buildProps({
      id: {
        type: definePropType([Array, String])
      },
      name: {
        type: definePropType([Array, String]),
        default: ""
      },
      popperClass: {
        type: String,
        default: ""
      },
      format: String,
      valueFormat: String,
      type: {
        type: String,
        default: ""
      },
      clearable: {
        type: Boolean,
        default: true
      },
      clearIcon: {
        type: definePropType([String, Object]),
        default: circle_close_default
      },
      editable: {
        type: Boolean,
        default: true
      },
      prefixIcon: {
        type: definePropType([String, Object]),
        default: ""
      },
      size: useSizeProp,
      readonly: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      placeholder: {
        type: String,
        default: ""
      },
      popperOptions: {
        type: definePropType(Object),
        default: () => ({})
      },
      modelValue: {
        type: definePropType([Date, Array, String, Number]),
        default: ""
      },
      rangeSeparator: {
        type: String,
        default: "-"
      },
      startPlaceholder: String,
      endPlaceholder: String,
      defaultValue: {
        type: definePropType([Date, Array])
      },
      defaultTime: {
        type: definePropType([Date, Array])
      },
      isRange: {
        type: Boolean,
        default: false
      },
      ...disabledTimeListsProps,
      disabledDate: {
        type: Function
      },
      cellClassName: {
        type: Function
      },
      shortcuts: {
        type: Array,
        default: () => []
      },
      arrowControl: {
        type: Boolean,
        default: false
      },
      label: {
        type: String,
        default: void 0
      },
      tabindex: {
        type: definePropType([String, Number]),
        default: 0
      },
      validateEvent: {
        type: Boolean,
        default: true
      },
      unlinkPanels: Boolean
    });
    const _hoisted_1$$ = ["id", "name", "placeholder", "value", "disabled", "readonly"];
    const _hoisted_2$F = ["id", "name", "placeholder", "value", "disabled", "readonly"];
    const __default__$19 = {
      name: "Picker"
    };
    const _sfc_main$1X = /* @__PURE__ */ defineComponent({
      ...__default__$19,
      props: timePickerDefaultProps,
      emits: [
        "update:modelValue",
        "change",
        "focus",
        "blur",
        "calendar-change",
        "panel-change",
        "visible-change",
        "keydown"
      ],
      setup(__props, { expose, emit }) {
        const props = __props;
        const { lang } = useLocale();
        const nsDate = useNamespace("date");
        const nsInput = useNamespace("input");
        const nsRange = useNamespace("range");
        const { form, formItem } = useFormItem();
        const elPopperOptions = inject("ElPopperOptions", {});
        const refPopper = ref();
        const inputRef = ref();
        const pickerVisible = ref(false);
        const pickerActualVisible = ref(false);
        const valueOnOpen = ref(null);
        let hasJustTabExitedInput = false;
        let ignoreFocusEvent = false;
        watch(pickerVisible, (val) => {
          if (!val) {
            userInput.value = null;
            nextTick(() => {
              emitChange(props.modelValue);
            });
          } else {
            valueOnOpen.value = props.modelValue;
          }
        });
        const emitChange = (val, isClear) => {
          if (isClear || !valueEquals(val, valueOnOpen.value)) {
            emit("change", val);
            props.validateEvent && (formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn()));
          }
        };
        const emitInput = (input) => {
          if (!valueEquals(props.modelValue, input)) {
            let formatted;
            if (isArray$4(input)) {
              formatted = input.map((item) => formatter(item, props.valueFormat, lang.value));
            } else if (input) {
              formatted = formatter(input, props.valueFormat, lang.value);
            }
            emit("update:modelValue", input ? formatted : input, lang.value);
          }
        };
        const emitKeydown = (e) => {
          emit("keydown", e);
        };
        const refInput = computed(() => {
          if (inputRef.value) {
            const _r = isRangeInput.value ? inputRef.value : inputRef.value.$el;
            return Array.from(_r.querySelectorAll("input"));
          }
          return [];
        });
        const setSelectionRange = (start, end2, pos) => {
          const _inputs = refInput.value;
          if (!_inputs.length)
            return;
          if (!pos || pos === "min") {
            _inputs[0].setSelectionRange(start, end2);
            _inputs[0].focus();
          } else if (pos === "max") {
            _inputs[1].setSelectionRange(start, end2);
            _inputs[1].focus();
          }
        };
        const focusOnInputBox = () => {
          focus(true, true);
          nextTick(() => {
            ignoreFocusEvent = false;
          });
        };
        const onPick = (date2 = "", visible = false) => {
          if (!visible) {
            focusOnInputBox();
          }
          pickerVisible.value = visible;
          let result;
          if (isArray$4(date2)) {
            result = date2.map((_2) => _2.toDate());
          } else {
            result = date2 ? date2.toDate() : date2;
          }
          userInput.value = null;
          emitInput(result);
        };
        const onBeforeShow = () => {
          pickerActualVisible.value = true;
        };
        const onShow = () => {
          emit("visible-change", true);
        };
        const onKeydownPopperContent = (event) => {
          if ((event == null ? void 0 : event.key) === EVENT_CODE.esc) {
            focus(true, true);
          }
        };
        const onHide = () => {
          pickerActualVisible.value = false;
          ignoreFocusEvent = false;
          emit("visible-change", false);
        };
        const handleOpen = () => {
          pickerVisible.value = true;
        };
        const handleClose = () => {
          pickerVisible.value = false;
        };
        const focus = (focusStartInput = true, isIgnoreFocusEvent = false) => {
          ignoreFocusEvent = isIgnoreFocusEvent;
          const [leftInput, rightInput] = unref(refInput);
          let input = leftInput;
          if (!focusStartInput && isRangeInput.value) {
            input = rightInput;
          }
          if (input) {
            input.focus();
          }
        };
        const handleFocusInput = (e) => {
          if (props.readonly || pickerDisabled.value || pickerVisible.value || ignoreFocusEvent) {
            return;
          }
          pickerVisible.value = true;
          emit("focus", e);
        };
        let currentHandleBlurDeferCallback = void 0;
        const handleBlurInput = (e) => {
          const handleBlurDefer = async () => {
            setTimeout(() => {
              var _a2;
              if (currentHandleBlurDeferCallback === handleBlurDefer) {
                if (!(((_a2 = refPopper.value) == null ? void 0 : _a2.isFocusInsideContent()) && !hasJustTabExitedInput) && refInput.value.filter((input) => {
                  return input.contains(document.activeElement);
                }).length === 0) {
                  handleChange();
                  pickerVisible.value = false;
                  emit("blur", e);
                  props.validateEvent && (formItem == null ? void 0 : formItem.validate("blur").catch((err) => debugWarn()));
                }
                hasJustTabExitedInput = false;
              }
            }, 0);
          };
          currentHandleBlurDeferCallback = handleBlurDefer;
          handleBlurDefer();
        };
        const pickerDisabled = computed(() => {
          return props.disabled || (form == null ? void 0 : form.disabled);
        });
        const parsedValue2 = computed(() => {
          let dayOrDays;
          if (valueIsEmpty.value) {
            if (pickerOptions.value.getDefaultValue) {
              dayOrDays = pickerOptions.value.getDefaultValue();
            }
          } else {
            if (isArray$4(props.modelValue)) {
              dayOrDays = props.modelValue.map((d2) => parseDate(d2, props.valueFormat, lang.value));
            } else {
              dayOrDays = parseDate(props.modelValue, props.valueFormat, lang.value);
            }
          }
          if (pickerOptions.value.getRangeAvailableTime) {
            const availableResult = pickerOptions.value.getRangeAvailableTime(dayOrDays);
            if (!isEqual$1(availableResult, dayOrDays)) {
              dayOrDays = availableResult;
              emitInput(isArray$4(dayOrDays) ? dayOrDays.map((_2) => _2.toDate()) : dayOrDays.toDate());
            }
          }
          if (isArray$4(dayOrDays) && dayOrDays.some((day) => !day)) {
            dayOrDays = [];
          }
          return dayOrDays;
        });
        const displayValue = computed(() => {
          if (!pickerOptions.value.panelReady)
            return "";
          const formattedValue = formatDayjsToString(parsedValue2.value);
          if (isArray$4(userInput.value)) {
            return [
              userInput.value[0] || formattedValue && formattedValue[0] || "",
              userInput.value[1] || formattedValue && formattedValue[1] || ""
            ];
          } else if (userInput.value !== null) {
            return userInput.value;
          }
          if (!isTimePicker.value && valueIsEmpty.value)
            return "";
          if (!pickerVisible.value && valueIsEmpty.value)
            return "";
          if (formattedValue) {
            return isDatesPicker.value ? formattedValue.join(", ") : formattedValue;
          }
          return "";
        });
        const isTimeLikePicker = computed(() => props.type.includes("time"));
        const isTimePicker = computed(() => props.type.startsWith("time"));
        const isDatesPicker = computed(() => props.type === "dates");
        const triggerIcon = computed(() => props.prefixIcon || (isTimeLikePicker.value ? clock_default : calendar_default));
        const showClose = ref(false);
        const onClearIconClick = (event) => {
          if (props.readonly || pickerDisabled.value)
            return;
          if (showClose.value) {
            event.stopPropagation();
            focusOnInputBox();
            emitInput(null);
            emitChange(null, true);
            showClose.value = false;
            pickerVisible.value = false;
            pickerOptions.value.handleClear && pickerOptions.value.handleClear();
          }
        };
        const valueIsEmpty = computed(() => {
          const { modelValue } = props;
          return !modelValue || isArray$4(modelValue) && !modelValue.filter(Boolean).length;
        });
        const onMouseDownInput = async (event) => {
          var _a2;
          if (props.readonly || pickerDisabled.value)
            return;
          if (((_a2 = event.target) == null ? void 0 : _a2.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
            pickerVisible.value = true;
          }
        };
        const onMouseEnter = () => {
          if (props.readonly || pickerDisabled.value)
            return;
          if (!valueIsEmpty.value && props.clearable) {
            showClose.value = true;
          }
        };
        const onMouseLeave = () => {
          showClose.value = false;
        };
        const onTouchStartInput = (event) => {
          var _a2;
          if (((_a2 = event.touches[0].target) == null ? void 0 : _a2.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
            pickerVisible.value = true;
          }
        };
        const isRangeInput = computed(() => {
          return props.type.includes("range");
        });
        const pickerSize = useSize();
        const popperEl = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = unref(refPopper)) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
        });
        const actualInputRef = computed(() => {
          var _a2;
          if (unref(isRangeInput)) {
            return unref(inputRef);
          }
          return (_a2 = unref(inputRef)) == null ? void 0 : _a2.$el;
        });
        onClickOutside(actualInputRef, (e) => {
          const unrefedPopperEl = unref(popperEl);
          const inputEl = unref(actualInputRef);
          if (unrefedPopperEl && (e.target === unrefedPopperEl || e.composedPath().includes(unrefedPopperEl)) || e.target === inputEl || e.composedPath().includes(inputEl))
            return;
          pickerVisible.value = false;
        });
        const userInput = ref(null);
        const handleChange = () => {
          if (userInput.value) {
            const value = parseUserInputToDayjs(displayValue.value);
            if (value) {
              if (isValidValue2(value)) {
                emitInput(isArray$4(value) ? value.map((_2) => _2.toDate()) : value.toDate());
                userInput.value = null;
              }
            }
          }
          if (userInput.value === "") {
            emitInput(null);
            emitChange(null);
            userInput.value = null;
          }
        };
        const parseUserInputToDayjs = (value) => {
          if (!value)
            return null;
          return pickerOptions.value.parseUserInput(value);
        };
        const formatDayjsToString = (value) => {
          if (!value)
            return null;
          return pickerOptions.value.formatToString(value);
        };
        const isValidValue2 = (value) => {
          return pickerOptions.value.isValidValue(value);
        };
        const handleKeydownInput = async (event) => {
          if (props.readonly || pickerDisabled.value)
            return;
          const { code: code2 } = event;
          emitKeydown(event);
          if (code2 === EVENT_CODE.esc) {
            if (pickerVisible.value === true) {
              pickerVisible.value = false;
              event.preventDefault();
              event.stopPropagation();
            }
            return;
          }
          if (code2 === EVENT_CODE.down) {
            if (pickerOptions.value.handleFocusPicker) {
              event.preventDefault();
              event.stopPropagation();
            }
            if (pickerVisible.value === false) {
              pickerVisible.value = true;
              await nextTick();
            }
            if (pickerOptions.value.handleFocusPicker) {
              pickerOptions.value.handleFocusPicker();
              return;
            }
          }
          if (code2 === EVENT_CODE.tab) {
            hasJustTabExitedInput = true;
            return;
          }
          if (code2 === EVENT_CODE.enter || code2 === EVENT_CODE.numpadEnter) {
            if (userInput.value === null || userInput.value === "" || isValidValue2(parseUserInputToDayjs(displayValue.value))) {
              handleChange();
              pickerVisible.value = false;
            }
            event.stopPropagation();
            return;
          }
          if (userInput.value) {
            event.stopPropagation();
            return;
          }
          if (pickerOptions.value.handleKeydownInput) {
            pickerOptions.value.handleKeydownInput(event);
          }
        };
        const onUserInput = (e) => {
          userInput.value = e;
          if (!pickerVisible.value) {
            pickerVisible.value = true;
          }
        };
        const handleStartInput = (event) => {
          const target = event.target;
          if (userInput.value) {
            userInput.value = [target.value, userInput.value[1]];
          } else {
            userInput.value = [target.value, null];
          }
        };
        const handleEndInput = (event) => {
          const target = event.target;
          if (userInput.value) {
            userInput.value = [userInput.value[0], target.value];
          } else {
            userInput.value = [null, target.value];
          }
        };
        const handleStartChange = () => {
          var _a2;
          const values = userInput.value;
          const value = parseUserInputToDayjs(values && values[0]);
          const parsedVal = unref(parsedValue2);
          if (value && value.isValid()) {
            userInput.value = [
              formatDayjsToString(value),
              ((_a2 = displayValue.value) == null ? void 0 : _a2[1]) || null
            ];
            const newValue = [value, parsedVal && (parsedVal[1] || null)];
            if (isValidValue2(newValue)) {
              emitInput(newValue);
              userInput.value = null;
            }
          }
        };
        const handleEndChange = () => {
          var _a2;
          const values = unref(userInput);
          const value = parseUserInputToDayjs(values && values[1]);
          const parsedVal = unref(parsedValue2);
          if (value && value.isValid()) {
            userInput.value = [
              ((_a2 = unref(displayValue)) == null ? void 0 : _a2[0]) || null,
              formatDayjsToString(value)
            ];
            const newValue = [parsedVal && parsedVal[0], value];
            if (isValidValue2(newValue)) {
              emitInput(newValue);
              userInput.value = null;
            }
          }
        };
        const pickerOptions = ref({});
        const onSetPickerOption = (e) => {
          pickerOptions.value[e[0]] = e[1];
          pickerOptions.value.panelReady = true;
        };
        const onCalendarChange = (e) => {
          emit("calendar-change", e);
        };
        const onPanelChange = (value, mode, view) => {
          emit("panel-change", value, mode, view);
        };
        provide("EP_PICKER_BASE", {
          props
        });
        expose({
          focus,
          handleFocusInput,
          handleBlurInput,
          handleOpen,
          handleClose,
          onPick
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElTooltip), mergeProps({
            ref_key: "refPopper",
            ref: refPopper,
            visible: pickerVisible.value,
            effect: "light",
            pure: "",
            trigger: "click"
          }, _ctx.$attrs, {
            role: "dialog",
            teleported: "",
            transition: `${unref(nsDate).namespace.value}-zoom-in-top`,
            "popper-class": [`${unref(nsDate).namespace.value}-picker__popper`, _ctx.popperClass],
            "popper-options": unref(elPopperOptions),
            "fallback-placements": ["bottom", "top", "right", "left"],
            "gpu-acceleration": false,
            "stop-popper-mouse-event": false,
            "hide-after": 0,
            persistent: "",
            onBeforeShow,
            onShow,
            onHide
          }), {
            default: withCtx(() => [
              !unref(isRangeInput) ? (openBlock(), createBlock(unref(ElInput), {
                key: 0,
                id: _ctx.id,
                ref_key: "inputRef",
                ref: inputRef,
                "container-role": "combobox",
                "model-value": unref(displayValue),
                name: _ctx.name,
                size: unref(pickerSize),
                disabled: unref(pickerDisabled),
                placeholder: _ctx.placeholder,
                class: normalizeClass([unref(nsDate).b("editor"), unref(nsDate).bm("editor", _ctx.type), _ctx.$attrs.class]),
                style: normalizeStyle(_ctx.$attrs.style),
                readonly: !_ctx.editable || _ctx.readonly || unref(isDatesPicker) || _ctx.type === "week",
                label: _ctx.label,
                tabindex: _ctx.tabindex,
                "validate-event": false,
                onInput: onUserInput,
                onFocus: handleFocusInput,
                onBlur: handleBlurInput,
                onKeydown: handleKeydownInput,
                onChange: handleChange,
                onMousedown: onMouseDownInput,
                onMouseenter: onMouseEnter,
                onMouseleave: onMouseLeave,
                onTouchstart: onTouchStartInput,
                onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                }, ["stop"]))
              }, {
                prefix: withCtx(() => [
                  unref(triggerIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(nsInput).e("icon")),
                    onMousedown: withModifiers(onMouseDownInput, ["prevent"]),
                    onTouchstart: onTouchStartInput
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(triggerIcon))))
                    ]),
                    _: 1
                  }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true)
                ]),
                suffix: withCtx(() => [
                  showClose.value && _ctx.clearIcon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(`${unref(nsInput).e("icon")} clear-icon`),
                    onClick: withModifiers(onClearIconClick, ["stop"])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ]),
                _: 1
              }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "label", "tabindex", "onKeydown"])) : (openBlock(), createElementBlock("div", {
                key: 1,
                ref_key: "inputRef",
                ref: inputRef,
                class: normalizeClass([
                  unref(nsDate).b("editor"),
                  unref(nsDate).bm("editor", _ctx.type),
                  unref(nsInput).e("wrapper"),
                  unref(nsDate).is("disabled", unref(pickerDisabled)),
                  unref(nsDate).is("active", pickerVisible.value),
                  unref(nsRange).b("editor"),
                  unref(pickerSize) ? unref(nsRange).bm("editor", unref(pickerSize)) : "",
                  _ctx.$attrs.class
                ]),
                style: normalizeStyle(_ctx.$attrs.style),
                onClick: handleFocusInput,
                onMouseenter: onMouseEnter,
                onMouseleave: onMouseLeave,
                onTouchstart: onTouchStartInput,
                onKeydown: handleKeydownInput
              }, [
                unref(triggerIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass([unref(nsInput).e("icon"), unref(nsRange).e("icon")]),
                  onMousedown: withModifiers(onMouseDownInput, ["prevent"]),
                  onTouchstart: onTouchStartInput
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(triggerIcon))))
                  ]),
                  _: 1
                }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                createBaseVNode("input", {
                  id: _ctx.id && _ctx.id[0],
                  autocomplete: "off",
                  name: _ctx.name && _ctx.name[0],
                  placeholder: _ctx.startPlaceholder,
                  value: unref(displayValue) && unref(displayValue)[0],
                  disabled: unref(pickerDisabled),
                  readonly: !_ctx.editable || _ctx.readonly,
                  class: normalizeClass(unref(nsRange).b("input")),
                  onMousedown: onMouseDownInput,
                  onInput: handleStartInput,
                  onChange: handleStartChange,
                  onFocus: handleFocusInput,
                  onBlur: handleBlurInput
                }, null, 42, _hoisted_1$$),
                renderSlot(_ctx.$slots, "range-separator", {}, () => [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(nsRange).b("separator"))
                  }, toDisplayString$1(_ctx.rangeSeparator), 3)
                ]),
                createBaseVNode("input", {
                  id: _ctx.id && _ctx.id[1],
                  autocomplete: "off",
                  name: _ctx.name && _ctx.name[1],
                  placeholder: _ctx.endPlaceholder,
                  value: unref(displayValue) && unref(displayValue)[1],
                  disabled: unref(pickerDisabled),
                  readonly: !_ctx.editable || _ctx.readonly,
                  class: normalizeClass(unref(nsRange).b("input")),
                  onMousedown: onMouseDownInput,
                  onFocus: handleFocusInput,
                  onBlur: handleBlurInput,
                  onInput: handleEndInput,
                  onChange: handleEndChange
                }, null, 42, _hoisted_2$F),
                _ctx.clearIcon ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 1,
                  class: normalizeClass([
                    unref(nsInput).e("icon"),
                    unref(nsRange).e("close-icon"),
                    {
                      [unref(nsRange).e("close-icon--hidden")]: !showClose.value
                    }
                  ]),
                  onClick: onClearIconClick
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true)
              ], 38))
            ]),
            content: withCtx(() => [
              renderSlot(_ctx.$slots, "default", {
                visible: pickerVisible.value,
                actualVisible: pickerActualVisible.value,
                parsedValue: unref(parsedValue2),
                format: _ctx.format,
                unlinkPanels: _ctx.unlinkPanels,
                type: _ctx.type,
                defaultValue: _ctx.defaultValue,
                onPick,
                onSelectRange: setSelectionRange,
                onSetPickerOption,
                onCalendarChange,
                onPanelChange,
                onKeydown: onKeydownPopperContent,
                onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {
                }, ["stop"]))
              })
            ]),
            _: 3
          }, 16, ["visible", "transition", "popper-class", "popper-options"]);
        };
      }
    });
    var CommonPicker = /* @__PURE__ */ _export_sfc(_sfc_main$1X, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/common/picker.vue"]]);
    const panelTimePickerProps = buildProps({
      ...timePanelSharedProps,
      datetimeRole: String,
      parsedValue: {
        type: definePropType(Object)
      }
    });
    const useTimePanel = ({
      getAvailableHours,
      getAvailableMinutes,
      getAvailableSeconds
    }) => {
      const getAvailableTime = (date2, role, first, compareDate) => {
        const availableTimeGetters = {
          hour: getAvailableHours,
          minute: getAvailableMinutes,
          second: getAvailableSeconds
        };
        let result = date2;
        ["hour", "minute", "second"].forEach((type2) => {
          if (availableTimeGetters[type2]) {
            let availableTimeSlots;
            const method2 = availableTimeGetters[type2];
            switch (type2) {
              case "minute": {
                availableTimeSlots = method2(result.hour(), role, compareDate);
                break;
              }
              case "second": {
                availableTimeSlots = method2(result.hour(), result.minute(), role, compareDate);
                break;
              }
              default: {
                availableTimeSlots = method2(role, compareDate);
                break;
              }
            }
            if ((availableTimeSlots == null ? void 0 : availableTimeSlots.length) && !availableTimeSlots.includes(result[type2]())) {
              const pos = first ? 0 : availableTimeSlots.length - 1;
              result = result[type2](availableTimeSlots[pos]);
            }
          }
        });
        return result;
      };
      const timePickerOptions = {};
      const onSetOption = ([key, val]) => {
        timePickerOptions[key] = val;
      };
      return {
        timePickerOptions,
        getAvailableTime,
        onSetOption
      };
    };
    const makeAvailableArr = (disabledList) => {
      const trueOrNumber = (isDisabled, index2) => isDisabled || index2;
      const getNumber = (predicate) => predicate !== true;
      return disabledList.map(trueOrNumber).filter(getNumber);
    };
    const getTimeLists = (disabledHours, disabledMinutes, disabledSeconds) => {
      const getHoursList = (role, compare) => {
        return makeList(24, disabledHours && (() => disabledHours == null ? void 0 : disabledHours(role, compare)));
      };
      const getMinutesList = (hour, role, compare) => {
        return makeList(60, disabledMinutes && (() => disabledMinutes == null ? void 0 : disabledMinutes(hour, role, compare)));
      };
      const getSecondsList = (hour, minute, role, compare) => {
        return makeList(60, disabledSeconds && (() => disabledSeconds == null ? void 0 : disabledSeconds(hour, minute, role, compare)));
      };
      return {
        getHoursList,
        getMinutesList,
        getSecondsList
      };
    };
    const buildAvailableTimeSlotGetter = (disabledHours, disabledMinutes, disabledSeconds) => {
      const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(disabledHours, disabledMinutes, disabledSeconds);
      const getAvailableHours = (role, compare) => {
        return makeAvailableArr(getHoursList(role, compare));
      };
      const getAvailableMinutes = (hour, role, compare) => {
        return makeAvailableArr(getMinutesList(hour, role, compare));
      };
      const getAvailableSeconds = (hour, minute, role, compare) => {
        return makeAvailableArr(getSecondsList(hour, minute, role, compare));
      };
      return {
        getAvailableHours,
        getAvailableMinutes,
        getAvailableSeconds
      };
    };
    const useOldValue = (props) => {
      const oldValue = ref(props.parsedValue);
      watch(() => props.visible, (val) => {
        if (!val) {
          oldValue.value = props.parsedValue;
        }
      });
      return oldValue;
    };
    const nodeList = /* @__PURE__ */ new Map();
    let startClick;
    if (isClient) {
      document.addEventListener("mousedown", (e) => startClick = e);
      document.addEventListener("mouseup", (e) => {
        for (const handlers of nodeList.values()) {
          for (const { documentHandler } of handlers) {
            documentHandler(e, startClick);
          }
        }
      });
    }
    function createDocumentHandler(el, binding) {
      let excludes = [];
      if (Array.isArray(binding.arg)) {
        excludes = binding.arg;
      } else if (isElement$1(binding.arg)) {
        excludes.push(binding.arg);
      }
      return function(mouseup, mousedown) {
        const popperRef = binding.instance.popperRef;
        const mouseUpTarget = mouseup.target;
        const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
        const isBound = !binding || !binding.instance;
        const isTargetExists = !mouseUpTarget || !mouseDownTarget;
        const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
        const isSelf = el === mouseUpTarget;
        const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
        const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
        if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
          return;
        }
        binding.value(mouseup, mousedown);
      };
    }
    const ClickOutside = {
      beforeMount(el, binding) {
        if (!nodeList.has(el)) {
          nodeList.set(el, []);
        }
        nodeList.get(el).push({
          documentHandler: createDocumentHandler(el, binding),
          bindingFn: binding.value
        });
      },
      updated(el, binding) {
        if (!nodeList.has(el)) {
          nodeList.set(el, []);
        }
        const handlers = nodeList.get(el);
        const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
        const newHandler = {
          documentHandler: createDocumentHandler(el, binding),
          bindingFn: binding.value
        };
        if (oldHandlerIndex >= 0) {
          handlers.splice(oldHandlerIndex, 1, newHandler);
        } else {
          handlers.push(newHandler);
        }
      },
      unmounted(el) {
        nodeList.delete(el);
      }
    };
    const REPEAT_INTERVAL = 100;
    const REPEAT_DELAY = 600;
    const RepeatClick = {
      beforeMount(el, binding) {
        let interval = null;
        let delay = null;
        const handler = () => binding.value && binding.value();
        const clear2 = () => {
          if (delay) {
            clearTimeout(delay);
            delay = null;
          }
          if (interval) {
            clearInterval(interval);
            interval = null;
          }
        };
        el.addEventListener("mousedown", (e) => {
          if (e.button !== 0)
            return;
          handler();
          document.addEventListener("mouseup", clear2, { once: true });
          clear2();
          delay = setTimeout(() => {
            interval = setInterval(() => {
              handler();
            }, REPEAT_INTERVAL);
          }, REPEAT_DELAY);
        });
      }
    };
    const FOCUSABLE_CHILDREN = "_trap-focus-children";
    const FOCUS_STACK = [];
    const FOCUS_HANDLER = (e) => {
      if (FOCUS_STACK.length === 0)
        return;
      const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
      if (focusableElement.length > 0 && e.code === EVENT_CODE.tab) {
        if (focusableElement.length === 1) {
          e.preventDefault();
          if (document.activeElement !== focusableElement[0]) {
            focusableElement[0].focus();
          }
          return;
        }
        const goingBackward = e.shiftKey;
        const isFirst = e.target === focusableElement[0];
        const isLast = e.target === focusableElement[focusableElement.length - 1];
        if (isFirst && goingBackward) {
          e.preventDefault();
          focusableElement[focusableElement.length - 1].focus();
        }
        if (isLast && !goingBackward) {
          e.preventDefault();
          focusableElement[0].focus();
        }
      }
    };
    const TrapFocus = {
      beforeMount(el) {
        el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
        FOCUS_STACK.push(el);
        if (FOCUS_STACK.length <= 1) {
          document.addEventListener("keydown", FOCUS_HANDLER);
        }
      },
      updated(el) {
        nextTick(() => {
          el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
        });
      },
      unmounted() {
        FOCUS_STACK.shift();
        if (FOCUS_STACK.length === 0) {
          document.removeEventListener("keydown", FOCUS_HANDLER);
        }
      }
    };
    var v = false, o, f, s, u, d, N, l, p, m, w, D, x, E, M, F;
    function a() {
      if (!v) {
        v = true;
        var e = navigator.userAgent, n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), i = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
        if (x = /\b(iPhone|iP[ao]d)/.exec(e), E = /\b(iP[ao]d)/.exec(e), w = /Android/i.exec(e), M = /FBAN\/\w+;/i.exec(e), F = /Mobile/i.exec(e), D = !!/Win64/.exec(e), n) {
          o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
          var r = /(?:Trident\/(\d+.\d+))/.exec(e);
          N = r ? parseFloat(r[1]) + 4 : o, f = n[2] ? parseFloat(n[2]) : NaN, s = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
        } else
          o = f = s = d = u = NaN;
        if (i) {
          if (i[1]) {
            var t = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
            l = t ? parseFloat(t[1].replace("_", ".")) : true;
          } else
            l = false;
          p = !!i[2], m = !!i[3];
        } else
          l = p = m = false;
      }
    }
    var _ = { ie: function() {
      return a() || o;
    }, ieCompatibilityMode: function() {
      return a() || N > o;
    }, ie64: function() {
      return _.ie() && D;
    }, firefox: function() {
      return a() || f;
    }, opera: function() {
      return a() || s;
    }, webkit: function() {
      return a() || u;
    }, safari: function() {
      return _.webkit();
    }, chrome: function() {
      return a() || d;
    }, windows: function() {
      return a() || p;
    }, osx: function() {
      return a() || l;
    }, linux: function() {
      return a() || m;
    }, iphone: function() {
      return a() || x;
    }, mobile: function() {
      return a() || x || E || w || F;
    }, nativeApp: function() {
      return a() || M;
    }, android: function() {
      return a() || w;
    }, ipad: function() {
      return a() || E;
    } }, A = _;
    var c = !!(typeof window < "u" && window.document && window.document.createElement), U = { canUseDOM: c, canUseWorkers: typeof Worker < "u", canUseEventListeners: c && !!(window.addEventListener || window.attachEvent), canUseViewport: c && !!window.screen, isInWorker: !c }, h = U;
    var X;
    h.canUseDOM && (X = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true);
    function S(e, n) {
      if (!h.canUseDOM || n && !("addEventListener" in document))
        return false;
      var i = "on" + e, r = i in document;
      if (!r) {
        var t = document.createElement("div");
        t.setAttribute(i, "return;"), r = typeof t[i] == "function";
      }
      return !r && X && e === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
    }
    var b = S;
    var O = 10, I = 40, P = 800;
    function T(e) {
      var n = 0, i = 0, r = 0, t = 0;
      return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (n = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (n = i, i = 0), r = n * O, t = i * O, "deltaY" in e && (t = e.deltaY), "deltaX" in e && (r = e.deltaX), (r || t) && e.deltaMode && (e.deltaMode == 1 ? (r *= I, t *= I) : (r *= P, t *= P)), r && !n && (n = r < 1 ? -1 : 1), t && !i && (i = t < 1 ? -1 : 1), { spinX: n, spinY: i, pixelX: r, pixelY: t };
    }
    T.getEventType = function() {
      return A.firefox() ? "DOMMouseScroll" : b("wheel") ? "wheel" : "mousewheel";
    };
    var Y = T;
    /**
    * Checks if an event is supported in the current execution environment.
    *
    * NOTE: This will not work correctly for non-generic events such as `change`,
    * `reset`, `load`, `error`, and `select`.
    *
    * Borrows from Modernizr.
    *
    * @param {string} eventNameSuffix Event name, e.g. "click".
    * @param {?boolean} capture Check if the capture phase is supported.
    * @return {boolean} True if the event is supported.
    * @internal
    * @license Modernizr 3.0.0pre (Custom Build) | MIT
    */
    const mousewheel = function(element, callback) {
      if (element && element.addEventListener) {
        const fn2 = function(event) {
          const normalized = Y(event);
          callback && Reflect.apply(callback, this, [event, normalized]);
        };
        element.addEventListener("wheel", fn2, { passive: true });
      }
    };
    const Mousewheel = {
      beforeMount(el, binding) {
        mousewheel(el, binding.value);
      }
    };
    const basicTimeSpinnerProps = buildProps({
      role: {
        type: String,
        required: true
      },
      spinnerDate: {
        type: definePropType(Object),
        required: true
      },
      showSeconds: {
        type: Boolean,
        default: true
      },
      arrowControl: Boolean,
      amPmMode: {
        type: definePropType(String),
        default: ""
      },
      ...disabledTimeListsProps
    });
    const _hoisted_1$_ = ["onClick"];
    const _hoisted_2$E = ["onMouseenter"];
    const _sfc_main$1W = /* @__PURE__ */ defineComponent({
      __name: "basic-time-spinner",
      props: basicTimeSpinnerProps,
      emits: ["change", "select-range", "set-option"],
      setup(__props, { emit }) {
        const props = __props;
        const ns2 = useNamespace("time");
        const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(props.disabledHours, props.disabledMinutes, props.disabledSeconds);
        let isScrolling = false;
        const currentScrollbar = ref();
        const listHoursRef = ref();
        const listMinutesRef = ref();
        const listSecondsRef = ref();
        const listRefsMap = {
          hours: listHoursRef,
          minutes: listMinutesRef,
          seconds: listSecondsRef
        };
        const spinnerItems = computed(() => {
          return props.showSeconds ? timeUnits : timeUnits.slice(0, 2);
        });
        const timePartials = computed(() => {
          const { spinnerDate } = props;
          const hours = spinnerDate.hour();
          const minutes = spinnerDate.minute();
          const seconds = spinnerDate.second();
          return { hours, minutes, seconds };
        });
        const timeList = computed(() => {
          const { hours, minutes } = unref(timePartials);
          return {
            hours: getHoursList(props.role),
            minutes: getMinutesList(hours, props.role),
            seconds: getSecondsList(hours, minutes, props.role)
          };
        });
        const arrowControlTimeList = computed(() => {
          const { hours, minutes, seconds } = unref(timePartials);
          return {
            hours: buildTimeList(hours, 23),
            minutes: buildTimeList(minutes, 59),
            seconds: buildTimeList(seconds, 59)
          };
        });
        const debouncedResetScroll = debounce((type2) => {
          isScrolling = false;
          adjustCurrentSpinner(type2);
        }, 200);
        const getAmPmFlag = (hour) => {
          const shouldShowAmPm = !!props.amPmMode;
          if (!shouldShowAmPm)
            return "";
          const isCapital = props.amPmMode === "A";
          let content = hour < 12 ? " am" : " pm";
          if (isCapital)
            content = content.toUpperCase();
          return content;
        };
        const emitSelectRange = (type2) => {
          let range2;
          switch (type2) {
            case "hours":
              range2 = [0, 2];
              break;
            case "minutes":
              range2 = [3, 5];
              break;
            case "seconds":
              range2 = [6, 8];
              break;
          }
          const [left2, right2] = range2;
          emit("select-range", left2, right2);
          currentScrollbar.value = type2;
        };
        const adjustCurrentSpinner = (type2) => {
          adjustSpinner(type2, unref(timePartials)[type2]);
        };
        const adjustSpinners = () => {
          adjustCurrentSpinner("hours");
          adjustCurrentSpinner("minutes");
          adjustCurrentSpinner("seconds");
        };
        const getScrollbarElement = (el) => el.querySelector(`.${ns2.namespace.value}-scrollbar__wrap`);
        const adjustSpinner = (type2, value) => {
          if (props.arrowControl)
            return;
          const scrollbar = unref(listRefsMap[type2]);
          if (scrollbar && scrollbar.$el) {
            getScrollbarElement(scrollbar.$el).scrollTop = Math.max(0, value * typeItemHeight(type2));
          }
        };
        const typeItemHeight = (type2) => {
          const scrollbar = unref(listRefsMap[type2]);
          return (scrollbar == null ? void 0 : scrollbar.$el.querySelector("li").offsetHeight) || 0;
        };
        const onIncrement = () => {
          scrollDown(1);
        };
        const onDecrement = () => {
          scrollDown(-1);
        };
        const scrollDown = (step) => {
          if (!currentScrollbar.value) {
            emitSelectRange("hours");
          }
          const label = currentScrollbar.value;
          const now2 = unref(timePartials)[label];
          const total2 = currentScrollbar.value === "hours" ? 24 : 60;
          const next = findNextUnDisabled(label, now2, step, total2);
          modifyDateField(label, next);
          adjustSpinner(label, next);
          nextTick(() => emitSelectRange(label));
        };
        const findNextUnDisabled = (type2, now2, step, total2) => {
          let next = (now2 + step + total2) % total2;
          const list = unref(timeList)[type2];
          while (list[next] && next !== now2) {
            next = (next + step + total2) % total2;
          }
          return next;
        };
        const modifyDateField = (type2, value) => {
          const list = unref(timeList)[type2];
          const isDisabled = list[value];
          if (isDisabled)
            return;
          const { hours, minutes, seconds } = unref(timePartials);
          let changeTo;
          switch (type2) {
            case "hours":
              changeTo = props.spinnerDate.hour(value).minute(minutes).second(seconds);
              break;
            case "minutes":
              changeTo = props.spinnerDate.hour(hours).minute(value).second(seconds);
              break;
            case "seconds":
              changeTo = props.spinnerDate.hour(hours).minute(minutes).second(value);
              break;
          }
          emit("change", changeTo);
        };
        const handleClick = (type2, { value, disabled }) => {
          if (!disabled) {
            modifyDateField(type2, value);
            emitSelectRange(type2);
            adjustSpinner(type2, value);
          }
        };
        const handleScroll2 = (type2) => {
          isScrolling = true;
          debouncedResetScroll(type2);
          const value = Math.min(Math.round((getScrollbarElement(unref(listRefsMap[type2]).$el).scrollTop - (scrollBarHeight(type2) * 0.5 - 10) / typeItemHeight(type2) + 3) / typeItemHeight(type2)), type2 === "hours" ? 23 : 59);
          modifyDateField(type2, value);
        };
        const scrollBarHeight = (type2) => {
          return unref(listRefsMap[type2]).$el.offsetHeight;
        };
        const bindScrollEvent = () => {
          const bindFunction = (type2) => {
            const scrollbar = unref(listRefsMap[type2]);
            if (scrollbar && scrollbar.$el) {
              getScrollbarElement(scrollbar.$el).onscroll = () => {
                handleScroll2(type2);
              };
            }
          };
          bindFunction("hours");
          bindFunction("minutes");
          bindFunction("seconds");
        };
        onMounted(() => {
          nextTick(() => {
            !props.arrowControl && bindScrollEvent();
            adjustSpinners();
            if (props.role === "start")
              emitSelectRange("hours");
          });
        });
        const setRef2 = (scrollbar, type2) => {
          listRefsMap[type2].value = scrollbar;
        };
        emit("set-option", [`${props.role}_scrollDown`, scrollDown]);
        emit("set-option", [`${props.role}_emitSelectRange`, emitSelectRange]);
        watch(() => props.spinnerDate, () => {
          if (isScrolling)
            return;
          adjustSpinners();
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([unref(ns2).b("spinner"), { "has-seconds": _ctx.showSeconds }])
          }, [
            !_ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(spinnerItems), (item) => {
              return openBlock(), createBlock(unref(ElScrollbar), {
                key: item,
                ref_for: true,
                ref: (scollbar) => setRef2(scollbar, item),
                class: normalizeClass(unref(ns2).be("spinner", "wrapper")),
                "wrap-style": "max-height: inherit;",
                "view-class": unref(ns2).be("spinner", "list"),
                noresize: "",
                tag: "ul",
                onMouseenter: ($event) => emitSelectRange(item),
                onMousemove: ($event) => adjustCurrentSpinner(item)
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(timeList)[item], (disabled, key) => {
                    return openBlock(), createElementBlock("li", {
                      key,
                      class: normalizeClass([
                        unref(ns2).be("spinner", "item"),
                        unref(ns2).is("active", key === unref(timePartials)[item]),
                        unref(ns2).is("disabled", disabled)
                      ]),
                      onClick: ($event) => handleClick(item, { value: key, disabled })
                    }, [
                      item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        createTextVNode(toDisplayString$1(("0" + (_ctx.amPmMode ? key % 12 || 12 : key)).slice(-2)) + toDisplayString$1(getAmPmFlag(key)), 1)
                      ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        createTextVNode(toDisplayString$1(("0" + key).slice(-2)), 1)
                      ], 64))
                    ], 10, _hoisted_1$_);
                  }), 128))
                ]),
                _: 2
              }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]);
            }), 128)) : createCommentVNode("v-if", true),
            _ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(spinnerItems), (item) => {
              return openBlock(), createElementBlock("div", {
                key: item,
                class: normalizeClass([unref(ns2).be("spinner", "wrapper"), unref(ns2).is("arrow")]),
                onMouseenter: ($event) => emitSelectRange(item)
              }, [
                withDirectives((openBlock(), createBlock(unref(ElIcon), {
                  class: normalizeClass(["arrow-up", unref(ns2).be("spinner", "arrow")])
                }, {
                  default: withCtx(() => [
                    createVNode(unref(arrow_up_default))
                  ]),
                  _: 1
                }, 8, ["class"])), [
                  [unref(RepeatClick), onDecrement]
                ]),
                withDirectives((openBlock(), createBlock(unref(ElIcon), {
                  class: normalizeClass(["arrow-down", unref(ns2).be("spinner", "arrow")])
                }, {
                  default: withCtx(() => [
                    createVNode(unref(arrow_down_default))
                  ]),
                  _: 1
                }, 8, ["class"])), [
                  [unref(RepeatClick), onIncrement]
                ]),
                createBaseVNode("ul", {
                  class: normalizeClass(unref(ns2).be("spinner", "list"))
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(arrowControlTimeList)[item], (time, key) => {
                    return openBlock(), createElementBlock("li", {
                      key,
                      class: normalizeClass([
                        unref(ns2).be("spinner", "item"),
                        unref(ns2).is("active", time === unref(timePartials)[item]),
                        unref(ns2).is("disabled", unref(timeList)[item][time])
                      ])
                    }, [
                      typeof time === "number" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          createTextVNode(toDisplayString$1(("0" + (_ctx.amPmMode ? time % 12 || 12 : time)).slice(-2)) + toDisplayString$1(getAmPmFlag(time)), 1)
                        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                          createTextVNode(toDisplayString$1(("0" + time).slice(-2)), 1)
                        ], 64))
                      ], 64)) : createCommentVNode("v-if", true)
                    ], 2);
                  }), 128))
                ], 2)
              ], 42, _hoisted_2$E);
            }), 128)) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    });
    var TimeSpinner = /* @__PURE__ */ _export_sfc(_sfc_main$1W, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/basic-time-spinner.vue"]]);
    const _sfc_main$1V = /* @__PURE__ */ defineComponent({
      __name: "panel-time-pick",
      props: panelTimePickerProps,
      emits: ["pick", "select-range", "set-picker-option"],
      setup(__props, { emit }) {
        const props = __props;
        const pickerBase = inject("EP_PICKER_BASE");
        const {
          arrowControl,
          disabledHours,
          disabledMinutes,
          disabledSeconds,
          defaultValue
        } = pickerBase.props;
        const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = buildAvailableTimeSlotGetter(disabledHours, disabledMinutes, disabledSeconds);
        const ns2 = useNamespace("time");
        const { t, lang } = useLocale();
        const selectionRange = ref([0, 2]);
        const oldValue = useOldValue(props);
        const transitionName = computed(() => {
          return isUndefined$1(props.actualVisible) ? `${ns2.namespace.value}-zoom-in-top` : "";
        });
        const showSeconds = computed(() => {
          return props.format.includes("ss");
        });
        const amPmMode = computed(() => {
          if (props.format.includes("A"))
            return "A";
          if (props.format.includes("a"))
            return "a";
          return "";
        });
        const isValidValue2 = (_date) => {
          const parsedDate = dayjs(_date).locale(lang.value);
          const result = getRangeAvailableTime(parsedDate);
          return parsedDate.isSame(result);
        };
        const handleCancel = () => {
          emit("pick", oldValue.value, false);
        };
        const handleConfirm = (visible = false, first = false) => {
          if (first)
            return;
          emit("pick", props.parsedValue, visible);
        };
        const handleChange = (_date) => {
          if (!props.visible) {
            return;
          }
          const result = getRangeAvailableTime(_date).millisecond(0);
          emit("pick", result, true);
        };
        const setSelectionRange = (start, end2) => {
          emit("select-range", start, end2);
          selectionRange.value = [start, end2];
        };
        const changeSelectionRange = (step) => {
          const list = [0, 3].concat(showSeconds.value ? [6] : []);
          const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
          const index2 = list.indexOf(selectionRange.value[0]);
          const next = (index2 + step + list.length) % list.length;
          timePickerOptions["start_emitSelectRange"](mapping[next]);
        };
        const handleKeydown = (event) => {
          const code2 = event.code;
          const { left: left2, right: right2, up: up2, down: down2 } = EVENT_CODE;
          if ([left2, right2].includes(code2)) {
            const step = code2 === left2 ? -1 : 1;
            changeSelectionRange(step);
            event.preventDefault();
            return;
          }
          if ([up2, down2].includes(code2)) {
            const step = code2 === up2 ? -1 : 1;
            timePickerOptions["start_scrollDown"](step);
            event.preventDefault();
            return;
          }
        };
        const { timePickerOptions, onSetOption, getAvailableTime } = useTimePanel({
          getAvailableHours,
          getAvailableMinutes,
          getAvailableSeconds
        });
        const getRangeAvailableTime = (date2) => {
          return getAvailableTime(date2, props.datetimeRole || "", true);
        };
        const parseUserInput = (value) => {
          if (!value)
            return null;
          return dayjs(value, props.format).locale(lang.value);
        };
        const formatToString = (value) => {
          if (!value)
            return null;
          return value.format(props.format);
        };
        const getDefaultValue2 = () => {
          return dayjs(defaultValue).locale(lang.value);
        };
        emit("set-picker-option", ["isValidValue", isValidValue2]);
        emit("set-picker-option", ["formatToString", formatToString]);
        emit("set-picker-option", ["parseUserInput", parseUserInput]);
        emit("set-picker-option", ["handleKeydownInput", handleKeydown]);
        emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
        emit("set-picker-option", ["getDefaultValue", getDefaultValue2]);
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition, { name: unref(transitionName) }, {
            default: withCtx(() => [
              _ctx.actualVisible || _ctx.visible ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns2).b("panel"))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass([unref(ns2).be("panel", "content"), { "has-seconds": unref(showSeconds) }])
                }, [
                  createVNode(TimeSpinner, {
                    ref: "spinner",
                    role: _ctx.datetimeRole || "start",
                    "arrow-control": unref(arrowControl),
                    "show-seconds": unref(showSeconds),
                    "am-pm-mode": unref(amPmMode),
                    "spinner-date": _ctx.parsedValue,
                    "disabled-hours": unref(disabledHours),
                    "disabled-minutes": unref(disabledMinutes),
                    "disabled-seconds": unref(disabledSeconds),
                    onChange: handleChange,
                    onSetOption: unref(onSetOption),
                    onSelectRange: setSelectionRange
                  }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])
                ], 2),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns2).be("panel", "footer"))
                }, [
                  createBaseVNode("button", {
                    type: "button",
                    class: normalizeClass([unref(ns2).be("panel", "btn"), "cancel"]),
                    onClick: handleCancel
                  }, toDisplayString$1(unref(t)("el.datepicker.cancel")), 3),
                  createBaseVNode("button", {
                    type: "button",
                    class: normalizeClass([unref(ns2).be("panel", "btn"), "confirm"]),
                    onClick: _cache[0] || (_cache[0] = ($event) => handleConfirm())
                  }, toDisplayString$1(unref(t)("el.datepicker.confirm")), 3)
                ], 2)
              ], 2)) : createCommentVNode("v-if", true)
            ]),
            _: 1
          }, 8, ["name"]);
        };
      }
    });
    var TimePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1V, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-pick.vue"]]);
    const panelTimeRangeProps = buildProps({
      ...timePanelSharedProps,
      parsedValue: {
        type: definePropType(Array)
      }
    });
    const _hoisted_1$Z = ["disabled"];
    const _sfc_main$1U = /* @__PURE__ */ defineComponent({
      __name: "panel-time-range",
      props: panelTimeRangeProps,
      emits: ["pick", "select-range", "set-picker-option"],
      setup(__props, { emit }) {
        const props = __props;
        const makeSelectRange = (start, end2) => {
          const result = [];
          for (let i = start; i <= end2; i++) {
            result.push(i);
          }
          return result;
        };
        const { t, lang } = useLocale();
        const nsTime = useNamespace("time");
        const nsPicker = useNamespace("picker");
        const pickerBase = inject("EP_PICKER_BASE");
        const {
          arrowControl,
          disabledHours,
          disabledMinutes,
          disabledSeconds,
          defaultValue
        } = pickerBase.props;
        const startTime = computed(() => props.parsedValue[0]);
        const endTime = computed(() => props.parsedValue[1]);
        const oldValue = useOldValue(props);
        const handleCancel = () => {
          emit("pick", oldValue.value, false);
        };
        const showSeconds = computed(() => {
          return props.format.includes("ss");
        });
        const amPmMode = computed(() => {
          if (props.format.includes("A"))
            return "A";
          if (props.format.includes("a"))
            return "a";
          return "";
        });
        const handleConfirm = (visible = false) => {
          emit("pick", [startTime.value, endTime.value], visible);
        };
        const handleMinChange = (date2) => {
          handleChange(date2.millisecond(0), endTime.value);
        };
        const handleMaxChange = (date2) => {
          handleChange(startTime.value, date2.millisecond(0));
        };
        const isValidValue2 = (_date) => {
          const parsedDate = _date.map((_2) => dayjs(_2).locale(lang.value));
          const result = getRangeAvailableTime(parsedDate);
          return parsedDate[0].isSame(result[0]) && parsedDate[1].isSame(result[1]);
        };
        const handleChange = (start, end2) => {
          emit("pick", [start, end2], true);
        };
        const btnConfirmDisabled = computed(() => {
          return startTime.value > endTime.value;
        });
        const selectionRange = ref([0, 2]);
        const setMinSelectionRange = (start, end2) => {
          emit("select-range", start, end2, "min");
          selectionRange.value = [start, end2];
        };
        const offset2 = computed(() => showSeconds.value ? 11 : 8);
        const setMaxSelectionRange = (start, end2) => {
          emit("select-range", start, end2, "max");
          const _offset = unref(offset2);
          selectionRange.value = [start + _offset, end2 + _offset];
        };
        const changeSelectionRange = (step) => {
          const list = showSeconds.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
          const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
          const index2 = list.indexOf(selectionRange.value[0]);
          const next = (index2 + step + list.length) % list.length;
          const half = list.length / 2;
          if (next < half) {
            timePickerOptions["start_emitSelectRange"](mapping[next]);
          } else {
            timePickerOptions["end_emitSelectRange"](mapping[next - half]);
          }
        };
        const handleKeydown = (event) => {
          const code2 = event.code;
          const { left: left2, right: right2, up: up2, down: down2 } = EVENT_CODE;
          if ([left2, right2].includes(code2)) {
            const step = code2 === left2 ? -1 : 1;
            changeSelectionRange(step);
            event.preventDefault();
            return;
          }
          if ([up2, down2].includes(code2)) {
            const step = code2 === up2 ? -1 : 1;
            const role = selectionRange.value[0] < offset2.value ? "start" : "end";
            timePickerOptions[`${role}_scrollDown`](step);
            event.preventDefault();
            return;
          }
        };
        const disabledHours_ = (role, compare) => {
          const defaultDisable = disabledHours ? disabledHours(role) : [];
          const isStart = role === "start";
          const compareDate = compare || (isStart ? endTime.value : startTime.value);
          const compareHour = compareDate.hour();
          const nextDisable = isStart ? makeSelectRange(compareHour + 1, 23) : makeSelectRange(0, compareHour - 1);
          return union$1(defaultDisable, nextDisable);
        };
        const disabledMinutes_ = (hour, role, compare) => {
          const defaultDisable = disabledMinutes ? disabledMinutes(hour, role) : [];
          const isStart = role === "start";
          const compareDate = compare || (isStart ? endTime.value : startTime.value);
          const compareHour = compareDate.hour();
          if (hour !== compareHour) {
            return defaultDisable;
          }
          const compareMinute = compareDate.minute();
          const nextDisable = isStart ? makeSelectRange(compareMinute + 1, 59) : makeSelectRange(0, compareMinute - 1);
          return union$1(defaultDisable, nextDisable);
        };
        const disabledSeconds_ = (hour, minute, role, compare) => {
          const defaultDisable = disabledSeconds ? disabledSeconds(hour, minute, role) : [];
          const isStart = role === "start";
          const compareDate = compare || (isStart ? endTime.value : startTime.value);
          const compareHour = compareDate.hour();
          const compareMinute = compareDate.minute();
          if (hour !== compareHour || minute !== compareMinute) {
            return defaultDisable;
          }
          const compareSecond = compareDate.second();
          const nextDisable = isStart ? makeSelectRange(compareSecond + 1, 59) : makeSelectRange(0, compareSecond - 1);
          return union$1(defaultDisable, nextDisable);
        };
        const getRangeAvailableTime = ([start, end2]) => {
          return [
            getAvailableTime(start, "start", true, end2),
            getAvailableTime(end2, "end", false, start)
          ];
        };
        const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = buildAvailableTimeSlotGetter(disabledHours_, disabledMinutes_, disabledSeconds_);
        const {
          timePickerOptions,
          getAvailableTime,
          onSetOption
        } = useTimePanel({
          getAvailableHours,
          getAvailableMinutes,
          getAvailableSeconds
        });
        const parseUserInput = (days) => {
          if (!days)
            return null;
          if (isArray$4(days)) {
            return days.map((d2) => dayjs(d2, props.format).locale(lang.value));
          }
          return dayjs(days, props.format).locale(lang.value);
        };
        const formatToString = (days) => {
          if (!days)
            return null;
          if (isArray$4(days)) {
            return days.map((d2) => d2.format(props.format));
          }
          return days.format(props.format);
        };
        const getDefaultValue2 = () => {
          if (isArray$4(defaultValue)) {
            return defaultValue.map((d2) => dayjs(d2).locale(lang.value));
          }
          const defaultDay = dayjs(defaultValue).locale(lang.value);
          return [defaultDay, defaultDay.add(60, "m")];
        };
        emit("set-picker-option", ["formatToString", formatToString]);
        emit("set-picker-option", ["parseUserInput", parseUserInput]);
        emit("set-picker-option", ["isValidValue", isValidValue2]);
        emit("set-picker-option", ["handleKeydownInput", handleKeydown]);
        emit("set-picker-option", ["getDefaultValue", getDefaultValue2]);
        emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
        return (_ctx, _cache) => {
          return _ctx.actualVisible ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass([unref(nsTime).b("range-picker"), unref(nsPicker).b("panel")])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(unref(nsTime).be("range-picker", "content"))
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(nsTime).be("range-picker", "cell"))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(unref(nsTime).be("range-picker", "header"))
                }, toDisplayString$1(unref(t)("el.datepicker.startTime")), 3),
                createBaseVNode("div", {
                  class: normalizeClass([
                    unref(nsTime).be("range-picker", "body"),
                    unref(nsTime).be("panel", "content"),
                    unref(nsTime).is("arrow", unref(arrowControl)),
                    { "has-seconds": unref(showSeconds) }
                  ])
                }, [
                  createVNode(TimeSpinner, {
                    ref: "minSpinner",
                    role: "start",
                    "show-seconds": unref(showSeconds),
                    "am-pm-mode": unref(amPmMode),
                    "arrow-control": unref(arrowControl),
                    "spinner-date": unref(startTime),
                    "disabled-hours": disabledHours_,
                    "disabled-minutes": disabledMinutes_,
                    "disabled-seconds": disabledSeconds_,
                    onChange: handleMinChange,
                    onSetOption: unref(onSetOption),
                    onSelectRange: setMinSelectionRange
                  }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
                ], 2)
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass(unref(nsTime).be("range-picker", "cell"))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(unref(nsTime).be("range-picker", "header"))
                }, toDisplayString$1(unref(t)("el.datepicker.endTime")), 3),
                createBaseVNode("div", {
                  class: normalizeClass([
                    unref(nsTime).be("range-picker", "body"),
                    unref(nsTime).be("panel", "content"),
                    unref(nsTime).is("arrow", unref(arrowControl)),
                    { "has-seconds": unref(showSeconds) }
                  ])
                }, [
                  createVNode(TimeSpinner, {
                    ref: "maxSpinner",
                    role: "end",
                    "show-seconds": unref(showSeconds),
                    "am-pm-mode": unref(amPmMode),
                    "arrow-control": unref(arrowControl),
                    "spinner-date": unref(endTime),
                    "disabled-hours": disabledHours_,
                    "disabled-minutes": disabledMinutes_,
                    "disabled-seconds": disabledSeconds_,
                    onChange: handleMaxChange,
                    onSetOption: unref(onSetOption),
                    onSelectRange: setMaxSelectionRange
                  }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
                ], 2)
              ], 2)
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass(unref(nsTime).be("panel", "footer"))
            }, [
              createBaseVNode("button", {
                type: "button",
                class: normalizeClass([unref(nsTime).be("panel", "btn"), "cancel"]),
                onClick: _cache[0] || (_cache[0] = ($event) => handleCancel())
              }, toDisplayString$1(unref(t)("el.datepicker.cancel")), 3),
              createBaseVNode("button", {
                type: "button",
                class: normalizeClass([unref(nsTime).be("panel", "btn"), "confirm"]),
                disabled: unref(btnConfirmDisabled),
                onClick: _cache[1] || (_cache[1] = ($event) => handleConfirm())
              }, toDisplayString$1(unref(t)("el.datepicker.confirm")), 11, _hoisted_1$Z)
            ], 2)
          ], 2)) : createCommentVNode("v-if", true);
        };
      }
    });
    var TimeRangePanel = /* @__PURE__ */ _export_sfc(_sfc_main$1U, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-range.vue"]]);
    dayjs.extend(customParseFormat);
    var TimePicker = defineComponent({
      name: "ElTimePicker",
      install: null,
      props: {
        ...timePickerDefaultProps,
        isRange: {
          type: Boolean,
          default: false
        }
      },
      emits: ["update:modelValue"],
      setup(props, ctx) {
        const commonPicker = ref();
        const [type2, Panel] = props.isRange ? ["timerange", TimeRangePanel] : ["time", TimePickPanel];
        const modelUpdater = (value) => ctx.emit("update:modelValue", value);
        provide("ElPopperOptions", props.popperOptions);
        ctx.expose({
          focus: (e) => {
            var _a2;
            (_a2 = commonPicker.value) == null ? void 0 : _a2.handleFocusInput(e);
          },
          blur: (e) => {
            var _a2;
            (_a2 = commonPicker.value) == null ? void 0 : _a2.handleBlurInput(e);
          },
          handleOpen: () => {
            var _a2;
            (_a2 = commonPicker.value) == null ? void 0 : _a2.handleOpen();
          },
          handleClose: () => {
            var _a2;
            (_a2 = commonPicker.value) == null ? void 0 : _a2.handleClose();
          }
        });
        return () => {
          var _a2;
          const format2 = (_a2 = props.format) != null ? _a2 : DEFAULT_FORMATS_TIME;
          return createVNode(CommonPicker, mergeProps(props, {
            "ref": commonPicker,
            "type": type2,
            "format": format2,
            "onUpdate:modelValue": modelUpdater
          }), {
            default: (props2) => createVNode(Panel, props2, null)
          });
        };
      }
    });
    const _TimePicker = TimePicker;
    _TimePicker.install = (app2) => {
      app2.component(_TimePicker.name, _TimePicker);
    };
    const ElTimePicker = _TimePicker;
    const getPrevMonthLastDays = (date2, count) => {
      const lastDay = date2.subtract(1, "month").endOf("month").date();
      return rangeArr(count).map((_2, index2) => lastDay - (count - index2 - 1));
    };
    const getMonthDays = (date2) => {
      const days = date2.daysInMonth();
      return rangeArr(days).map((_2, index2) => index2 + 1);
    };
    const toNestedArr = (days) => rangeArr(days.length / 7).map((index2) => {
      const start = index2 * 7;
      return days.slice(start, start + 7);
    });
    const dateTableProps = buildProps({
      selectedDay: {
        type: definePropType(Object)
      },
      range: {
        type: definePropType(Array)
      },
      date: {
        type: definePropType(Object),
        required: true
      },
      hideHeader: {
        type: Boolean
      }
    });
    const dateTableEmits = {
      pick: (value) => isObject$4(value)
    };
    const _hoisted_1$Y = { key: 0 };
    const _hoisted_2$D = ["onClick"];
    const __default__$18 = {
      name: "DateTable"
    };
    const _sfc_main$1T = /* @__PURE__ */ defineComponent({
      ...__default__$18,
      props: dateTableProps,
      emits: dateTableEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        dayjs.extend(localeData);
        const { t, lang } = useLocale();
        const nsTable = useNamespace("calendar-table");
        const nsDay = useNamespace("calendar-day");
        const now2 = dayjs().locale(lang.value);
        const firstDayOfWeek = now2.$locale().weekStart || 0;
        const isInRange = computed(() => !!props.range && !!props.range.length);
        const rows = computed(() => {
          let days = [];
          if (isInRange.value) {
            const [start, end2] = props.range;
            const currentMonthRange = rangeArr(end2.date() - start.date() + 1).map((index2) => ({
              text: start.date() + index2,
              type: "current"
            }));
            let remaining = currentMonthRange.length % 7;
            remaining = remaining === 0 ? 0 : 7 - remaining;
            const nextMonthRange = rangeArr(remaining).map((_2, index2) => ({
              text: index2 + 1,
              type: "next"
            }));
            days = currentMonthRange.concat(nextMonthRange);
          } else {
            const firstDay = props.date.startOf("month").day();
            const prevMonthDays = getPrevMonthLastDays(props.date, firstDay - firstDayOfWeek).map((day) => ({
              text: day,
              type: "prev"
            }));
            const currentMonthDays = getMonthDays(props.date).map((day) => ({
              text: day,
              type: "current"
            }));
            days = [...prevMonthDays, ...currentMonthDays];
            const remaining = 7 - (days.length % 7 || 7);
            const nextMonthDays = rangeArr(remaining).map((_2, index2) => ({
              text: index2 + 1,
              type: "next"
            }));
            days = days.concat(nextMonthDays);
          }
          return toNestedArr(days);
        });
        const weekDays = computed(() => {
          const start = firstDayOfWeek;
          if (start === 0) {
            return WEEK_DAYS.map((_2) => t(`el.datepicker.weeks.${_2}`));
          } else {
            return WEEK_DAYS.slice(start).concat(WEEK_DAYS.slice(0, start)).map((_2) => t(`el.datepicker.weeks.${_2}`));
          }
        });
        const getFormattedDate = (day, type2) => {
          switch (type2) {
            case "prev":
              return props.date.startOf("month").subtract(1, "month").date(day);
            case "next":
              return props.date.startOf("month").add(1, "month").date(day);
            case "current":
              return props.date.date(day);
          }
        };
        const getCellClass = ({ text, type: type2 }) => {
          const classes = [type2];
          if (type2 === "current") {
            const date2 = getFormattedDate(text, type2);
            if (date2.isSame(props.selectedDay, "day")) {
              classes.push(nsDay.is("selected"));
            }
            if (date2.isSame(now2, "day")) {
              classes.push(nsDay.is("today"));
            }
          }
          return classes;
        };
        const handlePickDay = ({ text, type: type2 }) => {
          const date2 = getFormattedDate(text, type2);
          emit("pick", date2);
        };
        const getSlotData = ({ text, type: type2 }) => {
          const day = getFormattedDate(text, type2);
          return {
            isSelected: day.isSame(props.selectedDay),
            type: `${type2}-month`,
            day: day.format("YYYY-MM-DD"),
            date: day.toDate()
          };
        };
        expose({
          getFormattedDate
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("table", {
            class: normalizeClass([unref(nsTable).b(), unref(nsTable).is("range", unref(isInRange))]),
            cellspacing: "0",
            cellpadding: "0"
          }, [
            !_ctx.hideHeader ? (openBlock(), createElementBlock("thead", _hoisted_1$Y, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(weekDays), (day) => {
                return openBlock(), createElementBlock("th", { key: day }, toDisplayString$1(day), 1);
              }), 128))
            ])) : createCommentVNode("v-if", true),
            createBaseVNode("tbody", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(rows), (row, index2) => {
                return openBlock(), createElementBlock("tr", {
                  key: index2,
                  class: normalizeClass({
                    [unref(nsTable).e("row")]: true,
                    [unref(nsTable).em("row", "hide-border")]: index2 === 0 && _ctx.hideHeader
                  })
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, key) => {
                    return openBlock(), createElementBlock("td", {
                      key,
                      class: normalizeClass(getCellClass(cell)),
                      onClick: ($event) => handlePickDay(cell)
                    }, [
                      createBaseVNode("div", {
                        class: normalizeClass(unref(nsDay).b())
                      }, [
                        renderSlot(_ctx.$slots, "dateCell", {
                          data: getSlotData(cell)
                        }, () => [
                          createBaseVNode("span", null, toDisplayString$1(cell.text), 1)
                        ])
                      ], 2)
                    ], 10, _hoisted_2$D);
                  }), 128))
                ], 2);
              }), 128))
            ])
          ], 2);
        };
      }
    });
    var DateTable$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1T, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/date-table.vue"]]);
    const isValidRange$1 = (range2) => isArray$4(range2) && range2.length === 2 && range2.every((item) => isDate$2(item));
    const calendarProps = buildProps({
      modelValue: {
        type: Date
      },
      range: {
        type: definePropType(Array),
        validator: isValidRange$1
      }
    });
    const calendarEmits = {
      [UPDATE_MODEL_EVENT]: (value) => isDate$2(value),
      [INPUT_EVENT]: (value) => isDate$2(value)
    };
    const __default__$17 = {
      name: "ElCalendar"
    };
    const _sfc_main$1S = /* @__PURE__ */ defineComponent({
      ...__default__$17,
      props: calendarProps,
      emits: calendarEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const ns2 = useNamespace("calendar");
        const { t, lang } = useLocale();
        const selectedDay = ref();
        const now2 = dayjs().locale(lang.value);
        const realSelectedDay = computed({
          get() {
            if (!props.modelValue)
              return selectedDay.value;
            return date2.value;
          },
          set(val) {
            if (!val)
              return;
            selectedDay.value = val;
            const result = val.toDate();
            emit(INPUT_EVENT, result);
            emit(UPDATE_MODEL_EVENT, result);
          }
        });
        const validatedRange = computed(() => {
          if (!props.range)
            return [];
          const rangeArrDayjs = props.range.map((_2) => dayjs(_2).locale(lang.value));
          const [startDayjs, endDayjs] = rangeArrDayjs;
          if (startDayjs.isAfter(endDayjs)) {
            return [];
          }
          if (startDayjs.isSame(endDayjs, "month")) {
            return calculateValidatedDateRange(startDayjs, endDayjs);
          } else {
            if (startDayjs.add(1, "month").month() !== endDayjs.month()) {
              return [];
            }
            return calculateValidatedDateRange(startDayjs, endDayjs);
          }
        });
        const date2 = computed(() => {
          if (!props.modelValue) {
            if (realSelectedDay.value) {
              return realSelectedDay.value;
            } else if (validatedRange.value.length) {
              return validatedRange.value[0][0];
            }
            return now2;
          } else {
            return dayjs(props.modelValue).locale(lang.value);
          }
        });
        const prevMonthDayjs = computed(() => date2.value.subtract(1, "month").date(1));
        const nextMonthDayjs = computed(() => date2.value.add(1, "month").date(1));
        const prevYearDayjs = computed(() => date2.value.subtract(1, "year").date(1));
        const nextYearDayjs = computed(() => date2.value.add(1, "year").date(1));
        const i18nDate = computed(() => {
          const pickedMonth = `el.datepicker.month${date2.value.format("M")}`;
          return `${date2.value.year()} ${t("el.datepicker.year")} ${t(pickedMonth)}`;
        });
        const calculateValidatedDateRange = (startDayjs, endDayjs) => {
          const firstDay = startDayjs.startOf("week");
          const lastDay = endDayjs.endOf("week");
          const firstMonth = firstDay.get("month");
          const lastMonth = lastDay.get("month");
          if (firstMonth === lastMonth) {
            return [[firstDay, lastDay]];
          } else if (firstMonth + 1 === lastMonth) {
            const firstMonthLastDay = firstDay.endOf("month");
            const lastMonthFirstDay = lastDay.startOf("month");
            const isSameWeek = firstMonthLastDay.isSame(lastMonthFirstDay, "week");
            const lastMonthStartDay = isSameWeek ? lastMonthFirstDay.add(1, "week") : lastMonthFirstDay;
            return [
              [firstDay, firstMonthLastDay],
              [lastMonthStartDay.startOf("week"), lastDay]
            ];
          } else if (firstMonth + 2 === lastMonth || (firstMonth + 1) % 11 === lastMonth) {
            const firstMonthLastDay = firstDay.endOf("month");
            const secondMonthFirstDay = firstDay.add(1, "month").startOf("month");
            const secondMonthStartDay = firstMonthLastDay.isSame(secondMonthFirstDay, "week") ? secondMonthFirstDay.add(1, "week") : secondMonthFirstDay;
            const secondMonthLastDay = secondMonthStartDay.endOf("month");
            const lastMonthFirstDay = lastDay.startOf("month");
            const lastMonthStartDay = secondMonthLastDay.isSame(lastMonthFirstDay, "week") ? lastMonthFirstDay.add(1, "week") : lastMonthFirstDay;
            return [
              [firstDay, firstMonthLastDay],
              [secondMonthStartDay.startOf("week"), secondMonthLastDay],
              [lastMonthStartDay.startOf("week"), lastDay]
            ];
          } else {
            return [];
          }
        };
        const pickDay = (day) => {
          realSelectedDay.value = day;
        };
        const selectDate = (type2) => {
          let day;
          if (type2 === "prev-month") {
            day = prevMonthDayjs.value;
          } else if (type2 === "next-month") {
            day = nextMonthDayjs.value;
          } else if (type2 === "prev-year") {
            day = prevYearDayjs.value;
          } else if (type2 === "next-year") {
            day = nextYearDayjs.value;
          } else {
            day = now2;
          }
          if (day.isSame(date2.value, "day"))
            return;
          pickDay(day);
        };
        expose({
          selectedDay: realSelectedDay,
          pickDay,
          selectDate,
          calculateValidatedDateRange
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(ns2).b())
          }, [
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("header"))
            }, [
              renderSlot(_ctx.$slots, "header", { date: unref(i18nDate) }, () => [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns2).e("title"))
                }, toDisplayString$1(unref(i18nDate)), 3),
                unref(validatedRange).length === 0 ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns2).e("button-group"))
                }, [
                  createVNode(unref(ElButtonGroup$1), null, {
                    default: withCtx(() => [
                      createVNode(unref(ElButton), {
                        size: "small",
                        onClick: _cache[0] || (_cache[0] = ($event) => selectDate("prev-month"))
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString$1(unref(t)("el.datepicker.prevMonth")), 1)
                        ]),
                        _: 1
                      }),
                      createVNode(unref(ElButton), {
                        size: "small",
                        onClick: _cache[1] || (_cache[1] = ($event) => selectDate("today"))
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString$1(unref(t)("el.datepicker.today")), 1)
                        ]),
                        _: 1
                      }),
                      createVNode(unref(ElButton), {
                        size: "small",
                        onClick: _cache[2] || (_cache[2] = ($event) => selectDate("next-month"))
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString$1(unref(t)("el.datepicker.nextMonth")), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ], 2)) : createCommentVNode("v-if", true)
              ])
            ], 2),
            unref(validatedRange).length === 0 ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(ns2).e("body"))
            }, [
              createVNode(DateTable$1, {
                date: unref(date2),
                "selected-day": unref(realSelectedDay),
                onPick: pickDay
              }, createSlots({ _: 2 }, [
                _ctx.$slots.dateCell ? {
                  name: "dateCell",
                  fn: withCtx((data) => [
                    renderSlot(_ctx.$slots, "dateCell", normalizeProps(guardReactiveProps(data)))
                  ])
                } : void 0
              ]), 1032, ["date", "selected-day"])
            ], 2)) : (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(unref(ns2).e("body"))
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(validatedRange), (range_, index2) => {
                return openBlock(), createBlock(DateTable$1, {
                  key: index2,
                  date: range_[0],
                  "selected-day": unref(realSelectedDay),
                  range: range_,
                  "hide-header": index2 !== 0,
                  onPick: pickDay
                }, createSlots({ _: 2 }, [
                  _ctx.$slots.dateCell ? {
                    name: "dateCell",
                    fn: withCtx((data) => [
                      renderSlot(_ctx.$slots, "dateCell", normalizeProps(guardReactiveProps(data)))
                    ])
                  } : void 0
                ]), 1032, ["date", "selected-day", "range", "hide-header"]);
              }), 128))
            ], 2))
          ], 2);
        };
      }
    });
    var Calendar = /* @__PURE__ */ _export_sfc(_sfc_main$1S, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/calendar.vue"]]);
    const ElCalendar = withInstall(Calendar);
    const cardProps = buildProps({
      header: {
        type: String,
        default: ""
      },
      bodyStyle: {
        type: definePropType([String, Object, Array]),
        default: ""
      },
      shadow: {
        type: String,
        values: ["always", "hover", "never"],
        default: "always"
      }
    });
    const __default__$16 = {
      name: "ElCard"
    };
    const _sfc_main$1R = /* @__PURE__ */ defineComponent({
      ...__default__$16,
      props: cardProps,
      setup(__props) {
        const ns2 = useNamespace("card");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([unref(ns2).b(), unref(ns2).is(`${_ctx.shadow}-shadow`)])
          }, [
            _ctx.$slots.header || _ctx.header ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(ns2).e("header"))
            }, [
              renderSlot(_ctx.$slots, "header", {}, () => [
                createTextVNode(toDisplayString$1(_ctx.header), 1)
              ])
            ], 2)) : createCommentVNode("v-if", true),
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("body")),
              style: normalizeStyle(_ctx.bodyStyle)
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6)
          ], 2);
        };
      }
    });
    var Card = /* @__PURE__ */ _export_sfc(_sfc_main$1R, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/card/src/card.vue"]]);
    const ElCard = withInstall(Card);
    const carouselProps = buildProps({
      initialIndex: {
        type: Number,
        default: 0
      },
      height: {
        type: String,
        default: ""
      },
      trigger: {
        type: String,
        values: ["hover", "click"],
        default: "hover"
      },
      autoplay: {
        type: Boolean,
        default: true
      },
      interval: {
        type: Number,
        default: 3e3
      },
      indicatorPosition: {
        type: String,
        values: ["", "none", "outside"],
        default: ""
      },
      indicator: {
        type: Boolean,
        default: true
      },
      arrow: {
        type: String,
        values: ["always", "hover", "never"],
        default: "hover"
      },
      type: {
        type: String,
        values: ["", "card"],
        default: ""
      },
      loop: {
        type: Boolean,
        default: true
      },
      direction: {
        type: String,
        values: ["horizontal", "vertical"],
        default: "horizontal"
      },
      pauseOnHover: {
        type: Boolean,
        default: true
      }
    });
    const carouselEmits = {
      change: (current, prev) => [current, prev].every(isNumber$2)
    };
    const _hoisted_1$X = ["onMouseenter", "onMouseleave"];
    const _hoisted_2$C = ["onMouseenter", "onClick"];
    const _hoisted_3$m = { key: 0 };
    const __default__$15 = {
      name: "ElCarousel"
    };
    const _sfc_main$1Q = /* @__PURE__ */ defineComponent({
      ...__default__$15,
      props: carouselProps,
      emits: carouselEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const ns2 = useNamespace("carousel");
        const THROTTLE_TIME = 300;
        const activeIndex = ref(-1);
        const timer = ref(null);
        const hover = ref(false);
        const root2 = ref();
        const items = ref([]);
        const arrowDisplay = computed(() => props.arrow !== "never" && !unref(isVertical));
        const hasLabel = computed(() => {
          return items.value.some((item) => item.props.label.toString().length > 0);
        });
        const carouselClasses = computed(() => {
          const classes = [ns2.b(), ns2.m(props.direction)];
          if (unref(isCardType)) {
            classes.push(ns2.m("card"));
          }
          return classes;
        });
        const indicatorsClasses = computed(() => {
          const classes = [ns2.e("indicators"), ns2.em("indicators", props.direction)];
          if (hasLabel.value) {
            classes.push(ns2.em("indicators", "labels"));
          }
          if (props.indicatorPosition === "outside" || unref(isCardType)) {
            classes.push(ns2.em("indicators", "outside"));
          }
          return classes;
        });
        const isCardType = computed(() => props.type === "card");
        const isVertical = computed(() => props.direction === "vertical");
        const throttledArrowClick = throttle((index2) => {
          setActiveItem(index2);
        }, THROTTLE_TIME, { trailing: true });
        const throttledIndicatorHover = throttle((index2) => {
          handleIndicatorHover(index2);
        }, THROTTLE_TIME);
        function pauseTimer() {
          if (timer.value) {
            clearInterval(timer.value);
            timer.value = null;
          }
        }
        function startTimer() {
          if (props.interval <= 0 || !props.autoplay || timer.value)
            return;
          timer.value = setInterval(() => playSlides(), props.interval);
        }
        const playSlides = () => {
          if (activeIndex.value < items.value.length - 1) {
            activeIndex.value = activeIndex.value + 1;
          } else if (props.loop) {
            activeIndex.value = 0;
          }
        };
        function setActiveItem(index2) {
          if (isString$3(index2)) {
            const filteredItems = items.value.filter((item) => item.props.name === index2);
            if (filteredItems.length > 0) {
              index2 = items.value.indexOf(filteredItems[0]);
            }
          }
          index2 = Number(index2);
          if (Number.isNaN(index2) || index2 !== Math.floor(index2)) {
            return;
          }
          const itemCount = items.value.length;
          const oldIndex = activeIndex.value;
          if (index2 < 0) {
            activeIndex.value = props.loop ? itemCount - 1 : 0;
          } else if (index2 >= itemCount) {
            activeIndex.value = props.loop ? 0 : itemCount - 1;
          } else {
            activeIndex.value = index2;
          }
          if (oldIndex === activeIndex.value) {
            resetItemPosition(oldIndex);
          }
          resetTimer();
        }
        function resetItemPosition(oldIndex) {
          items.value.forEach((item, index2) => {
            item.translateItem(index2, activeIndex.value, oldIndex);
          });
        }
        function addItem(item) {
          items.value.push(item);
        }
        function removeItem(uid2) {
          const index2 = items.value.findIndex((item) => item.uid === uid2);
          if (index2 !== -1) {
            items.value.splice(index2, 1);
            if (activeIndex.value === index2)
              next();
          }
        }
        function itemInStage(item, index2) {
          var _a2, _b, _c, _d;
          const _items = unref(items);
          const itemCount = _items.length;
          if (itemCount === 0 || !item.states.inStage)
            return false;
          const nextItemIndex = index2 + 1;
          const prevItemIndex = index2 - 1;
          const lastItemIndex = itemCount - 1;
          const isLastItemActive = _items[lastItemIndex].states.active;
          const isFirstItemActive = _items[0].states.active;
          const isNextItemActive = (_b = (_a2 = _items[nextItemIndex]) == null ? void 0 : _a2.states) == null ? void 0 : _b.active;
          const isPrevItemActive = (_d = (_c = _items[prevItemIndex]) == null ? void 0 : _c.states) == null ? void 0 : _d.active;
          if (index2 === lastItemIndex && isFirstItemActive || isNextItemActive) {
            return "left";
          } else if (index2 === 0 && isLastItemActive || isPrevItemActive) {
            return "right";
          }
          return false;
        }
        function handleMouseEnter() {
          hover.value = true;
          if (props.pauseOnHover) {
            pauseTimer();
          }
        }
        function handleMouseLeave() {
          hover.value = false;
          startTimer();
        }
        function handleButtonEnter(arrow2) {
          if (unref(isVertical))
            return;
          items.value.forEach((item, index2) => {
            if (arrow2 === itemInStage(item, index2)) {
              item.states.hover = true;
            }
          });
        }
        function handleButtonLeave() {
          if (unref(isVertical))
            return;
          items.value.forEach((item) => {
            item.states.hover = false;
          });
        }
        function handleIndicatorClick(index2) {
          activeIndex.value = index2;
        }
        function handleIndicatorHover(index2) {
          if (props.trigger === "hover" && index2 !== activeIndex.value) {
            activeIndex.value = index2;
          }
        }
        function prev() {
          setActiveItem(activeIndex.value - 1);
        }
        function next() {
          setActiveItem(activeIndex.value + 1);
        }
        function resetTimer() {
          pauseTimer();
          startTimer();
        }
        watch(() => activeIndex.value, (current, prev2) => {
          resetItemPosition(prev2);
          if (prev2 > -1) {
            emit("change", current, prev2);
          }
        });
        watch(() => props.autoplay, (autoplay) => {
          autoplay ? startTimer() : pauseTimer();
        });
        watch(() => props.loop, () => {
          setActiveItem(activeIndex.value);
        });
        watch(() => props.interval, () => {
          resetTimer();
        });
        const resizeObserver = shallowRef();
        onMounted(async () => {
          await nextTick();
          resizeObserver.value = useResizeObserver(root2.value, () => {
            resetItemPosition();
          });
          if (props.initialIndex < items.value.length && props.initialIndex >= 0) {
            activeIndex.value = props.initialIndex;
          }
          startTimer();
        });
        onBeforeUnmount(() => {
          pauseTimer();
          if (root2.value && resizeObserver.value)
            resizeObserver.value.stop();
        });
        provide(carouselContextKey, {
          root: root2,
          isCardType,
          isVertical,
          items,
          loop: props.loop,
          addItem,
          removeItem,
          setActiveItem
        });
        expose({
          setActiveItem,
          prev,
          next
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "root",
            ref: root2,
            class: normalizeClass(unref(carouselClasses)),
            onMouseenter: withModifiers(handleMouseEnter, ["stop"]),
            onMouseleave: withModifiers(handleMouseLeave, ["stop"])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("container")),
              style: normalizeStyle({ height: _ctx.height })
            }, [
              unref(arrowDisplay) ? (openBlock(), createBlock(Transition, {
                key: 0,
                name: "carousel-arrow-left",
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createBaseVNode("button", {
                    type: "button",
                    class: normalizeClass([unref(ns2).e("arrow"), unref(ns2).em("arrow", "left")]),
                    onMouseenter: _cache[0] || (_cache[0] = ($event) => handleButtonEnter("left")),
                    onMouseleave: handleButtonLeave,
                    onClick: _cache[1] || (_cache[1] = withModifiers(($event) => unref(throttledArrowClick)(activeIndex.value - 1), ["stop"]))
                  }, [
                    createVNode(unref(ElIcon), null, {
                      default: withCtx(() => [
                        createVNode(unref(arrow_left_default))
                      ]),
                      _: 1
                    })
                  ], 34), [
                    [
                      vShow,
                      (_ctx.arrow === "always" || hover.value) && (props.loop || activeIndex.value > 0)
                    ]
                  ])
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              unref(arrowDisplay) ? (openBlock(), createBlock(Transition, {
                key: 1,
                name: "carousel-arrow-right",
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createBaseVNode("button", {
                    type: "button",
                    class: normalizeClass([unref(ns2).e("arrow"), unref(ns2).em("arrow", "right")]),
                    onMouseenter: _cache[2] || (_cache[2] = ($event) => handleButtonEnter("right")),
                    onMouseleave: handleButtonLeave,
                    onClick: _cache[3] || (_cache[3] = withModifiers(($event) => unref(throttledArrowClick)(activeIndex.value + 1), ["stop"]))
                  }, [
                    createVNode(unref(ElIcon), null, {
                      default: withCtx(() => [
                        createVNode(unref(arrow_right_default))
                      ]),
                      _: 1
                    })
                  ], 34), [
                    [
                      vShow,
                      (_ctx.arrow === "always" || hover.value) && (props.loop || activeIndex.value < items.value.length - 1)
                    ]
                  ])
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              renderSlot(_ctx.$slots, "default")
            ], 6),
            _ctx.indicatorPosition !== "none" ? (openBlock(), createElementBlock("ul", {
              key: 0,
              class: normalizeClass(unref(indicatorsClasses))
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(items.value, (item, index2) => {
                return openBlock(), createElementBlock("li", {
                  key: index2,
                  class: normalizeClass([
                    unref(ns2).e("indicator"),
                    unref(ns2).em("indicator", _ctx.direction),
                    unref(ns2).is("active", index2 === activeIndex.value)
                  ]),
                  onMouseenter: ($event) => unref(throttledIndicatorHover)(index2),
                  onClick: withModifiers(($event) => handleIndicatorClick(index2), ["stop"])
                }, [
                  createBaseVNode("button", {
                    class: normalizeClass(unref(ns2).e("button"))
                  }, [
                    unref(hasLabel) ? (openBlock(), createElementBlock("span", _hoisted_3$m, toDisplayString$1(item.props.label), 1)) : createCommentVNode("v-if", true)
                  ], 2)
                ], 42, _hoisted_2$C);
              }), 128))
            ], 2)) : createCommentVNode("v-if", true)
          ], 42, _hoisted_1$X);
        };
      }
    });
    var Carousel = /* @__PURE__ */ _export_sfc(_sfc_main$1Q, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel.vue"]]);
    const carouselItemProps = buildProps({
      name: { type: String, default: "" },
      label: {
        type: [String, Number],
        default: ""
      }
    });
    const __default__$14 = {
      name: "ElCarouselItem"
    };
    const _sfc_main$1P = /* @__PURE__ */ defineComponent({
      ...__default__$14,
      props: carouselItemProps,
      setup(__props) {
        const props = __props;
        const ns2 = useNamespace("carousel");
        const carouselContext = inject(carouselContextKey);
        const instance = getCurrentInstance();
        const CARD_SCALE = 0.83;
        const hover = ref(false);
        const translate2 = ref(0);
        const scale = ref(1);
        const active = ref(false);
        const ready = ref(false);
        const inStage = ref(false);
        const animating = ref(false);
        const { isCardType, isVertical } = carouselContext;
        const itemStyle = computed(() => {
          const translateType = `translate${unref(isVertical) ? "Y" : "X"}`;
          const _translate = `${translateType}(${unref(translate2)}px)`;
          const _scale = `scale(${unref(scale)})`;
          const transform2 = [_translate, _scale].join(" ");
          return {
            transform: transform2
          };
        });
        function processIndex(index2, activeIndex, length) {
          const lastItemIndex = length - 1;
          const prevItemIndex = activeIndex - 1;
          const nextItemIndex = activeIndex + 1;
          const halfItemIndex = length / 2;
          if (activeIndex === 0 && index2 === lastItemIndex) {
            return -1;
          } else if (activeIndex === lastItemIndex && index2 === 0) {
            return length;
          } else if (index2 < prevItemIndex && activeIndex - index2 >= halfItemIndex) {
            return length + 1;
          } else if (index2 > nextItemIndex && index2 - activeIndex >= halfItemIndex) {
            return -2;
          }
          return index2;
        }
        function calcCardTranslate(index2, activeIndex) {
          var _a2;
          const parentWidth = ((_a2 = carouselContext.root.value) == null ? void 0 : _a2.offsetWidth) || 0;
          if (inStage.value) {
            return parentWidth * ((2 - CARD_SCALE) * (index2 - activeIndex) + 1) / 4;
          } else if (index2 < activeIndex) {
            return -(1 + CARD_SCALE) * parentWidth / 4;
          } else {
            return (3 + CARD_SCALE) * parentWidth / 4;
          }
        }
        function calcTranslate(index2, activeIndex, isVertical2) {
          const rootEl = carouselContext.root.value;
          if (!rootEl)
            return 0;
          const distance = (isVertical2 ? rootEl.offsetHeight : rootEl.offsetWidth) || 0;
          return distance * (index2 - activeIndex);
        }
        const translateItem = (index2, activeIndex, oldIndex) => {
          var _a2;
          const _isCardType = unref(isCardType);
          const carouselItemLength = (_a2 = carouselContext.items.value.length) != null ? _a2 : Number.NaN;
          const isActive = index2 === activeIndex;
          if (!_isCardType && !isUndefined$1(oldIndex)) {
            animating.value = isActive || index2 === oldIndex;
          }
          if (!isActive && carouselItemLength > 2 && carouselContext.loop) {
            index2 = processIndex(index2, activeIndex, carouselItemLength);
          }
          const _isVertical = unref(isVertical);
          active.value = isActive;
          if (_isCardType) {
            inStage.value = Math.round(Math.abs(index2 - activeIndex)) <= 1;
            translate2.value = calcCardTranslate(index2, activeIndex);
            scale.value = unref(active) ? 1 : CARD_SCALE;
          } else {
            translate2.value = calcTranslate(index2, activeIndex, _isVertical);
          }
          ready.value = true;
        };
        function handleItemClick() {
          if (carouselContext && unref(isCardType)) {
            const index2 = carouselContext.items.value.findIndex(({ uid: uid2 }) => uid2 === instance.uid);
            carouselContext.setActiveItem(index2);
          }
        }
        onMounted(() => {
          carouselContext.addItem({
            props,
            states: reactive({
              hover,
              translate: translate2,
              scale,
              active,
              ready,
              inStage,
              animating
            }),
            uid: instance.uid,
            translateItem
          });
        });
        onUnmounted(() => {
          carouselContext.removeItem(instance.uid);
        });
        return (_ctx, _cache) => {
          return withDirectives((openBlock(), createElementBlock("div", {
            class: normalizeClass([
              unref(ns2).e("item"),
              unref(ns2).is("active", active.value),
              unref(ns2).is("in-stage", inStage.value),
              unref(ns2).is("hover", hover.value),
              unref(ns2).is("animating", animating.value),
              { [unref(ns2).em("item", "card")]: unref(isCardType) }
            ]),
            style: normalizeStyle(unref(itemStyle)),
            onClick: handleItemClick
          }, [
            unref(isCardType) ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(ns2).e("mask"))
            }, null, 2)), [
              [vShow, !active.value]
            ]) : createCommentVNode("v-if", true),
            renderSlot(_ctx.$slots, "default")
          ], 6)), [
            [vShow, ready.value]
          ]);
        };
      }
    });
    var CarouselItem = /* @__PURE__ */ _export_sfc(_sfc_main$1P, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel-item.vue"]]);
    const ElCarousel = withInstall(Carousel, {
      CarouselItem
    });
    const ElCarouselItem = withNoopInstall(CarouselItem);
    const useCheckboxGroupProps = {
      modelValue: {
        type: Array,
        default: () => []
      },
      disabled: Boolean,
      min: {
        type: Number,
        default: void 0
      },
      max: {
        type: Number,
        default: void 0
      },
      size: useSizeProp,
      id: {
        type: String,
        default: void 0
      },
      label: {
        type: String,
        default: void 0
      },
      fill: {
        type: String,
        default: void 0
      },
      textColor: {
        type: String,
        default: void 0
      },
      tag: {
        type: String,
        default: "div"
      },
      validateEvent: {
        type: Boolean,
        default: true
      }
    };
    const checkboxProps = {
      modelValue: {
        type: [Number, String, Boolean],
        default: () => void 0
      },
      label: {
        type: [String, Boolean, Number, Object]
      },
      indeterminate: Boolean,
      disabled: Boolean,
      checked: Boolean,
      name: {
        type: String,
        default: void 0
      },
      trueLabel: {
        type: [String, Number],
        default: void 0
      },
      falseLabel: {
        type: [String, Number],
        default: void 0
      },
      id: {
        type: String,
        default: void 0
      },
      controls: {
        type: String,
        default: void 0
      },
      border: Boolean,
      size: useSizeProp,
      tabindex: [String, Number],
      validateEvent: {
        type: Boolean,
        default: true
      }
    };
    const useCheckboxGroup = () => {
      const { form: elForm, formItem: elFormItem } = useFormItem();
      const checkboxGroup = inject("CheckboxGroup", {});
      const isGroup = computed(() => checkboxGroup && (checkboxGroup == null ? void 0 : checkboxGroup.name) === "ElCheckboxGroup");
      const elFormItemSize = computed(() => {
        return elFormItem == null ? void 0 : elFormItem.size;
      });
      return {
        isGroup,
        checkboxGroup,
        elForm,
        elFormItemSize,
        elFormItem
      };
    };
    const useCheckboxGroupId = (props, { elFormItem }) => {
      const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
        formItemContext: elFormItem
      });
      return {
        isLabeledByFormItem,
        groupId
      };
    };
    const useModel = (props) => {
      const selfModel = ref(false);
      const { emit } = getCurrentInstance();
      const { isGroup, checkboxGroup, elFormItem } = useCheckboxGroup();
      const isLimitExceeded = ref(false);
      const model = computed({
        get() {
          var _a2, _b;
          return isGroup.value ? (_a2 = checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b = props.modelValue) != null ? _b : selfModel.value;
        },
        set(val) {
          var _a2;
          if (isGroup.value && Array.isArray(val)) {
            isLimitExceeded.value = checkboxGroup.max !== void 0 && val.length > checkboxGroup.max.value;
            isLimitExceeded.value === false && ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _a2.call(checkboxGroup, val));
          } else {
            emit(UPDATE_MODEL_EVENT, val);
            selfModel.value = val;
          }
        }
      });
      return {
        model,
        isGroup,
        isLimitExceeded,
        elFormItem
      };
    };
    const useCheckboxStatus = (props, slots, { model }) => {
      const { isGroup, checkboxGroup } = useCheckboxGroup();
      const focus = ref(false);
      const size2 = useSize(checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize, { prop: true });
      const isChecked = computed(() => {
        const value = model.value;
        if (toTypeString$1(value) === "[object Boolean]") {
          return value;
        } else if (Array.isArray(value)) {
          return value.map(toRaw).includes(props.label);
        } else if (value !== null && value !== void 0) {
          return value === props.trueLabel;
        } else {
          return !!value;
        }
      });
      const checkboxSize = useSize(computed(() => {
        var _a2;
        return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize) == null ? void 0 : _a2.value : void 0;
      }));
      const hasOwnLabel = computed(() => {
        return !!(slots.default || props.label);
      });
      return {
        isChecked,
        focus,
        size: size2,
        checkboxSize,
        hasOwnLabel
      };
    };
    const useDisabled = (props, {
      model,
      isChecked
    }) => {
      const { elForm, isGroup, checkboxGroup } = useCheckboxGroup();
      const isLimitDisabled = computed(() => {
        var _a2, _b;
        const max2 = (_a2 = checkboxGroup.max) == null ? void 0 : _a2.value;
        const min2 = (_b = checkboxGroup.min) == null ? void 0 : _b.value;
        return !!(max2 || min2) && model.value.length >= max2 && !isChecked.value || model.value.length <= min2 && isChecked.value;
      });
      const isDisabled = computed(() => {
        var _a2, _b;
        const disabled = props.disabled || (elForm == null ? void 0 : elForm.disabled);
        return (_b = isGroup.value ? ((_a2 = checkboxGroup.disabled) == null ? void 0 : _a2.value) || disabled || isLimitDisabled.value : disabled) != null ? _b : false;
      });
      return {
        isDisabled,
        isLimitDisabled
      };
    };
    const setStoreValue = (props, { model }) => {
      function addToStore() {
        if (Array.isArray(model.value) && !model.value.includes(props.label)) {
          model.value.push(props.label);
        } else {
          model.value = props.trueLabel || true;
        }
      }
      props.checked && addToStore();
    };
    const useEvent$1 = (props, {
      model,
      isLimitExceeded,
      hasOwnLabel,
      isDisabled,
      isLabeledByFormItem
    }) => {
      const { elFormItem, checkboxGroup } = useCheckboxGroup();
      const { emit } = getCurrentInstance();
      function getLabeledValue(value) {
        var _a2, _b;
        return value === props.trueLabel || value === true ? (_a2 = props.trueLabel) != null ? _a2 : true : (_b = props.falseLabel) != null ? _b : false;
      }
      function emitChangeEvent(checked, e) {
        emit("change", getLabeledValue(checked), e);
      }
      function handleChange(e) {
        if (isLimitExceeded.value)
          return;
        const target = e.target;
        emit("change", getLabeledValue(target.checked), e);
      }
      async function onClickRoot(e) {
        if (isLimitExceeded.value)
          return;
        if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
          model.value = getLabeledValue([false, props.falseLabel].includes(model.value));
          await nextTick();
          emitChangeEvent(model.value, e);
        }
      }
      const validateEvent = computed(() => {
        var _a2;
        return ((_a2 = checkboxGroup.validateEvent) == null ? void 0 : _a2.value) || props.validateEvent;
      });
      watch(() => props.modelValue, () => {
        if (validateEvent.value) {
          elFormItem == null ? void 0 : elFormItem.validate("change").catch((err) => debugWarn());
        }
      });
      return {
        handleChange,
        onClickRoot
      };
    };
    const checkboxEmits = {
      [UPDATE_MODEL_EVENT]: (val) => isString$3(val) || isNumber$2(val) || isBoolean$2(val),
      change: (val) => isString$3(val) || isNumber$2(val) || isBoolean$2(val)
    };
    const checkboxGroupEmits = {
      [UPDATE_MODEL_EVENT]: (val) => isArray$4(val),
      change: (val) => isArray$4(val)
    };
    const useCheckbox = (props, slots) => {
      const { model, isGroup, isLimitExceeded, elFormItem } = useModel(props);
      const { focus, size: size2, isChecked, checkboxSize, hasOwnLabel } = useCheckboxStatus(props, slots, {
        model
      });
      const { isDisabled } = useDisabled(props, { model, isChecked });
      const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
        formItemContext: elFormItem,
        disableIdGeneration: hasOwnLabel,
        disableIdManagement: isGroup
      });
      const { handleChange, onClickRoot } = useEvent$1(props, {
        model,
        isLimitExceeded,
        hasOwnLabel,
        isDisabled,
        isLabeledByFormItem
      });
      setStoreValue(props, { model });
      return {
        elFormItem,
        inputId,
        isLabeledByFormItem,
        isChecked,
        isDisabled,
        isGroup,
        checkboxSize,
        hasOwnLabel,
        model,
        handleChange,
        onClickRoot,
        focus,
        size: size2
      };
    };
    const _hoisted_1$W = ["tabindex", "role", "aria-checked"];
    const _hoisted_2$B = ["id", "aria-hidden", "name", "tabindex", "disabled", "true-value", "false-value"];
    const _hoisted_3$l = ["id", "aria-hidden", "disabled", "value", "name", "tabindex"];
    const __default__$13 = {
      name: "ElCheckbox"
    };
    const _sfc_main$1O = /* @__PURE__ */ defineComponent({
      ...__default__$13,
      props: checkboxProps,
      emits: checkboxEmits,
      setup(__props) {
        const props = __props;
        const slots = useSlots();
        const {
          inputId,
          isLabeledByFormItem,
          isChecked,
          isDisabled,
          checkboxSize,
          hasOwnLabel,
          model,
          handleChange,
          onClickRoot,
          focus
        } = useCheckbox(props, slots);
        const ns2 = useNamespace("checkbox");
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(!unref(hasOwnLabel) && unref(isLabeledByFormItem) ? "span" : "label"), {
            class: normalizeClass([
              unref(ns2).b(),
              unref(ns2).m(unref(checkboxSize)),
              unref(ns2).is("disabled", unref(isDisabled)),
              unref(ns2).is("bordered", _ctx.border),
              unref(ns2).is("checked", unref(isChecked))
            ]),
            "aria-controls": _ctx.indeterminate ? _ctx.controls : null,
            onClick: unref(onClickRoot)
          }, {
            default: withCtx(() => [
              createBaseVNode("span", {
                class: normalizeClass([
                  unref(ns2).e("input"),
                  unref(ns2).is("disabled", unref(isDisabled)),
                  unref(ns2).is("checked", unref(isChecked)),
                  unref(ns2).is("indeterminate", _ctx.indeterminate),
                  unref(ns2).is("focus", unref(focus))
                ]),
                tabindex: _ctx.indeterminate ? 0 : void 0,
                role: _ctx.indeterminate ? "checkbox" : void 0,
                "aria-checked": _ctx.indeterminate ? "mixed" : void 0
              }, [
                _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                  key: 0,
                  id: unref(inputId),
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
                  class: normalizeClass(unref(ns2).e("original")),
                  type: "checkbox",
                  "aria-hidden": _ctx.indeterminate ? "true" : "false",
                  name: _ctx.name,
                  tabindex: _ctx.tabindex,
                  disabled: unref(isDisabled),
                  "true-value": _ctx.trueLabel,
                  "false-value": _ctx.falseLabel,
                  onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                  onFocus: _cache[2] || (_cache[2] = ($event) => focus.value = true),
                  onBlur: _cache[3] || (_cache[3] = ($event) => focus.value = false)
                }, null, 42, _hoisted_2$B)), [
                  [vModelCheckbox, unref(model)]
                ]) : withDirectives((openBlock(), createElementBlock("input", {
                  key: 1,
                  id: unref(inputId),
                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(model) ? model.value = $event : null),
                  class: normalizeClass(unref(ns2).e("original")),
                  type: "checkbox",
                  "aria-hidden": _ctx.indeterminate ? "true" : "false",
                  disabled: unref(isDisabled),
                  value: _ctx.label,
                  name: _ctx.name,
                  tabindex: _ctx.tabindex,
                  onChange: _cache[5] || (_cache[5] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
                  onFocus: _cache[6] || (_cache[6] = ($event) => focus.value = true),
                  onBlur: _cache[7] || (_cache[7] = ($event) => focus.value = false)
                }, null, 42, _hoisted_3$l)), [
                  [vModelCheckbox, unref(model)]
                ]),
                createBaseVNode("span", {
                  class: normalizeClass(unref(ns2).e("inner"))
                }, null, 2)
              ], 10, _hoisted_1$W),
              unref(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: normalizeClass(unref(ns2).e("label"))
              }, [
                renderSlot(_ctx.$slots, "default"),
                !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createTextVNode(toDisplayString$1(_ctx.label), 1)
                ], 64)) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 8, ["class", "aria-controls", "onClick"]);
        };
      }
    });
    var Checkbox = /* @__PURE__ */ _export_sfc(_sfc_main$1O, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
    const _hoisted_1$V = ["name", "tabindex", "disabled", "true-value", "false-value"];
    const _hoisted_2$A = ["name", "tabindex", "disabled", "value"];
    const __default__$12 = {
      name: "ElCheckboxButton"
    };
    const _sfc_main$1N = /* @__PURE__ */ defineComponent({
      ...__default__$12,
      props: checkboxProps,
      emits: checkboxEmits,
      setup(__props) {
        const props = __props;
        const slots = useSlots();
        const { focus, isChecked, isDisabled, size: size2, model, handleChange } = useCheckbox(props, slots);
        const { checkboxGroup } = useCheckboxGroup();
        const ns2 = useNamespace("checkbox");
        const activeStyle = computed(() => {
          var _a2, _b, _c, _d;
          const fillValue = (_b = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b : "";
          return {
            backgroundColor: fillValue,
            borderColor: fillValue,
            color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
            boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
          };
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("label", {
            class: normalizeClass([
              unref(ns2).b("button"),
              unref(ns2).bm("button", unref(size2)),
              unref(ns2).is("disabled", unref(isDisabled)),
              unref(ns2).is("checked", unref(isChecked)),
              unref(ns2).is("focus", unref(focus))
            ])
          }, [
            _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
              key: 0,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
              class: normalizeClass(unref(ns2).be("button", "original")),
              type: "checkbox",
              name: _ctx.name,
              tabindex: _ctx.tabindex,
              disabled: unref(isDisabled),
              "true-value": _ctx.trueLabel,
              "false-value": _ctx.falseLabel,
              onChange: _cache[1] || (_cache[1] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
              onFocus: _cache[2] || (_cache[2] = ($event) => focus.value = true),
              onBlur: _cache[3] || (_cache[3] = ($event) => focus.value = false)
            }, null, 42, _hoisted_1$V)), [
              [vModelCheckbox, unref(model)]
            ]) : withDirectives((openBlock(), createElementBlock("input", {
              key: 1,
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(model) ? model.value = $event : null),
              class: normalizeClass(unref(ns2).be("button", "original")),
              type: "checkbox",
              name: _ctx.name,
              tabindex: _ctx.tabindex,
              disabled: unref(isDisabled),
              value: _ctx.label,
              onChange: _cache[5] || (_cache[5] = (...args) => unref(handleChange) && unref(handleChange)(...args)),
              onFocus: _cache[6] || (_cache[6] = ($event) => focus.value = true),
              onBlur: _cache[7] || (_cache[7] = ($event) => focus.value = false)
            }, null, 42, _hoisted_2$A)), [
              [vModelCheckbox, unref(model)]
            ]),
            _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
              key: 2,
              class: normalizeClass(unref(ns2).be("button", "inner")),
              style: normalizeStyle(unref(isChecked) ? unref(activeStyle) : void 0)
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(toDisplayString$1(_ctx.label), 1)
              ])
            ], 6)) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    });
    var CheckboxButton = /* @__PURE__ */ _export_sfc(_sfc_main$1N, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
    const __default__$11 = {
      name: "ElCheckboxGroup"
    };
    const _sfc_main$1M = /* @__PURE__ */ defineComponent({
      ...__default__$11,
      props: useCheckboxGroupProps,
      emits: checkboxGroupEmits,
      setup(__props, { emit }) {
        const props = __props;
        const { elFormItem } = useCheckboxGroup();
        const { groupId, isLabeledByFormItem } = useCheckboxGroupId(props, {
          elFormItem
        });
        const checkboxGroupSize = useSize();
        const ns2 = useNamespace("checkbox");
        const changeEvent = (value) => {
          emit(UPDATE_MODEL_EVENT, value);
          nextTick(() => {
            emit("change", value);
          });
        };
        const modelValue = computed({
          get() {
            return props.modelValue;
          },
          set(val) {
            changeEvent(val);
          }
        });
        provide("CheckboxGroup", {
          name: "ElCheckboxGroup",
          ...toRefs(props),
          modelValue,
          checkboxGroupSize,
          changeEvent
        });
        watch(() => props.modelValue, () => {
          if (props.validateEvent) {
            elFormItem == null ? void 0 : elFormItem.validate("change").catch((err) => debugWarn());
          }
        });
        return (_ctx, _cache) => {
          var _a2;
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
            id: unref(groupId),
            class: normalizeClass(unref(ns2).b("group")),
            role: "group",
            "aria-label": !unref(isLabeledByFormItem) ? _ctx.label || "checkbox-group" : void 0,
            "aria-labelledby": unref(isLabeledByFormItem) ? (_a2 = unref(elFormItem)) == null ? void 0 : _a2.labelId : void 0
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
        };
      }
    });
    var CheckboxGroup = /* @__PURE__ */ _export_sfc(_sfc_main$1M, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
    const ElCheckbox = withInstall(Checkbox, {
      CheckboxButton,
      CheckboxGroup
    });
    const ElCheckboxButton = withNoopInstall(CheckboxButton);
    const ElCheckboxGroup$1 = withNoopInstall(CheckboxGroup);
    const radioPropsBase = buildProps({
      size: useSizeProp,
      disabled: Boolean,
      label: {
        type: [String, Number, Boolean],
        default: ""
      }
    });
    const radioProps = buildProps({
      ...radioPropsBase,
      modelValue: {
        type: [String, Number, Boolean],
        default: ""
      },
      name: {
        type: String,
        default: ""
      },
      border: Boolean
    });
    const radioEmits = {
      [UPDATE_MODEL_EVENT]: (val) => isString$3(val) || isNumber$2(val) || isBoolean$2(val),
      [CHANGE_EVENT]: (val) => isString$3(val) || isNumber$2(val) || isBoolean$2(val)
    };
    const useRadio = (props, emit) => {
      const radioRef = ref();
      const radioGroup = inject(radioGroupKey, void 0);
      const isGroup = computed(() => !!radioGroup);
      const modelValue = computed({
        get() {
          return isGroup.value ? radioGroup.modelValue : props.modelValue;
        },
        set(val) {
          if (isGroup.value) {
            radioGroup.changeEvent(val);
          } else {
            emit && emit(UPDATE_MODEL_EVENT, val);
          }
          radioRef.value.checked = props.modelValue === props.label;
        }
      });
      const size2 = useSize(computed(() => radioGroup == null ? void 0 : radioGroup.size));
      const disabled = useDisabled$1(computed(() => radioGroup == null ? void 0 : radioGroup.disabled));
      const focus = ref(false);
      const tabIndex = computed(() => {
        return disabled.value || isGroup.value && modelValue.value !== props.label ? -1 : 0;
      });
      return {
        radioRef,
        isGroup,
        radioGroup,
        focus,
        size: size2,
        disabled,
        tabIndex,
        modelValue
      };
    };
    const _hoisted_1$U = ["value", "name", "disabled"];
    const __default__$10 = {
      name: "ElRadio"
    };
    const _sfc_main$1L = /* @__PURE__ */ defineComponent({
      ...__default__$10,
      props: radioProps,
      emits: radioEmits,
      setup(__props, { emit }) {
        const props = __props;
        const ns2 = useNamespace("radio");
        const { radioRef, radioGroup, focus, size: size2, disabled, modelValue } = useRadio(props, emit);
        function handleChange() {
          nextTick(() => emit("change", modelValue.value));
        }
        return (_ctx, _cache) => {
          var _a2;
          return openBlock(), createElementBlock("label", {
            class: normalizeClass([
              unref(ns2).b(),
              unref(ns2).is("disabled", unref(disabled)),
              unref(ns2).is("focus", unref(focus)),
              unref(ns2).is("bordered", _ctx.border),
              unref(ns2).is("checked", unref(modelValue) === _ctx.label),
              unref(ns2).m(unref(size2))
            ])
          }, [
            createBaseVNode("span", {
              class: normalizeClass([
                unref(ns2).e("input"),
                unref(ns2).is("disabled", unref(disabled)),
                unref(ns2).is("checked", unref(modelValue) === _ctx.label)
              ])
            }, [
              withDirectives(createBaseVNode("input", {
                ref_key: "radioRef",
                ref: radioRef,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
                class: normalizeClass(unref(ns2).e("original")),
                value: _ctx.label,
                name: _ctx.name || ((_a2 = unref(radioGroup)) == null ? void 0 : _a2.name),
                disabled: unref(disabled),
                type: "radio",
                onFocus: _cache[1] || (_cache[1] = ($event) => focus.value = true),
                onBlur: _cache[2] || (_cache[2] = ($event) => focus.value = false),
                onChange: handleChange
              }, null, 42, _hoisted_1$U), [
                [vModelRadio, unref(modelValue)]
              ]),
              createBaseVNode("span", {
                class: normalizeClass(unref(ns2).e("inner"))
              }, null, 2)
            ], 2),
            createBaseVNode("span", {
              class: normalizeClass(unref(ns2).e("label")),
              onKeydown: _cache[3] || (_cache[3] = withModifiers(() => {
              }, ["stop"]))
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(toDisplayString$1(_ctx.label), 1)
              ])
            ], 34)
          ], 2);
        };
      }
    });
    var Radio = /* @__PURE__ */ _export_sfc(_sfc_main$1L, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio.vue"]]);
    const radioButtonProps = buildProps({
      ...radioPropsBase,
      name: {
        type: String,
        default: ""
      }
    });
    const _hoisted_1$T = ["value", "name", "disabled"];
    const __default__$$ = {
      name: "ElRadioButton"
    };
    const _sfc_main$1K = /* @__PURE__ */ defineComponent({
      ...__default__$$,
      props: radioButtonProps,
      setup(__props) {
        const props = __props;
        const ns2 = useNamespace("radio");
        const { radioRef, focus, size: size2, disabled, modelValue, radioGroup } = useRadio(props);
        const activeStyle = computed(() => {
          return {
            backgroundColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
            borderColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
            boxShadow: (radioGroup == null ? void 0 : radioGroup.fill) ? `-1px 0 0 0 ${radioGroup.fill}` : "",
            color: (radioGroup == null ? void 0 : radioGroup.textColor) || ""
          };
        });
        return (_ctx, _cache) => {
          var _a2;
          return openBlock(), createElementBlock("label", {
            class: normalizeClass([
              unref(ns2).b("button"),
              unref(ns2).is("active", unref(modelValue) === _ctx.label),
              unref(ns2).is("disabled", unref(disabled)),
              unref(ns2).is("focus", unref(focus)),
              unref(ns2).bm("button", unref(size2))
            ])
          }, [
            withDirectives(createBaseVNode("input", {
              ref_key: "radioRef",
              ref: radioRef,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
              class: normalizeClass(unref(ns2).be("button", "original-radio")),
              value: _ctx.label,
              type: "radio",
              name: _ctx.name || ((_a2 = unref(radioGroup)) == null ? void 0 : _a2.name),
              disabled: unref(disabled),
              onFocus: _cache[1] || (_cache[1] = ($event) => focus.value = true),
              onBlur: _cache[2] || (_cache[2] = ($event) => focus.value = false)
            }, null, 42, _hoisted_1$T), [
              [vModelRadio, unref(modelValue)]
            ]),
            createBaseVNode("span", {
              class: normalizeClass(unref(ns2).be("button", "inner")),
              style: normalizeStyle(unref(modelValue) === _ctx.label ? unref(activeStyle) : {}),
              onKeydown: _cache[3] || (_cache[3] = withModifiers(() => {
              }, ["stop"]))
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(toDisplayString$1(_ctx.label), 1)
              ])
            ], 38)
          ], 2);
        };
      }
    });
    var RadioButton = /* @__PURE__ */ _export_sfc(_sfc_main$1K, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-button.vue"]]);
    const radioGroupProps = buildProps({
      id: {
        type: String,
        default: void 0
      },
      size: useSizeProp,
      disabled: Boolean,
      modelValue: {
        type: [String, Number, Boolean],
        default: ""
      },
      fill: {
        type: String,
        default: ""
      },
      label: {
        type: String,
        default: void 0
      },
      textColor: {
        type: String,
        default: ""
      },
      name: {
        type: String,
        default: void 0
      },
      validateEvent: {
        type: Boolean,
        default: true
      }
    });
    const radioGroupEmits = radioEmits;
    const _hoisted_1$S = ["id", "aria-label", "aria-labelledby"];
    const __default__$_ = {
      name: "ElRadioGroup"
    };
    const _sfc_main$1J = /* @__PURE__ */ defineComponent({
      ...__default__$_,
      props: radioGroupProps,
      emits: radioGroupEmits,
      setup(__props, { emit }) {
        const props = __props;
        const ns2 = useNamespace("radio");
        const radioId = useId();
        const radioGroupRef = ref();
        const { formItem } = useFormItem();
        const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const changeEvent = (value) => {
          emit(UPDATE_MODEL_EVENT, value);
          nextTick(() => emit("change", value));
        };
        onMounted(() => {
          const radios = radioGroupRef.value.querySelectorAll("[type=radio]");
          const firstLabel = radios[0];
          if (!Array.from(radios).some((radio) => radio.checked) && firstLabel) {
            firstLabel.tabIndex = 0;
          }
        });
        const name = computed(() => {
          return props.name || radioId.value;
        });
        provide(radioGroupKey, reactive({
          ...toRefs(props),
          changeEvent,
          name
        }));
        watch(() => props.modelValue, () => {
          if (props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            id: unref(groupId),
            ref_key: "radioGroupRef",
            ref: radioGroupRef,
            class: normalizeClass(unref(ns2).b("group")),
            role: "radiogroup",
            "aria-label": !unref(isLabeledByFormItem) ? _ctx.label || "radio-group" : void 0,
            "aria-labelledby": unref(isLabeledByFormItem) ? unref(formItem).labelId : void 0
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 10, _hoisted_1$S);
        };
      }
    });
    var RadioGroup = /* @__PURE__ */ _export_sfc(_sfc_main$1J, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-group.vue"]]);
    const ElRadio = withInstall(Radio, {
      RadioButton,
      RadioGroup
    });
    const ElRadioGroup = withNoopInstall(RadioGroup);
    const ElRadioButton = withNoopInstall(RadioButton);
    var NodeContent$1 = defineComponent({
      name: "NodeContent",
      setup() {
        const ns2 = useNamespace("cascader-node");
        return {
          ns: ns2
        };
      },
      render() {
        const { ns: ns2 } = this;
        const { node, panel } = this.$parent;
        const { data, label } = node;
        const { renderLabelFn } = panel;
        return h$1("span", { class: ns2.e("label") }, renderLabelFn ? renderLabelFn({ node, data }) : label);
      }
    });
    const CASCADER_PANEL_INJECTION_KEY = Symbol();
    const _sfc_main$1I = defineComponent({
      name: "ElCascaderNode",
      components: {
        ElCheckbox,
        ElRadio,
        NodeContent: NodeContent$1,
        ElIcon,
        Check: check_default,
        Loading: loading_default,
        ArrowRight: arrow_right_default
      },
      props: {
        node: {
          type: Object,
          required: true
        },
        menuId: String
      },
      emits: ["expand"],
      setup(props, { emit }) {
        const panel = inject(CASCADER_PANEL_INJECTION_KEY);
        const ns2 = useNamespace("cascader-node");
        const isHoverMenu = computed(() => panel.isHoverMenu);
        const multiple = computed(() => panel.config.multiple);
        const checkStrictly = computed(() => panel.config.checkStrictly);
        const checkedNodeId = computed(() => {
          var _a2;
          return (_a2 = panel.checkedNodes[0]) == null ? void 0 : _a2.uid;
        });
        const isDisabled = computed(() => props.node.isDisabled);
        const isLeaf2 = computed(() => props.node.isLeaf);
        const expandable = computed(() => checkStrictly.value && !isLeaf2.value || !isDisabled.value);
        const inExpandingPath = computed(() => isInPath(panel.expandingNode));
        const inCheckedPath = computed(() => checkStrictly.value && panel.checkedNodes.some(isInPath));
        const isInPath = (node) => {
          var _a2;
          const { level, uid: uid2 } = props.node;
          return ((_a2 = node == null ? void 0 : node.pathNodes[level - 1]) == null ? void 0 : _a2.uid) === uid2;
        };
        const doExpand = () => {
          if (inExpandingPath.value)
            return;
          panel.expandNode(props.node);
        };
        const doCheck = (checked) => {
          const { node } = props;
          if (checked === node.checked)
            return;
          panel.handleCheckChange(node, checked);
        };
        const doLoad = () => {
          panel.lazyLoad(props.node, () => {
            if (!isLeaf2.value)
              doExpand();
          });
        };
        const handleHoverExpand = (e) => {
          if (!isHoverMenu.value)
            return;
          handleExpand();
          !isLeaf2.value && emit("expand", e);
        };
        const handleExpand = () => {
          const { node } = props;
          if (!expandable.value || node.loading)
            return;
          node.loaded ? doExpand() : doLoad();
        };
        const handleClick = () => {
          if (isHoverMenu.value && !isLeaf2.value)
            return;
          if (isLeaf2.value && !isDisabled.value && !checkStrictly.value && !multiple.value) {
            handleCheck(true);
          } else {
            handleExpand();
          }
        };
        const handleSelectCheck = (checked) => {
          if (checkStrictly.value) {
            doCheck(checked);
            if (props.node.loaded) {
              doExpand();
            }
          } else {
            handleCheck(checked);
          }
        };
        const handleCheck = (checked) => {
          if (!props.node.loaded) {
            doLoad();
          } else {
            doCheck(checked);
            !checkStrictly.value && doExpand();
          }
        };
        return {
          panel,
          isHoverMenu,
          multiple,
          checkStrictly,
          checkedNodeId,
          isDisabled,
          isLeaf: isLeaf2,
          expandable,
          inExpandingPath,
          inCheckedPath,
          ns: ns2,
          handleHoverExpand,
          handleExpand,
          handleClick,
          handleCheck,
          handleSelectCheck
        };
      }
    });
    const _hoisted_1$R = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"];
    const _hoisted_2$z = /* @__PURE__ */ createBaseVNode("span", null, null, -1);
    function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_checkbox = resolveComponent("el-checkbox");
      const _component_el_radio = resolveComponent("el-radio");
      const _component_check = resolveComponent("check");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_node_content = resolveComponent("node-content");
      const _component_loading = resolveComponent("loading");
      const _component_arrow_right = resolveComponent("arrow-right");
      return openBlock(), createElementBlock("li", {
        id: `${_ctx.menuId}-${_ctx.node.uid}`,
        role: "menuitem",
        "aria-haspopup": !_ctx.isLeaf,
        "aria-owns": _ctx.isLeaf ? null : _ctx.menuId,
        "aria-expanded": _ctx.inExpandingPath,
        tabindex: _ctx.expandable ? -1 : void 0,
        class: normalizeClass([
          _ctx.ns.b(),
          _ctx.ns.is("selectable", _ctx.checkStrictly),
          _ctx.ns.is("active", _ctx.node.checked),
          _ctx.ns.is("disabled", !_ctx.expandable),
          _ctx.inExpandingPath && "in-active-path",
          _ctx.inCheckedPath && "in-checked-path"
        ]),
        onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)),
        onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)),
        onClick: _cache[4] || (_cache[4] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
      }, [
        createCommentVNode(" prefix "),
        _ctx.multiple ? (openBlock(), createBlock(_component_el_checkbox, {
          key: 0,
          "model-value": _ctx.node.checked,
          indeterminate: _ctx.node.indeterminate,
          disabled: _ctx.isDisabled,
          onClick: _cache[0] || (_cache[0] = withModifiers(() => {
          }, ["stop"])),
          "onUpdate:modelValue": _ctx.handleSelectCheck
        }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : _ctx.checkStrictly ? (openBlock(), createBlock(_component_el_radio, {
          key: 1,
          "model-value": _ctx.checkedNodeId,
          label: _ctx.node.uid,
          disabled: _ctx.isDisabled,
          "onUpdate:modelValue": _ctx.handleSelectCheck,
          onClick: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"]))
        }, {
          default: withCtx(() => [
            createCommentVNode("\n        Add an empty element to avoid render label,\n        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485\n      "),
            _hoisted_2$z
          ]),
          _: 1
        }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : _ctx.isLeaf && _ctx.node.checked ? (openBlock(), createBlock(_component_el_icon, {
          key: 2,
          class: normalizeClass(_ctx.ns.e("prefix"))
        }, {
          default: withCtx(() => [
            createVNode(_component_check)
          ]),
          _: 1
        }, 8, ["class"])) : createCommentVNode("v-if", true),
        createCommentVNode(" content "),
        createVNode(_component_node_content),
        createCommentVNode(" postfix "),
        !_ctx.isLeaf ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
          _ctx.node.loading ? (openBlock(), createBlock(_component_el_icon, {
            key: 0,
            class: normalizeClass([_ctx.ns.is("loading"), _ctx.ns.e("postfix")])
          }, {
            default: withCtx(() => [
              createVNode(_component_loading)
            ]),
            _: 1
          }, 8, ["class"])) : (openBlock(), createBlock(_component_el_icon, {
            key: 1,
            class: normalizeClass(["arrow-right", _ctx.ns.e("postfix")])
          }, {
            default: withCtx(() => [
              createVNode(_component_arrow_right)
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : createCommentVNode("v-if", true)
      ], 42, _hoisted_1$R);
    }
    var ElCascaderNode = /* @__PURE__ */ _export_sfc(_sfc_main$1I, [["render", _sfc_render$A], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/node.vue"]]);
    const _sfc_main$1H = defineComponent({
      name: "ElCascaderMenu",
      components: {
        Loading: loading_default,
        ElIcon,
        ElScrollbar,
        ElCascaderNode
      },
      props: {
        nodes: {
          type: Array,
          required: true
        },
        index: {
          type: Number,
          required: true
        }
      },
      setup(props) {
        const instance = getCurrentInstance();
        const ns2 = useNamespace("cascader-menu");
        const { t } = useLocale();
        const id2 = generateId();
        let activeNode = null;
        let hoverTimer = null;
        const panel = inject(CASCADER_PANEL_INJECTION_KEY);
        const hoverZone = ref(null);
        const isEmpty2 = computed(() => !props.nodes.length);
        const isLoading = computed(() => !panel.initialLoaded);
        const menuId = computed(() => `cascader-menu-${id2}-${props.index}`);
        const handleExpand = (e) => {
          activeNode = e.target;
        };
        const handleMouseMove = (e) => {
          if (!panel.isHoverMenu || !activeNode || !hoverZone.value)
            return;
          if (activeNode.contains(e.target)) {
            clearHoverTimer();
            const el = instance.vnode.el;
            const { left: left2 } = el.getBoundingClientRect();
            const { offsetWidth, offsetHeight } = el;
            const startX = e.clientX - left2;
            const top = activeNode.offsetTop;
            const bottom = top + activeNode.offsetHeight;
            hoverZone.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${top} L${offsetWidth} 0 V${top} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${bottom} L${offsetWidth} ${offsetHeight} V${bottom} Z" />
        `;
          } else if (!hoverTimer) {
            hoverTimer = window.setTimeout(clearHoverZone, panel.config.hoverThreshold);
          }
        };
        const clearHoverTimer = () => {
          if (!hoverTimer)
            return;
          clearTimeout(hoverTimer);
          hoverTimer = null;
        };
        const clearHoverZone = () => {
          if (!hoverZone.value)
            return;
          hoverZone.value.innerHTML = "";
          clearHoverTimer();
        };
        return {
          ns: ns2,
          panel,
          hoverZone,
          isEmpty: isEmpty2,
          isLoading,
          menuId,
          t,
          handleExpand,
          handleMouseMove,
          clearHoverZone
        };
      }
    });
    function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_cascader_node = resolveComponent("el-cascader-node");
      const _component_loading = resolveComponent("loading");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      return openBlock(), createBlock(_component_el_scrollbar, {
        key: _ctx.menuId,
        tag: "ul",
        role: "menu",
        class: normalizeClass(_ctx.ns.b()),
        "wrap-class": _ctx.ns.e("wrap"),
        "view-class": [_ctx.ns.e("list"), _ctx.ns.is("empty", _ctx.isEmpty)],
        onMousemove: _ctx.handleMouseMove,
        onMouseleave: _ctx.clearHoverZone
      }, {
        default: withCtx(() => {
          var _a2;
          return [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.nodes, (node) => {
              return openBlock(), createBlock(_component_el_cascader_node, {
                key: node.uid,
                node,
                "menu-id": _ctx.menuId,
                onExpand: _ctx.handleExpand
              }, null, 8, ["node", "menu-id", "onExpand"]);
            }), 128)),
            _ctx.isLoading ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.ns.e("empty-text"))
            }, [
              createVNode(_component_el_icon, {
                size: "14",
                class: normalizeClass(_ctx.ns.is("loading"))
              }, {
                default: withCtx(() => [
                  createVNode(_component_loading)
                ]),
                _: 1
              }, 8, ["class"]),
              createTextVNode(" " + toDisplayString$1(_ctx.t("el.cascader.loading")), 1)
            ], 2)) : _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(_ctx.ns.e("empty-text"))
            }, toDisplayString$1(_ctx.t("el.cascader.noData")), 3)) : ((_a2 = _ctx.panel) == null ? void 0 : _a2.isHoverMenu) ? (openBlock(), createElementBlock("svg", {
              key: 2,
              ref: "hoverZone",
              class: normalizeClass(_ctx.ns.e("hover-zone"))
            }, null, 2)) : createCommentVNode("v-if", true)
          ];
        }),
        _: 1
      }, 8, ["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"]);
    }
    var ElCascaderMenu = /* @__PURE__ */ _export_sfc(_sfc_main$1H, [["render", _sfc_render$z], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/menu.vue"]]);
    let uid = 0;
    const calculatePathNodes = (node) => {
      const nodes = [node];
      let { parent } = node;
      while (parent) {
        nodes.unshift(parent);
        parent = parent.parent;
      }
      return nodes;
    };
    class Node$1 {
      constructor(data, config, parent, root2 = false) {
        this.data = data;
        this.config = config;
        this.parent = parent;
        this.root = root2;
        this.uid = uid++;
        this.checked = false;
        this.indeterminate = false;
        this.loading = false;
        const { value: valueKey, label: labelKey, children: childrenKey } = config;
        const childrenData = data[childrenKey];
        const pathNodes = calculatePathNodes(this);
        this.level = root2 ? 0 : parent ? parent.level + 1 : 1;
        this.value = data[valueKey];
        this.label = data[labelKey];
        this.pathNodes = pathNodes;
        this.pathValues = pathNodes.map((node) => node.value);
        this.pathLabels = pathNodes.map((node) => node.label);
        this.childrenData = childrenData;
        this.children = (childrenData || []).map((child) => new Node$1(child, config, this));
        this.loaded = !config.lazy || this.isLeaf || !isEmpty(childrenData);
      }
      get isDisabled() {
        const { data, parent, config } = this;
        const { disabled, checkStrictly } = config;
        const isDisabled = isFunction$4(disabled) ? disabled(data, this) : !!data[disabled];
        return isDisabled || !checkStrictly && (parent == null ? void 0 : parent.isDisabled);
      }
      get isLeaf() {
        const { data, config, childrenData, loaded } = this;
        const { lazy, leaf } = config;
        const isLeaf2 = isFunction$4(leaf) ? leaf(data, this) : data[leaf];
        return isUndefined$1(isLeaf2) ? lazy && !loaded ? false : !(Array.isArray(childrenData) && childrenData.length) : !!isLeaf2;
      }
      get valueByOption() {
        return this.config.emitPath ? this.pathValues : this.value;
      }
      appendChild(childData) {
        const { childrenData, children } = this;
        const node = new Node$1(childData, this.config, this);
        if (Array.isArray(childrenData)) {
          childrenData.push(childData);
        } else {
          this.childrenData = [childData];
        }
        children.push(node);
        return node;
      }
      calcText(allLevels, separator) {
        const text = allLevels ? this.pathLabels.join(separator) : this.label;
        this.text = text;
        return text;
      }
      broadcast(event, ...args) {
        const handlerName = `onParent${capitalize$1(event)}`;
        this.children.forEach((child) => {
          if (child) {
            child.broadcast(event, ...args);
            child[handlerName] && child[handlerName](...args);
          }
        });
      }
      emit(event, ...args) {
        const { parent } = this;
        const handlerName = `onChild${capitalize$1(event)}`;
        if (parent) {
          parent[handlerName] && parent[handlerName](...args);
          parent.emit(event, ...args);
        }
      }
      onParentCheck(checked) {
        if (!this.isDisabled) {
          this.setCheckState(checked);
        }
      }
      onChildCheck() {
        const { children } = this;
        const validChildren = children.filter((child) => !child.isDisabled);
        const checked = validChildren.length ? validChildren.every((child) => child.checked) : false;
        this.setCheckState(checked);
      }
      setCheckState(checked) {
        const totalNum = this.children.length;
        const checkedNum = this.children.reduce((c2, p2) => {
          const num = p2.checked ? 1 : p2.indeterminate ? 0.5 : 0;
          return c2 + num;
        }, 0);
        this.checked = this.loaded && this.children.filter((child) => !child.isDisabled).every((child) => child.loaded && child.checked) && checked;
        this.indeterminate = this.loaded && checkedNum !== totalNum && checkedNum > 0;
      }
      doCheck(checked) {
        if (this.checked === checked)
          return;
        const { checkStrictly, multiple } = this.config;
        if (checkStrictly || !multiple) {
          this.checked = checked;
        } else {
          this.broadcast("check", checked);
          this.setCheckState(checked);
          this.emit("check");
        }
      }
    }
    const flatNodes = (nodes, leafOnly) => {
      return nodes.reduce((res, node) => {
        if (node.isLeaf) {
          res.push(node);
        } else {
          !leafOnly && res.push(node);
          res = res.concat(flatNodes(node.children, leafOnly));
        }
        return res;
      }, []);
    };
    class Store {
      constructor(data, config) {
        this.config = config;
        const nodes = (data || []).map((nodeData) => new Node$1(nodeData, this.config));
        this.nodes = nodes;
        this.allNodes = flatNodes(nodes, false);
        this.leafNodes = flatNodes(nodes, true);
      }
      getNodes() {
        return this.nodes;
      }
      getFlattedNodes(leafOnly) {
        return leafOnly ? this.leafNodes : this.allNodes;
      }
      appendNode(nodeData, parentNode) {
        const node = parentNode ? parentNode.appendChild(nodeData) : new Node$1(nodeData, this.config);
        if (!parentNode)
          this.nodes.push(node);
        this.allNodes.push(node);
        node.isLeaf && this.leafNodes.push(node);
      }
      appendNodes(nodeDataList, parentNode) {
        nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode));
      }
      getNodeByValue(value, leafOnly = false) {
        if (!value && value !== 0)
          return null;
        const node = this.getFlattedNodes(leafOnly).find((node2) => isEqual$1(node2.value, value) || isEqual$1(node2.pathValues, value));
        return node || null;
      }
      getSameNode(node) {
        if (!node)
          return null;
        const node_ = this.getFlattedNodes(false).find(({ value, level }) => isEqual$1(node.value, value) && node.level === level);
        return node_ || null;
      }
    }
    const CommonProps = {
      modelValue: [Number, String, Array],
      options: {
        type: Array,
        default: () => []
      },
      props: {
        type: Object,
        default: () => ({})
      }
    };
    const DefaultProps = {
      expandTrigger: "click",
      multiple: false,
      checkStrictly: false,
      emitPath: true,
      lazy: false,
      lazyLoad: NOOP,
      value: "value",
      label: "label",
      children: "children",
      leaf: "leaf",
      disabled: "disabled",
      hoverThreshold: 500
    };
    const useCascaderConfig = (props) => {
      return computed(() => ({
        ...DefaultProps,
        ...props.props
      }));
    };
    const getMenuIndex = (el) => {
      if (!el)
        return 0;
      const pieces = el.id.split("-");
      return Number(pieces[pieces.length - 2]);
    };
    const checkNode = (el) => {
      if (!el)
        return;
      const input = el.querySelector("input");
      if (input) {
        input.click();
      } else if (isLeaf(el)) {
        el.click();
      }
    };
    const sortByOriginalOrder = (oldNodes, newNodes) => {
      const newNodesCopy = newNodes.slice(0);
      const newIds = newNodesCopy.map((node) => node.uid);
      const res = oldNodes.reduce((acc, item) => {
        const index2 = newIds.indexOf(item.uid);
        if (index2 > -1) {
          acc.push(item);
          newNodesCopy.splice(index2, 1);
          newIds.splice(index2, 1);
        }
        return acc;
      }, []);
      res.push(...newNodesCopy);
      return res;
    };
    const _sfc_main$1G = defineComponent({
      name: "ElCascaderPanel",
      components: {
        ElCascaderMenu
      },
      props: {
        ...CommonProps,
        border: {
          type: Boolean,
          default: true
        },
        renderLabel: Function
      },
      emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, "close", "expand-change"],
      setup(props, { emit, slots }) {
        let manualChecked = false;
        const ns2 = useNamespace("cascader");
        const config = useCascaderConfig(props);
        let store = null;
        const initialLoaded = ref(true);
        const menuList = ref([]);
        const checkedValue = ref(null);
        const menus = ref([]);
        const expandingNode = ref(null);
        const checkedNodes = ref([]);
        const isHoverMenu = computed(() => config.value.expandTrigger === "hover");
        const renderLabelFn = computed(() => props.renderLabel || slots.default);
        const initStore = () => {
          const { options } = props;
          const cfg = config.value;
          manualChecked = false;
          store = new Store(options, cfg);
          menus.value = [store.getNodes()];
          if (cfg.lazy && isEmpty(props.options)) {
            initialLoaded.value = false;
            lazyLoad(void 0, (list) => {
              if (list) {
                store = new Store(list, cfg);
                menus.value = [store.getNodes()];
              }
              initialLoaded.value = true;
              syncCheckedValue(false, true);
            });
          } else {
            syncCheckedValue(false, true);
          }
        };
        const lazyLoad = (node, cb) => {
          const cfg = config.value;
          node = node || new Node$1({}, cfg, void 0, true);
          node.loading = true;
          const resolve2 = (dataList) => {
            const _node = node;
            const parent = _node.root ? null : _node;
            dataList && (store == null ? void 0 : store.appendNodes(dataList, parent));
            _node.loading = false;
            _node.loaded = true;
            _node.childrenData = _node.childrenData || [];
            cb && cb(dataList);
          };
          cfg.lazyLoad(node, resolve2);
        };
        const expandNode = (node, silent) => {
          var _a2;
          const { level } = node;
          const newMenus = menus.value.slice(0, level);
          let newExpandingNode;
          if (node.isLeaf) {
            newExpandingNode = node.pathNodes[level - 2];
          } else {
            newExpandingNode = node;
            newMenus.push(node.children);
          }
          if (((_a2 = expandingNode.value) == null ? void 0 : _a2.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {
            expandingNode.value = node;
            menus.value = newMenus;
            !silent && emit("expand-change", (node == null ? void 0 : node.pathValues) || []);
          }
        };
        const handleCheckChange = (node, checked, emitClose = true) => {
          const { checkStrictly, multiple } = config.value;
          const oldNode = checkedNodes.value[0];
          manualChecked = true;
          !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));
          node.doCheck(checked);
          calculateCheckedValue();
          emitClose && !multiple && !checkStrictly && emit("close");
          !emitClose && !multiple && !checkStrictly && expandParentNode(node);
        };
        const expandParentNode = (node) => {
          if (!node)
            return;
          node = node.parent;
          expandParentNode(node);
          node && expandNode(node);
        };
        const getFlattedNodes = (leafOnly) => {
          return store == null ? void 0 : store.getFlattedNodes(leafOnly);
        };
        const getCheckedNodes = (leafOnly) => {
          var _a2;
          return (_a2 = getFlattedNodes(leafOnly)) == null ? void 0 : _a2.filter((node) => node.checked !== false);
        };
        const clearCheckedNodes = () => {
          checkedNodes.value.forEach((node) => node.doCheck(false));
          calculateCheckedValue();
        };
        const calculateCheckedValue = () => {
          var _a2;
          const { checkStrictly, multiple } = config.value;
          const oldNodes = checkedNodes.value;
          const newNodes = getCheckedNodes(!checkStrictly);
          const nodes = sortByOriginalOrder(oldNodes, newNodes);
          const values = nodes.map((node) => node.valueByOption);
          checkedNodes.value = nodes;
          checkedValue.value = multiple ? values : (_a2 = values[0]) != null ? _a2 : null;
        };
        const syncCheckedValue = (loaded = false, forced = false) => {
          const { modelValue } = props;
          const { lazy, multiple, checkStrictly } = config.value;
          const leafOnly = !checkStrictly;
          if (!initialLoaded.value || manualChecked || !forced && isEqual$1(modelValue, checkedValue.value))
            return;
          if (lazy && !loaded) {
            const values = unique(flattenDeep(castArray(modelValue)));
            const nodes = values.map((val) => store == null ? void 0 : store.getNodeByValue(val)).filter((node) => !!node && !node.loaded && !node.loading);
            if (nodes.length) {
              nodes.forEach((node) => {
                lazyLoad(node, () => syncCheckedValue(false, forced));
              });
            } else {
              syncCheckedValue(true, forced);
            }
          } else {
            const values = multiple ? castArray(modelValue) : [modelValue];
            const nodes = unique(values.map((val) => store == null ? void 0 : store.getNodeByValue(val, leafOnly)));
            syncMenuState(nodes, forced);
            checkedValue.value = modelValue;
          }
        };
        const syncMenuState = (newCheckedNodes, reserveExpandingState = true) => {
          const { checkStrictly } = config.value;
          const oldNodes = checkedNodes.value;
          const newNodes = newCheckedNodes.filter((node) => !!node && (checkStrictly || node.isLeaf));
          const oldExpandingNode = store == null ? void 0 : store.getSameNode(expandingNode.value);
          const newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];
          if (newExpandingNode) {
            newExpandingNode.pathNodes.forEach((node) => expandNode(node, true));
          } else {
            expandingNode.value = null;
          }
          oldNodes.forEach((node) => node.doCheck(false));
          newNodes.forEach((node) => node.doCheck(true));
          checkedNodes.value = newNodes;
          nextTick(scrollToExpandingNode);
        };
        const scrollToExpandingNode = () => {
          if (!isClient)
            return;
          menuList.value.forEach((menu) => {
            const menuElement = menu == null ? void 0 : menu.$el;
            if (menuElement) {
              const container = menuElement.querySelector(`.${ns2.namespace.value}-scrollbar__wrap`);
              const activeNode = menuElement.querySelector(`.${ns2.b("node")}.${ns2.is("active")}`) || menuElement.querySelector(`.${ns2.b("node")}.in-active-path`);
              scrollIntoView(container, activeNode);
            }
          });
        };
        const handleKeyDown = (e) => {
          const target = e.target;
          const { code: code2 } = e;
          switch (code2) {
            case EVENT_CODE.up:
            case EVENT_CODE.down: {
              e.preventDefault();
              const distance = code2 === EVENT_CODE.up ? -1 : 1;
              focusNode(getSibling(target, distance, `.${ns2.b("node")}[tabindex="-1"]`));
              break;
            }
            case EVENT_CODE.left: {
              e.preventDefault();
              const preMenu = menuList.value[getMenuIndex(target) - 1];
              const expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector(`.${ns2.b("node")}[aria-expanded="true"]`);
              focusNode(expandedNode);
              break;
            }
            case EVENT_CODE.right: {
              e.preventDefault();
              const nextMenu = menuList.value[getMenuIndex(target) + 1];
              const firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector(`.${ns2.b("node")}[tabindex="-1"]`);
              focusNode(firstNode);
              break;
            }
            case EVENT_CODE.enter:
              checkNode(target);
              break;
          }
        };
        provide(CASCADER_PANEL_INJECTION_KEY, reactive({
          config,
          expandingNode,
          checkedNodes,
          isHoverMenu,
          initialLoaded,
          renderLabelFn,
          lazyLoad,
          expandNode,
          handleCheckChange
        }));
        watch([config, () => props.options], initStore, {
          deep: true,
          immediate: true
        });
        watch(() => props.modelValue, () => {
          manualChecked = false;
          syncCheckedValue();
        });
        watch(checkedValue, (val) => {
          if (!isEqual$1(val, props.modelValue)) {
            emit(UPDATE_MODEL_EVENT, val);
            emit(CHANGE_EVENT, val);
          }
        });
        onBeforeUpdate(() => menuList.value = []);
        onMounted(() => !isEmpty(props.modelValue) && syncCheckedValue());
        return {
          ns: ns2,
          menuList,
          menus,
          checkedNodes,
          handleKeyDown,
          handleCheckChange,
          getFlattedNodes,
          getCheckedNodes,
          clearCheckedNodes,
          calculateCheckedValue,
          scrollToExpandingNode
        };
      }
    });
    function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_cascader_menu = resolveComponent("el-cascader-menu");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.ns.b("panel"), _ctx.ns.is("bordered", _ctx.border)]),
        onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args))
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.menus, (menu, index2) => {
          return openBlock(), createBlock(_component_el_cascader_menu, {
            key: index2,
            ref_for: true,
            ref: (item) => _ctx.menuList[index2] = item,
            index: index2,
            nodes: [...menu]
          }, null, 8, ["index", "nodes"]);
        }), 128))
      ], 34);
    }
    var CascaderPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1G, [["render", _sfc_render$y], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue"]]);
    CascaderPanel.install = (app2) => {
      app2.component(CascaderPanel.name, CascaderPanel);
    };
    const _CascaderPanel = CascaderPanel;
    const ElCascaderPanel = _CascaderPanel;
    const tagProps = buildProps({
      closable: Boolean,
      type: {
        type: String,
        values: ["success", "info", "warning", "danger", ""],
        default: ""
      },
      hit: Boolean,
      disableTransitions: Boolean,
      color: {
        type: String,
        default: ""
      },
      size: {
        type: String,
        values: componentSizes,
        default: ""
      },
      effect: {
        type: String,
        values: ["dark", "light", "plain"],
        default: "light"
      },
      round: Boolean
    });
    const tagEmits = {
      close: (evt) => evt instanceof MouseEvent,
      click: (evt) => evt instanceof MouseEvent
    };
    const __default__$Z = {
      name: "ElTag"
    };
    const _sfc_main$1F = /* @__PURE__ */ defineComponent({
      ...__default__$Z,
      props: tagProps,
      emits: tagEmits,
      setup(__props, { emit }) {
        const props = __props;
        const tagSize = useSize();
        const ns2 = useNamespace("tag");
        const classes = computed(() => {
          const { type: type2, hit, effect, closable, round: round2 } = props;
          return [
            ns2.b(),
            ns2.is("closable", closable),
            ns2.m(type2),
            ns2.m(tagSize.value),
            ns2.m(effect),
            ns2.is("hit", hit),
            ns2.is("round", round2)
          ];
        });
        const handleClose = (event) => {
          emit("close", event);
        };
        const handleClick = (event) => {
          emit("click", event);
        };
        return (_ctx, _cache) => {
          return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass(unref(classes)),
            style: normalizeStyle({ backgroundColor: _ctx.color }),
            onClick: handleClick
          }, [
            createBaseVNode("span", {
              class: normalizeClass(unref(ns2).e("content"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2),
            _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
              key: 0,
              class: normalizeClass(unref(ns2).e("close")),
              onClick: withModifiers(handleClose, ["stop"])
            }, {
              default: withCtx(() => [
                createVNode(unref(close_default))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
          ], 6)) : (openBlock(), createBlock(Transition, {
            key: 1,
            name: `${unref(ns2).namespace.value}-zoom-in-center`,
            appear: ""
          }, {
            default: withCtx(() => [
              createBaseVNode("span", {
                class: normalizeClass(unref(classes)),
                style: normalizeStyle({ backgroundColor: _ctx.color }),
                onClick: handleClick
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(unref(ns2).e("content"))
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2),
                _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(ns2).e("close")),
                  onClick: withModifiers(handleClose, ["stop"])
                }, {
                  default: withCtx(() => [
                    createVNode(unref(close_default))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
              ], 6)
            ]),
            _: 3
          }, 8, ["name"]));
        };
      }
    });
    var Tag = /* @__PURE__ */ _export_sfc(_sfc_main$1F, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
    const ElTag = withInstall(Tag);
    const DEFAULT_INPUT_HEIGHT = 40;
    const INPUT_HEIGHT_MAP = {
      large: 36,
      default: 32,
      small: 28
    };
    const popperOptions = {
      modifiers: [
        {
          name: "arrowPosition",
          enabled: true,
          phase: "main",
          fn: ({ state }) => {
            const { modifiersData, placement } = state;
            if (["right", "left", "bottom", "top"].includes(placement))
              return;
            modifiersData.arrow.x = 35;
          },
          requires: ["arrow"]
        }
      ]
    };
    const COMPONENT_NAME$a = "ElCascader";
    const _sfc_main$1E = defineComponent({
      name: COMPONENT_NAME$a,
      components: {
        ElCascaderPanel: _CascaderPanel,
        ElInput,
        ElTooltip,
        ElScrollbar,
        ElTag,
        ElIcon,
        CircleClose: circle_close_default,
        Check: check_default,
        ArrowDown: arrow_down_default
      },
      directives: {
        Clickoutside: ClickOutside
      },
      props: {
        ...CommonProps,
        size: {
          type: String,
          validator: isValidComponentSize
        },
        placeholder: {
          type: String
        },
        disabled: Boolean,
        clearable: Boolean,
        filterable: Boolean,
        filterMethod: {
          type: Function,
          default: (node, keyword) => node.text.includes(keyword)
        },
        separator: {
          type: String,
          default: " / "
        },
        showAllLevels: {
          type: Boolean,
          default: true
        },
        collapseTags: Boolean,
        collapseTagsTooltip: {
          type: Boolean,
          default: false
        },
        debounce: {
          type: Number,
          default: 300
        },
        beforeFilter: {
          type: Function,
          default: () => true
        },
        popperClass: {
          type: String,
          default: ""
        },
        teleported: useTooltipContentProps.teleported,
        tagType: { ...tagProps.type, default: "info" },
        validateEvent: {
          type: Boolean,
          default: true
        }
      },
      emits: [
        UPDATE_MODEL_EVENT,
        CHANGE_EVENT,
        "focus",
        "blur",
        "visible-change",
        "expand-change",
        "remove-tag"
      ],
      setup(props, { emit }) {
        let inputInitialHeight = 0;
        let pressDeleteCount = 0;
        const nsCascader = useNamespace("cascader");
        const nsInput = useNamespace("input");
        const { t } = useLocale();
        const { form, formItem } = useFormItem();
        const tooltipRef = ref(null);
        const input = ref(null);
        const tagWrapper = ref(null);
        const panel = ref(null);
        const suggestionPanel = ref(null);
        const popperVisible = ref(false);
        const inputHover = ref(false);
        const filtering = ref(false);
        const inputValue = ref("");
        const searchInputValue = ref("");
        const presentTags = ref([]);
        const allPresentTags = ref([]);
        const suggestions = ref([]);
        const isOnComposition = ref(false);
        const isDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled));
        const inputPlaceholder = computed(() => props.placeholder || t("el.cascader.placeholder"));
        const realSize = useSize();
        const tagSize = computed(() => ["small"].includes(realSize.value) ? "small" : "default");
        const multiple = computed(() => !!props.props.multiple);
        const readonly2 = computed(() => !props.filterable || multiple.value);
        const searchKeyword = computed(() => multiple.value ? searchInputValue.value : inputValue.value);
        const checkedNodes = computed(() => {
          var _a2;
          return ((_a2 = panel.value) == null ? void 0 : _a2.checkedNodes) || [];
        });
        const clearBtnVisible = computed(() => {
          if (!props.clearable || isDisabled.value || filtering.value || !inputHover.value)
            return false;
          return !!checkedNodes.value.length;
        });
        const presentText = computed(() => {
          const { showAllLevels, separator } = props;
          const nodes = checkedNodes.value;
          return nodes.length ? multiple.value ? " " : nodes[0].calcText(showAllLevels, separator) : "";
        });
        const checkedValue = computed({
          get() {
            return props.modelValue;
          },
          set(val) {
            emit(UPDATE_MODEL_EVENT, val);
            emit(CHANGE_EVENT, val);
            if (props.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
          }
        });
        const popperPaneRef = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
        });
        const togglePopperVisible = (visible) => {
          var _a2, _b, _c;
          if (isDisabled.value)
            return;
          visible = visible != null ? visible : !popperVisible.value;
          if (visible !== popperVisible.value) {
            popperVisible.value = visible;
            (_b = (_a2 = input.value) == null ? void 0 : _a2.input) == null ? void 0 : _b.setAttribute("aria-expanded", `${visible}`);
            if (visible) {
              updatePopperPosition();
              nextTick((_c = panel.value) == null ? void 0 : _c.scrollToExpandingNode);
            } else if (props.filterable) {
              syncPresentTextValue();
            }
            emit("visible-change", visible);
          }
        };
        const updatePopperPosition = () => {
          nextTick(() => {
            var _a2;
            (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper();
          });
        };
        const hideSuggestionPanel = () => {
          filtering.value = false;
        };
        const genTag2 = (node) => {
          const { showAllLevels, separator } = props;
          return {
            node,
            key: node.uid,
            text: node.calcText(showAllLevels, separator),
            hitState: false,
            closable: !isDisabled.value && !node.isDisabled,
            isCollapseTag: false
          };
        };
        const deleteTag = (tag) => {
          var _a2;
          const node = tag.node;
          node.doCheck(false);
          (_a2 = panel.value) == null ? void 0 : _a2.calculateCheckedValue();
          emit("remove-tag", node.valueByOption);
        };
        const calculatePresentTags = () => {
          if (!multiple.value)
            return;
          const nodes = checkedNodes.value;
          const tags = [];
          const allTags = [];
          nodes.forEach((node) => allTags.push(genTag2(node)));
          allPresentTags.value = allTags;
          if (nodes.length) {
            const [first, ...rest] = nodes;
            const restCount = rest.length;
            tags.push(genTag2(first));
            if (restCount) {
              if (props.collapseTags) {
                tags.push({
                  key: -1,
                  text: `+ ${restCount}`,
                  closable: false,
                  isCollapseTag: true
                });
              } else {
                rest.forEach((node) => tags.push(genTag2(node)));
              }
            }
          }
          presentTags.value = tags;
        };
        const calculateSuggestions = () => {
          var _a2, _b;
          const { filterMethod, showAllLevels, separator } = props;
          const res = (_b = (_a2 = panel.value) == null ? void 0 : _a2.getFlattedNodes(!props.props.checkStrictly)) == null ? void 0 : _b.filter((node) => {
            if (node.isDisabled)
              return false;
            node.calcText(showAllLevels, separator);
            return filterMethod(node, searchKeyword.value);
          });
          if (multiple.value) {
            presentTags.value.forEach((tag) => {
              tag.hitState = false;
            });
            allPresentTags.value.forEach((tag) => {
              tag.hitState = false;
            });
          }
          filtering.value = true;
          suggestions.value = res;
          updatePopperPosition();
        };
        const focusFirstNode = () => {
          var _a2;
          let firstNode;
          if (filtering.value && suggestionPanel.value) {
            firstNode = suggestionPanel.value.$el.querySelector(`.${nsCascader.e("suggestion-item")}`);
          } else {
            firstNode = (_a2 = panel.value) == null ? void 0 : _a2.$el.querySelector(`.${nsCascader.b("node")}[tabindex="-1"]`);
          }
          if (firstNode) {
            firstNode.focus();
            !filtering.value && firstNode.click();
          }
        };
        const updateStyle = () => {
          var _a2, _b;
          const inputInner = (_a2 = input.value) == null ? void 0 : _a2.input;
          const tagWrapperEl = tagWrapper.value;
          const suggestionPanelEl = (_b = suggestionPanel.value) == null ? void 0 : _b.$el;
          if (!isClient || !inputInner)
            return;
          if (suggestionPanelEl) {
            const suggestionList = suggestionPanelEl.querySelector(`.${nsCascader.e("suggestion-list")}`);
            suggestionList.style.minWidth = `${inputInner.offsetWidth}px`;
          }
          if (tagWrapperEl) {
            const { offsetHeight } = tagWrapperEl;
            const height = presentTags.value.length > 0 ? `${Math.max(offsetHeight + 6, inputInitialHeight)}px` : `${inputInitialHeight}px`;
            inputInner.style.height = height;
            updatePopperPosition();
          }
        };
        const getCheckedNodes = (leafOnly) => {
          var _a2;
          return (_a2 = panel.value) == null ? void 0 : _a2.getCheckedNodes(leafOnly);
        };
        const handleExpandChange = (value) => {
          updatePopperPosition();
          emit("expand-change", value);
        };
        const handleComposition = (event) => {
          var _a2;
          const text = (_a2 = event.target) == null ? void 0 : _a2.value;
          if (event.type === "compositionend") {
            isOnComposition.value = false;
            nextTick(() => handleInput(text));
          } else {
            const lastCharacter = text[text.length - 1] || "";
            isOnComposition.value = !isKorean(lastCharacter);
          }
        };
        const handleKeyDown = (e) => {
          if (isOnComposition.value)
            return;
          switch (e.code) {
            case EVENT_CODE.enter:
              togglePopperVisible();
              break;
            case EVENT_CODE.down:
              togglePopperVisible(true);
              nextTick(focusFirstNode);
              e.preventDefault();
              break;
            case EVENT_CODE.esc:
              if (popperVisible.value === true) {
                e.preventDefault();
                e.stopPropagation();
                togglePopperVisible(false);
              }
              break;
            case EVENT_CODE.tab:
              togglePopperVisible(false);
              break;
          }
        };
        const handleClear = () => {
          var _a2;
          (_a2 = panel.value) == null ? void 0 : _a2.clearCheckedNodes();
          if (!popperVisible.value && props.filterable) {
            syncPresentTextValue();
          }
          togglePopperVisible(false);
        };
        const syncPresentTextValue = () => {
          const { value } = presentText;
          inputValue.value = value;
          searchInputValue.value = value;
        };
        const handleSuggestionClick = (node) => {
          var _a2, _b;
          const { checked } = node;
          if (multiple.value) {
            (_a2 = panel.value) == null ? void 0 : _a2.handleCheckChange(node, !checked, false);
          } else {
            !checked && ((_b = panel.value) == null ? void 0 : _b.handleCheckChange(node, true, false));
            togglePopperVisible(false);
          }
        };
        const handleSuggestionKeyDown = (e) => {
          const target = e.target;
          const { code: code2 } = e;
          switch (code2) {
            case EVENT_CODE.up:
            case EVENT_CODE.down: {
              const distance = code2 === EVENT_CODE.up ? -1 : 1;
              focusNode(getSibling(target, distance, `.${nsCascader.e("suggestion-item")}[tabindex="-1"]`));
              break;
            }
            case EVENT_CODE.enter:
              target.click();
              break;
          }
        };
        const handleDelete = () => {
          const tags = presentTags.value;
          const lastTag = tags[tags.length - 1];
          pressDeleteCount = searchInputValue.value ? 0 : pressDeleteCount + 1;
          if (!lastTag || !pressDeleteCount || props.collapseTags && tags.length > 1)
            return;
          if (lastTag.hitState) {
            deleteTag(lastTag);
          } else {
            lastTag.hitState = true;
          }
        };
        const handleFilter = debounce(() => {
          const { value } = searchKeyword;
          if (!value)
            return;
          const passed = props.beforeFilter(value);
          if (isPromise(passed)) {
            passed.then(calculateSuggestions).catch(() => {
            });
          } else if (passed !== false) {
            calculateSuggestions();
          } else {
            hideSuggestionPanel();
          }
        }, props.debounce);
        const handleInput = (val, e) => {
          !popperVisible.value && togglePopperVisible(true);
          if (e == null ? void 0 : e.isComposing)
            return;
          val ? handleFilter() : hideSuggestionPanel();
        };
        watch(filtering, updatePopperPosition);
        watch([checkedNodes, isDisabled], calculatePresentTags);
        watch(presentTags, () => {
          nextTick(() => updateStyle());
        });
        watch(presentText, (val) => inputValue.value = val, { immediate: true });
        onMounted(() => {
          var _a2;
          const inputEl = (_a2 = input.value) == null ? void 0 : _a2.$el;
          inputInitialHeight = (inputEl == null ? void 0 : inputEl.offsetHeight) || INPUT_HEIGHT_MAP[realSize.value] || DEFAULT_INPUT_HEIGHT;
          useResizeObserver(inputEl, updateStyle);
        });
        return {
          popperOptions,
          tooltipRef,
          popperPaneRef,
          input,
          tagWrapper,
          panel,
          suggestionPanel,
          popperVisible,
          inputHover,
          inputPlaceholder,
          filtering,
          presentText,
          checkedValue,
          inputValue,
          searchInputValue,
          presentTags,
          allPresentTags,
          suggestions,
          isDisabled,
          isOnComposition,
          realSize,
          tagSize,
          multiple,
          readonly: readonly2,
          clearBtnVisible,
          nsCascader,
          nsInput,
          t,
          togglePopperVisible,
          hideSuggestionPanel,
          deleteTag,
          focusFirstNode,
          getCheckedNodes,
          handleExpandChange,
          handleKeyDown,
          handleComposition,
          handleClear,
          handleSuggestionClick,
          handleSuggestionKeyDown,
          handleDelete,
          handleInput
        };
      }
    });
    const _hoisted_1$Q = { key: 0 };
    const _hoisted_2$y = ["placeholder"];
    const _hoisted_3$k = ["onClick"];
    function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_circle_close = resolveComponent("circle-close");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_arrow_down = resolveComponent("arrow-down");
      const _component_el_input = resolveComponent("el-input");
      const _component_el_tag = resolveComponent("el-tag");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _component_el_cascader_panel = resolveComponent("el-cascader-panel");
      const _component_check = resolveComponent("check");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _directive_clickoutside = resolveDirective("clickoutside");
      return openBlock(), createBlock(_component_el_tooltip, {
        ref: "tooltipRef",
        visible: _ctx.popperVisible,
        teleported: _ctx.teleported,
        "popper-class": [_ctx.nsCascader.e("dropdown"), _ctx.popperClass],
        "popper-options": _ctx.popperOptions,
        "fallback-placements": [
          "bottom-start",
          "bottom",
          "top-start",
          "top",
          "right",
          "left"
        ],
        "stop-popper-mouse-event": false,
        "gpu-acceleration": false,
        placement: "bottom-start",
        transition: `${_ctx.nsCascader.namespace.value}-zoom-in-top`,
        effect: "light",
        pure: "",
        persistent: "",
        onHide: _ctx.hideSuggestionPanel
      }, {
        default: withCtx(() => [
          withDirectives((openBlock(), createElementBlock("div", {
            class: normalizeClass([
              _ctx.nsCascader.b(),
              _ctx.nsCascader.m(_ctx.realSize),
              _ctx.nsCascader.is("disabled", _ctx.isDisabled),
              _ctx.$attrs.class
            ]),
            style: normalizeStyle(_ctx.$attrs.style),
            onClick: _cache[11] || (_cache[11] = () => _ctx.togglePopperVisible(_ctx.readonly ? void 0 : true)),
            onKeydown: _cache[12] || (_cache[12] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args)),
            onMouseenter: _cache[13] || (_cache[13] = ($event) => _ctx.inputHover = true),
            onMouseleave: _cache[14] || (_cache[14] = ($event) => _ctx.inputHover = false)
          }, [
            createVNode(_component_el_input, {
              ref: "input",
              modelValue: _ctx.inputValue,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.inputValue = $event),
              placeholder: _ctx.searchInputValue ? "" : _ctx.inputPlaceholder,
              readonly: _ctx.readonly,
              disabled: _ctx.isDisabled,
              "validate-event": false,
              size: _ctx.realSize,
              class: normalizeClass(_ctx.nsCascader.is("focus", _ctx.popperVisible)),
              onCompositionstart: _ctx.handleComposition,
              onCompositionupdate: _ctx.handleComposition,
              onCompositionend: _ctx.handleComposition,
              onFocus: _cache[2] || (_cache[2] = (e) => _ctx.$emit("focus", e)),
              onBlur: _cache[3] || (_cache[3] = (e) => _ctx.$emit("blur", e)),
              onInput: _ctx.handleInput
            }, {
              suffix: withCtx(() => [
                _ctx.clearBtnVisible ? (openBlock(), createBlock(_component_el_icon, {
                  key: "clear",
                  class: normalizeClass([_ctx.nsInput.e("icon"), "icon-circle-close"]),
                  onClick: withModifiers(_ctx.handleClear, ["stop"])
                }, {
                  default: withCtx(() => [
                    createVNode(_component_circle_close)
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : (openBlock(), createBlock(_component_el_icon, {
                  key: "arrow-down",
                  class: normalizeClass([
                    _ctx.nsInput.e("icon"),
                    "icon-arrow-down",
                    _ctx.nsCascader.is("reverse", _ctx.popperVisible)
                  ]),
                  onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.togglePopperVisible(), ["stop"]))
                }, {
                  default: withCtx(() => [
                    createVNode(_component_arrow_down)
                  ]),
                  _: 1
                }, 8, ["class"]))
              ]),
              _: 1
            }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onInput"]),
            _ctx.multiple ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "tagWrapper",
              class: normalizeClass(_ctx.nsCascader.e("tags"))
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.presentTags, (tag) => {
                return openBlock(), createBlock(_component_el_tag, {
                  key: tag.key,
                  type: _ctx.tagType,
                  size: _ctx.tagSize,
                  hit: tag.hitState,
                  closable: tag.closable,
                  "disable-transitions": "",
                  onClose: ($event) => _ctx.deleteTag(tag)
                }, {
                  default: withCtx(() => [
                    tag.isCollapseTag === false ? (openBlock(), createElementBlock("span", _hoisted_1$Q, toDisplayString$1(tag.text), 1)) : (openBlock(), createBlock(_component_el_tooltip, {
                      key: 1,
                      teleported: false,
                      disabled: _ctx.popperVisible || !_ctx.collapseTagsTooltip,
                      "fallback-placements": ["bottom", "top", "right", "left"],
                      placement: "bottom",
                      effect: "light"
                    }, {
                      default: withCtx(() => [
                        createBaseVNode("span", null, toDisplayString$1(tag.text), 1)
                      ]),
                      content: withCtx(() => [
                        createBaseVNode("div", {
                          class: normalizeClass(_ctx.nsCascader.e("collapse-tags"))
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.allPresentTags.slice(1), (tag2, idx) => {
                            return openBlock(), createElementBlock("div", {
                              key: idx,
                              class: normalizeClass(_ctx.nsCascader.e("collapse-tag"))
                            }, [
                              (openBlock(), createBlock(_component_el_tag, {
                                key: tag2.key,
                                class: "in-tooltip",
                                type: _ctx.tagType,
                                size: _ctx.tagSize,
                                hit: tag2.hitState,
                                closable: tag2.closable,
                                "disable-transitions": "",
                                onClose: ($event) => _ctx.deleteTag(tag2)
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("span", null, toDisplayString$1(tag2.text), 1)
                                ]),
                                _: 2
                              }, 1032, ["type", "size", "hit", "closable", "onClose"]))
                            ], 2);
                          }), 128))
                        ], 2)
                      ]),
                      _: 2
                    }, 1032, ["disabled"]))
                  ]),
                  _: 2
                }, 1032, ["type", "size", "hit", "closable", "onClose"]);
              }), 128)),
              _ctx.filterable && !_ctx.isDisabled ? withDirectives((openBlock(), createElementBlock("input", {
                key: 0,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.searchInputValue = $event),
                type: "text",
                class: normalizeClass(_ctx.nsCascader.e("search-input")),
                placeholder: _ctx.presentText ? "" : _ctx.inputPlaceholder,
                onInput: _cache[5] || (_cache[5] = (e) => _ctx.handleInput(_ctx.searchInputValue, e)),
                onClick: _cache[6] || (_cache[6] = withModifiers(($event) => _ctx.togglePopperVisible(true), ["stop"])),
                onKeydown: _cache[7] || (_cache[7] = withKeys((...args) => _ctx.handleDelete && _ctx.handleDelete(...args), ["delete"])),
                onCompositionstart: _cache[8] || (_cache[8] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                onCompositionupdate: _cache[9] || (_cache[9] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                onCompositionend: _cache[10] || (_cache[10] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args))
              }, null, 42, _hoisted_2$y)), [
                [vModelText, _ctx.searchInputValue]
              ]) : createCommentVNode("v-if", true)
            ], 2)) : createCommentVNode("v-if", true)
          ], 38)), [
            [_directive_clickoutside, () => _ctx.togglePopperVisible(false), _ctx.popperPaneRef]
          ])
        ]),
        content: withCtx(() => [
          withDirectives(createVNode(_component_el_cascader_panel, {
            ref: "panel",
            modelValue: _ctx.checkedValue,
            "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => _ctx.checkedValue = $event),
            options: _ctx.options,
            props: _ctx.props,
            border: false,
            "render-label": _ctx.$slots.default,
            onExpandChange: _ctx.handleExpandChange,
            onClose: _cache[16] || (_cache[16] = ($event) => _ctx.$nextTick(() => _ctx.togglePopperVisible(false)))
          }, null, 8, ["modelValue", "options", "props", "render-label", "onExpandChange"]), [
            [vShow, !_ctx.filtering]
          ]),
          _ctx.filterable ? withDirectives((openBlock(), createBlock(_component_el_scrollbar, {
            key: 0,
            ref: "suggestionPanel",
            tag: "ul",
            class: normalizeClass(_ctx.nsCascader.e("suggestion-panel")),
            "view-class": _ctx.nsCascader.e("suggestion-list"),
            onKeydown: _ctx.handleSuggestionKeyDown
          }, {
            default: withCtx(() => [
              _ctx.suggestions.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.suggestions, (item) => {
                return openBlock(), createElementBlock("li", {
                  key: item.uid,
                  class: normalizeClass([
                    _ctx.nsCascader.e("suggestion-item"),
                    _ctx.nsCascader.is("checked", item.checked)
                  ]),
                  tabindex: -1,
                  onClick: ($event) => _ctx.handleSuggestionClick(item)
                }, [
                  createBaseVNode("span", null, toDisplayString$1(item.text), 1),
                  item.checked ? (openBlock(), createBlock(_component_el_icon, { key: 0 }, {
                    default: withCtx(() => [
                      createVNode(_component_check)
                    ]),
                    _: 1
                  })) : createCommentVNode("v-if", true)
                ], 10, _hoisted_3$k);
              }), 128)) : renderSlot(_ctx.$slots, "empty", { key: 1 }, () => [
                createBaseVNode("li", {
                  class: normalizeClass(_ctx.nsCascader.e("empty-text"))
                }, toDisplayString$1(_ctx.t("el.cascader.noMatch")), 3)
              ])
            ]),
            _: 3
          }, 8, ["class", "view-class", "onKeydown"])), [
            [vShow, _ctx.filtering]
          ]) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 8, ["visible", "teleported", "popper-class", "popper-options", "transition", "onHide"]);
    }
    var Cascader = /* @__PURE__ */ _export_sfc(_sfc_main$1E, [["render", _sfc_render$x], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader/src/index.vue"]]);
    Cascader.install = (app2) => {
      app2.component(Cascader.name, Cascader);
    };
    const _Cascader = Cascader;
    const ElCascader = _Cascader;
    const checkTagProps = buildProps({
      checked: {
        type: Boolean,
        default: false
      }
    });
    const checkTagEmits = {
      "update:checked": (value) => isBoolean$2(value),
      [CHANGE_EVENT]: (value) => isBoolean$2(value)
    };
    const __default__$Y = {
      name: "ElCheckTag"
    };
    const _sfc_main$1D = /* @__PURE__ */ defineComponent({
      ...__default__$Y,
      props: checkTagProps,
      emits: checkTagEmits,
      setup(__props, { emit }) {
        const props = __props;
        const ns2 = useNamespace("check-tag");
        const handleChange = () => {
          const checked = !props.checked;
          emit(CHANGE_EVENT, checked);
          emit("update:checked", checked);
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            class: normalizeClass([unref(ns2).b(), unref(ns2).is("checked", _ctx.checked)]),
            onClick: handleChange
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var CheckTag = /* @__PURE__ */ _export_sfc(_sfc_main$1D, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/check-tag/src/check-tag.vue"]]);
    const ElCheckTag = withInstall(CheckTag);
    const colProps = buildProps({
      tag: {
        type: String,
        default: "div"
      },
      span: {
        type: Number,
        default: 24
      },
      offset: {
        type: Number,
        default: 0
      },
      pull: {
        type: Number,
        default: 0
      },
      push: {
        type: Number,
        default: 0
      },
      xs: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      },
      sm: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      },
      md: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      },
      lg: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      },
      xl: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      }
    });
    const __default__$X = {
      name: "ElCol"
    };
    const _sfc_main$1C = /* @__PURE__ */ defineComponent({
      ...__default__$X,
      props: colProps,
      setup(__props) {
        const props = __props;
        const { gutter } = inject(rowContextKey, { gutter: computed(() => 0) });
        const ns2 = useNamespace("col");
        const style2 = computed(() => {
          const styles = {};
          if (gutter.value) {
            styles.paddingLeft = styles.paddingRight = `${gutter.value / 2}px`;
          }
          return styles;
        });
        const classes = computed(() => {
          const classes2 = [];
          const pos = ["span", "offset", "pull", "push"];
          pos.forEach((prop) => {
            const size2 = props[prop];
            if (isNumber$2(size2)) {
              if (prop === "span")
                classes2.push(ns2.b(`${props[prop]}`));
              else if (size2 > 0)
                classes2.push(ns2.b(`${prop}-${props[prop]}`));
            }
          });
          const sizes = ["xs", "sm", "md", "lg", "xl"];
          sizes.forEach((size2) => {
            if (isNumber$2(props[size2])) {
              classes2.push(ns2.b(`${size2}-${props[size2]}`));
            } else if (isObject$4(props[size2])) {
              Object.entries(props[size2]).forEach(([prop, sizeProp]) => {
                classes2.push(prop !== "span" ? ns2.b(`${size2}-${prop}-${sizeProp}`) : ns2.b(`${size2}-${sizeProp}`));
              });
            }
          });
          if (gutter.value) {
            classes2.push(ns2.is("guttered"));
          }
          return classes2;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
            class: normalizeClass([unref(ns2).b(), unref(classes)]),
            style: normalizeStyle(unref(style2))
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"]);
        };
      }
    });
    var Col = /* @__PURE__ */ _export_sfc(_sfc_main$1C, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/col/src/col.vue"]]);
    const ElCol = withInstall(Col);
    const emitChangeFn = (value) => typeof isNumber$2(value);
    const collapseProps = buildProps({
      accordion: Boolean,
      modelValue: {
        type: definePropType([Array, String, Number]),
        default: () => mutable([])
      }
    });
    const collapseEmits = {
      [UPDATE_MODEL_EVENT]: emitChangeFn,
      [CHANGE_EVENT]: emitChangeFn
    };
    const __default__$W = {
      name: "ElCollapse"
    };
    const _sfc_main$1B = /* @__PURE__ */ defineComponent({
      ...__default__$W,
      props: collapseProps,
      emits: collapseEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const ns2 = useNamespace("collapse");
        const activeNames = ref(castArray$1(props.modelValue));
        const setActiveNames = (_activeNames) => {
          activeNames.value = _activeNames;
          const value = props.accordion ? activeNames.value[0] : activeNames.value;
          emit(UPDATE_MODEL_EVENT, value);
          emit(CHANGE_EVENT, value);
        };
        const handleItemClick = (name) => {
          if (props.accordion) {
            setActiveNames([
              (activeNames.value[0] || activeNames.value[0] === 0) && activeNames.value[0] === name ? "" : name
            ]);
          } else {
            const _activeNames = [...activeNames.value];
            const index2 = _activeNames.indexOf(name);
            if (index2 > -1) {
              _activeNames.splice(index2, 1);
            } else {
              _activeNames.push(name);
            }
            setActiveNames(_activeNames);
          }
        };
        watch(() => props.modelValue, () => activeNames.value = castArray$1(props.modelValue), { deep: true });
        provide(collapseContextKey, {
          activeNames,
          handleItemClick
        });
        expose({
          activeNames,
          setActiveNames
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(ns2).b()),
            role: "tablist",
            "aria-multiselectable": "true"
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var Collapse = /* @__PURE__ */ _export_sfc(_sfc_main$1B, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse.vue"]]);
    const __default__$V = {
      name: "ElCollapseTransition"
    };
    const _sfc_main$1A = /* @__PURE__ */ defineComponent({
      ...__default__$V,
      setup(__props) {
        const ns2 = useNamespace("collapse-transition");
        const on2 = {
          beforeEnter(el) {
            if (!el.dataset)
              el.dataset = {};
            el.dataset.oldPaddingTop = el.style.paddingTop;
            el.dataset.oldPaddingBottom = el.style.paddingBottom;
            el.style.maxHeight = 0;
            el.style.paddingTop = 0;
            el.style.paddingBottom = 0;
          },
          enter(el) {
            el.dataset.oldOverflow = el.style.overflow;
            if (el.scrollHeight !== 0) {
              el.style.maxHeight = `${el.scrollHeight}px`;
              el.style.paddingTop = el.dataset.oldPaddingTop;
              el.style.paddingBottom = el.dataset.oldPaddingBottom;
            } else {
              el.style.maxHeight = 0;
              el.style.paddingTop = el.dataset.oldPaddingTop;
              el.style.paddingBottom = el.dataset.oldPaddingBottom;
            }
            el.style.overflow = "hidden";
          },
          afterEnter(el) {
            el.style.maxHeight = "";
            el.style.overflow = el.dataset.oldOverflow;
          },
          beforeLeave(el) {
            if (!el.dataset)
              el.dataset = {};
            el.dataset.oldPaddingTop = el.style.paddingTop;
            el.dataset.oldPaddingBottom = el.style.paddingBottom;
            el.dataset.oldOverflow = el.style.overflow;
            el.style.maxHeight = `${el.scrollHeight}px`;
            el.style.overflow = "hidden";
          },
          leave(el) {
            if (el.scrollHeight !== 0) {
              el.style.maxHeight = 0;
              el.style.paddingTop = 0;
              el.style.paddingBottom = 0;
            }
          },
          afterLeave(el) {
            el.style.maxHeight = "";
            el.style.overflow = el.dataset.oldOverflow;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          }
        };
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition, mergeProps({
            name: unref(ns2).b()
          }, toHandlers(on2)), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["name"]);
        };
      }
    });
    var CollapseTransition = /* @__PURE__ */ _export_sfc(_sfc_main$1A, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);
    CollapseTransition.install = (app2) => {
      app2.component(CollapseTransition.name, CollapseTransition);
    };
    const _CollapseTransition = CollapseTransition;
    const ElCollapseTransition = _CollapseTransition;
    const collapseItemProps = buildProps({
      title: {
        type: String,
        default: ""
      },
      name: {
        type: definePropType([String, Number]),
        default: () => generateId()
      },
      disabled: Boolean
    });
    const _hoisted_1$P = ["aria-expanded", "aria-controls", "aria-describedby"];
    const _hoisted_2$x = ["id", "tabindex", "onKeypress"];
    const _hoisted_3$j = ["id", "aria-hidden", "aria-labelledby"];
    const __default__$U = {
      name: "ElCollapseItem"
    };
    const _sfc_main$1z = /* @__PURE__ */ defineComponent({
      ...__default__$U,
      props: collapseItemProps,
      setup(__props, { expose }) {
        const props = __props;
        const collapse = inject(collapseContextKey);
        const ns2 = useNamespace("collapse");
        const focusing = ref(false);
        const isClick = ref(false);
        const id2 = ref(generateId());
        const isActive = computed(() => collapse == null ? void 0 : collapse.activeNames.value.includes(props.name));
        const handleFocus = () => {
          setTimeout(() => {
            if (!isClick.value) {
              focusing.value = true;
            } else {
              isClick.value = false;
            }
          }, 50);
        };
        const handleHeaderClick = () => {
          if (props.disabled)
            return;
          collapse == null ? void 0 : collapse.handleItemClick(props.name);
          focusing.value = false;
          isClick.value = true;
        };
        const handleEnterClick = () => {
          collapse == null ? void 0 : collapse.handleItemClick(props.name);
        };
        expose({
          isActive
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([
              unref(ns2).b("item"),
              unref(ns2).is("active", unref(isActive)),
              unref(ns2).is("disabled", _ctx.disabled)
            ])
          }, [
            createBaseVNode("div", {
              role: "tab",
              "aria-expanded": unref(isActive),
              "aria-controls": unref(ns2).b(`content-${id2.value}`),
              "aria-describedby": unref(ns2).b(`content-${id2.value}`)
            }, [
              createBaseVNode("div", {
                id: unref(ns2).b(`head-${id2.value}`),
                class: normalizeClass([
                  unref(ns2).be("item", "header"),
                  unref(ns2).is("active", unref(isActive)),
                  { focusing: focusing.value && !_ctx.disabled }
                ]),
                role: "button",
                tabindex: _ctx.disabled ? -1 : 0,
                onClick: handleHeaderClick,
                onKeypress: withKeys(withModifiers(handleEnterClick, ["stop", "prevent"]), ["space", "enter"]),
                onFocus: handleFocus,
                onBlur: _cache[0] || (_cache[0] = ($event) => focusing.value = false)
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString$1(_ctx.title), 1)
                ]),
                createVNode(unref(ElIcon), {
                  class: normalizeClass([unref(ns2).be("item", "arrow"), unref(ns2).is("active", unref(isActive))])
                }, {
                  default: withCtx(() => [
                    createVNode(unref(arrow_right_default))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 42, _hoisted_2$x)
            ], 8, _hoisted_1$P),
            createVNode(unref(_CollapseTransition), null, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  id: unref(ns2).b(`content-${id2.value}`),
                  class: normalizeClass(unref(ns2).be("item", "wrap")),
                  role: "tabpanel",
                  "aria-hidden": !unref(isActive),
                  "aria-labelledby": unref(ns2).b(`head-${id2.value}`)
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns2).be("item", "content"))
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 2)
                ], 10, _hoisted_3$j), [
                  [vShow, unref(isActive)]
                ])
              ]),
              _: 3
            })
          ], 2);
        };
      }
    });
    var CollapseItem = /* @__PURE__ */ _export_sfc(_sfc_main$1z, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse-item.vue"]]);
    const ElCollapse = withInstall(Collapse, {
      CollapseItem
    });
    const ElCollapseItem = withNoopInstall(CollapseItem);
    let isDragging = false;
    function draggable(element, options) {
      if (!isClient)
        return;
      const moveFn = function(event) {
        var _a2;
        (_a2 = options.drag) == null ? void 0 : _a2.call(options, event);
      };
      const upFn = function(event) {
        var _a2;
        document.removeEventListener("mousemove", moveFn);
        document.removeEventListener("mouseup", upFn);
        document.removeEventListener("touchmove", moveFn);
        document.removeEventListener("touchend", upFn);
        document.onselectstart = null;
        document.ondragstart = null;
        isDragging = false;
        (_a2 = options.end) == null ? void 0 : _a2.call(options, event);
      };
      const downFn = function(event) {
        var _a2;
        if (isDragging)
          return;
        event.preventDefault();
        document.onselectstart = () => false;
        document.ondragstart = () => false;
        document.addEventListener("mousemove", moveFn);
        document.addEventListener("mouseup", upFn);
        document.addEventListener("touchmove", moveFn);
        document.addEventListener("touchend", upFn);
        isDragging = true;
        (_a2 = options.start) == null ? void 0 : _a2.call(options, event);
      };
      element.addEventListener("mousedown", downFn);
      element.addEventListener("touchstart", downFn);
    }
    const _sfc_main$1y = defineComponent({
      name: "ElColorAlphaSlider",
      props: {
        color: {
          type: Object,
          required: true
        },
        vertical: {
          type: Boolean,
          default: false
        }
      },
      setup(props) {
        const ns2 = useNamespace("color-alpha-slider");
        const instance = getCurrentInstance();
        const thumb = shallowRef(null);
        const bar = shallowRef(null);
        const thumbLeft = ref(0);
        const thumbTop = ref(0);
        const background = ref(null);
        watch(() => props.color.get("alpha"), () => {
          update();
        });
        watch(() => props.color.value, () => {
          update();
        });
        function getThumbLeft() {
          if (props.vertical)
            return 0;
          const el = instance.vnode.el;
          const alpha = props.color.get("alpha");
          if (!el)
            return 0;
          return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);
        }
        function getThumbTop() {
          const el = instance.vnode.el;
          if (!props.vertical)
            return 0;
          const alpha = props.color.get("alpha");
          if (!el)
            return 0;
          return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);
        }
        function getBackground() {
          if (props.color && props.color.value) {
            const { r, g, b: b2 } = props.color.toRgb();
            return `linear-gradient(to right, rgba(${r}, ${g}, ${b2}, 0) 0%, rgba(${r}, ${g}, ${b2}, 1) 100%)`;
          }
          return null;
        }
        function handleClick(event) {
          const target = event.target;
          if (target !== thumb.value) {
            handleDrag(event);
          }
        }
        function handleDrag(event) {
          const el = instance.vnode.el;
          const rect = el.getBoundingClientRect();
          const { clientX, clientY } = getClientXY(event);
          if (!props.vertical) {
            let left2 = clientX - rect.left;
            left2 = Math.max(thumb.value.offsetWidth / 2, left2);
            left2 = Math.min(left2, rect.width - thumb.value.offsetWidth / 2);
            props.color.set("alpha", Math.round((left2 - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));
          } else {
            let top = clientY - rect.top;
            top = Math.max(thumb.value.offsetHeight / 2, top);
            top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
            props.color.set("alpha", Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));
          }
        }
        function update() {
          thumbLeft.value = getThumbLeft();
          thumbTop.value = getThumbTop();
          background.value = getBackground();
        }
        onMounted(() => {
          const dragConfig = {
            drag: (event) => {
              handleDrag(event);
            },
            end: (event) => {
              handleDrag(event);
            }
          };
          draggable(bar.value, dragConfig);
          draggable(thumb.value, dragConfig);
          update();
        });
        return {
          thumb,
          bar,
          thumbLeft,
          thumbTop,
          background,
          handleClick,
          update,
          ns: ns2
        };
      }
    });
    function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("vertical", _ctx.vertical)])
      }, [
        createBaseVNode("div", {
          ref: "bar",
          class: normalizeClass(_ctx.ns.e("bar")),
          style: normalizeStyle({
            background: _ctx.background
          }),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
        }, null, 6),
        createBaseVNode("div", {
          ref: "thumb",
          class: normalizeClass(_ctx.ns.e("thumb")),
          style: normalizeStyle({
            left: _ctx.thumbLeft + "px",
            top: _ctx.thumbTop + "px"
          })
        }, null, 6)
      ], 2);
    }
    var AlphaSlider = /* @__PURE__ */ _export_sfc(_sfc_main$1y, [["render", _sfc_render$w], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/alpha-slider.vue"]]);
    const _sfc_main$1x = defineComponent({
      name: "ElColorHueSlider",
      props: {
        color: {
          type: Object,
          required: true
        },
        vertical: Boolean
      },
      setup(props) {
        const ns2 = useNamespace("color-hue-slider");
        const instance = getCurrentInstance();
        const thumb = ref(null);
        const bar = ref(null);
        const thumbLeft = ref(0);
        const thumbTop = ref(0);
        const hueValue = computed(() => {
          return props.color.get("hue");
        });
        watch(() => hueValue.value, () => {
          update();
        });
        function handleClick(event) {
          const target = event.target;
          if (target !== thumb.value) {
            handleDrag(event);
          }
        }
        function handleDrag(event) {
          const el = instance.vnode.el;
          const rect = el.getBoundingClientRect();
          const { clientX, clientY } = getClientXY(event);
          let hue;
          if (!props.vertical) {
            let left2 = clientX - rect.left;
            left2 = Math.min(left2, rect.width - thumb.value.offsetWidth / 2);
            left2 = Math.max(thumb.value.offsetWidth / 2, left2);
            hue = Math.round((left2 - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 360);
          } else {
            let top = clientY - rect.top;
            top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
            top = Math.max(thumb.value.offsetHeight / 2, top);
            hue = Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 360);
          }
          props.color.set("hue", hue);
        }
        function getThumbLeft() {
          const el = instance.vnode.el;
          if (props.vertical)
            return 0;
          const hue = props.color.get("hue");
          if (!el)
            return 0;
          return Math.round(hue * (el.offsetWidth - thumb.value.offsetWidth / 2) / 360);
        }
        function getThumbTop() {
          const el = instance.vnode.el;
          if (!props.vertical)
            return 0;
          const hue = props.color.get("hue");
          if (!el)
            return 0;
          return Math.round(hue * (el.offsetHeight - thumb.value.offsetHeight / 2) / 360);
        }
        function update() {
          thumbLeft.value = getThumbLeft();
          thumbTop.value = getThumbTop();
        }
        onMounted(() => {
          const dragConfig = {
            drag: (event) => {
              handleDrag(event);
            },
            end: (event) => {
              handleDrag(event);
            }
          };
          draggable(bar.value, dragConfig);
          draggable(thumb.value, dragConfig);
          update();
        });
        return {
          bar,
          thumb,
          thumbLeft,
          thumbTop,
          hueValue,
          handleClick,
          update,
          ns: ns2
        };
      }
    });
    function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("vertical", _ctx.vertical)])
      }, [
        createBaseVNode("div", {
          ref: "bar",
          class: normalizeClass(_ctx.ns.e("bar")),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
        }, null, 2),
        createBaseVNode("div", {
          ref: "thumb",
          class: normalizeClass(_ctx.ns.e("thumb")),
          style: normalizeStyle({
            left: _ctx.thumbLeft + "px",
            top: _ctx.thumbTop + "px"
          })
        }, null, 6)
      ], 2);
    }
    var HueSlider = /* @__PURE__ */ _export_sfc(_sfc_main$1x, [["render", _sfc_render$v], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/hue-slider.vue"]]);
    const OPTIONS_KEY = Symbol();
    const useOptions = () => {
      return inject(OPTIONS_KEY);
    };
    const hsv2hsl = function(hue, sat, val) {
      return [
        hue,
        sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0,
        hue / 2
      ];
    };
    const isOnePointZero = function(n) {
      return typeof n === "string" && n.includes(".") && Number.parseFloat(n) === 1;
    };
    const isPercentage = function(n) {
      return typeof n === "string" && n.includes("%");
    };
    const bound01 = function(value, max2) {
      if (isOnePointZero(value))
        value = "100%";
      const processPercent = isPercentage(value);
      value = Math.min(max2, Math.max(0, Number.parseFloat(`${value}`)));
      if (processPercent) {
        value = Number.parseInt(`${value * max2}`, 10) / 100;
      }
      if (Math.abs(value - max2) < 1e-6) {
        return 1;
      }
      return value % max2 / Number.parseFloat(max2);
    };
    const INT_HEX_MAP = { 10: "A", 11: "B", 12: "C", 13: "D", 14: "E", 15: "F" };
    const hexOne = function(value) {
      value = Math.min(Math.round(value), 255);
      const high = Math.floor(value / 16);
      const low = value % 16;
      return `${INT_HEX_MAP[high] || high}${INT_HEX_MAP[low] || low}`;
    };
    const toHex = function({ r, g, b: b2 }) {
      if (Number.isNaN(+r) || Number.isNaN(+g) || Number.isNaN(+b2))
        return "";
      return `#${hexOne(r)}${hexOne(g)}${hexOne(b2)}`;
    };
    const HEX_INT_MAP = { A: 10, B: 11, C: 12, D: 13, E: 14, F: 15 };
    const parseHexChannel = function(hex) {
      if (hex.length === 2) {
        return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);
      }
      return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];
    };
    const hsl2hsv = function(hue, sat, light) {
      sat = sat / 100;
      light = light / 100;
      let smin = sat;
      const lmin = Math.max(light, 0.01);
      light *= 2;
      sat *= light <= 1 ? light : 2 - light;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v2 = (light + sat) / 2;
      const sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);
      return {
        h: hue,
        s: sv * 100,
        v: v2 * 100
      };
    };
    const rgb2hsv = function(r, g, b2) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b2 = bound01(b2, 255);
      const max2 = Math.max(r, g, b2);
      const min2 = Math.min(r, g, b2);
      let h2;
      const v2 = max2;
      const d2 = max2 - min2;
      const s2 = max2 === 0 ? 0 : d2 / max2;
      if (max2 === min2) {
        h2 = 0;
      } else {
        switch (max2) {
          case r: {
            h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
            break;
          }
          case g: {
            h2 = (b2 - r) / d2 + 2;
            break;
          }
          case b2: {
            h2 = (r - g) / d2 + 4;
            break;
          }
        }
        h2 /= 6;
      }
      return { h: h2 * 360, s: s2 * 100, v: v2 * 100 };
    };
    const hsv2rgb = function(h2, s2, v2) {
      h2 = bound01(h2, 360) * 6;
      s2 = bound01(s2, 100);
      v2 = bound01(v2, 100);
      const i = Math.floor(h2);
      const f2 = h2 - i;
      const p2 = v2 * (1 - s2);
      const q2 = v2 * (1 - f2 * s2);
      const t = v2 * (1 - (1 - f2) * s2);
      const mod = i % 6;
      const r = [v2, q2, p2, p2, t, v2][mod];
      const g = [t, v2, v2, q2, p2, p2][mod];
      const b2 = [p2, p2, t, v2, v2, q2][mod];
      return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b2 * 255)
      };
    };
    class Color {
      constructor(options) {
        this._hue = 0;
        this._saturation = 100;
        this._value = 100;
        this._alpha = 100;
        this.enableAlpha = false;
        this.format = "hex";
        this.value = "";
        options = options || {};
        for (const option in options) {
          if (hasOwn$1(options, option)) {
            this[option] = options[option];
          }
        }
        if (options.value) {
          this.fromString(options.value);
        } else {
          this.doOnChange();
        }
      }
      set(prop, value) {
        if (arguments.length === 1 && typeof prop === "object") {
          for (const p2 in prop) {
            if (hasOwn$1(prop, p2)) {
              this.set(p2, prop[p2]);
            }
          }
          return;
        }
        this[`_${prop}`] = value;
        this.doOnChange();
      }
      get(prop) {
        if (prop === "alpha") {
          return Math.floor(this[`_${prop}`]);
        }
        return this[`_${prop}`];
      }
      toRgb() {
        return hsv2rgb(this._hue, this._saturation, this._value);
      }
      fromString(value) {
        if (!value) {
          this._hue = 0;
          this._saturation = 100;
          this._value = 100;
          this.doOnChange();
          return;
        }
        const fromHSV = (h2, s2, v2) => {
          this._hue = Math.max(0, Math.min(360, h2));
          this._saturation = Math.max(0, Math.min(100, s2));
          this._value = Math.max(0, Math.min(100, v2));
          this.doOnChange();
        };
        if (value.includes("hsl")) {
          const parts = value.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
          if (parts.length === 4) {
            this._alpha = Number.parseFloat(parts[3]) * 100;
          } else if (parts.length === 3) {
            this._alpha = 100;
          }
          if (parts.length >= 3) {
            const { h: h2, s: s2, v: v2 } = hsl2hsv(parts[0], parts[1], parts[2]);
            fromHSV(h2, s2, v2);
          }
        } else if (value.includes("hsv")) {
          const parts = value.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
          if (parts.length === 4) {
            this._alpha = Number.parseFloat(parts[3]) * 100;
          } else if (parts.length === 3) {
            this._alpha = 100;
          }
          if (parts.length >= 3) {
            fromHSV(parts[0], parts[1], parts[2]);
          }
        } else if (value.includes("rgb")) {
          const parts = value.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
          if (parts.length === 4) {
            this._alpha = Number.parseFloat(parts[3]) * 100;
          } else if (parts.length === 3) {
            this._alpha = 100;
          }
          if (parts.length >= 3) {
            const { h: h2, s: s2, v: v2 } = rgb2hsv(parts[0], parts[1], parts[2]);
            fromHSV(h2, s2, v2);
          }
        } else if (value.includes("#")) {
          const hex = value.replace("#", "").trim();
          if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(hex))
            return;
          let r, g, b2;
          if (hex.length === 3) {
            r = parseHexChannel(hex[0] + hex[0]);
            g = parseHexChannel(hex[1] + hex[1]);
            b2 = parseHexChannel(hex[2] + hex[2]);
          } else if (hex.length === 6 || hex.length === 8) {
            r = parseHexChannel(hex.slice(0, 2));
            g = parseHexChannel(hex.slice(2, 4));
            b2 = parseHexChannel(hex.slice(4, 6));
          }
          if (hex.length === 8) {
            this._alpha = parseHexChannel(hex.slice(6)) / 255 * 100;
          } else if (hex.length === 3 || hex.length === 6) {
            this._alpha = 100;
          }
          const { h: h2, s: s2, v: v2 } = rgb2hsv(r, g, b2);
          fromHSV(h2, s2, v2);
        }
      }
      compare(color) {
        return Math.abs(color._hue - this._hue) < 2 && Math.abs(color._saturation - this._saturation) < 1 && Math.abs(color._value - this._value) < 1 && Math.abs(color._alpha - this._alpha) < 1;
      }
      doOnChange() {
        const { _hue, _saturation, _value, _alpha, format: format2 } = this;
        if (this.enableAlpha) {
          switch (format2) {
            case "hsl": {
              const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
              this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${this.get("alpha") / 100})`;
              break;
            }
            case "hsv": {
              this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${this.get("alpha") / 100})`;
              break;
            }
            case "hex": {
              this.value = `${toHex(hsv2rgb(_hue, _saturation, _value))}${hexOne(_alpha * 255 / 100)}`;
              break;
            }
            default: {
              const { r, g, b: b2 } = hsv2rgb(_hue, _saturation, _value);
              this.value = `rgba(${r}, ${g}, ${b2}, ${this.get("alpha") / 100})`;
            }
          }
        } else {
          switch (format2) {
            case "hsl": {
              const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
              this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;
              break;
            }
            case "hsv": {
              this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;
              break;
            }
            case "rgb": {
              const { r, g, b: b2 } = hsv2rgb(_hue, _saturation, _value);
              this.value = `rgb(${r}, ${g}, ${b2})`;
              break;
            }
            default: {
              this.value = toHex(hsv2rgb(_hue, _saturation, _value));
            }
          }
        }
      }
    }
    const _sfc_main$1w = defineComponent({
      props: {
        colors: { type: Array, required: true },
        color: {
          type: Object,
          required: true
        }
      },
      setup(props) {
        const ns2 = useNamespace("color-predefine");
        const { currentColor } = useOptions();
        const rgbaColors = ref(parseColors(props.colors, props.color));
        watch(() => currentColor.value, (val) => {
          const color = new Color();
          color.fromString(val);
          rgbaColors.value.forEach((item) => {
            item.selected = color.compare(item);
          });
        });
        watchEffect(() => {
          rgbaColors.value = parseColors(props.colors, props.color);
        });
        function handleSelect(index2) {
          props.color.fromString(props.colors[index2]);
        }
        function parseColors(colors, color) {
          return colors.map((value) => {
            const c2 = new Color();
            c2.enableAlpha = true;
            c2.format = "rgba";
            c2.fromString(value);
            c2.selected = c2.value === color.value;
            return c2;
          });
        }
        return {
          rgbaColors,
          handleSelect,
          ns: ns2
        };
      }
    });
    const _hoisted_1$O = ["onClick"];
    function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(_ctx.ns.b())
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.ns.e("colors"))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rgbaColors, (item, index2) => {
            return openBlock(), createElementBlock("div", {
              key: _ctx.colors[index2],
              class: normalizeClass([
                _ctx.ns.e("color-selector"),
                _ctx.ns.is("alpha", item._alpha < 100),
                { selected: item.selected }
              ]),
              onClick: ($event) => _ctx.handleSelect(index2)
            }, [
              createBaseVNode("div", {
                style: normalizeStyle({ backgroundColor: item.value })
              }, null, 4)
            ], 10, _hoisted_1$O);
          }), 128))
        ], 2)
      ], 2);
    }
    var Predefine = /* @__PURE__ */ _export_sfc(_sfc_main$1w, [["render", _sfc_render$u], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/predefine.vue"]]);
    const _sfc_main$1v = defineComponent({
      name: "ElSlPanel",
      props: {
        color: {
          type: Object,
          required: true
        }
      },
      setup(props) {
        const ns2 = useNamespace("color-svpanel");
        const instance = getCurrentInstance();
        const cursorTop = ref(0);
        const cursorLeft = ref(0);
        const background = ref("hsl(0, 100%, 50%)");
        const colorValue = computed(() => {
          const hue = props.color.get("hue");
          const value = props.color.get("value");
          return { hue, value };
        });
        function update() {
          const saturation = props.color.get("saturation");
          const value = props.color.get("value");
          const el = instance.vnode.el;
          const { clientWidth: width, clientHeight: height } = el;
          cursorLeft.value = saturation * width / 100;
          cursorTop.value = (100 - value) * height / 100;
          background.value = `hsl(${props.color.get("hue")}, 100%, 50%)`;
        }
        function handleDrag(event) {
          const el = instance.vnode.el;
          const rect = el.getBoundingClientRect();
          const { clientX, clientY } = getClientXY(event);
          let left2 = clientX - rect.left;
          let top = clientY - rect.top;
          left2 = Math.max(0, left2);
          left2 = Math.min(left2, rect.width);
          top = Math.max(0, top);
          top = Math.min(top, rect.height);
          cursorLeft.value = left2;
          cursorTop.value = top;
          props.color.set({
            saturation: left2 / rect.width * 100,
            value: 100 - top / rect.height * 100
          });
        }
        watch(() => colorValue.value, () => {
          update();
        });
        onMounted(() => {
          draggable(instance.vnode.el, {
            drag: (event) => {
              handleDrag(event);
            },
            end: (event) => {
              handleDrag(event);
            }
          });
          update();
        });
        return {
          cursorTop,
          cursorLeft,
          background,
          colorValue,
          handleDrag,
          update,
          ns: ns2
        };
      }
    });
    const _hoisted_1$N = /* @__PURE__ */ createBaseVNode("div", null, null, -1);
    const _hoisted_2$w = [
      _hoisted_1$N
    ];
    function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(_ctx.ns.b()),
        style: normalizeStyle({
          backgroundColor: _ctx.background
        })
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.ns.e("white"))
        }, null, 2),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.ns.e("black"))
        }, null, 2),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.ns.e("cursor")),
          style: normalizeStyle({
            top: _ctx.cursorTop + "px",
            left: _ctx.cursorLeft + "px"
          })
        }, _hoisted_2$w, 6)
      ], 6);
    }
    var SvPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1v, [["render", _sfc_render$t], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/components/sv-panel.vue"]]);
    const _sfc_main$1u = defineComponent({
      name: "ElColorPicker",
      components: {
        ElButton,
        ElTooltip,
        ElInput,
        ElIcon,
        Close: close_default,
        ArrowDown: arrow_down_default,
        SvPanel,
        HueSlider,
        AlphaSlider,
        Predefine
      },
      directives: {
        ClickOutside
      },
      props: {
        modelValue: String,
        id: String,
        showAlpha: Boolean,
        colorFormat: String,
        disabled: Boolean,
        size: {
          type: String,
          validator: isValidComponentSize
        },
        popperClass: String,
        label: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        predefine: Array,
        validateEvent: {
          type: Boolean,
          default: true
        }
      },
      emits: ["change", "active-change", UPDATE_MODEL_EVENT],
      setup(props, { emit }) {
        const { t } = useLocale();
        const ns2 = useNamespace("color");
        const { form, formItem } = useFormItem();
        const { inputId: buttonId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const hue = ref();
        const svPanel = ref();
        const alpha = ref();
        const popper = ref(null);
        let shouldActiveChange = true;
        const color = reactive(new Color({
          enableAlpha: props.showAlpha,
          format: props.colorFormat || "",
          value: props.modelValue
        }));
        const showPicker = ref(false);
        const showPanelColor = ref(false);
        const customInput = ref("");
        const displayedColor = computed(() => {
          if (!props.modelValue && !showPanelColor.value) {
            return "transparent";
          }
          return displayedRgb(color, props.showAlpha);
        });
        const colorSize = useSize();
        const colorDisabled = computed(() => {
          return !!(props.disabled || (form == null ? void 0 : form.disabled));
        });
        const currentColor = computed(() => {
          return !props.modelValue && !showPanelColor.value ? "" : color.value;
        });
        const buttonAriaLabel = computed(() => {
          return !isLabeledByFormItem.value ? props.label || t("el.colorpicker.defaultLabel") : void 0;
        });
        const buttonAriaLabelledby = computed(() => {
          return isLabeledByFormItem.value ? formItem == null ? void 0 : formItem.labelId : void 0;
        });
        watch(() => props.modelValue, (newVal) => {
          if (!newVal) {
            showPanelColor.value = false;
          } else if (newVal && newVal !== color.value) {
            shouldActiveChange = false;
            color.fromString(newVal);
          }
        });
        watch(() => currentColor.value, (val) => {
          customInput.value = val;
          shouldActiveChange && emit("active-change", val);
          shouldActiveChange = true;
        });
        watch(() => color.value, () => {
          if (!props.modelValue && !showPanelColor.value) {
            showPanelColor.value = true;
          }
        });
        function displayedRgb(color2, showAlpha) {
          if (!(color2 instanceof Color)) {
            throw new TypeError("color should be instance of _color Class");
          }
          const { r, g, b: b2 } = color2.toRgb();
          return showAlpha ? `rgba(${r}, ${g}, ${b2}, ${color2.get("alpha") / 100})` : `rgb(${r}, ${g}, ${b2})`;
        }
        function setShowPicker(value) {
          showPicker.value = value;
        }
        const debounceSetShowPicker = debounce(setShowPicker, 100);
        function hide() {
          debounceSetShowPicker(false);
          resetColor();
        }
        function resetColor() {
          nextTick(() => {
            if (props.modelValue) {
              color.fromString(props.modelValue);
            } else {
              color.value = "";
              nextTick(() => {
                showPanelColor.value = false;
              });
            }
          });
        }
        function handleTrigger() {
          if (colorDisabled.value)
            return;
          debounceSetShowPicker(!showPicker.value);
        }
        function handleConfirm() {
          color.fromString(customInput.value);
        }
        function confirmValue() {
          const value = color.value;
          emit(UPDATE_MODEL_EVENT, value);
          emit("change", value);
          if (props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
          debounceSetShowPicker(false);
          nextTick(() => {
            const newColor = new Color({
              enableAlpha: props.showAlpha,
              format: props.colorFormat || "",
              value: props.modelValue
            });
            if (!color.compare(newColor)) {
              resetColor();
            }
          });
        }
        function clear2() {
          debounceSetShowPicker(false);
          emit(UPDATE_MODEL_EVENT, null);
          emit("change", null);
          if (props.modelValue !== null && props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
          resetColor();
        }
        onMounted(() => {
          if (props.modelValue) {
            customInput.value = currentColor.value;
          }
        });
        watch(() => showPicker.value, () => {
          nextTick(() => {
            var _a2, _b, _c;
            (_a2 = hue.value) == null ? void 0 : _a2.update();
            (_b = svPanel.value) == null ? void 0 : _b.update();
            (_c = alpha.value) == null ? void 0 : _c.update();
          });
        });
        provide(OPTIONS_KEY, {
          currentColor
        });
        return {
          color,
          colorDisabled,
          colorSize,
          displayedColor,
          showPanelColor,
          showPicker,
          customInput,
          buttonId,
          buttonAriaLabel,
          buttonAriaLabelledby,
          handleConfirm,
          hide,
          handleTrigger,
          clear: clear2,
          confirmValue,
          t,
          ns: ns2,
          hue,
          svPanel,
          alpha,
          popper
        };
      }
    });
    const _hoisted_1$M = ["id", "aria-label", "aria-labelledby", "aria-description", "tabindex"];
    function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_hue_slider = resolveComponent("hue-slider");
      const _component_sv_panel = resolveComponent("sv-panel");
      const _component_alpha_slider = resolveComponent("alpha-slider");
      const _component_predefine = resolveComponent("predefine");
      const _component_el_input = resolveComponent("el-input");
      const _component_el_button = resolveComponent("el-button");
      const _component_arrow_down = resolveComponent("arrow-down");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_close = resolveComponent("close");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _directive_click_outside = resolveDirective("click-outside");
      return openBlock(), createBlock(_component_el_tooltip, {
        ref: "popper",
        visible: _ctx.showPicker,
        "show-arrow": false,
        "fallback-placements": ["bottom", "top", "right", "left"],
        offset: 0,
        "gpu-acceleration": false,
        "popper-class": [_ctx.ns.be("picker", "panel"), _ctx.ns.b("dropdown"), _ctx.popperClass],
        "stop-popper-mouse-event": false,
        effect: "light",
        trigger: "click",
        transition: `${_ctx.ns.namespace.value}-zoom-in-top`,
        persistent: ""
      }, {
        content: withCtx(() => [
          withDirectives((openBlock(), createElementBlock("div", null, [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.ns.be("dropdown", "main-wrapper"))
            }, [
              createVNode(_component_hue_slider, {
                ref: "hue",
                class: "hue-slider",
                color: _ctx.color,
                vertical: ""
              }, null, 8, ["color"]),
              createVNode(_component_sv_panel, {
                ref: "svPanel",
                color: _ctx.color
              }, null, 8, ["color"])
            ], 2),
            _ctx.showAlpha ? (openBlock(), createBlock(_component_alpha_slider, {
              key: 0,
              ref: "alpha",
              color: _ctx.color
            }, null, 8, ["color"])) : createCommentVNode("v-if", true),
            _ctx.predefine ? (openBlock(), createBlock(_component_predefine, {
              key: 1,
              ref: "predefine",
              color: _ctx.color,
              colors: _ctx.predefine
            }, null, 8, ["color", "colors"])) : createCommentVNode("v-if", true),
            createBaseVNode("div", {
              class: normalizeClass(_ctx.ns.be("dropdown", "btns"))
            }, [
              createBaseVNode("span", {
                class: normalizeClass(_ctx.ns.be("dropdown", "value"))
              }, [
                createVNode(_component_el_input, {
                  modelValue: _ctx.customInput,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.customInput = $event),
                  "validate-event": false,
                  size: "small",
                  onKeyup: withKeys(_ctx.handleConfirm, ["enter"]),
                  onBlur: _ctx.handleConfirm
                }, null, 8, ["modelValue", "onKeyup", "onBlur"])
              ], 2),
              createVNode(_component_el_button, {
                class: normalizeClass(_ctx.ns.be("dropdown", "link-btn")),
                text: "",
                size: "small",
                onClick: _ctx.clear
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(_ctx.t("el.colorpicker.clear")), 1)
                ]),
                _: 1
              }, 8, ["class", "onClick"]),
              createVNode(_component_el_button, {
                plain: "",
                size: "small",
                class: normalizeClass(_ctx.ns.be("dropdown", "btn")),
                onClick: _ctx.confirmValue
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(_ctx.t("el.colorpicker.confirm")), 1)
                ]),
                _: 1
              }, 8, ["class", "onClick"])
            ], 2)
          ])), [
            [_directive_click_outside, _ctx.hide]
          ])
        ]),
        default: withCtx(() => [
          createBaseVNode("div", {
            id: _ctx.buttonId,
            class: normalizeClass([
              _ctx.ns.b("picker"),
              _ctx.ns.is("disabled", _ctx.colorDisabled),
              _ctx.ns.bm("picker", _ctx.colorSize)
            ]),
            role: "button",
            "aria-label": _ctx.buttonAriaLabel,
            "aria-labelledby": _ctx.buttonAriaLabelledby,
            "aria-description": _ctx.t("el.colorpicker.description", { color: _ctx.modelValue || "" }),
            tabindex: _ctx.tabindex,
            onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => _ctx.handleTrigger && _ctx.handleTrigger(...args), ["enter"]))
          }, [
            _ctx.colorDisabled ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.ns.be("picker", "mask"))
            }, null, 2)) : createCommentVNode("v-if", true),
            createBaseVNode("div", {
              class: normalizeClass(_ctx.ns.be("picker", "trigger")),
              onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleTrigger && _ctx.handleTrigger(...args))
            }, [
              createBaseVNode("span", {
                class: normalizeClass([_ctx.ns.be("picker", "color"), _ctx.ns.is("alpha", _ctx.showAlpha)])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(_ctx.ns.be("picker", "color-inner")),
                  style: normalizeStyle({
                    backgroundColor: _ctx.displayedColor
                  })
                }, [
                  withDirectives(createVNode(_component_el_icon, {
                    class: normalizeClass([_ctx.ns.be("picker", "icon"), _ctx.ns.is("icon-arrow-down")])
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_arrow_down)
                    ]),
                    _: 1
                  }, 8, ["class"]), [
                    [vShow, _ctx.modelValue || _ctx.showPanelColor]
                  ]),
                  !_ctx.modelValue && !_ctx.showPanelColor ? (openBlock(), createBlock(_component_el_icon, {
                    key: 0,
                    class: normalizeClass([_ctx.ns.be("picker", "empty"), _ctx.ns.is("icon-close")])
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_close)
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 6)
              ], 2)
            ], 2)
          ], 42, _hoisted_1$M)
        ]),
        _: 1
      }, 8, ["visible", "popper-class", "transition"]);
    }
    var ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$1u, [["render", _sfc_render$s], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/index.vue"]]);
    ColorPicker.install = (app2) => {
      app2.component(ColorPicker.name, ColorPicker);
    };
    const _ColorPicker = ColorPicker;
    const ElColorPicker = _ColorPicker;
    const messageConfig = {};
    const configProviderProps = buildProps({
      a11y: {
        type: Boolean,
        default: true
      },
      locale: {
        type: definePropType(Object)
      },
      size: useSizeProp,
      button: {
        type: definePropType(Object)
      },
      experimentalFeatures: {
        type: definePropType(Object)
      },
      keyboardNavigation: {
        type: Boolean,
        default: true
      },
      message: {
        type: definePropType(Object)
      },
      zIndex: Number,
      namespace: {
        type: String,
        default: "el"
      }
    });
    const ConfigProvider = defineComponent({
      name: "ElConfigProvider",
      props: configProviderProps,
      setup(props, { slots }) {
        watch(() => props.message, (val) => {
          Object.assign(messageConfig, val != null ? val : {});
        }, { immediate: true, deep: true });
        const config = provideGlobalConfig(props);
        return () => renderSlot(slots, "default", { config: config == null ? void 0 : config.value });
      }
    });
    const ElConfigProvider = withInstall(ConfigProvider);
    const __default__$T = {
      name: "ElContainer"
    };
    const _sfc_main$1t = /* @__PURE__ */ defineComponent({
      ...__default__$T,
      props: {
        direction: {
          type: String
        }
      },
      setup(__props) {
        const props = __props;
        const slots = useSlots();
        const ns2 = useNamespace("container");
        const isVertical = computed(() => {
          if (props.direction === "vertical") {
            return true;
          } else if (props.direction === "horizontal") {
            return false;
          }
          if (slots && slots.default) {
            const vNodes = slots.default();
            return vNodes.some((vNode) => {
              const tag = vNode.type.name;
              return tag === "ElHeader" || tag === "ElFooter";
            });
          } else {
            return false;
          }
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("section", {
            class: normalizeClass([unref(ns2).b(), unref(ns2).is("vertical", unref(isVertical))])
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var Container = /* @__PURE__ */ _export_sfc(_sfc_main$1t, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);
    const __default__$S = {
      name: "ElAside"
    };
    const _sfc_main$1s = /* @__PURE__ */ defineComponent({
      ...__default__$S,
      props: {
        width: {
          type: String,
          default: null
        }
      },
      setup(__props) {
        const props = __props;
        const ns2 = useNamespace("aside");
        const style2 = computed(() => props.width ? ns2.cssVarBlock({ width: props.width }) : {});
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("aside", {
            class: normalizeClass(unref(ns2).b()),
            style: normalizeStyle(unref(style2))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6);
        };
      }
    });
    var Aside = /* @__PURE__ */ _export_sfc(_sfc_main$1s, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);
    const __default__$R = {
      name: "ElFooter"
    };
    const _sfc_main$1r = /* @__PURE__ */ defineComponent({
      ...__default__$R,
      props: {
        height: {
          type: String,
          default: null
        }
      },
      setup(__props) {
        const props = __props;
        const ns2 = useNamespace("footer");
        const style2 = computed(() => props.height ? ns2.cssVarBlock({ height: props.height }) : {});
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("footer", {
            class: normalizeClass(unref(ns2).b()),
            style: normalizeStyle(unref(style2))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6);
        };
      }
    });
    var Footer$2 = /* @__PURE__ */ _export_sfc(_sfc_main$1r, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);
    const __default__$Q = {
      name: "ElHeader"
    };
    const _sfc_main$1q = /* @__PURE__ */ defineComponent({
      ...__default__$Q,
      props: {
        height: {
          type: String,
          default: null
        }
      },
      setup(__props) {
        const props = __props;
        const ns2 = useNamespace("header");
        const style2 = computed(() => {
          return props.height ? ns2.cssVarBlock({
            height: props.height
          }) : {};
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("header", {
            class: normalizeClass(unref(ns2).b()),
            style: normalizeStyle(unref(style2))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6);
        };
      }
    });
    var Header = /* @__PURE__ */ _export_sfc(_sfc_main$1q, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);
    const __default__$P = {
      name: "ElMain"
    };
    const _sfc_main$1p = /* @__PURE__ */ defineComponent({
      ...__default__$P,
      setup(__props) {
        const ns2 = useNamespace("main");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("main", {
            class: normalizeClass(unref(ns2).b())
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var Main = /* @__PURE__ */ _export_sfc(_sfc_main$1p, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);
    const ElContainer = withInstall(Container, {
      Aside,
      Footer: Footer$2,
      Header,
      Main
    });
    const ElAside = withNoopInstall(Aside);
    const ElFooter = withNoopInstall(Footer$2);
    const ElHeader = withNoopInstall(Header);
    const ElMain = withNoopInstall(Main);
    var advancedFormat$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal, function() {
        return function(e, t, r) {
          var n = t.prototype, s2 = n.format;
          r.en.ordinal = function(e2) {
            var t2 = ["th", "st", "nd", "rd"], r2 = e2 % 100;
            return "[" + e2 + (t2[(r2 - 20) % 10] || t2[r2] || t2[0]) + "]";
          }, n.format = function(e2) {
            var t2 = this, r2 = this.$locale();
            if (!this.isValid())
              return s2.bind(this)(e2);
            var n2 = this.$utils(), a2 = (e2 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e3) {
              switch (e3) {
                case "Q":
                  return Math.ceil((t2.$M + 1) / 3);
                case "Do":
                  return r2.ordinal(t2.$D);
                case "gggg":
                  return t2.weekYear();
                case "GGGG":
                  return t2.isoWeekYear();
                case "wo":
                  return r2.ordinal(t2.week(), "W");
                case "w":
                case "ww":
                  return n2.s(t2.week(), "w" === e3 ? 1 : 2, "0");
                case "W":
                case "WW":
                  return n2.s(t2.isoWeek(), "W" === e3 ? 1 : 2, "0");
                case "k":
                case "kk":
                  return n2.s(String(0 === t2.$H ? 24 : t2.$H), "k" === e3 ? 1 : 2, "0");
                case "X":
                  return Math.floor(t2.$d.getTime() / 1e3);
                case "x":
                  return t2.$d.getTime();
                case "z":
                  return "[" + t2.offsetName() + "]";
                case "zzz":
                  return "[" + t2.offsetName("long") + "]";
                default:
                  return e3;
              }
            });
            return s2.bind(this)(a2);
          };
        };
      });
    })(advancedFormat$1);
    const advancedFormat = advancedFormat$1.exports;
    var weekOfYear$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal, function() {
        var e = "week", t = "year";
        return function(i, n, r) {
          var f2 = n.prototype;
          f2.week = function(i2) {
            if (void 0 === i2 && (i2 = null), null !== i2)
              return this.add(7 * (i2 - this.week()), "day");
            var n2 = this.$locale().yearStart || 1;
            if (11 === this.month() && this.date() > 25) {
              var f3 = r(this).startOf(t).add(1, t).date(n2), s2 = r(this).endOf(e);
              if (f3.isBefore(s2))
                return 1;
            }
            var a2 = r(this).startOf(t).date(n2).startOf(e).subtract(1, "millisecond"), o2 = this.diff(a2, e, true);
            return o2 < 0 ? r(this).startOf("week").week() : Math.ceil(o2);
          }, f2.weeks = function(e2) {
            return void 0 === e2 && (e2 = null), this.week(e2);
          };
        };
      });
    })(weekOfYear$1);
    const weekOfYear = weekOfYear$1.exports;
    var weekYear$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal, function() {
        return function(e, t) {
          t.prototype.weekYear = function() {
            var e2 = this.month(), t2 = this.week(), n = this.year();
            return 1 === t2 && 11 === e2 ? n + 1 : 0 === e2 && t2 >= 52 ? n - 1 : n;
          };
        };
      });
    })(weekYear$1);
    const weekYear = weekYear$1.exports;
    var dayOfYear$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal, function() {
        return function(e, t, n) {
          t.prototype.dayOfYear = function(e2) {
            var t2 = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
            return null == e2 ? t2 : this.add(e2 - t2, "day");
          };
        };
      });
    })(dayOfYear$1);
    const dayOfYear = dayOfYear$1.exports;
    var isSameOrAfter$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal, function() {
        return function(e, t) {
          t.prototype.isSameOrAfter = function(e2, t2) {
            return this.isSame(e2, t2) || this.isAfter(e2, t2);
          };
        };
      });
    })(isSameOrAfter$1);
    const isSameOrAfter = isSameOrAfter$1.exports;
    var isSameOrBefore$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e, i) {
        module2.exports = i();
      }(commonjsGlobal, function() {
        return function(e, i) {
          i.prototype.isSameOrBefore = function(e2, i2) {
            return this.isSame(e2, i2) || this.isBefore(e2, i2);
          };
        };
      });
    })(isSameOrBefore$1);
    const isSameOrBefore = isSameOrBefore$1.exports;
    const datePickerProps = buildProps({
      type: {
        type: definePropType(String),
        default: "date"
      }
    });
    const selectionModes = ["date", "dates", "year", "month", "week", "range"];
    const datePickerSharedProps = buildProps({
      disabledDate: {
        type: definePropType(Function)
      },
      date: {
        type: definePropType(Object),
        required: true
      },
      minDate: {
        type: definePropType(Object)
      },
      maxDate: {
        type: definePropType(Object)
      },
      parsedValue: {
        type: definePropType([Object, Array])
      },
      rangeState: {
        type: definePropType(Object),
        default: () => ({
          endDate: null,
          selecting: false
        })
      }
    });
    const panelSharedProps = buildProps({
      type: {
        type: definePropType(String),
        required: true,
        values: datePickTypes
      }
    });
    const panelRangeSharedProps = buildProps({
      unlinkPanels: Boolean,
      parsedValue: {
        type: definePropType(Array)
      }
    });
    const selectionModeWithDefault = (mode) => {
      return {
        type: String,
        values: selectionModes,
        default: mode
      };
    };
    const panelDatePickProps = buildProps({
      ...panelSharedProps,
      parsedValue: {
        type: definePropType([Object, Array])
      },
      visible: {
        type: Boolean
      },
      format: {
        type: String,
        default: ""
      }
    });
    const basicDateTableProps = buildProps({
      ...datePickerSharedProps,
      cellClassName: {
        type: definePropType(Function)
      },
      showWeekNumber: Boolean,
      selectionMode: selectionModeWithDefault("date")
    });
    const isValidRange = (range2) => {
      if (!isArray$4(range2))
        return false;
      const [left2, right2] = range2;
      return dayjs.isDayjs(left2) && dayjs.isDayjs(right2) && left2.isSameOrBefore(right2);
    };
    const getDefaultValue = (defaultValue, { lang, unit, unlinkPanels }) => {
      let start;
      if (isArray$4(defaultValue)) {
        let [left2, right2] = defaultValue.map((d2) => dayjs(d2).locale(lang));
        if (!unlinkPanels) {
          right2 = left2.add(1, unit);
        }
        return [left2, right2];
      } else if (defaultValue) {
        start = dayjs(defaultValue);
      } else {
        start = dayjs();
      }
      start = start.locale(lang);
      return [start, start.add(1, unit)];
    };
    const buildPickerTable = (dimension, rows, {
      columnIndexOffset,
      startDate,
      nextEndDate,
      now: now2,
      unit,
      relativeDateGetter,
      setCellMetadata,
      setRowMetadata
    }) => {
      for (let rowIndex = 0; rowIndex < dimension.row; rowIndex++) {
        const row = rows[rowIndex];
        for (let columnIndex = 0; columnIndex < dimension.column; columnIndex++) {
          let cell = row[columnIndex + columnIndexOffset];
          if (!cell) {
            cell = {
              row: rowIndex,
              column: columnIndex,
              type: "normal",
              inRange: false,
              start: false,
              end: false
            };
          }
          const index2 = rowIndex * dimension.column + columnIndex;
          const nextStartDate = relativeDateGetter(index2);
          cell.dayjs = nextStartDate;
          cell.date = nextStartDate.toDate();
          cell.timestamp = nextStartDate.valueOf();
          cell.type = "normal";
          cell.inRange = !!(startDate && nextStartDate.isSameOrAfter(startDate, unit) && nextEndDate && nextStartDate.isSameOrBefore(nextEndDate, unit)) || !!(startDate && nextStartDate.isSameOrBefore(startDate, unit) && nextEndDate && nextStartDate.isSameOrAfter(nextEndDate, unit));
          if (startDate == null ? void 0 : startDate.isSameOrAfter(nextEndDate)) {
            cell.start = !!nextEndDate && nextStartDate.isSame(nextEndDate, unit);
            cell.end = startDate && nextStartDate.isSame(startDate, unit);
          } else {
            cell.start = !!startDate && nextStartDate.isSame(startDate, unit);
            cell.end = !!nextEndDate && nextStartDate.isSame(nextEndDate, unit);
          }
          const isToday = nextStartDate.isSame(now2, unit);
          if (isToday) {
            cell.type = "today";
          }
          setCellMetadata == null ? void 0 : setCellMetadata(cell, { rowIndex, columnIndex });
          row[columnIndex + columnIndexOffset] = cell;
        }
        setRowMetadata == null ? void 0 : setRowMetadata(row);
      }
    };
    const basicCellProps = buildProps({
      cell: {
        type: definePropType(Object)
      }
    });
    var ElDatePickerCell = defineComponent({
      name: "ElDatePickerCell",
      props: basicCellProps,
      setup(props) {
        const ns2 = useNamespace("date-table-cell");
        const {
          slots
        } = inject(ROOT_PICKER_INJECTION_KEY);
        return () => {
          const {
            cell
          } = props;
          if (slots.default) {
            const list = slots.default(cell).filter((item) => {
              return item.patchFlag !== -2 && item.type.toString() !== "Symbol(Comment)";
            });
            if (list.length) {
              return list;
            }
          }
          return createVNode("div", {
            "class": ns2.b()
          }, [createVNode("span", {
            "class": ns2.e("text")
          }, [cell == null ? void 0 : cell.text])]);
        };
      }
    });
    const _hoisted_1$L = ["aria-label"];
    const _hoisted_2$v = {
      key: 0,
      scope: "col"
    };
    const _hoisted_3$i = ["aria-label"];
    const _hoisted_4$d = ["aria-current", "aria-selected", "tabindex"];
    const _sfc_main$1o = /* @__PURE__ */ defineComponent({
      __name: "basic-date-table",
      props: basicDateTableProps,
      emits: ["changerange", "pick", "select"],
      setup(__props, { expose, emit }) {
        const props = __props;
        const ns2 = useNamespace("date-table");
        const { t, lang } = useLocale();
        const tbodyRef = ref();
        const currentCellRef = ref();
        const lastRow = ref();
        const lastColumn = ref();
        const tableRows = ref([[], [], [], [], [], []]);
        let focusWithClick = false;
        const firstDayOfWeek = props.date.$locale().weekStart || 7;
        const WEEKS_CONSTANT = props.date.locale("en").localeData().weekdaysShort().map((_2) => _2.toLowerCase());
        const offsetDay = computed(() => {
          return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;
        });
        const startDate = computed(() => {
          const startDayOfMonth = props.date.startOf("month");
          return startDayOfMonth.subtract(startDayOfMonth.day() || 7, "day");
        });
        const WEEKS = computed(() => {
          return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(firstDayOfWeek, firstDayOfWeek + 7);
        });
        const hasCurrent = computed(() => {
          return flatten(rows.value).some((row) => {
            return row.isCurrent;
          });
        });
        const days = computed(() => {
          const startOfMonth = props.date.startOf("month");
          const startOfMonthDay = startOfMonth.day() || 7;
          const dateCountOfMonth = startOfMonth.daysInMonth();
          const dateCountOfLastMonth = startOfMonth.subtract(1, "month").daysInMonth();
          return {
            startOfMonthDay,
            dateCountOfMonth,
            dateCountOfLastMonth
          };
        });
        const selectedDate = computed(() => {
          return props.selectionMode === "dates" ? castArray(props.parsedValue) : [];
        });
        const setDateText = (cell, {
          count,
          rowIndex,
          columnIndex
        }) => {
          const { startOfMonthDay, dateCountOfMonth, dateCountOfLastMonth } = unref(days);
          const offset2 = unref(offsetDay);
          if (rowIndex >= 0 && rowIndex <= 1) {
            const numberOfDaysFromPreviousMonth = startOfMonthDay + offset2 < 0 ? 7 + startOfMonthDay + offset2 : startOfMonthDay + offset2;
            if (columnIndex + rowIndex * 7 >= numberOfDaysFromPreviousMonth) {
              cell.text = count;
              return true;
            } else {
              cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - columnIndex % 7) + 1 + rowIndex * 7;
              cell.type = "prev-month";
            }
          } else {
            if (count <= dateCountOfMonth) {
              cell.text = count;
            } else {
              cell.text = count - dateCountOfMonth;
              cell.type = "next-month";
            }
            return true;
          }
          return false;
        };
        const setCellMetadata = (cell, {
          columnIndex,
          rowIndex
        }, count) => {
          const { disabledDate: disabledDate2, cellClassName } = props;
          const _selectedDate = unref(selectedDate);
          const shouldIncrement = setDateText(cell, { count, rowIndex, columnIndex });
          const cellDate = cell.dayjs.toDate();
          cell.selected = _selectedDate.find((d2) => d2.valueOf() === cell.dayjs.valueOf());
          cell.isSelected = !!cell.selected;
          cell.isCurrent = isCurrent(cell);
          cell.disabled = disabledDate2 == null ? void 0 : disabledDate2(cellDate);
          cell.customClass = cellClassName == null ? void 0 : cellClassName(cellDate);
          return shouldIncrement;
        };
        const setRowMetadata = (row) => {
          if (props.selectionMode === "week") {
            const [start, end2] = props.showWeekNumber ? [1, 7] : [0, 6];
            const isActive = isWeekActive(row[start + 1]);
            row[start].inRange = isActive;
            row[start].start = isActive;
            row[end2].inRange = isActive;
            row[end2].end = isActive;
          }
        };
        const rows = computed(() => {
          const { minDate, maxDate, rangeState, showWeekNumber } = props;
          const offset2 = offsetDay.value;
          const rows_ = tableRows.value;
          const dateUnit = "day";
          let count = 1;
          if (showWeekNumber) {
            for (let rowIndex = 0; rowIndex < 6; rowIndex++) {
              if (!rows_[rowIndex][0]) {
                rows_[rowIndex][0] = {
                  type: "week",
                  text: startDate.value.add(rowIndex * 7 + 1, dateUnit).week()
                };
              }
            }
          }
          buildPickerTable({ row: 6, column: 7 }, rows_, {
            startDate: minDate,
            columnIndexOffset: showWeekNumber ? 1 : 0,
            nextEndDate: rangeState.endDate || maxDate || rangeState.selecting && minDate || null,
            now: dayjs().locale(unref(lang)).startOf(dateUnit),
            unit: dateUnit,
            relativeDateGetter: (idx) => startDate.value.add(idx - offset2, dateUnit),
            setCellMetadata: (...args) => {
              if (setCellMetadata(...args, count)) {
                count += 1;
              }
            },
            setRowMetadata
          });
          return rows_;
        });
        watch(() => props.date, async () => {
          var _a2, _b;
          if ((_a2 = tbodyRef.value) == null ? void 0 : _a2.contains(document.activeElement)) {
            await nextTick();
            (_b = currentCellRef.value) == null ? void 0 : _b.focus();
          }
        });
        const focus = async () => {
          var _a2;
          (_a2 = currentCellRef.value) == null ? void 0 : _a2.focus();
        };
        const isNormalDay = (type2 = "") => {
          return ["normal", "today"].includes(type2);
        };
        const isCurrent = (cell) => {
          return props.selectionMode === "date" && isNormalDay(cell.type) && cellMatchesDate(cell, props.parsedValue);
        };
        const cellMatchesDate = (cell, date2) => {
          if (!date2)
            return false;
          return dayjs(date2).locale(lang.value).isSame(props.date.date(Number(cell.text)), "day");
        };
        const getCellClasses = (cell) => {
          const classes = [];
          if (isNormalDay(cell.type) && !cell.disabled) {
            classes.push("available");
            if (cell.type === "today") {
              classes.push("today");
            }
          } else {
            classes.push(cell.type);
          }
          if (isCurrent(cell)) {
            classes.push("current");
          }
          if (cell.inRange && (isNormalDay(cell.type) || props.selectionMode === "week")) {
            classes.push("in-range");
            if (cell.start) {
              classes.push("start-date");
            }
            if (cell.end) {
              classes.push("end-date");
            }
          }
          if (cell.disabled) {
            classes.push("disabled");
          }
          if (cell.selected) {
            classes.push("selected");
          }
          if (cell.customClass) {
            classes.push(cell.customClass);
          }
          return classes.join(" ");
        };
        const getDateOfCell = (row, column) => {
          const offsetFromStart = row * 7 + (column - (props.showWeekNumber ? 1 : 0)) - offsetDay.value;
          return startDate.value.add(offsetFromStart, "day");
        };
        const handleMouseMove = (event) => {
          var _a2;
          if (!props.rangeState.selecting)
            return;
          let target = event.target;
          if (target.tagName === "SPAN") {
            target = (_a2 = target.parentNode) == null ? void 0 : _a2.parentNode;
          }
          if (target.tagName === "DIV") {
            target = target.parentNode;
          }
          if (target.tagName !== "TD")
            return;
          const row = target.parentNode.rowIndex - 1;
          const column = target.cellIndex;
          if (rows.value[row][column].disabled)
            return;
          if (row !== lastRow.value || column !== lastColumn.value) {
            lastRow.value = row;
            lastColumn.value = column;
            emit("changerange", {
              selecting: true,
              endDate: getDateOfCell(row, column)
            });
          }
        };
        const isSelectedCell = (cell) => {
          return !hasCurrent.value && (cell == null ? void 0 : cell.text) === 1 && cell.type === "normal" || cell.isCurrent;
        };
        const handleFocus = (event) => {
          if (focusWithClick || hasCurrent.value || props.selectionMode !== "date")
            return;
          handlePickDate(event, true);
        };
        const handleMouseDown = (event) => {
          const target = event.target.closest("td");
          if (!target)
            return;
          focusWithClick = true;
        };
        const handleMouseUp = (event) => {
          const target = event.target.closest("td");
          if (!target)
            return;
          focusWithClick = false;
        };
        const handlePickDate = (event, isKeyboardMovement = false) => {
          const target = event.target.closest("td");
          if (!target)
            return;
          const row = target.parentNode.rowIndex - 1;
          const column = target.cellIndex;
          const cell = rows.value[row][column];
          if (cell.disabled || cell.type === "week")
            return;
          const newDate = getDateOfCell(row, column);
          if (props.selectionMode === "range") {
            if (!props.rangeState.selecting || !props.minDate) {
              emit("pick", { minDate: newDate, maxDate: null });
              emit("select", true);
            } else {
              if (newDate >= props.minDate) {
                emit("pick", { minDate: props.minDate, maxDate: newDate });
              } else {
                emit("pick", { minDate: newDate, maxDate: props.minDate });
              }
              emit("select", false);
            }
          } else if (props.selectionMode === "date") {
            emit("pick", newDate, isKeyboardMovement);
          } else if (props.selectionMode === "week") {
            const weekNumber = newDate.week();
            const value = `${newDate.year()}w${weekNumber}`;
            emit("pick", {
              year: newDate.year(),
              week: weekNumber,
              value,
              date: newDate.startOf("week")
            });
          } else if (props.selectionMode === "dates") {
            const newValue = cell.selected ? castArray(props.parsedValue).filter((d2) => (d2 == null ? void 0 : d2.valueOf()) !== newDate.valueOf()) : castArray(props.parsedValue).concat([newDate]);
            emit("pick", newValue);
          }
        };
        const isWeekActive = (cell) => {
          if (props.selectionMode !== "week")
            return false;
          let newDate = props.date.startOf("day");
          if (cell.type === "prev-month") {
            newDate = newDate.subtract(1, "month");
          }
          if (cell.type === "next-month") {
            newDate = newDate.add(1, "month");
          }
          newDate = newDate.date(Number.parseInt(cell.text, 10));
          if (props.parsedValue && !Array.isArray(props.parsedValue)) {
            const dayOffset = (props.parsedValue.day() - firstDayOfWeek + 7) % 7 - 1;
            const weekDate = props.parsedValue.subtract(dayOffset, "day");
            return weekDate.isSame(newDate, "day");
          }
          return false;
        };
        expose({
          focus
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("table", {
            role: "grid",
            "aria-label": unref(t)("el.datepicker.dateTablePrompt"),
            cellspacing: "0",
            cellpadding: "0",
            class: normalizeClass([unref(ns2).b(), { "is-week-mode": _ctx.selectionMode === "week" }]),
            onClick: handlePickDate,
            onMousemove: handleMouseMove,
            onMousedown: handleMouseDown,
            onMouseup: handleMouseUp
          }, [
            createBaseVNode("tbody", {
              ref_key: "tbodyRef",
              ref: tbodyRef
            }, [
              createBaseVNode("tr", null, [
                _ctx.showWeekNumber ? (openBlock(), createElementBlock("th", _hoisted_2$v, toDisplayString$1(unref(t)("el.datepicker.week")), 1)) : createCommentVNode("v-if", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(WEEKS), (week, key) => {
                  return openBlock(), createElementBlock("th", {
                    key,
                    scope: "col",
                    "aria-label": unref(t)("el.datepicker.weeksFull." + week)
                  }, toDisplayString$1(unref(t)("el.datepicker.weeks." + week)), 9, _hoisted_3$i);
                }), 128))
              ]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(rows), (row, rowKey2) => {
                return openBlock(), createElementBlock("tr", {
                  key: rowKey2,
                  class: normalizeClass([unref(ns2).e("row"), { current: isWeekActive(row[1]) }])
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, columnKey) => {
                    return openBlock(), createElementBlock("td", {
                      key: `${rowKey2}.${columnKey}`,
                      ref_for: true,
                      ref: (el) => isSelectedCell(cell) && (currentCellRef.value = el),
                      class: normalizeClass(getCellClasses(cell)),
                      "aria-current": cell.isCurrent ? "date" : void 0,
                      "aria-selected": cell.isCurrent,
                      tabindex: isSelectedCell(cell) ? 0 : -1,
                      onFocus: handleFocus
                    }, [
                      createVNode(unref(ElDatePickerCell), { cell }, null, 8, ["cell"])
                    ], 42, _hoisted_4$d);
                  }), 128))
                ], 2);
              }), 128))
            ], 512)
          ], 42, _hoisted_1$L);
        };
      }
    });
    var DateTable = /* @__PURE__ */ _export_sfc(_sfc_main$1o, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-date-table.vue"]]);
    const basicMonthTableProps = buildProps({
      ...datePickerSharedProps,
      selectionMode: selectionModeWithDefault("month")
    });
    const _hoisted_1$K = ["aria-label"];
    const _hoisted_2$u = ["aria-selected", "aria-label", "tabindex", "onKeydown"];
    const _hoisted_3$h = { class: "cell" };
    const _sfc_main$1n = /* @__PURE__ */ defineComponent({
      __name: "basic-month-table",
      props: basicMonthTableProps,
      emits: ["changerange", "pick", "select"],
      setup(__props, { expose, emit }) {
        const props = __props;
        const datesInMonth = (year, month, lang2) => {
          const firstDay = dayjs().locale(lang2).startOf("month").month(month).year(year);
          const numOfDays = firstDay.daysInMonth();
          return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
        };
        const ns2 = useNamespace("month-table");
        const { t, lang } = useLocale();
        const tbodyRef = ref();
        const currentCellRef = ref();
        const months = ref(props.date.locale("en").localeData().monthsShort().map((_2) => _2.toLowerCase()));
        const tableRows = ref([
          [],
          [],
          []
        ]);
        const lastRow = ref();
        const lastColumn = ref();
        const rows = computed(() => {
          var _a2, _b;
          const rows2 = tableRows.value;
          const now2 = dayjs().locale(lang.value).startOf("month");
          for (let i = 0; i < 3; i++) {
            const row = rows2[i];
            for (let j = 0; j < 4; j++) {
              const cell = row[j] || (row[j] = {
                row: i,
                column: j,
                type: "normal",
                inRange: false,
                start: false,
                end: false,
                text: -1,
                disabled: false
              });
              cell.type = "normal";
              const index2 = i * 4 + j;
              const calTime = props.date.startOf("year").month(index2);
              const calEndDate = props.rangeState.endDate || props.maxDate || props.rangeState.selecting && props.minDate || null;
              cell.inRange = !!(props.minDate && calTime.isSameOrAfter(props.minDate, "month") && calEndDate && calTime.isSameOrBefore(calEndDate, "month")) || !!(props.minDate && calTime.isSameOrBefore(props.minDate, "month") && calEndDate && calTime.isSameOrAfter(calEndDate, "month"));
              if ((_a2 = props.minDate) == null ? void 0 : _a2.isSameOrAfter(calEndDate)) {
                cell.start = !!(calEndDate && calTime.isSame(calEndDate, "month"));
                cell.end = props.minDate && calTime.isSame(props.minDate, "month");
              } else {
                cell.start = !!(props.minDate && calTime.isSame(props.minDate, "month"));
                cell.end = !!(calEndDate && calTime.isSame(calEndDate, "month"));
              }
              const isToday = now2.isSame(calTime);
              if (isToday) {
                cell.type = "today";
              }
              cell.text = index2;
              cell.disabled = ((_b = props.disabledDate) == null ? void 0 : _b.call(props, calTime.toDate())) || false;
            }
          }
          return rows2;
        });
        const focus = () => {
          var _a2;
          (_a2 = currentCellRef.value) == null ? void 0 : _a2.focus();
        };
        const getCellStyle = (cell) => {
          const style2 = {};
          const year = props.date.year();
          const today = new Date();
          const month = cell.text;
          style2.disabled = props.disabledDate ? datesInMonth(year, month, lang.value).every(props.disabledDate) : false;
          style2.current = castArray(props.parsedValue).findIndex((date2) => dayjs.isDayjs(date2) && date2.year() === year && date2.month() === month) >= 0;
          style2.today = today.getFullYear() === year && today.getMonth() === month;
          if (cell.inRange) {
            style2["in-range"] = true;
            if (cell.start) {
              style2["start-date"] = true;
            }
            if (cell.end) {
              style2["end-date"] = true;
            }
          }
          return style2;
        };
        const isSelectedCell = (cell) => {
          const year = props.date.year();
          const month = cell.text;
          return castArray(props.date).findIndex((date2) => date2.year() === year && date2.month() === month) >= 0;
        };
        const handleMouseMove = (event) => {
          var _a2;
          if (!props.rangeState.selecting)
            return;
          let target = event.target;
          if (target.tagName === "A") {
            target = (_a2 = target.parentNode) == null ? void 0 : _a2.parentNode;
          }
          if (target.tagName === "DIV") {
            target = target.parentNode;
          }
          if (target.tagName !== "TD")
            return;
          const row = target.parentNode.rowIndex;
          const column = target.cellIndex;
          if (rows.value[row][column].disabled)
            return;
          if (row !== lastRow.value || column !== lastColumn.value) {
            lastRow.value = row;
            lastColumn.value = column;
            emit("changerange", {
              selecting: true,
              endDate: props.date.startOf("year").month(row * 4 + column)
            });
          }
        };
        const handleMonthTableClick = (event) => {
          var _a2;
          const target = (_a2 = event.target) == null ? void 0 : _a2.closest("td");
          if ((target == null ? void 0 : target.tagName) !== "TD")
            return;
          if (hasClass(target, "disabled"))
            return;
          const column = target.cellIndex;
          const row = target.parentNode.rowIndex;
          const month = row * 4 + column;
          const newDate = props.date.startOf("year").month(month);
          if (props.selectionMode === "range") {
            if (!props.rangeState.selecting) {
              emit("pick", { minDate: newDate, maxDate: null });
              emit("select", true);
            } else {
              if (props.minDate && newDate >= props.minDate) {
                emit("pick", { minDate: props.minDate, maxDate: newDate });
              } else {
                emit("pick", { minDate: newDate, maxDate: props.minDate });
              }
              emit("select", false);
            }
          } else {
            emit("pick", month);
          }
        };
        watch(() => props.date, async () => {
          var _a2, _b;
          if ((_a2 = tbodyRef.value) == null ? void 0 : _a2.contains(document.activeElement)) {
            await nextTick();
            (_b = currentCellRef.value) == null ? void 0 : _b.focus();
          }
        });
        expose({
          focus
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("table", {
            role: "grid",
            "aria-label": unref(t)("el.datepicker.monthTablePrompt"),
            class: normalizeClass(unref(ns2).b()),
            onClick: handleMonthTableClick,
            onMousemove: handleMouseMove
          }, [
            createBaseVNode("tbody", {
              ref_key: "tbodyRef",
              ref: tbodyRef
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(rows), (row, key) => {
                return openBlock(), createElementBlock("tr", { key }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, key_) => {
                    return openBlock(), createElementBlock("td", {
                      key: key_,
                      ref_for: true,
                      ref: (el) => isSelectedCell(cell) && (currentCellRef.value = el),
                      class: normalizeClass(getCellStyle(cell)),
                      "aria-selected": `${isSelectedCell(cell)}`,
                      "aria-label": unref(t)(`el.datepicker.month${+cell.text + 1}`),
                      tabindex: isSelectedCell(cell) ? 0 : -1,
                      onKeydown: [
                        withKeys(withModifiers(handleMonthTableClick, ["prevent", "stop"]), ["space"]),
                        withKeys(withModifiers(handleMonthTableClick, ["prevent", "stop"]), ["enter"])
                      ]
                    }, [
                      createBaseVNode("div", null, [
                        createBaseVNode("span", _hoisted_3$h, toDisplayString$1(unref(t)("el.datepicker.months." + months.value[cell.text])), 1)
                      ])
                    ], 42, _hoisted_2$u);
                  }), 128))
                ]);
              }), 128))
            ], 512)
          ], 42, _hoisted_1$K);
        };
      }
    });
    var MonthTable = /* @__PURE__ */ _export_sfc(_sfc_main$1n, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-month-table.vue"]]);
    const { date: date$1, disabledDate, parsedValue } = datePickerSharedProps;
    const basicYearTableProps = buildProps({
      date: date$1,
      disabledDate,
      parsedValue
    });
    const _hoisted_1$J = ["aria-label"];
    const _hoisted_2$t = ["aria-selected", "tabindex", "onKeydown"];
    const _hoisted_3$g = { class: "cell" };
    const _hoisted_4$c = { key: 1 };
    const _sfc_main$1m = /* @__PURE__ */ defineComponent({
      __name: "basic-year-table",
      props: basicYearTableProps,
      emits: ["pick"],
      setup(__props, { expose, emit }) {
        const props = __props;
        const datesInYear = (year, lang2) => {
          const firstDay = dayjs(String(year)).locale(lang2).startOf("year");
          const lastDay = firstDay.endOf("year");
          const numOfDays = lastDay.dayOfYear();
          return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
        };
        const ns2 = useNamespace("year-table");
        const { t, lang } = useLocale();
        const tbodyRef = ref();
        const currentCellRef = ref();
        const startYear = computed(() => {
          return Math.floor(props.date.year() / 10) * 10;
        });
        const focus = () => {
          var _a2;
          (_a2 = currentCellRef.value) == null ? void 0 : _a2.focus();
        };
        const getCellKls = (year) => {
          const kls = {};
          const today = dayjs().locale(lang.value);
          kls.disabled = props.disabledDate ? datesInYear(year, lang.value).every(props.disabledDate) : false;
          kls.current = castArray(props.parsedValue).findIndex((d2) => d2.year() === year) >= 0;
          kls.today = today.year() === year;
          return kls;
        };
        const isSelectedCell = (year) => {
          return year === startYear.value && props.date.year() < startYear.value && props.date.year() > startYear.value + 9 || castArray(props.date).findIndex((date2) => date2.year() === year) >= 0;
        };
        const handleYearTableClick = (event) => {
          const clickTarget = event.target;
          const target = clickTarget.closest("td");
          if (target && target.textContent) {
            if (hasClass(target, "disabled"))
              return;
            const year = target.textContent || target.innerText;
            emit("pick", Number(year));
          }
        };
        watch(() => props.date, async () => {
          var _a2, _b;
          if ((_a2 = tbodyRef.value) == null ? void 0 : _a2.contains(document.activeElement)) {
            await nextTick();
            (_b = currentCellRef.value) == null ? void 0 : _b.focus();
          }
        });
        expose({
          focus
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("table", {
            role: "grid",
            "aria-label": unref(t)("el.datepicker.yearTablePrompt"),
            class: normalizeClass(unref(ns2).b()),
            onClick: handleYearTableClick
          }, [
            createBaseVNode("tbody", {
              ref_key: "tbodyRef",
              ref: tbodyRef
            }, [
              (openBlock(), createElementBlock(Fragment, null, renderList(3, (_2, i) => {
                return createBaseVNode("tr", { key: i }, [
                  (openBlock(), createElementBlock(Fragment, null, renderList(4, (__, j) => {
                    return openBlock(), createElementBlock(Fragment, {
                      key: i + "_" + j
                    }, [
                      i * 4 + j < 10 ? (openBlock(), createElementBlock("td", {
                        key: 0,
                        ref_for: true,
                        ref: (el) => isSelectedCell(unref(startYear) + i * 4 + j) && (currentCellRef.value = el),
                        class: normalizeClass(["available", getCellKls(unref(startYear) + i * 4 + j)]),
                        "aria-selected": `${isSelectedCell(unref(startYear) + i * 4 + j)}`,
                        tabindex: isSelectedCell(unref(startYear) + i * 4 + j) ? 0 : -1,
                        onKeydown: [
                          withKeys(withModifiers(handleYearTableClick, ["prevent", "stop"]), ["space"]),
                          withKeys(withModifiers(handleYearTableClick, ["prevent", "stop"]), ["enter"])
                        ]
                      }, [
                        createBaseVNode("span", _hoisted_3$g, toDisplayString$1(unref(startYear) + i * 4 + j), 1)
                      ], 42, _hoisted_2$t)) : (openBlock(), createElementBlock("td", _hoisted_4$c))
                    ], 64);
                  }), 64))
                ]);
              }), 64))
            ], 512)
          ], 10, _hoisted_1$J);
        };
      }
    });
    var YearTable = /* @__PURE__ */ _export_sfc(_sfc_main$1m, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-year-table.vue"]]);
    const _hoisted_1$I = ["onClick"];
    const _hoisted_2$s = ["aria-label"];
    const _hoisted_3$f = ["aria-label"];
    const _hoisted_4$b = ["aria-label"];
    const _hoisted_5$9 = ["aria-label"];
    const _sfc_main$1l = /* @__PURE__ */ defineComponent({
      __name: "panel-date-pick",
      props: panelDatePickProps,
      emits: ["pick", "set-picker-option", "panel-change"],
      setup(__props, { emit: contextEmit }) {
        const props = __props;
        const timeWithinRange = (_2, __, ___) => true;
        const ppNs = useNamespace("picker-panel");
        const dpNs = useNamespace("date-picker");
        const attrs = useAttrs$1();
        const slots = useSlots();
        const { t, lang } = useLocale();
        const pickerBase = inject("EP_PICKER_BASE");
        const popper = inject(TOOLTIP_INJECTION_KEY);
        const { shortcuts, disabledDate: disabledDate2, cellClassName, defaultTime, arrowControl } = pickerBase.props;
        const defaultValue = toRef(pickerBase.props, "defaultValue");
        const currentViewRef = ref();
        const innerDate = ref(dayjs().locale(lang.value));
        const defaultTimeD = computed(() => {
          return dayjs(defaultTime).locale(lang.value);
        });
        const month = computed(() => {
          return innerDate.value.month();
        });
        const year = computed(() => {
          return innerDate.value.year();
        });
        const selectableRange = ref([]);
        const userInputDate = ref(null);
        const userInputTime = ref(null);
        const checkDateWithinRange = (date2) => {
          return selectableRange.value.length > 0 ? timeWithinRange(date2, selectableRange.value, props.format || "HH:mm:ss") : true;
        };
        const formatEmit = (emitDayjs) => {
          if (defaultTime && !visibleTime.value) {
            return defaultTimeD.value.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
          }
          if (showTime.value)
            return emitDayjs.millisecond(0);
          return emitDayjs.startOf("day");
        };
        const emit = (value, ...args) => {
          if (!value) {
            contextEmit("pick", value, ...args);
          } else if (isArray$4(value)) {
            const dates = value.map(formatEmit);
            contextEmit("pick", dates, ...args);
          } else {
            contextEmit("pick", formatEmit(value), ...args);
          }
          userInputDate.value = null;
          userInputTime.value = null;
        };
        const handleDatePick = (value, keepOpen) => {
          if (selectionMode.value === "date") {
            value = value;
            let newDate = props.parsedValue ? props.parsedValue.year(value.year()).month(value.month()).date(value.date()) : value;
            if (!checkDateWithinRange(newDate)) {
              newDate = selectableRange.value[0][0].year(value.year()).month(value.month()).date(value.date());
            }
            innerDate.value = newDate;
            emit(newDate, showTime.value || keepOpen);
          } else if (selectionMode.value === "week") {
            emit(value.date);
          } else if (selectionMode.value === "dates") {
            emit(value, true);
          }
        };
        const moveByMonth = (forward) => {
          const action = forward ? "add" : "subtract";
          innerDate.value = innerDate.value[action](1, "month");
          handlePanelChange("month");
        };
        const moveByYear = (forward) => {
          const currentDate = innerDate.value;
          const action = forward ? "add" : "subtract";
          innerDate.value = currentView.value === "year" ? currentDate[action](10, "year") : currentDate[action](1, "year");
          handlePanelChange("year");
        };
        const currentView = ref("date");
        const yearLabel = computed(() => {
          const yearTranslation = t("el.datepicker.year");
          if (currentView.value === "year") {
            const startYear = Math.floor(year.value / 10) * 10;
            if (yearTranslation) {
              return `${startYear} ${yearTranslation} - ${startYear + 9} ${yearTranslation}`;
            }
            return `${startYear} - ${startYear + 9}`;
          }
          return `${year.value} ${yearTranslation}`;
        });
        const handleShortcutClick = (shortcut) => {
          const shortcutValue = isFunction$4(shortcut.value) ? shortcut.value() : shortcut.value;
          if (shortcutValue) {
            emit(dayjs(shortcutValue).locale(lang.value));
            return;
          }
          if (shortcut.onClick) {
            shortcut.onClick({
              attrs,
              slots,
              emit: contextEmit
            });
          }
        };
        const selectionMode = computed(() => {
          const { type: type2 } = props;
          if (["week", "month", "year", "dates"].includes(type2))
            return type2;
          return "date";
        });
        const keyboardMode = computed(() => {
          return selectionMode.value === "date" ? currentView.value : selectionMode.value;
        });
        const hasShortcuts = computed(() => !!shortcuts.length);
        const handleMonthPick = async (month2) => {
          innerDate.value = innerDate.value.startOf("month").month(month2);
          if (selectionMode.value === "month") {
            emit(innerDate.value, false);
          } else {
            currentView.value = "date";
            if (["month", "year", "date", "week"].includes(selectionMode.value)) {
              emit(innerDate.value, true);
              await nextTick();
              handleFocusPicker();
            }
          }
          handlePanelChange("month");
        };
        const handleYearPick = async (year2) => {
          if (selectionMode.value === "year") {
            innerDate.value = innerDate.value.startOf("year").year(year2);
            emit(innerDate.value, false);
          } else {
            innerDate.value = innerDate.value.year(year2);
            currentView.value = "month";
            if (["month", "year", "date", "week"].includes(selectionMode.value)) {
              emit(innerDate.value, true);
              await nextTick();
              handleFocusPicker();
            }
          }
          handlePanelChange("year");
        };
        const showPicker = async (view) => {
          currentView.value = view;
          await nextTick();
          handleFocusPicker();
        };
        const showTime = computed(() => props.type === "datetime" || props.type === "datetimerange");
        const footerVisible = computed(() => {
          return showTime.value || selectionMode.value === "dates";
        });
        const onConfirm = () => {
          if (selectionMode.value === "dates") {
            emit(props.parsedValue);
          } else {
            let result = props.parsedValue;
            if (!result) {
              const defaultTimeD2 = dayjs(defaultTime).locale(lang.value);
              const defaultValueD = getDefaultValue2();
              result = defaultTimeD2.year(defaultValueD.year()).month(defaultValueD.month()).date(defaultValueD.date());
            }
            innerDate.value = result;
            emit(result);
          }
        };
        const changeToNow = () => {
          const now2 = dayjs().locale(lang.value);
          const nowDate = now2.toDate();
          if ((!disabledDate2 || !disabledDate2(nowDate)) && checkDateWithinRange(nowDate)) {
            innerDate.value = dayjs().locale(lang.value);
            emit(innerDate.value);
          }
        };
        const timeFormat = computed(() => {
          return extractTimeFormat(props.format);
        });
        const dateFormat = computed(() => {
          return extractDateFormat(props.format);
        });
        const visibleTime = computed(() => {
          if (userInputTime.value)
            return userInputTime.value;
          if (!props.parsedValue && !defaultValue.value)
            return;
          return (props.parsedValue || innerDate.value).format(timeFormat.value);
        });
        const visibleDate = computed(() => {
          if (userInputDate.value)
            return userInputDate.value;
          if (!props.parsedValue && !defaultValue.value)
            return;
          return (props.parsedValue || innerDate.value).format(dateFormat.value);
        });
        const timePickerVisible = ref(false);
        const onTimePickerInputFocus = () => {
          timePickerVisible.value = true;
        };
        const handleTimePickClose = () => {
          timePickerVisible.value = false;
        };
        const getUnits = (date2) => {
          return {
            hour: date2.hour(),
            minute: date2.minute(),
            second: date2.second(),
            year: date2.year(),
            month: date2.month(),
            date: date2.date()
          };
        };
        const handleTimePick = (value, visible, first) => {
          const { hour, minute, second } = getUnits(value);
          const newDate = props.parsedValue ? props.parsedValue.hour(hour).minute(minute).second(second) : value;
          innerDate.value = newDate;
          emit(innerDate.value, true);
          if (!first) {
            timePickerVisible.value = visible;
          }
        };
        const handleVisibleTimeChange = (value) => {
          const newDate = dayjs(value, timeFormat.value).locale(lang.value);
          if (newDate.isValid() && checkDateWithinRange(newDate)) {
            const { year: year2, month: month2, date: date2 } = getUnits(innerDate.value);
            innerDate.value = newDate.year(year2).month(month2).date(date2);
            userInputTime.value = null;
            timePickerVisible.value = false;
            emit(innerDate.value, true);
          }
        };
        const handleVisibleDateChange = (value) => {
          const newDate = dayjs(value, dateFormat.value).locale(lang.value);
          if (newDate.isValid()) {
            if (disabledDate2 && disabledDate2(newDate.toDate())) {
              return;
            }
            const { hour, minute, second } = getUnits(innerDate.value);
            innerDate.value = newDate.hour(hour).minute(minute).second(second);
            userInputDate.value = null;
            emit(innerDate.value, true);
          }
        };
        const isValidValue2 = (date2) => {
          return dayjs.isDayjs(date2) && date2.isValid() && (disabledDate2 ? !disabledDate2(date2.toDate()) : true);
        };
        const formatToString = (value) => {
          if (selectionMode.value === "dates") {
            return value.map((_2) => _2.format(props.format));
          }
          return value.format(props.format);
        };
        const parseUserInput = (value) => {
          return dayjs(value, props.format).locale(lang.value);
        };
        const getDefaultValue2 = () => {
          const parseDate2 = dayjs(defaultValue.value).locale(lang.value);
          if (!defaultValue.value) {
            const defaultTimeDValue = defaultTimeD.value;
            return dayjs().hour(defaultTimeDValue.hour()).minute(defaultTimeDValue.minute()).second(defaultTimeDValue.second()).locale(lang.value);
          }
          return parseDate2;
        };
        const handleFocusPicker = async () => {
          var _a2;
          if (["week", "month", "year", "date"].includes(selectionMode.value)) {
            (_a2 = currentViewRef.value) == null ? void 0 : _a2.focus();
            if (selectionMode.value === "week") {
              handleKeyControl(EVENT_CODE.down);
            }
          }
        };
        const handleKeydownTable = (event) => {
          const { code: code2 } = event;
          const validCode = [
            EVENT_CODE.up,
            EVENT_CODE.down,
            EVENT_CODE.left,
            EVENT_CODE.right,
            EVENT_CODE.home,
            EVENT_CODE.end,
            EVENT_CODE.pageUp,
            EVENT_CODE.pageDown
          ];
          if (validCode.includes(code2)) {
            handleKeyControl(code2);
            event.stopPropagation();
            event.preventDefault();
          }
          if ([EVENT_CODE.enter, EVENT_CODE.space].includes(code2) && userInputDate.value === null && userInputTime.value === null) {
            event.preventDefault();
            emit(innerDate.value, false);
          }
        };
        const handleKeyControl = (code2) => {
          var _a2;
          const { up: up2, down: down2, left: left2, right: right2, home: home2, end: end2, pageUp: pageUp2, pageDown: pageDown2 } = EVENT_CODE;
          const mapping = {
            year: {
              [up2]: -4,
              [down2]: 4,
              [left2]: -1,
              [right2]: 1,
              offset: (date2, step) => date2.setFullYear(date2.getFullYear() + step)
            },
            month: {
              [up2]: -4,
              [down2]: 4,
              [left2]: -1,
              [right2]: 1,
              offset: (date2, step) => date2.setMonth(date2.getMonth() + step)
            },
            week: {
              [up2]: -1,
              [down2]: 1,
              [left2]: -1,
              [right2]: 1,
              offset: (date2, step) => date2.setDate(date2.getDate() + step * 7)
            },
            date: {
              [up2]: -7,
              [down2]: 7,
              [left2]: -1,
              [right2]: 1,
              [home2]: (date2) => -date2.getDay(),
              [end2]: (date2) => -date2.getDay() + 6,
              [pageUp2]: (date2) => -new Date(date2.getFullYear(), date2.getMonth(), 0).getDate(),
              [pageDown2]: (date2) => new Date(date2.getFullYear(), date2.getMonth() + 1, 0).getDate(),
              offset: (date2, step) => date2.setDate(date2.getDate() + step)
            }
          };
          const newDate = innerDate.value.toDate();
          while (Math.abs(innerDate.value.diff(newDate, "year", true)) < 1) {
            const map = mapping[keyboardMode.value];
            if (!map)
              return;
            map.offset(newDate, isFunction$4(map[code2]) ? map[code2](newDate) : (_a2 = map[code2]) != null ? _a2 : 0);
            if (disabledDate2 && disabledDate2(newDate)) {
              break;
            }
            const result = dayjs(newDate).locale(lang.value);
            innerDate.value = result;
            contextEmit("pick", result, true);
            break;
          }
        };
        const handlePanelChange = (mode) => {
          contextEmit("panel-change", innerDate.value.toDate(), mode, currentView.value);
        };
        watch(() => selectionMode.value, (val) => {
          if (["month", "year"].includes(val)) {
            currentView.value = val;
            return;
          }
          currentView.value = "date";
        }, { immediate: true });
        watch(() => currentView.value, () => {
          popper == null ? void 0 : popper.updatePopper();
        });
        watch(() => defaultValue.value, (val) => {
          if (val) {
            innerDate.value = getDefaultValue2();
          }
        }, { immediate: true });
        watch(() => props.parsedValue, (val) => {
          if (val) {
            if (selectionMode.value === "dates")
              return;
            if (Array.isArray(val))
              return;
            innerDate.value = val;
          } else {
            innerDate.value = getDefaultValue2();
          }
        }, { immediate: true });
        contextEmit("set-picker-option", ["isValidValue", isValidValue2]);
        contextEmit("set-picker-option", ["formatToString", formatToString]);
        contextEmit("set-picker-option", ["parseUserInput", parseUserInput]);
        contextEmit("set-picker-option", ["handleFocusPicker", handleFocusPicker]);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([
              unref(ppNs).b(),
              unref(dpNs).b(),
              {
                "has-sidebar": _ctx.$slots.sidebar || unref(hasShortcuts),
                "has-time": unref(showTime)
              }
            ])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(unref(ppNs).e("body-wrapper"))
            }, [
              renderSlot(_ctx.$slots, "sidebar", {
                class: normalizeClass(unref(ppNs).e("sidebar"))
              }),
              unref(hasShortcuts) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ppNs).e("sidebar"))
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(shortcuts), (shortcut, key) => {
                  return openBlock(), createElementBlock("button", {
                    key,
                    type: "button",
                    class: normalizeClass(unref(ppNs).e("shortcut")),
                    onClick: ($event) => handleShortcutClick(shortcut)
                  }, toDisplayString$1(shortcut.text), 11, _hoisted_1$I);
                }), 128))
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                class: normalizeClass(unref(ppNs).e("body"))
              }, [
                unref(showTime) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(dpNs).e("time-header"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(dpNs).e("editor-wrap"))
                  }, [
                    createVNode(unref(ElInput), {
                      placeholder: unref(t)("el.datepicker.selectDate"),
                      "model-value": unref(visibleDate),
                      size: "small",
                      "validate-event": false,
                      onInput: _cache[0] || (_cache[0] = (val) => userInputDate.value = val),
                      onChange: handleVisibleDateChange
                    }, null, 8, ["placeholder", "model-value"])
                  ], 2),
                  withDirectives((openBlock(), createElementBlock("span", {
                    class: normalizeClass(unref(dpNs).e("editor-wrap"))
                  }, [
                    createVNode(unref(ElInput), {
                      placeholder: unref(t)("el.datepicker.selectTime"),
                      "model-value": unref(visibleTime),
                      size: "small",
                      "validate-event": false,
                      onFocus: onTimePickerInputFocus,
                      onInput: _cache[1] || (_cache[1] = (val) => userInputTime.value = val),
                      onChange: handleVisibleTimeChange
                    }, null, 8, ["placeholder", "model-value"]),
                    createVNode(unref(TimePickPanel), {
                      visible: timePickerVisible.value,
                      format: unref(timeFormat),
                      "time-arrow-control": unref(arrowControl),
                      "parsed-value": innerDate.value,
                      onPick: handleTimePick
                    }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
                  ], 2)), [
                    [unref(ClickOutside), handleTimePickClose]
                  ])
                ], 2)) : createCommentVNode("v-if", true),
                withDirectives(createBaseVNode("div", {
                  class: normalizeClass([
                    unref(dpNs).e("header"),
                    (currentView.value === "year" || currentView.value === "month") && unref(dpNs).e("header--bordered")
                  ])
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(dpNs).e("prev-btn"))
                  }, [
                    createBaseVNode("button", {
                      type: "button",
                      "aria-label": unref(t)(`el.datepicker.prevYear`),
                      class: normalizeClass(["d-arrow-left", unref(ppNs).e("icon-btn")]),
                      onClick: _cache[2] || (_cache[2] = ($event) => moveByYear(false))
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(d_arrow_left_default))
                        ]),
                        _: 1
                      })
                    ], 10, _hoisted_2$s),
                    withDirectives(createBaseVNode("button", {
                      type: "button",
                      "aria-label": unref(t)(`el.datepicker.prevMonth`),
                      class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-left"]),
                      onClick: _cache[3] || (_cache[3] = ($event) => moveByMonth(false))
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(arrow_left_default))
                        ]),
                        _: 1
                      })
                    ], 10, _hoisted_3$f), [
                      [vShow, currentView.value === "date"]
                    ])
                  ], 2),
                  createBaseVNode("span", {
                    role: "button",
                    class: normalizeClass(unref(dpNs).e("header-label")),
                    "aria-live": "polite",
                    tabindex: "0",
                    onKeydown: _cache[4] || (_cache[4] = withKeys(($event) => showPicker("year"), ["enter"])),
                    onClick: _cache[5] || (_cache[5] = ($event) => showPicker("year"))
                  }, toDisplayString$1(unref(yearLabel)), 35),
                  withDirectives(createBaseVNode("span", {
                    role: "button",
                    "aria-live": "polite",
                    tabindex: "0",
                    class: normalizeClass([
                      unref(dpNs).e("header-label"),
                      { active: currentView.value === "month" }
                    ]),
                    onKeydown: _cache[6] || (_cache[6] = withKeys(($event) => showPicker("month"), ["enter"])),
                    onClick: _cache[7] || (_cache[7] = ($event) => showPicker("month"))
                  }, toDisplayString$1(unref(t)(`el.datepicker.month${unref(month) + 1}`)), 35), [
                    [vShow, currentView.value === "date"]
                  ]),
                  createBaseVNode("span", {
                    class: normalizeClass(unref(dpNs).e("next-btn"))
                  }, [
                    withDirectives(createBaseVNode("button", {
                      type: "button",
                      "aria-label": unref(t)(`el.datepicker.nextMonth`),
                      class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-right"]),
                      onClick: _cache[8] || (_cache[8] = ($event) => moveByMonth(true))
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(arrow_right_default))
                        ]),
                        _: 1
                      })
                    ], 10, _hoisted_4$b), [
                      [vShow, currentView.value === "date"]
                    ]),
                    createBaseVNode("button", {
                      type: "button",
                      "aria-label": unref(t)(`el.datepicker.nextYear`),
                      class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-right"]),
                      onClick: _cache[9] || (_cache[9] = ($event) => moveByYear(true))
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(d_arrow_right_default))
                        ]),
                        _: 1
                      })
                    ], 10, _hoisted_5$9)
                  ], 2)
                ], 2), [
                  [vShow, currentView.value !== "time"]
                ]),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ppNs).e("content")),
                  onKeydown: handleKeydownTable
                }, [
                  currentView.value === "date" ? (openBlock(), createBlock(DateTable, {
                    key: 0,
                    ref_key: "currentViewRef",
                    ref: currentViewRef,
                    "selection-mode": unref(selectionMode),
                    date: innerDate.value,
                    "parsed-value": _ctx.parsedValue,
                    "disabled-date": unref(disabledDate2),
                    "cell-class-name": unref(cellClassName),
                    onPick: handleDatePick
                  }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "cell-class-name"])) : createCommentVNode("v-if", true),
                  currentView.value === "year" ? (openBlock(), createBlock(YearTable, {
                    key: 1,
                    ref_key: "currentViewRef",
                    ref: currentViewRef,
                    date: innerDate.value,
                    "disabled-date": unref(disabledDate2),
                    "parsed-value": _ctx.parsedValue,
                    onPick: handleYearPick
                  }, null, 8, ["date", "disabled-date", "parsed-value"])) : createCommentVNode("v-if", true),
                  currentView.value === "month" ? (openBlock(), createBlock(MonthTable, {
                    key: 2,
                    ref_key: "currentViewRef",
                    ref: currentViewRef,
                    date: innerDate.value,
                    "parsed-value": _ctx.parsedValue,
                    "disabled-date": unref(disabledDate2),
                    onPick: handleMonthPick
                  }, null, 8, ["date", "parsed-value", "disabled-date"])) : createCommentVNode("v-if", true)
                ], 34)
              ], 2)
            ], 2),
            withDirectives(createBaseVNode("div", {
              class: normalizeClass(unref(ppNs).e("footer"))
            }, [
              withDirectives(createVNode(unref(ElButton), {
                text: "",
                size: "small",
                class: normalizeClass(unref(ppNs).e("link-btn")),
                onClick: changeToNow
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(t)("el.datepicker.now")), 1)
                ]),
                _: 1
              }, 8, ["class"]), [
                [vShow, unref(selectionMode) !== "dates"]
              ]),
              createVNode(unref(ElButton), {
                plain: "",
                size: "small",
                class: normalizeClass(unref(ppNs).e("link-btn")),
                onClick: onConfirm
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(t)("el.datepicker.confirm")), 1)
                ]),
                _: 1
              }, 8, ["class"])
            ], 2), [
              [vShow, unref(footerVisible) && currentView.value === "date"]
            ])
          ], 2);
        };
      }
    });
    var DatePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1l, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-pick.vue"]]);
    const panelDateRangeProps = buildProps({
      ...panelSharedProps,
      ...panelRangeSharedProps
    });
    const useShortcut = (lang) => {
      const { emit } = getCurrentInstance();
      const attrs = useAttrs$1();
      const slots = useSlots();
      const handleShortcutClick = (shortcut) => {
        const shortcutValues = isFunction$4(shortcut.value) ? shortcut.value() : shortcut.value;
        if (shortcutValues) {
          emit("pick", [
            dayjs(shortcutValues[0]).locale(lang.value),
            dayjs(shortcutValues[1]).locale(lang.value)
          ]);
          return;
        }
        if (shortcut.onClick) {
          shortcut.onClick({
            attrs,
            slots,
            emit
          });
        }
      };
      return handleShortcutClick;
    };
    const useRangePicker = (props, {
      defaultValue,
      leftDate,
      rightDate,
      unit,
      onParsedValueChanged
    }) => {
      const { emit } = getCurrentInstance();
      const { pickerNs } = inject(ROOT_PICKER_INJECTION_KEY);
      const drpNs = useNamespace("date-range-picker");
      const { t, lang } = useLocale();
      const handleShortcutClick = useShortcut(lang);
      const minDate = ref();
      const maxDate = ref();
      const rangeState = ref({
        endDate: null,
        selecting: false
      });
      const handleChangeRange = (val) => {
        rangeState.value = val;
      };
      const handleRangeConfirm = (visible = false) => {
        const _minDate = unref(minDate);
        const _maxDate = unref(maxDate);
        if (isValidRange([_minDate, _maxDate])) {
          emit("pick", [_minDate, _maxDate], visible);
        }
      };
      const onSelect = (selecting) => {
        rangeState.value.selecting = selecting;
        if (!selecting) {
          rangeState.value.endDate = null;
        }
      };
      const restoreDefault = () => {
        const [start, end2] = getDefaultValue(unref(defaultValue), {
          lang: unref(lang),
          unit,
          unlinkPanels: props.unlinkPanels
        });
        minDate.value = void 0;
        maxDate.value = void 0;
        leftDate.value = start;
        rightDate.value = end2;
      };
      watch(defaultValue, (val) => {
        if (val) {
          restoreDefault();
        }
      }, { immediate: true });
      watch(() => props.parsedValue, (parsedValue2) => {
        if (isArray$4(parsedValue2) && parsedValue2.length === 2) {
          const [start, end2] = parsedValue2;
          minDate.value = start;
          leftDate.value = start;
          maxDate.value = end2;
          onParsedValueChanged(unref(minDate), unref(maxDate));
        } else {
          restoreDefault();
        }
      }, { immediate: true });
      return {
        minDate,
        maxDate,
        rangeState,
        lang,
        ppNs: pickerNs,
        drpNs,
        handleChangeRange,
        handleRangeConfirm,
        handleShortcutClick,
        onSelect,
        t
      };
    };
    const _hoisted_1$H = ["onClick"];
    const _hoisted_2$r = ["disabled"];
    const _hoisted_3$e = ["disabled"];
    const _hoisted_4$a = ["disabled"];
    const _hoisted_5$8 = ["disabled"];
    const _sfc_main$1k = /* @__PURE__ */ defineComponent({
      __name: "panel-date-range",
      props: panelDateRangeProps,
      emits: [
        "pick",
        "set-picker-option",
        "calendar-change",
        "panel-change"
      ],
      setup(__props, { emit }) {
        const props = __props;
        const unit = "month";
        const pickerBase = inject("EP_PICKER_BASE");
        const {
          disabledDate: disabledDate2,
          cellClassName,
          format: format2,
          defaultTime,
          arrowControl,
          clearable
        } = pickerBase.props;
        const shortcuts = toRef(pickerBase.props, "shortcuts");
        const defaultValue = toRef(pickerBase.props, "defaultValue");
        const { lang } = useLocale();
        const leftDate = ref(dayjs().locale(lang.value));
        const rightDate = ref(dayjs().locale(lang.value).add(1, unit));
        const {
          minDate,
          maxDate,
          rangeState,
          ppNs,
          drpNs,
          handleChangeRange,
          handleRangeConfirm,
          handleShortcutClick,
          onSelect,
          t
        } = useRangePicker(props, {
          defaultValue,
          leftDate,
          rightDate,
          unit,
          onParsedValueChanged
        });
        const dateUserInput = ref({
          min: null,
          max: null
        });
        const timeUserInput = ref({
          min: null,
          max: null
        });
        const leftLabel = computed(() => {
          return `${leftDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${leftDate.value.month() + 1}`)}`;
        });
        const rightLabel = computed(() => {
          return `${rightDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${rightDate.value.month() + 1}`)}`;
        });
        const leftYear = computed(() => {
          return leftDate.value.year();
        });
        const leftMonth = computed(() => {
          return leftDate.value.month();
        });
        const rightYear = computed(() => {
          return rightDate.value.year();
        });
        const rightMonth = computed(() => {
          return rightDate.value.month();
        });
        const hasShortcuts = computed(() => !!shortcuts.value.length);
        const minVisibleDate = computed(() => {
          if (dateUserInput.value.min !== null)
            return dateUserInput.value.min;
          if (minDate.value)
            return minDate.value.format(dateFormat.value);
          return "";
        });
        const maxVisibleDate = computed(() => {
          if (dateUserInput.value.max !== null)
            return dateUserInput.value.max;
          if (maxDate.value || minDate.value)
            return (maxDate.value || minDate.value).format(dateFormat.value);
          return "";
        });
        const minVisibleTime = computed(() => {
          if (timeUserInput.value.min !== null)
            return timeUserInput.value.min;
          if (minDate.value)
            return minDate.value.format(timeFormat.value);
          return "";
        });
        const maxVisibleTime = computed(() => {
          if (timeUserInput.value.max !== null)
            return timeUserInput.value.max;
          if (maxDate.value || minDate.value)
            return (maxDate.value || minDate.value).format(timeFormat.value);
          return "";
        });
        const timeFormat = computed(() => {
          return extractTimeFormat(format2);
        });
        const dateFormat = computed(() => {
          return extractDateFormat(format2);
        });
        const leftPrevYear = () => {
          leftDate.value = leftDate.value.subtract(1, "year");
          if (!props.unlinkPanels) {
            rightDate.value = leftDate.value.add(1, "month");
          }
          handlePanelChange("year");
        };
        const leftPrevMonth = () => {
          leftDate.value = leftDate.value.subtract(1, "month");
          if (!props.unlinkPanels) {
            rightDate.value = leftDate.value.add(1, "month");
          }
          handlePanelChange("month");
        };
        const rightNextYear = () => {
          if (!props.unlinkPanels) {
            leftDate.value = leftDate.value.add(1, "year");
            rightDate.value = leftDate.value.add(1, "month");
          } else {
            rightDate.value = rightDate.value.add(1, "year");
          }
          handlePanelChange("year");
        };
        const rightNextMonth = () => {
          if (!props.unlinkPanels) {
            leftDate.value = leftDate.value.add(1, "month");
            rightDate.value = leftDate.value.add(1, "month");
          } else {
            rightDate.value = rightDate.value.add(1, "month");
          }
          handlePanelChange("month");
        };
        const leftNextYear = () => {
          leftDate.value = leftDate.value.add(1, "year");
          handlePanelChange("year");
        };
        const leftNextMonth = () => {
          leftDate.value = leftDate.value.add(1, "month");
          handlePanelChange("month");
        };
        const rightPrevYear = () => {
          rightDate.value = rightDate.value.subtract(1, "year");
          handlePanelChange("year");
        };
        const rightPrevMonth = () => {
          rightDate.value = rightDate.value.subtract(1, "month");
          handlePanelChange("month");
        };
        const handlePanelChange = (mode) => {
          emit("panel-change", [leftDate.value.toDate(), rightDate.value.toDate()], mode);
        };
        const enableMonthArrow = computed(() => {
          const nextMonth = (leftMonth.value + 1) % 12;
          const yearOffset = leftMonth.value + 1 >= 12 ? 1 : 0;
          return props.unlinkPanels && new Date(leftYear.value + yearOffset, nextMonth) < new Date(rightYear.value, rightMonth.value);
        });
        const enableYearArrow = computed(() => {
          return props.unlinkPanels && rightYear.value * 12 + rightMonth.value - (leftYear.value * 12 + leftMonth.value + 1) >= 12;
        });
        const btnDisabled = computed(() => {
          return !(minDate.value && maxDate.value && !rangeState.value.selecting && isValidRange([minDate.value, maxDate.value]));
        });
        const showTime = computed(() => props.type === "datetime" || props.type === "datetimerange");
        const formatEmit = (emitDayjs, index2) => {
          if (!emitDayjs)
            return;
          if (defaultTime) {
            const defaultTimeD = dayjs(defaultTime[index2] || defaultTime).locale(lang.value);
            return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
          }
          return emitDayjs;
        };
        const handleRangePick = (val, close2 = true) => {
          const min_ = val.minDate;
          const max_ = val.maxDate;
          const minDate_ = formatEmit(min_, 0);
          const maxDate_ = formatEmit(max_, 1);
          if (maxDate.value === maxDate_ && minDate.value === minDate_) {
            return;
          }
          emit("calendar-change", [min_.toDate(), max_ && max_.toDate()]);
          maxDate.value = maxDate_;
          minDate.value = minDate_;
          if (!close2 || showTime.value)
            return;
          handleRangeConfirm();
        };
        const minTimePickerVisible = ref(false);
        const maxTimePickerVisible = ref(false);
        const handleMinTimeClose = () => {
          minTimePickerVisible.value = false;
        };
        const handleMaxTimeClose = () => {
          maxTimePickerVisible.value = false;
        };
        const handleDateInput = (value, type2) => {
          dateUserInput.value[type2] = value;
          const parsedValueD = dayjs(value, dateFormat.value).locale(lang.value);
          if (parsedValueD.isValid()) {
            if (disabledDate2 && disabledDate2(parsedValueD.toDate())) {
              return;
            }
            if (type2 === "min") {
              leftDate.value = parsedValueD;
              minDate.value = (minDate.value || leftDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
              if (!props.unlinkPanels) {
                rightDate.value = parsedValueD.add(1, "month");
                maxDate.value = minDate.value.add(1, "month");
              }
            } else {
              rightDate.value = parsedValueD;
              maxDate.value = (maxDate.value || rightDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
              if (!props.unlinkPanels) {
                leftDate.value = parsedValueD.subtract(1, "month");
                minDate.value = maxDate.value.subtract(1, "month");
              }
            }
          }
        };
        const handleDateChange = (_2, type2) => {
          dateUserInput.value[type2] = null;
        };
        const handleTimeInput = (value, type2) => {
          timeUserInput.value[type2] = value;
          const parsedValueD = dayjs(value, timeFormat.value).locale(lang.value);
          if (parsedValueD.isValid()) {
            if (type2 === "min") {
              minTimePickerVisible.value = true;
              minDate.value = (minDate.value || leftDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
              if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
                maxDate.value = minDate.value;
              }
            } else {
              maxTimePickerVisible.value = true;
              maxDate.value = (maxDate.value || rightDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
              rightDate.value = maxDate.value;
              if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
                minDate.value = maxDate.value;
              }
            }
          }
        };
        const handleTimeChange = (value, type2) => {
          timeUserInput.value[type2] = null;
          if (type2 === "min") {
            leftDate.value = minDate.value;
            minTimePickerVisible.value = false;
          } else {
            rightDate.value = maxDate.value;
            maxTimePickerVisible.value = false;
          }
        };
        const handleMinTimePick = (value, visible, first) => {
          if (timeUserInput.value.min)
            return;
          if (value) {
            leftDate.value = value;
            minDate.value = (minDate.value || leftDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
          }
          if (!first) {
            minTimePickerVisible.value = visible;
          }
          if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
            maxDate.value = minDate.value;
            rightDate.value = value;
          }
        };
        const handleMaxTimePick = (value, visible, first) => {
          if (timeUserInput.value.max)
            return;
          if (value) {
            rightDate.value = value;
            maxDate.value = (maxDate.value || rightDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
          }
          if (!first) {
            maxTimePickerVisible.value = visible;
          }
          if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
            minDate.value = maxDate.value;
          }
        };
        const handleClear = () => {
          leftDate.value = getDefaultValue(unref(defaultValue), {
            lang: unref(lang),
            unit: "month",
            unlinkPanels: props.unlinkPanels
          })[0];
          rightDate.value = leftDate.value.add(1, "month");
          emit("pick", null);
        };
        const formatToString = (value) => {
          return isArray$4(value) ? value.map((_2) => _2.format(format2)) : value.format(format2);
        };
        const parseUserInput = (value) => {
          return isArray$4(value) ? value.map((_2) => dayjs(_2, format2).locale(lang.value)) : dayjs(value, format2).locale(lang.value);
        };
        function onParsedValueChanged(minDate2, maxDate2) {
          if (props.unlinkPanels && maxDate2) {
            const minDateYear = (minDate2 == null ? void 0 : minDate2.year()) || 0;
            const minDateMonth = (minDate2 == null ? void 0 : minDate2.month()) || 0;
            const maxDateYear = maxDate2.year();
            const maxDateMonth = maxDate2.month();
            rightDate.value = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? maxDate2.add(1, unit) : maxDate2;
          } else {
            rightDate.value = leftDate.value.add(1, unit);
            if (maxDate2) {
              rightDate.value = rightDate.value.hour(maxDate2.hour()).minute(maxDate2.minute()).second(maxDate2.second());
            }
          }
        }
        emit("set-picker-option", ["isValidValue", isValidRange]);
        emit("set-picker-option", ["parseUserInput", parseUserInput]);
        emit("set-picker-option", ["formatToString", formatToString]);
        emit("set-picker-option", ["handleClear", handleClear]);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([
              unref(ppNs).b(),
              unref(drpNs).b(),
              {
                "has-sidebar": _ctx.$slots.sidebar || unref(hasShortcuts),
                "has-time": unref(showTime)
              }
            ])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(unref(ppNs).e("body-wrapper"))
            }, [
              renderSlot(_ctx.$slots, "sidebar", {
                class: normalizeClass(unref(ppNs).e("sidebar"))
              }),
              unref(hasShortcuts) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ppNs).e("sidebar"))
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(shortcuts), (shortcut, key) => {
                  return openBlock(), createElementBlock("button", {
                    key,
                    type: "button",
                    class: normalizeClass(unref(ppNs).e("shortcut")),
                    onClick: ($event) => unref(handleShortcutClick)(shortcut)
                  }, toDisplayString$1(shortcut.text), 11, _hoisted_1$H);
                }), 128))
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                class: normalizeClass(unref(ppNs).e("body"))
              }, [
                unref(showTime) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(drpNs).e("time-header"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(drpNs).e("editors-wrap"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                    }, [
                      createVNode(unref(ElInput), {
                        size: "small",
                        disabled: unref(rangeState).selecting,
                        placeholder: unref(t)("el.datepicker.startDate"),
                        class: normalizeClass(unref(drpNs).e("editor")),
                        "model-value": unref(minVisibleDate),
                        "validate-event": false,
                        onInput: _cache[0] || (_cache[0] = (val) => handleDateInput(val, "min")),
                        onChange: _cache[1] || (_cache[1] = (val) => handleDateChange(val, "min"))
                      }, null, 8, ["disabled", "placeholder", "class", "model-value"])
                    ], 2),
                    withDirectives((openBlock(), createElementBlock("span", {
                      class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                    }, [
                      createVNode(unref(ElInput), {
                        size: "small",
                        class: normalizeClass(unref(drpNs).e("editor")),
                        disabled: unref(rangeState).selecting,
                        placeholder: unref(t)("el.datepicker.startTime"),
                        "model-value": unref(minVisibleTime),
                        "validate-event": false,
                        onFocus: _cache[2] || (_cache[2] = ($event) => minTimePickerVisible.value = true),
                        onInput: _cache[3] || (_cache[3] = (val) => handleTimeInput(val, "min")),
                        onChange: _cache[4] || (_cache[4] = (val) => handleTimeChange(val, "min"))
                      }, null, 8, ["class", "disabled", "placeholder", "model-value"]),
                      createVNode(unref(TimePickPanel), {
                        visible: minTimePickerVisible.value,
                        format: unref(timeFormat),
                        "datetime-role": "start",
                        "time-arrow-control": unref(arrowControl),
                        "parsed-value": leftDate.value,
                        onPick: handleMinTimePick
                      }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
                    ], 2)), [
                      [unref(ClickOutside), handleMinTimeClose]
                    ])
                  ], 2),
                  createBaseVNode("span", null, [
                    createVNode(unref(ElIcon), null, {
                      default: withCtx(() => [
                        createVNode(unref(arrow_right_default))
                      ]),
                      _: 1
                    })
                  ]),
                  createBaseVNode("span", {
                    class: normalizeClass([unref(drpNs).e("editors-wrap"), "is-right"])
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                    }, [
                      createVNode(unref(ElInput), {
                        size: "small",
                        class: normalizeClass(unref(drpNs).e("editor")),
                        disabled: unref(rangeState).selecting,
                        placeholder: unref(t)("el.datepicker.endDate"),
                        "model-value": unref(maxVisibleDate),
                        readonly: !unref(minDate),
                        "validate-event": false,
                        onInput: _cache[5] || (_cache[5] = (val) => handleDateInput(val, "max")),
                        onChange: _cache[6] || (_cache[6] = (val) => handleDateChange(val, "max"))
                      }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"])
                    ], 2),
                    withDirectives((openBlock(), createElementBlock("span", {
                      class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                    }, [
                      createVNode(unref(ElInput), {
                        size: "small",
                        class: normalizeClass(unref(drpNs).e("editor")),
                        disabled: unref(rangeState).selecting,
                        placeholder: unref(t)("el.datepicker.endTime"),
                        "model-value": unref(maxVisibleTime),
                        readonly: !unref(minDate),
                        "validate-event": false,
                        onFocus: _cache[7] || (_cache[7] = ($event) => unref(minDate) && (maxTimePickerVisible.value = true)),
                        onInput: _cache[8] || (_cache[8] = (val) => handleTimeInput(val, "max")),
                        onChange: _cache[9] || (_cache[9] = (val) => handleTimeChange(val, "max"))
                      }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"]),
                      createVNode(unref(TimePickPanel), {
                        "datetime-role": "end",
                        visible: maxTimePickerVisible.value,
                        format: unref(timeFormat),
                        "time-arrow-control": unref(arrowControl),
                        "parsed-value": rightDate.value,
                        onPick: handleMaxTimePick
                      }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
                    ], 2)), [
                      [unref(ClickOutside), handleMaxTimeClose]
                    ])
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-left"])
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass(unref(drpNs).e("header"))
                  }, [
                    createBaseVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-left"]),
                      onClick: leftPrevYear
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(d_arrow_left_default))
                        ]),
                        _: 1
                      })
                    ], 2),
                    createBaseVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-left"]),
                      onClick: leftPrevMonth
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(arrow_left_default))
                        ]),
                        _: 1
                      })
                    ], 2),
                    _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                      key: 0,
                      type: "button",
                      disabled: !unref(enableYearArrow),
                      class: normalizeClass([[unref(ppNs).e("icon-btn"), { "is-disabled": !unref(enableYearArrow) }], "d-arrow-right"]),
                      onClick: leftNextYear
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(d_arrow_right_default))
                        ]),
                        _: 1
                      })
                    ], 10, _hoisted_2$r)) : createCommentVNode("v-if", true),
                    _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                      key: 1,
                      type: "button",
                      disabled: !unref(enableMonthArrow),
                      class: normalizeClass([[
                        unref(ppNs).e("icon-btn"),
                        { "is-disabled": !unref(enableMonthArrow) }
                      ], "arrow-right"]),
                      onClick: leftNextMonth
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(arrow_right_default))
                        ]),
                        _: 1
                      })
                    ], 10, _hoisted_3$e)) : createCommentVNode("v-if", true),
                    createBaseVNode("div", null, toDisplayString$1(unref(leftLabel)), 1)
                  ], 2),
                  createVNode(DateTable, {
                    "selection-mode": "range",
                    date: leftDate.value,
                    "min-date": unref(minDate),
                    "max-date": unref(maxDate),
                    "range-state": unref(rangeState),
                    "disabled-date": unref(disabledDate2),
                    "cell-class-name": unref(cellClassName),
                    onChangerange: unref(handleChangeRange),
                    onPick: handleRangePick,
                    onSelect: unref(onSelect)
                  }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])
                ], 2),
                createBaseVNode("div", {
                  class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-right"])
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass(unref(drpNs).e("header"))
                  }, [
                    _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                      key: 0,
                      type: "button",
                      disabled: !unref(enableYearArrow),
                      class: normalizeClass([[unref(ppNs).e("icon-btn"), { "is-disabled": !unref(enableYearArrow) }], "d-arrow-left"]),
                      onClick: rightPrevYear
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(d_arrow_left_default))
                        ]),
                        _: 1
                      })
                    ], 10, _hoisted_4$a)) : createCommentVNode("v-if", true),
                    _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                      key: 1,
                      type: "button",
                      disabled: !unref(enableMonthArrow),
                      class: normalizeClass([[
                        unref(ppNs).e("icon-btn"),
                        { "is-disabled": !unref(enableMonthArrow) }
                      ], "arrow-left"]),
                      onClick: rightPrevMonth
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(arrow_left_default))
                        ]),
                        _: 1
                      })
                    ], 10, _hoisted_5$8)) : createCommentVNode("v-if", true),
                    createBaseVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-right"]),
                      onClick: rightNextYear
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(d_arrow_right_default))
                        ]),
                        _: 1
                      })
                    ], 2),
                    createBaseVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-right"]),
                      onClick: rightNextMonth
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(arrow_right_default))
                        ]),
                        _: 1
                      })
                    ], 2),
                    createBaseVNode("div", null, toDisplayString$1(unref(rightLabel)), 1)
                  ], 2),
                  createVNode(DateTable, {
                    "selection-mode": "range",
                    date: rightDate.value,
                    "min-date": unref(minDate),
                    "max-date": unref(maxDate),
                    "range-state": unref(rangeState),
                    "disabled-date": unref(disabledDate2),
                    "cell-class-name": unref(cellClassName),
                    onChangerange: unref(handleChangeRange),
                    onPick: handleRangePick,
                    onSelect: unref(onSelect)
                  }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])
                ], 2)
              ], 2)
            ], 2),
            unref(showTime) ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(ppNs).e("footer"))
            }, [
              unref(clearable) ? (openBlock(), createBlock(unref(ElButton), {
                key: 0,
                text: "",
                size: "small",
                class: normalizeClass(unref(ppNs).e("link-btn")),
                onClick: handleClear
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(t)("el.datepicker.clear")), 1)
                ]),
                _: 1
              }, 8, ["class"])) : createCommentVNode("v-if", true),
              createVNode(unref(ElButton), {
                plain: "",
                size: "small",
                class: normalizeClass(unref(ppNs).e("link-btn")),
                disabled: unref(btnDisabled),
                onClick: _cache[10] || (_cache[10] = ($event) => unref(handleRangeConfirm)(false))
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(t)("el.datepicker.confirm")), 1)
                ]),
                _: 1
              }, 8, ["class", "disabled"])
            ], 2)) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    });
    var DateRangePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-range.vue"]]);
    const panelMonthRangeProps = buildProps({
      ...panelRangeSharedProps
    });
    const panelMonthRangeEmits = ["pick", "set-picker-option"];
    const useMonthRangeHeader = ({
      unlinkPanels,
      leftDate,
      rightDate
    }) => {
      const { t } = useLocale();
      const leftPrevYear = () => {
        leftDate.value = leftDate.value.subtract(1, "year");
        if (!unlinkPanels) {
          rightDate.value = rightDate.value.subtract(1, "year");
        }
      };
      const rightNextYear = () => {
        if (!unlinkPanels) {
          leftDate.value = leftDate.value.add(1, "year");
        }
        rightDate.value = rightDate.value.add(1, "year");
      };
      const leftNextYear = () => {
        leftDate.value = leftDate.value.add(1, "year");
      };
      const rightPrevYear = () => {
        rightDate.value = rightDate.value.subtract(1, "year");
      };
      const leftLabel = computed(() => {
        return `${leftDate.value.year()} ${t("el.datepicker.year")}`;
      });
      const rightLabel = computed(() => {
        return `${rightDate.value.year()} ${t("el.datepicker.year")}`;
      });
      const leftYear = computed(() => {
        return leftDate.value.year();
      });
      const rightYear = computed(() => {
        return rightDate.value.year() === leftDate.value.year() ? leftDate.value.year() + 1 : rightDate.value.year();
      });
      return {
        leftPrevYear,
        rightNextYear,
        leftNextYear,
        rightPrevYear,
        leftLabel,
        rightLabel,
        leftYear,
        rightYear
      };
    };
    const _hoisted_1$G = ["onClick"];
    const _hoisted_2$q = ["disabled"];
    const _hoisted_3$d = ["disabled"];
    const __default__$O = {
      name: "DatePickerMonthRange"
    };
    const _sfc_main$1j = /* @__PURE__ */ defineComponent({
      ...__default__$O,
      props: panelMonthRangeProps,
      emits: panelMonthRangeEmits,
      setup(__props, { emit }) {
        const props = __props;
        const unit = "year";
        const { lang } = useLocale();
        const pickerBase = inject("EP_PICKER_BASE");
        const { shortcuts, disabledDate: disabledDate2, format: format2 } = pickerBase.props;
        const defaultValue = toRef(pickerBase.props, "defaultValue");
        const leftDate = ref(dayjs().locale(lang.value));
        const rightDate = ref(dayjs().locale(lang.value).add(1, unit));
        const {
          minDate,
          maxDate,
          rangeState,
          ppNs,
          drpNs,
          handleChangeRange,
          handleRangeConfirm,
          handleShortcutClick,
          onSelect
        } = useRangePicker(props, {
          defaultValue,
          leftDate,
          rightDate,
          unit,
          onParsedValueChanged
        });
        const hasShortcuts = computed(() => !!shortcuts.length);
        const {
          leftPrevYear,
          rightNextYear,
          leftNextYear,
          rightPrevYear,
          leftLabel,
          rightLabel,
          leftYear,
          rightYear
        } = useMonthRangeHeader({
          unlinkPanels: toRef(props, "unlinkPanels"),
          leftDate,
          rightDate
        });
        const enableYearArrow = computed(() => {
          return props.unlinkPanels && rightYear.value > leftYear.value + 1;
        });
        const handleRangePick = (val, close2 = true) => {
          const minDate_ = val.minDate;
          const maxDate_ = val.maxDate;
          if (maxDate.value === maxDate_ && minDate.value === minDate_) {
            return;
          }
          maxDate.value = maxDate_;
          minDate.value = minDate_;
          if (!close2)
            return;
          handleRangeConfirm();
        };
        const formatToString = (days) => {
          return days.map((day) => day.format(format2));
        };
        function onParsedValueChanged(minDate2, maxDate2) {
          if (props.unlinkPanels && maxDate2) {
            const minDateYear = (minDate2 == null ? void 0 : minDate2.year()) || 0;
            const maxDateYear = maxDate2.year();
            rightDate.value = minDateYear === maxDateYear ? maxDate2.add(1, unit) : maxDate2;
          } else {
            rightDate.value = leftDate.value.add(1, unit);
          }
        }
        emit("set-picker-option", ["formatToString", formatToString]);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([
              unref(ppNs).b(),
              unref(drpNs).b(),
              {
                "has-sidebar": Boolean(_ctx.$slots.sidebar) || unref(hasShortcuts)
              }
            ])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(unref(ppNs).e("body-wrapper"))
            }, [
              renderSlot(_ctx.$slots, "sidebar", {
                class: normalizeClass(unref(ppNs).e("sidebar"))
              }),
              unref(hasShortcuts) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ppNs).e("sidebar"))
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(shortcuts), (shortcut, key) => {
                  return openBlock(), createElementBlock("button", {
                    key,
                    type: "button",
                    class: normalizeClass(unref(ppNs).e("shortcut")),
                    onClick: ($event) => unref(handleShortcutClick)(shortcut)
                  }, toDisplayString$1(shortcut.text), 11, _hoisted_1$G);
                }), 128))
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                class: normalizeClass(unref(ppNs).e("body"))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-left"])
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass(unref(drpNs).e("header"))
                  }, [
                    createBaseVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-left"]),
                      onClick: _cache[0] || (_cache[0] = (...args) => unref(leftPrevYear) && unref(leftPrevYear)(...args))
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(d_arrow_left_default))
                        ]),
                        _: 1
                      })
                    ], 2),
                    _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                      key: 0,
                      type: "button",
                      disabled: !unref(enableYearArrow),
                      class: normalizeClass([[
                        unref(ppNs).e("icon-btn"),
                        { [unref(ppNs).is("disabled")]: !unref(enableYearArrow) }
                      ], "d-arrow-right"]),
                      onClick: _cache[1] || (_cache[1] = (...args) => unref(leftNextYear) && unref(leftNextYear)(...args))
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(d_arrow_right_default))
                        ]),
                        _: 1
                      })
                    ], 10, _hoisted_2$q)) : createCommentVNode("v-if", true),
                    createBaseVNode("div", null, toDisplayString$1(unref(leftLabel)), 1)
                  ], 2),
                  createVNode(MonthTable, {
                    "selection-mode": "range",
                    date: leftDate.value,
                    "min-date": unref(minDate),
                    "max-date": unref(maxDate),
                    "range-state": unref(rangeState),
                    "disabled-date": unref(disabledDate2),
                    onChangerange: unref(handleChangeRange),
                    onPick: handleRangePick,
                    onSelect: unref(onSelect)
                  }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
                ], 2),
                createBaseVNode("div", {
                  class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-right"])
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass(unref(drpNs).e("header"))
                  }, [
                    _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                      key: 0,
                      type: "button",
                      disabled: !unref(enableYearArrow),
                      class: normalizeClass([[unref(ppNs).e("icon-btn"), { "is-disabled": !unref(enableYearArrow) }], "d-arrow-left"]),
                      onClick: _cache[2] || (_cache[2] = (...args) => unref(rightPrevYear) && unref(rightPrevYear)(...args))
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(d_arrow_left_default))
                        ]),
                        _: 1
                      })
                    ], 10, _hoisted_3$d)) : createCommentVNode("v-if", true),
                    createBaseVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-right"]),
                      onClick: _cache[3] || (_cache[3] = (...args) => unref(rightNextYear) && unref(rightNextYear)(...args))
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(d_arrow_right_default))
                        ]),
                        _: 1
                      })
                    ], 2),
                    createBaseVNode("div", null, toDisplayString$1(unref(rightLabel)), 1)
                  ], 2),
                  createVNode(MonthTable, {
                    "selection-mode": "range",
                    date: rightDate.value,
                    "min-date": unref(minDate),
                    "max-date": unref(maxDate),
                    "range-state": unref(rangeState),
                    "disabled-date": unref(disabledDate2),
                    onChangerange: unref(handleChangeRange),
                    onPick: handleRangePick,
                    onSelect: unref(onSelect)
                  }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
                ], 2)
              ], 2)
            ], 2)
          ], 2);
        };
      }
    });
    var MonthRangePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1j, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-month-range.vue"]]);
    const getPanel = function(type2) {
      switch (type2) {
        case "daterange":
        case "datetimerange": {
          return DateRangePickPanel;
        }
        case "monthrange": {
          return MonthRangePickPanel;
        }
        default: {
          return DatePickPanel;
        }
      }
    };
    dayjs.extend(localeData);
    dayjs.extend(advancedFormat);
    dayjs.extend(customParseFormat);
    dayjs.extend(weekOfYear);
    dayjs.extend(weekYear);
    dayjs.extend(dayOfYear);
    dayjs.extend(isSameOrAfter);
    dayjs.extend(isSameOrBefore);
    var DatePicker = defineComponent({
      name: "ElDatePicker",
      install: null,
      props: {
        ...timePickerDefaultProps,
        ...datePickerProps
      },
      emits: ["update:modelValue"],
      setup(props, {
        expose,
        emit,
        slots
      }) {
        const ns2 = useNamespace("picker-panel");
        provide("ElPopperOptions", reactive(toRef(props, "popperOptions")));
        provide(ROOT_PICKER_INJECTION_KEY, {
          slots,
          pickerNs: ns2
        });
        const commonPicker = ref();
        const refProps = {
          focus: (focusStartInput = true) => {
            var _a2;
            (_a2 = commonPicker.value) == null ? void 0 : _a2.focus(focusStartInput);
          },
          handleOpen: () => {
            var _a2;
            (_a2 = commonPicker.value) == null ? void 0 : _a2.handleOpen();
          },
          handleClose: () => {
            var _a2;
            (_a2 = commonPicker.value) == null ? void 0 : _a2.handleClose();
          }
        };
        expose(refProps);
        const onModelValueUpdated = (val) => {
          emit("update:modelValue", val);
        };
        return () => {
          var _a2;
          const format2 = (_a2 = props.format) != null ? _a2 : DEFAULT_FORMATS_DATEPICKER[props.type] || DEFAULT_FORMATS_DATE;
          const Component = getPanel(props.type);
          return createVNode(CommonPicker, mergeProps(props, {
            "format": format2,
            "type": props.type,
            "ref": commonPicker,
            "onUpdate:modelValue": onModelValueUpdated
          }), {
            default: (scopedProps) => createVNode(Component, scopedProps, null),
            "range-separator": slots["range-separator"]
          });
        };
      }
    });
    const _DatePicker = DatePicker;
    _DatePicker.install = (app2) => {
      app2.component(_DatePicker.name, _DatePicker);
    };
    const ElDatePicker = _DatePicker;
    const descriptionsKey = "elDescriptions";
    var ElDescriptionsCell = defineComponent({
      name: "ElDescriptionsCell",
      props: {
        cell: {
          type: Object
        },
        tag: {
          type: String
        },
        type: {
          type: String
        }
      },
      setup() {
        const descriptions = inject(descriptionsKey, {});
        return {
          descriptions
        };
      },
      render() {
        var _a2, _b, _c, _d, _e, _f;
        const item = getNormalizedProps(this.cell);
        const { border, direction: direction2 } = this.descriptions;
        const isVertical = direction2 === "vertical";
        const label = ((_c = (_b = (_a2 = this.cell) == null ? void 0 : _a2.children) == null ? void 0 : _b.label) == null ? void 0 : _c.call(_b)) || item.label;
        const content = (_f = (_e = (_d = this.cell) == null ? void 0 : _d.children) == null ? void 0 : _e.default) == null ? void 0 : _f.call(_e);
        const span = item.span;
        const align = item.align ? `is-${item.align}` : "";
        const labelAlign = item.labelAlign ? `is-${item.labelAlign}` : align;
        const className = item.className;
        const labelClassName = item.labelClassName;
        const style2 = {
          width: addUnit(item.width),
          minWidth: addUnit(item.minWidth)
        };
        const ns2 = useNamespace("descriptions");
        switch (this.type) {
          case "label":
            return h$1(this.tag, {
              style: style2,
              class: [
                ns2.e("cell"),
                ns2.e("label"),
                ns2.is("bordered-label", border),
                ns2.is("vertical-label", isVertical),
                labelAlign,
                labelClassName
              ],
              colSpan: isVertical ? span : 1
            }, label);
          case "content":
            return h$1(this.tag, {
              style: style2,
              class: [
                ns2.e("cell"),
                ns2.e("content"),
                ns2.is("bordered-content", border),
                ns2.is("vertical-content", isVertical),
                align,
                className
              ],
              colSpan: isVertical ? span : span * 2 - 1
            }, content);
          default:
            return h$1("td", {
              style: style2,
              class: [ns2.e("cell"), align],
              colSpan: span
            }, [
              h$1("span", {
                class: [ns2.e("label"), labelClassName]
              }, label),
              h$1("span", {
                class: [ns2.e("content"), className]
              }, content)
            ]);
        }
      }
    });
    const descriptionsRowProps = buildProps({
      row: {
        type: Array,
        default: () => []
      }
    });
    const _hoisted_1$F = { key: 1 };
    const __default__$N = {
      name: "ElDescriptionsRow"
    };
    const _sfc_main$1i = /* @__PURE__ */ defineComponent({
      ...__default__$N,
      props: descriptionsRowProps,
      setup(__props) {
        const descriptions = inject(descriptionsKey, {});
        return (_ctx, _cache) => {
          return unref(descriptions).direction === "vertical" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("tr", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.row, (cell, index2) => {
                return openBlock(), createBlock(unref(ElDescriptionsCell), {
                  key: `tr1-${index2}`,
                  cell,
                  tag: "th",
                  type: "label"
                }, null, 8, ["cell"]);
              }), 128))
            ]),
            createBaseVNode("tr", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.row, (cell, index2) => {
                return openBlock(), createBlock(unref(ElDescriptionsCell), {
                  key: `tr2-${index2}`,
                  cell,
                  tag: "td",
                  type: "content"
                }, null, 8, ["cell"]);
              }), 128))
            ])
          ], 64)) : (openBlock(), createElementBlock("tr", _hoisted_1$F, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.row, (cell, index2) => {
              return openBlock(), createElementBlock(Fragment, {
                key: `tr3-${index2}`
              }, [
                unref(descriptions).border ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createVNode(unref(ElDescriptionsCell), {
                    cell,
                    tag: "td",
                    type: "label"
                  }, null, 8, ["cell"]),
                  createVNode(unref(ElDescriptionsCell), {
                    cell,
                    tag: "td",
                    type: "content"
                  }, null, 8, ["cell"])
                ], 64)) : (openBlock(), createBlock(unref(ElDescriptionsCell), {
                  key: 1,
                  cell,
                  tag: "td",
                  type: "both"
                }, null, 8, ["cell"]))
              ], 64);
            }), 128))
          ]));
        };
      }
    });
    var ElDescriptionsRow = /* @__PURE__ */ _export_sfc(_sfc_main$1i, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/descriptions-row.vue"]]);
    const descriptionProps = buildProps({
      border: {
        type: Boolean,
        default: false
      },
      column: {
        type: Number,
        default: 3
      },
      direction: {
        type: String,
        values: ["horizontal", "vertical"],
        default: "horizontal"
      },
      size: useSizeProp,
      title: {
        type: String,
        default: ""
      },
      extra: {
        type: String,
        default: ""
      }
    });
    const __default__$M = {
      name: "ElDescriptions"
    };
    const _sfc_main$1h = /* @__PURE__ */ defineComponent({
      ...__default__$M,
      props: descriptionProps,
      setup(__props) {
        const props = __props;
        const ns2 = useNamespace("descriptions");
        const descriptionsSize = useSize();
        const slots = useSlots();
        provide(descriptionsKey, props);
        const descriptionKls = computed(() => [ns2.b(), ns2.m(descriptionsSize.value)]);
        const flattedChildren = (children) => {
          const temp = Array.isArray(children) ? children : [children];
          const res = [];
          temp.forEach((child) => {
            if (Array.isArray(child.children)) {
              res.push(...flattedChildren(child.children));
            } else {
              res.push(child);
            }
          });
          return res;
        };
        const filledNode = (node, span, count, isLast = false) => {
          if (!node.props) {
            node.props = {};
          }
          if (span > count) {
            node.props.span = count;
          }
          if (isLast) {
            node.props.span = span;
          }
          return node;
        };
        const getRows = () => {
          var _a2;
          const children = flattedChildren((_a2 = slots.default) == null ? void 0 : _a2.call(slots)).filter((node) => {
            var _a22;
            return ((_a22 = node == null ? void 0 : node.type) == null ? void 0 : _a22.name) === "ElDescriptionsItem";
          });
          const rows = [];
          let temp = [];
          let count = props.column;
          let totalSpan = 0;
          children.forEach((node, index2) => {
            var _a22;
            const span = ((_a22 = node.props) == null ? void 0 : _a22.span) || 1;
            if (index2 < children.length - 1) {
              totalSpan += span > count ? count : span;
            }
            if (index2 === children.length - 1) {
              const lastSpan = props.column - totalSpan % props.column;
              temp.push(filledNode(node, lastSpan, count, true));
              rows.push(temp);
              return;
            }
            if (span < count) {
              count -= span;
              temp.push(node);
            } else {
              temp.push(filledNode(node, span, count));
              rows.push(temp);
              count = props.column;
              temp = [];
            }
          });
          return rows;
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(descriptionKls))
          }, [
            _ctx.title || _ctx.extra || _ctx.$slots.title || _ctx.$slots.extra ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(ns2).e("header"))
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ns2).e("title"))
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString$1(_ctx.title), 1)
                ])
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns2).e("extra"))
              }, [
                renderSlot(_ctx.$slots, "extra", {}, () => [
                  createTextVNode(toDisplayString$1(_ctx.extra), 1)
                ])
              ], 2)
            ], 2)) : createCommentVNode("v-if", true),
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("body"))
            }, [
              createBaseVNode("table", {
                class: normalizeClass([unref(ns2).e("table"), unref(ns2).is("bordered", _ctx.border)])
              }, [
                createBaseVNode("tbody", null, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(getRows(), (row, index2) => {
                    return openBlock(), createBlock(ElDescriptionsRow, {
                      key: index2,
                      row
                    }, null, 8, ["row"]);
                  }), 128))
                ])
              ], 2)
            ], 2)
          ], 2);
        };
      }
    });
    var Descriptions = /* @__PURE__ */ _export_sfc(_sfc_main$1h, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/description.vue"]]);
    var DescriptionsItem = defineComponent({
      name: "ElDescriptionsItem",
      props: {
        label: {
          type: String,
          default: ""
        },
        span: {
          type: Number,
          default: 1
        },
        width: {
          type: [String, Number],
          default: ""
        },
        minWidth: {
          type: [String, Number],
          default: ""
        },
        align: {
          type: String,
          default: "left"
        },
        labelAlign: {
          type: String,
          default: ""
        },
        className: {
          type: String,
          default: ""
        },
        labelClassName: {
          type: String,
          default: ""
        }
      }
    });
    const ElDescriptions = withInstall(Descriptions, {
      DescriptionsItem
    });
    const ElDescriptionsItem = withNoopInstall(DescriptionsItem);
    const overlayProps = buildProps({
      mask: {
        type: Boolean,
        default: true
      },
      customMaskEvent: {
        type: Boolean,
        default: false
      },
      overlayClass: {
        type: definePropType([
          String,
          Array,
          Object
        ])
      },
      zIndex: {
        type: definePropType([String, Number])
      }
    });
    const overlayEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    var Overlay$1 = defineComponent({
      name: "ElOverlay",
      props: overlayProps,
      emits: overlayEmits,
      setup(props, { slots, emit }) {
        const ns2 = useNamespace("overlay");
        const onMaskClick = (e) => {
          emit("click", e);
        };
        const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
        return () => {
          return props.mask ? createVNode("div", {
            class: [ns2.b(), props.overlayClass],
            style: {
              zIndex: props.zIndex
            },
            onClick,
            onMousedown,
            onMouseup
          }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h$1("div", {
            class: props.overlayClass,
            style: {
              zIndex: props.zIndex,
              position: "fixed",
              top: "0px",
              right: "0px",
              bottom: "0px",
              left: "0px"
            }
          }, [renderSlot(slots, "default")]);
        };
      }
    });
    const ElOverlay = Overlay$1;
    const dialogContentProps = buildProps({
      center: {
        type: Boolean,
        default: false
      },
      alignCenter: {
        type: Boolean,
        default: false
      },
      closeIcon: {
        type: iconPropType
      },
      customClass: {
        type: String,
        default: ""
      },
      draggable: {
        type: Boolean,
        default: false
      },
      fullscreen: {
        type: Boolean,
        default: false
      },
      showClose: {
        type: Boolean,
        default: true
      },
      title: {
        type: String,
        default: ""
      }
    });
    const dialogContentEmits = {
      close: () => true
    };
    const _hoisted_1$E = ["aria-label"];
    const _hoisted_2$p = ["id"];
    const __default__$L = { name: "ElDialogContent" };
    const _sfc_main$1g = /* @__PURE__ */ defineComponent({
      ...__default__$L,
      props: dialogContentProps,
      emits: dialogContentEmits,
      setup(__props) {
        const props = __props;
        const { t } = useLocale();
        const { Close } = CloseComponents;
        const { dialogRef, headerRef, bodyId, ns: ns2, style: style2 } = inject(dialogInjectionKey);
        const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
        const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
        const draggable2 = computed(() => props.draggable);
        useDraggable(dialogRef, headerRef, draggable2);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref: unref(composedDialogRef),
            class: normalizeClass([
              unref(ns2).b(),
              unref(ns2).is("fullscreen", _ctx.fullscreen),
              unref(ns2).is("draggable", unref(draggable2)),
              unref(ns2).is("align-center", _ctx.alignCenter),
              { [unref(ns2).m("center")]: _ctx.center },
              _ctx.customClass
            ]),
            style: normalizeStyle(unref(style2)),
            tabindex: "-1",
            onClick: _cache[1] || (_cache[1] = withModifiers(() => {
            }, ["stop"]))
          }, [
            createBaseVNode("header", {
              ref_key: "headerRef",
              ref: headerRef,
              class: normalizeClass(unref(ns2).e("header"))
            }, [
              renderSlot(_ctx.$slots, "header", {}, () => [
                createBaseVNode("span", {
                  role: "heading",
                  class: normalizeClass(unref(ns2).e("title"))
                }, toDisplayString$1(_ctx.title), 3)
              ]),
              _ctx.showClose ? (openBlock(), createElementBlock("button", {
                key: 0,
                "aria-label": unref(t)("el.dialog.close"),
                class: normalizeClass(unref(ns2).e("headerbtn")),
                type: "button",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
              }, [
                createVNode(unref(ElIcon), {
                  class: normalizeClass(unref(ns2).e("close"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 10, _hoisted_1$E)) : createCommentVNode("v-if", true)
            ], 2),
            createBaseVNode("div", {
              id: unref(bodyId),
              class: normalizeClass(unref(ns2).e("body"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 10, _hoisted_2$p),
            _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
              key: 0,
              class: normalizeClass(unref(ns2).e("footer"))
            }, [
              renderSlot(_ctx.$slots, "footer")
            ], 2)) : createCommentVNode("v-if", true)
          ], 6);
        };
      }
    });
    var ElDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$1g, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);
    const dialogProps = buildProps({
      ...dialogContentProps,
      appendToBody: {
        type: Boolean,
        default: false
      },
      beforeClose: {
        type: definePropType(Function)
      },
      destroyOnClose: {
        type: Boolean,
        default: false
      },
      closeOnClickModal: {
        type: Boolean,
        default: true
      },
      closeOnPressEscape: {
        type: Boolean,
        default: true
      },
      lockScroll: {
        type: Boolean,
        default: true
      },
      modal: {
        type: Boolean,
        default: true
      },
      openDelay: {
        type: Number,
        default: 0
      },
      closeDelay: {
        type: Number,
        default: 0
      },
      top: {
        type: String
      },
      modelValue: {
        type: Boolean,
        default: false
      },
      modalClass: String,
      width: {
        type: [String, Number]
      },
      zIndex: {
        type: Number
      },
      trapFocus: {
        type: Boolean,
        default: false
      }
    });
    const dialogEmits = {
      open: () => true,
      opened: () => true,
      close: () => true,
      closed: () => true,
      [UPDATE_MODEL_EVENT]: (value) => isBoolean$2(value),
      openAutoFocus: () => true,
      closeAutoFocus: () => true
    };
    const useDialog = (props, targetRef) => {
      const instance = getCurrentInstance();
      const emit = instance.emit;
      const { nextZIndex } = useZIndex();
      let lastPosition = "";
      const titleId = useId();
      const bodyId = useId();
      const visible = ref(false);
      const closed = ref(false);
      const rendered = ref(false);
      const zIndex2 = ref(props.zIndex || nextZIndex());
      let openTimer = void 0;
      let closeTimer = void 0;
      const namespace = useGlobalConfig("namespace", defaultNamespace);
      const style2 = computed(() => {
        const style22 = {};
        const varPrefix = `--${namespace.value}-dialog`;
        if (!props.fullscreen) {
          if (props.top) {
            style22[`${varPrefix}-margin-top`] = props.top;
          }
          if (props.width) {
            style22[`${varPrefix}-width`] = addUnit(props.width);
          }
        }
        return style22;
      });
      const overlayDialogStyle = computed(() => {
        if (props.alignCenter) {
          return { display: "flex" };
        }
        return {};
      });
      function afterEnter() {
        emit("opened");
      }
      function afterLeave() {
        emit("closed");
        emit(UPDATE_MODEL_EVENT, false);
        if (props.destroyOnClose) {
          rendered.value = false;
        }
      }
      function beforeLeave() {
        emit("close");
      }
      function open() {
        closeTimer == null ? void 0 : closeTimer();
        openTimer == null ? void 0 : openTimer();
        if (props.openDelay && props.openDelay > 0) {
          ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props.openDelay));
        } else {
          doOpen();
        }
      }
      function close2() {
        openTimer == null ? void 0 : openTimer();
        closeTimer == null ? void 0 : closeTimer();
        if (props.closeDelay && props.closeDelay > 0) {
          ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props.closeDelay));
        } else {
          doClose();
        }
      }
      function handleClose() {
        function hide(shouldCancel) {
          if (shouldCancel)
            return;
          closed.value = true;
          visible.value = false;
        }
        if (props.beforeClose) {
          props.beforeClose(hide);
        } else {
          close2();
        }
      }
      function onModalClick() {
        if (props.closeOnClickModal) {
          handleClose();
        }
      }
      function doOpen() {
        if (!isClient)
          return;
        visible.value = true;
      }
      function doClose() {
        visible.value = false;
      }
      function onOpenAutoFocus() {
        emit("openAutoFocus");
      }
      function onCloseAutoFocus() {
        emit("closeAutoFocus");
      }
      if (props.lockScroll) {
        useLockscreen(visible);
      }
      function onCloseRequested() {
        if (props.closeOnPressEscape) {
          handleClose();
        }
      }
      watch(() => props.modelValue, (val) => {
        if (val) {
          closed.value = false;
          open();
          rendered.value = true;
          zIndex2.value = props.zIndex ? zIndex2.value++ : nextZIndex();
          nextTick(() => {
            emit("open");
            if (targetRef.value) {
              targetRef.value.scrollTop = 0;
            }
          });
        } else {
          if (visible.value) {
            close2();
          }
        }
      });
      watch(() => props.fullscreen, (val) => {
        if (!targetRef.value)
          return;
        if (val) {
          lastPosition = targetRef.value.style.transform;
          targetRef.value.style.transform = "";
        } else {
          targetRef.value.style.transform = lastPosition;
        }
      });
      onMounted(() => {
        if (props.modelValue) {
          visible.value = true;
          rendered.value = true;
          open();
        }
      });
      return {
        afterEnter,
        afterLeave,
        beforeLeave,
        handleClose,
        onModalClick,
        close: close2,
        doClose,
        onOpenAutoFocus,
        onCloseAutoFocus,
        onCloseRequested,
        titleId,
        bodyId,
        closed,
        style: style2,
        overlayDialogStyle,
        rendered,
        visible,
        zIndex: zIndex2
      };
    };
    const _hoisted_1$D = ["aria-label", "aria-labelledby", "aria-describedby"];
    const __default__$K = {
      name: "ElDialog",
      inheritAttrs: false
    };
    const _sfc_main$1f = /* @__PURE__ */ defineComponent({
      ...__default__$K,
      props: dialogProps,
      emits: dialogEmits,
      setup(__props, { expose }) {
        const props = __props;
        const slots = useSlots();
        useDeprecated({
          scope: "el-dialog",
          from: "the title slot",
          replacement: "the header slot",
          version: "3.0.0",
          ref: "https://element-plus.org/en-US/component/dialog.html#slots"
        }, computed(() => !!slots.title));
        useDeprecated({
          scope: "el-dialog",
          from: "custom-class",
          replacement: "class",
          version: "2.3.0",
          ref: "https://element-plus.org/en-US/component/dialog.html#attributes",
          type: "Attribute"
        }, computed(() => !!props.customClass));
        const ns2 = useNamespace("dialog");
        const dialogRef = ref();
        const headerRef = ref();
        const dialogContentRef = ref();
        const {
          visible,
          titleId,
          bodyId,
          style: style2,
          overlayDialogStyle,
          rendered,
          zIndex: zIndex2,
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested
        } = useDialog(props, dialogRef);
        provide(dialogInjectionKey, {
          dialogRef,
          headerRef,
          bodyId,
          ns: ns2,
          rendered,
          style: style2
        });
        const overlayEvent = useSameTarget(onModalClick);
        const draggable2 = computed(() => props.draggable && !props.fullscreen);
        expose({
          visible,
          dialogContentRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Teleport, {
            to: "body",
            disabled: !_ctx.appendToBody
          }, [
            createVNode(Transition, {
              name: "dialog-fade",
              onAfterEnter: unref(afterEnter),
              onAfterLeave: unref(afterLeave),
              onBeforeLeave: unref(beforeLeave),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createVNode(unref(ElOverlay), {
                  "custom-mask-event": "",
                  mask: _ctx.modal,
                  "overlay-class": _ctx.modalClass,
                  "z-index": unref(zIndex2)
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      role: "dialog",
                      "aria-modal": "true",
                      "aria-label": _ctx.title || void 0,
                      "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                      "aria-describedby": unref(bodyId),
                      class: normalizeClass(`${unref(ns2).namespace.value}-overlay-dialog`),
                      style: normalizeStyle(unref(overlayDialogStyle)),
                      onClick: _cache[0] || (_cache[0] = (...args) => unref(overlayEvent).onClick && unref(overlayEvent).onClick(...args)),
                      onMousedown: _cache[1] || (_cache[1] = (...args) => unref(overlayEvent).onMousedown && unref(overlayEvent).onMousedown(...args)),
                      onMouseup: _cache[2] || (_cache[2] = (...args) => unref(overlayEvent).onMouseup && unref(overlayEvent).onMouseup(...args))
                    }, [
                      createVNode(unref(ElFocusTrap), {
                        loop: "",
                        trapped: unref(visible),
                        "focus-start-el": "container",
                        onFocusAfterTrapped: unref(onOpenAutoFocus),
                        onFocusAfterReleased: unref(onCloseAutoFocus),
                        onReleaseRequested: unref(onCloseRequested)
                      }, {
                        default: withCtx(() => [
                          unref(rendered) ? (openBlock(), createBlock(ElDialogContent, mergeProps({
                            key: 0,
                            ref_key: "dialogContentRef",
                            ref: dialogContentRef
                          }, _ctx.$attrs, {
                            "custom-class": _ctx.customClass,
                            center: _ctx.center,
                            "align-center": _ctx.alignCenter,
                            "close-icon": _ctx.closeIcon,
                            draggable: unref(draggable2),
                            fullscreen: _ctx.fullscreen,
                            "show-close": _ctx.showClose,
                            title: _ctx.title,
                            onClose: unref(handleClose)
                          }), createSlots({
                            header: withCtx(() => [
                              !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                key: 0,
                                close: unref(handleClose),
                                titleId: unref(titleId),
                                titleClass: unref(ns2).e("title")
                              }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                            ]),
                            default: withCtx(() => [
                              renderSlot(_ctx.$slots, "default")
                            ]),
                            _: 2
                          }, [
                            _ctx.$slots.footer ? {
                              name: "footer",
                              fn: withCtx(() => [
                                renderSlot(_ctx.$slots, "footer")
                              ])
                            } : void 0
                          ]), 1040, ["custom-class", "center", "align-center", "close-icon", "draggable", "fullscreen", "show-close", "title", "onClose"])) : createCommentVNode("v-if", true)
                        ]),
                        _: 3
                      }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onReleaseRequested"])
                    ], 46, _hoisted_1$D)
                  ]),
                  _: 3
                }, 8, ["mask", "overlay-class", "z-index"]), [
                  [vShow, unref(visible)]
                ])
              ]),
              _: 3
            }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
          ], 8, ["disabled"]);
        };
      }
    });
    var Dialog = /* @__PURE__ */ _export_sfc(_sfc_main$1f, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);
    const ElDialog = withInstall(Dialog);
    const dividerProps = buildProps({
      direction: {
        type: String,
        values: ["horizontal", "vertical"],
        default: "horizontal"
      },
      contentPosition: {
        type: String,
        values: ["left", "center", "right"],
        default: "center"
      },
      borderStyle: {
        type: definePropType(String),
        default: "solid"
      }
    });
    const __default__$J = {
      name: "ElDivider"
    };
    const _sfc_main$1e = /* @__PURE__ */ defineComponent({
      ...__default__$J,
      props: dividerProps,
      setup(__props) {
        const props = __props;
        const ns2 = useNamespace("divider");
        const dividerStyle = computed(() => {
          return ns2.cssVar({
            "border-style": props.borderStyle
          });
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([unref(ns2).b(), unref(ns2).m(_ctx.direction)]),
            style: normalizeStyle(unref(dividerStyle)),
            role: "separator"
          }, [
            _ctx.$slots.default && _ctx.direction !== "vertical" ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass([unref(ns2).e("text"), unref(ns2).is(_ctx.contentPosition)])
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)) : createCommentVNode("v-if", true)
          ], 6);
        };
      }
    });
    var Divider = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/divider/src/divider.vue"]]);
    const ElDivider = withInstall(Divider);
    const drawerProps = buildProps({
      ...dialogProps,
      direction: {
        type: String,
        default: "rtl",
        values: ["ltr", "rtl", "ttb", "btt"]
      },
      size: {
        type: [String, Number],
        default: "30%"
      },
      withHeader: {
        type: Boolean,
        default: true
      },
      modalFade: {
        type: Boolean,
        default: true
      }
    });
    const drawerEmits = dialogEmits;
    const _sfc_main$1d = defineComponent({
      name: "ElDrawer",
      components: {
        ElOverlay,
        ElFocusTrap,
        ElIcon,
        Close: close_default
      },
      props: drawerProps,
      emits: drawerEmits,
      setup(props, { slots }) {
        useDeprecated({
          scope: "el-drawer",
          from: "the title slot",
          replacement: "the header slot",
          version: "3.0.0",
          ref: "https://element-plus.org/en-US/component/drawer.html#slots"
        }, computed(() => !!slots.title));
        const drawerRef = ref();
        const focusStartRef = ref();
        const ns2 = useNamespace("drawer");
        const { t } = useLocale();
        const isHorizontal2 = computed(() => props.direction === "rtl" || props.direction === "ltr");
        const drawerSize = computed(() => addUnit(props.size));
        return {
          ...useDialog(props, drawerRef),
          drawerRef,
          focusStartRef,
          isHorizontal: isHorizontal2,
          drawerSize,
          ns: ns2,
          t
        };
      }
    });
    const _hoisted_1$C = ["aria-label", "aria-labelledby", "aria-describedby"];
    const _hoisted_2$o = ["id"];
    const _hoisted_3$c = ["aria-label"];
    const _hoisted_4$9 = ["id"];
    function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_close = resolveComponent("close");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_focus_trap = resolveComponent("el-focus-trap");
      const _component_el_overlay = resolveComponent("el-overlay");
      return openBlock(), createBlock(Teleport, {
        to: "body",
        disabled: !_ctx.appendToBody
      }, [
        createVNode(Transition, {
          name: _ctx.ns.b("fade"),
          onAfterEnter: _ctx.afterEnter,
          onAfterLeave: _ctx.afterLeave,
          onBeforeLeave: _ctx.beforeLeave,
          persisted: ""
        }, {
          default: withCtx(() => [
            withDirectives(createVNode(_component_el_overlay, {
              mask: _ctx.modal,
              "overlay-class": _ctx.modalClass,
              "z-index": _ctx.zIndex,
              onClick: _ctx.onModalClick
            }, {
              default: withCtx(() => [
                createVNode(_component_el_focus_trap, {
                  loop: "",
                  trapped: _ctx.visible,
                  "focus-trap-el": _ctx.drawerRef,
                  "focus-start-el": _ctx.focusStartRef,
                  onReleaseRequested: _ctx.onCloseRequested
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      ref: "drawerRef",
                      "aria-modal": "true",
                      "aria-label": _ctx.title || void 0,
                      "aria-labelledby": !_ctx.title ? _ctx.titleId : void 0,
                      "aria-describedby": _ctx.bodyId,
                      class: normalizeClass([_ctx.ns.b(), _ctx.direction, _ctx.visible && "open", _ctx.customClass]),
                      style: normalizeStyle(_ctx.isHorizontal ? "width: " + _ctx.drawerSize : "height: " + _ctx.drawerSize),
                      role: "dialog",
                      onClick: _cache[1] || (_cache[1] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      createBaseVNode("span", {
                        ref: "focusStartRef",
                        class: normalizeClass(_ctx.ns.e("sr-focus")),
                        tabindex: "-1"
                      }, null, 2),
                      _ctx.withHeader ? (openBlock(), createElementBlock("header", {
                        key: 0,
                        class: normalizeClass(_ctx.ns.e("header"))
                      }, [
                        !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                          key: 0,
                          close: _ctx.handleClose,
                          titleId: _ctx.titleId,
                          titleClass: _ctx.ns.e("title")
                        }, () => [
                          !_ctx.$slots.title ? (openBlock(), createElementBlock("span", {
                            key: 0,
                            id: _ctx.titleId,
                            role: "heading",
                            class: normalizeClass(_ctx.ns.e("title"))
                          }, toDisplayString$1(_ctx.title), 11, _hoisted_2$o)) : createCommentVNode("v-if", true)
                        ]) : renderSlot(_ctx.$slots, "title", { key: 1 }, () => [
                          createCommentVNode(" DEPRECATED SLOT ")
                        ]),
                        _ctx.showClose ? (openBlock(), createElementBlock("button", {
                          key: 2,
                          "aria-label": _ctx.t("el.drawer.close"),
                          class: normalizeClass(_ctx.ns.e("close-btn")),
                          type: "button",
                          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
                        }, [
                          createVNode(_component_el_icon, {
                            class: normalizeClass(_ctx.ns.e("close"))
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_close)
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ], 10, _hoisted_3$c)) : createCommentVNode("v-if", true)
                      ], 2)) : createCommentVNode("v-if", true),
                      _ctx.rendered ? (openBlock(), createElementBlock("div", {
                        key: 1,
                        id: _ctx.bodyId,
                        class: normalizeClass(_ctx.ns.e("body"))
                      }, [
                        renderSlot(_ctx.$slots, "default")
                      ], 10, _hoisted_4$9)) : createCommentVNode("v-if", true),
                      _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
                        key: 2,
                        class: normalizeClass(_ctx.ns.e("footer"))
                      }, [
                        renderSlot(_ctx.$slots, "footer")
                      ], 2)) : createCommentVNode("v-if", true)
                    ], 14, _hoisted_1$C)
                  ]),
                  _: 3
                }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
              ]),
              _: 3
            }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
              [vShow, _ctx.visible]
            ])
          ]),
          _: 3
        }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])
      ], 8, ["disabled"]);
    }
    var Drawer = /* @__PURE__ */ _export_sfc(_sfc_main$1d, [["render", _sfc_render$r], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/drawer/src/drawer.vue"]]);
    const ElDrawer = withInstall(Drawer);
    const _sfc_main$1c = {
      inheritAttrs: false
    };
    function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
      return renderSlot(_ctx.$slots, "default");
    }
    var Collection = /* @__PURE__ */ _export_sfc(_sfc_main$1c, [["render", _sfc_render$q], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
    const _sfc_main$1b = {
      name: "ElCollectionItem",
      inheritAttrs: false
    };
    function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
      return renderSlot(_ctx.$slots, "default");
    }
    var CollectionItem = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["render", _sfc_render$p], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
    const COLLECTION_ITEM_SIGN = `data-el-collection-item`;
    const createCollectionWithScope = (name) => {
      const COLLECTION_NAME = `El${name}Collection`;
      const COLLECTION_ITEM_NAME = `${COLLECTION_NAME}Item`;
      const COLLECTION_INJECTION_KEY2 = Symbol(COLLECTION_NAME);
      const COLLECTION_ITEM_INJECTION_KEY2 = Symbol(COLLECTION_ITEM_NAME);
      const ElCollection2 = {
        ...Collection,
        name: COLLECTION_NAME,
        setup() {
          const collectionRef = ref(null);
          const itemMap = /* @__PURE__ */ new Map();
          const getItems = () => {
            const collectionEl = unref(collectionRef);
            if (!collectionEl)
              return [];
            const orderedNodes = Array.from(collectionEl.querySelectorAll(`[${COLLECTION_ITEM_SIGN}]`));
            const items = [...itemMap.values()];
            return items.sort((a2, b2) => orderedNodes.indexOf(a2.ref) - orderedNodes.indexOf(b2.ref));
          };
          provide(COLLECTION_INJECTION_KEY2, {
            itemMap,
            getItems,
            collectionRef
          });
        }
      };
      const ElCollectionItem2 = {
        ...CollectionItem,
        name: COLLECTION_ITEM_NAME,
        setup(_2, { attrs }) {
          const collectionItemRef = ref(null);
          const collectionInjection = inject(COLLECTION_INJECTION_KEY2, void 0);
          provide(COLLECTION_ITEM_INJECTION_KEY2, {
            collectionItemRef
          });
          onMounted(() => {
            const collectionItemEl = unref(collectionItemRef);
            if (collectionItemEl) {
              collectionInjection.itemMap.set(collectionItemEl, {
                ref: collectionItemEl,
                ...attrs
              });
            }
          });
          onBeforeUnmount(() => {
            const collectionItemEl = unref(collectionItemRef);
            collectionInjection.itemMap.delete(collectionItemEl);
          });
        }
      };
      return {
        COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY2,
        COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY2,
        ElCollection: ElCollection2,
        ElCollectionItem: ElCollectionItem2
      };
    };
    const rovingFocusGroupProps = buildProps({
      style: { type: definePropType([String, Array, Object]) },
      currentTabId: {
        type: definePropType(String)
      },
      defaultCurrentTabId: String,
      loop: Boolean,
      dir: {
        type: String,
        values: ["ltr", "rtl"],
        default: "ltr"
      },
      orientation: {
        type: definePropType(String)
      },
      onBlur: Function,
      onFocus: Function,
      onMousedown: Function
    });
    const {
      ElCollection: ElCollection$1,
      ElCollectionItem: ElCollectionItem$1,
      COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY$1,
      COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY$1
    } = createCollectionWithScope("RovingFocusGroup");
    const ROVING_FOCUS_GROUP_INJECTION_KEY = Symbol("elRovingFocusGroup");
    const ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY = Symbol("elRovingFocusGroupItem");
    const MAP_KEY_TO_FOCUS_INTENT = {
      ArrowLeft: "prev",
      ArrowUp: "prev",
      ArrowRight: "next",
      ArrowDown: "next",
      PageUp: "first",
      Home: "first",
      PageDown: "last",
      End: "last"
    };
    const getDirectionAwareKey = (key, dir) => {
      if (dir !== "rtl")
        return key;
      switch (key) {
        case EVENT_CODE.right:
          return EVENT_CODE.left;
        case EVENT_CODE.left:
          return EVENT_CODE.right;
        default:
          return key;
      }
    };
    const getFocusIntent = (event, orientation, dir) => {
      const key = getDirectionAwareKey(event.key, dir);
      if (orientation === "vertical" && [EVENT_CODE.left, EVENT_CODE.right].includes(key))
        return void 0;
      if (orientation === "horizontal" && [EVENT_CODE.up, EVENT_CODE.down].includes(key))
        return void 0;
      return MAP_KEY_TO_FOCUS_INTENT[key];
    };
    const reorderArray = (array2, atIdx) => {
      return array2.map((_2, idx) => array2[(idx + atIdx) % array2.length]);
    };
    const focusFirst = (elements) => {
      const { activeElement: prevActive } = document;
      for (const element of elements) {
        if (element === prevActive)
          return;
        element.focus();
        if (prevActive !== document.activeElement)
          return;
      }
    };
    const CURRENT_TAB_ID_CHANGE_EVT = "currentTabIdChange";
    const ENTRY_FOCUS_EVT = "rovingFocusGroup.entryFocus";
    const EVT_OPTS = { bubbles: false, cancelable: true };
    const _sfc_main$1a = defineComponent({
      name: "ElRovingFocusGroupImpl",
      inheritAttrs: false,
      props: rovingFocusGroupProps,
      emits: [CURRENT_TAB_ID_CHANGE_EVT, "entryFocus"],
      setup(props, { emit }) {
        var _a2;
        const currentTabbedId = ref((_a2 = props.currentTabId || props.defaultCurrentTabId) != null ? _a2 : null);
        const isBackingOut = ref(false);
        const isClickFocus = ref(false);
        const rovingFocusGroupRef = ref(null);
        const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
        const rovingFocusGroupRootStyle = computed(() => {
          return [
            {
              outline: "none"
            },
            props.style
          ];
        });
        const onItemFocus = (tabbedId) => {
          emit(CURRENT_TAB_ID_CHANGE_EVT, tabbedId);
        };
        const onItemShiftTab = () => {
          isBackingOut.value = true;
        };
        const onMousedown = composeEventHandlers((e) => {
          var _a22;
          (_a22 = props.onMousedown) == null ? void 0 : _a22.call(props, e);
        }, () => {
          isClickFocus.value = true;
        });
        const onFocus = composeEventHandlers((e) => {
          var _a22;
          (_a22 = props.onFocus) == null ? void 0 : _a22.call(props, e);
        }, (e) => {
          const isKeyboardFocus = !unref(isClickFocus);
          const { target, currentTarget } = e;
          if (target === currentTarget && isKeyboardFocus && !unref(isBackingOut)) {
            const entryFocusEvt = new Event(ENTRY_FOCUS_EVT, EVT_OPTS);
            currentTarget == null ? void 0 : currentTarget.dispatchEvent(entryFocusEvt);
            if (!entryFocusEvt.defaultPrevented) {
              const items = getItems().filter((item) => item.focusable);
              const activeItem = items.find((item) => item.active);
              const currentItem = items.find((item) => item.id === unref(currentTabbedId));
              const candidates = [activeItem, currentItem, ...items].filter(Boolean);
              const candidateNodes = candidates.map((item) => item.ref);
              focusFirst(candidateNodes);
            }
          }
          isClickFocus.value = false;
        });
        const onBlur = composeEventHandlers((e) => {
          var _a22;
          (_a22 = props.onBlur) == null ? void 0 : _a22.call(props, e);
        }, () => {
          isBackingOut.value = false;
        });
        const handleEntryFocus = (...args) => {
          emit("entryFocus", ...args);
        };
        provide(ROVING_FOCUS_GROUP_INJECTION_KEY, {
          currentTabbedId: readonly(currentTabbedId),
          loop: toRef(props, "loop"),
          tabIndex: computed(() => {
            return unref(isBackingOut) ? -1 : 0;
          }),
          rovingFocusGroupRef,
          rovingFocusGroupRootStyle,
          orientation: toRef(props, "orientation"),
          dir: toRef(props, "dir"),
          onItemFocus,
          onItemShiftTab,
          onBlur,
          onFocus,
          onMousedown
        });
        watch(() => props.currentTabId, (val) => {
          currentTabbedId.value = val != null ? val : null;
        });
        useEventListener(rovingFocusGroupRef, ENTRY_FOCUS_EVT, handleEntryFocus);
      }
    });
    function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
      return renderSlot(_ctx.$slots, "default");
    }
    var ElRovingFocusGroupImpl = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$o], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group-impl.vue"]]);
    const _sfc_main$19 = defineComponent({
      name: "ElRovingFocusGroup",
      components: {
        ElFocusGroupCollection: ElCollection$1,
        ElRovingFocusGroupImpl
      }
    });
    function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_roving_focus_group_impl = resolveComponent("el-roving-focus-group-impl");
      const _component_el_focus_group_collection = resolveComponent("el-focus-group-collection");
      return openBlock(), createBlock(_component_el_focus_group_collection, null, {
        default: withCtx(() => [
          createVNode(_component_el_roving_focus_group_impl, normalizeProps(guardReactiveProps(_ctx.$attrs)), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      });
    }
    var ElRovingFocusGroup = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$n], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group.vue"]]);
    const _sfc_main$18 = defineComponent({
      components: {
        ElRovingFocusCollectionItem: ElCollectionItem$1
      },
      props: {
        focusable: {
          type: Boolean,
          default: true
        },
        active: {
          type: Boolean,
          default: false
        }
      },
      emits: ["mousedown", "focus", "keydown"],
      setup(props, { emit }) {
        const { currentTabbedId, loop, onItemFocus, onItemShiftTab } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
        const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
        const id2 = useId();
        const rovingFocusGroupItemRef = ref(null);
        const handleMousedown = composeEventHandlers((e) => {
          emit("mousedown", e);
        }, (e) => {
          if (!props.focusable) {
            e.preventDefault();
          } else {
            onItemFocus(unref(id2));
          }
        });
        const handleFocus = composeEventHandlers((e) => {
          emit("focus", e);
        }, () => {
          onItemFocus(unref(id2));
        });
        const handleKeydown = composeEventHandlers((e) => {
          emit("keydown", e);
        }, (e) => {
          const { key, shiftKey, target, currentTarget } = e;
          if (key === EVENT_CODE.tab && shiftKey) {
            onItemShiftTab();
            return;
          }
          if (target !== currentTarget)
            return;
          const focusIntent = getFocusIntent(e);
          if (focusIntent) {
            e.preventDefault();
            const items = getItems().filter((item) => item.focusable);
            let elements = items.map((item) => item.ref);
            switch (focusIntent) {
              case "last": {
                elements.reverse();
                break;
              }
              case "prev":
              case "next": {
                if (focusIntent === "prev") {
                  elements.reverse();
                }
                const currentIdx = elements.indexOf(currentTarget);
                elements = loop.value ? reorderArray(elements, currentIdx + 1) : elements.slice(currentIdx + 1);
                break;
              }
            }
            nextTick(() => {
              focusFirst(elements);
            });
          }
        });
        const isCurrentTab = computed(() => currentTabbedId.value === unref(id2));
        provide(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, {
          rovingFocusGroupItemRef,
          tabIndex: computed(() => unref(isCurrentTab) ? 0 : -1),
          handleMousedown,
          handleFocus,
          handleKeydown
        });
        return {
          id: id2,
          handleKeydown,
          handleFocus,
          handleMousedown
        };
      }
    });
    function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_roving_focus_collection_item = resolveComponent("el-roving-focus-collection-item");
      return openBlock(), createBlock(_component_el_roving_focus_collection_item, {
        id: _ctx.id,
        focusable: _ctx.focusable,
        active: _ctx.active
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "focusable", "active"]);
    }
    var ElRovingFocusItem = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$m], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-item.vue"]]);
    const dropdownProps = buildProps({
      trigger: useTooltipTriggerProps.trigger,
      effect: {
        ...useTooltipContentProps.effect,
        default: "light"
      },
      type: {
        type: definePropType(String)
      },
      placement: {
        type: definePropType(String),
        default: "bottom"
      },
      popperOptions: {
        type: definePropType(Object),
        default: () => ({})
      },
      id: String,
      size: {
        type: String,
        default: ""
      },
      splitButton: Boolean,
      hideOnClick: {
        type: Boolean,
        default: true
      },
      loop: {
        type: Boolean,
        default: true
      },
      showTimeout: {
        type: Number,
        default: 150
      },
      hideTimeout: {
        type: Number,
        default: 150
      },
      tabindex: {
        type: definePropType([Number, String]),
        default: 0
      },
      maxHeight: {
        type: definePropType([Number, String]),
        default: ""
      },
      popperClass: {
        type: String,
        default: ""
      },
      disabled: {
        type: Boolean,
        default: false
      },
      role: {
        type: String,
        default: "menu"
      },
      buttonProps: {
        type: definePropType(Object)
      }
    });
    const dropdownItemProps = buildProps({
      command: {
        type: [Object, String, Number],
        default: () => ({})
      },
      disabled: Boolean,
      divided: Boolean,
      textValue: String,
      icon: {
        type: iconPropType
      }
    });
    const dropdownMenuProps = buildProps({
      onKeydown: { type: definePropType(Function) }
    });
    const FIRST_KEYS = [
      EVENT_CODE.down,
      EVENT_CODE.pageDown,
      EVENT_CODE.home
    ];
    const LAST_KEYS = [EVENT_CODE.up, EVENT_CODE.pageUp, EVENT_CODE.end];
    const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
    const {
      ElCollection,
      ElCollectionItem,
      COLLECTION_INJECTION_KEY,
      COLLECTION_ITEM_INJECTION_KEY
    } = createCollectionWithScope("Dropdown");
    const DROPDOWN_INJECTION_KEY = Symbol("elDropdown");
    const { ButtonGroup: ElButtonGroup } = ElButton;
    const _sfc_main$17 = defineComponent({
      name: "ElDropdown",
      components: {
        ElButton,
        ElButtonGroup,
        ElScrollbar,
        ElDropdownCollection: ElCollection,
        ElTooltip,
        ElRovingFocusGroup,
        ElOnlyChild: OnlyChild,
        ElIcon,
        ArrowDown: arrow_down_default
      },
      props: dropdownProps,
      emits: ["visible-change", "click", "command"],
      setup(props, { emit }) {
        const _instance = getCurrentInstance();
        const ns2 = useNamespace("dropdown");
        const { t } = useLocale();
        const triggeringElementRef = ref();
        const referenceElementRef = ref();
        const popperRef = ref(null);
        const contentRef = ref(null);
        const scrollbar = ref(null);
        const currentTabId = ref(null);
        const isUsingKeyboard = ref(false);
        const triggerKeys = [EVENT_CODE.enter, EVENT_CODE.space, EVENT_CODE.down];
        const wrapStyle = computed(() => ({
          maxHeight: addUnit(props.maxHeight)
        }));
        const dropdownTriggerKls = computed(() => [ns2.m(dropdownSize.value)]);
        const defaultTriggerId = useId().value;
        const triggerId = computed(() => {
          return props.id || defaultTriggerId;
        });
        function handleClick() {
          handleClose();
        }
        function handleClose() {
          var _a2;
          (_a2 = popperRef.value) == null ? void 0 : _a2.onClose();
        }
        function handleOpen() {
          var _a2;
          (_a2 = popperRef.value) == null ? void 0 : _a2.onOpen();
        }
        const dropdownSize = useSize();
        function commandHandler(...args) {
          emit("command", ...args);
        }
        function onItemEnter() {
        }
        function onItemLeave() {
          const contentEl = unref(contentRef);
          contentEl == null ? void 0 : contentEl.focus();
          currentTabId.value = null;
        }
        function handleCurrentTabIdChange(id2) {
          currentTabId.value = id2;
        }
        function handleEntryFocus(e) {
          if (!isUsingKeyboard.value) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        }
        function handleBeforeShowTooltip() {
          emit("visible-change", true);
        }
        function handleShowTooltip(event) {
          if ((event == null ? void 0 : event.type) === "keydown") {
            contentRef.value.focus();
          }
        }
        function handleBeforeHideTooltip() {
          emit("visible-change", false);
        }
        provide(DROPDOWN_INJECTION_KEY, {
          contentRef,
          role: computed(() => props.role),
          triggerId,
          isUsingKeyboard,
          onItemEnter,
          onItemLeave
        });
        provide("elDropdown", {
          instance: _instance,
          dropdownSize,
          handleClick,
          commandHandler,
          trigger: toRef(props, "trigger"),
          hideOnClick: toRef(props, "hideOnClick")
        });
        const onFocusAfterTrapped = (e) => {
          var _a2, _b;
          e.preventDefault();
          (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2, {
            preventScroll: true
          });
        };
        const handlerMainButtonClick = (event) => {
          emit("click", event);
        };
        return {
          t,
          ns: ns2,
          scrollbar,
          wrapStyle,
          dropdownTriggerKls,
          dropdownSize,
          triggerId,
          triggerKeys,
          currentTabId,
          handleCurrentTabIdChange,
          handlerMainButtonClick,
          handleEntryFocus,
          handleClose,
          handleOpen,
          handleBeforeShowTooltip,
          handleShowTooltip,
          handleBeforeHideTooltip,
          onFocusAfterTrapped,
          popperRef,
          contentRef,
          triggeringElementRef,
          referenceElementRef
        };
      }
    });
    function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
      var _a2;
      const _component_el_dropdown_collection = resolveComponent("el-dropdown-collection");
      const _component_el_roving_focus_group = resolveComponent("el-roving-focus-group");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_el_only_child = resolveComponent("el-only-child");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _component_el_button = resolveComponent("el-button");
      const _component_arrow_down = resolveComponent("arrow-down");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_button_group = resolveComponent("el-button-group");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("disabled", _ctx.disabled)])
      }, [
        createVNode(_component_el_tooltip, {
          ref: "popperRef",
          role: _ctx.role,
          effect: _ctx.effect,
          "fallback-placements": ["bottom", "top"],
          "popper-options": _ctx.popperOptions,
          "gpu-acceleration": false,
          "hide-after": _ctx.trigger === "hover" ? _ctx.hideTimeout : 0,
          "manual-mode": true,
          placement: _ctx.placement,
          "popper-class": [_ctx.ns.e("popper"), _ctx.popperClass],
          "reference-element": (_a2 = _ctx.referenceElementRef) == null ? void 0 : _a2.$el,
          trigger: _ctx.trigger,
          "trigger-keys": _ctx.triggerKeys,
          "trigger-target-el": _ctx.contentRef,
          "show-after": _ctx.trigger === "hover" ? _ctx.showTimeout : 0,
          "stop-popper-mouse-event": false,
          "virtual-ref": _ctx.triggeringElementRef,
          "virtual-triggering": _ctx.splitButton,
          disabled: _ctx.disabled,
          transition: `${_ctx.ns.namespace.value}-zoom-in-top`,
          teleported: "",
          pure: "",
          persistent: "",
          onBeforeShow: _ctx.handleBeforeShowTooltip,
          onShow: _ctx.handleShowTooltip,
          onBeforeHide: _ctx.handleBeforeHideTooltip
        }, createSlots({
          content: withCtx(() => [
            createVNode(_component_el_scrollbar, {
              ref: "scrollbar",
              "wrap-style": _ctx.wrapStyle,
              tag: "div",
              "view-class": _ctx.ns.e("list")
            }, {
              default: withCtx(() => [
                createVNode(_component_el_roving_focus_group, {
                  loop: _ctx.loop,
                  "current-tab-id": _ctx.currentTabId,
                  orientation: "horizontal",
                  onCurrentTabIdChange: _ctx.handleCurrentTabIdChange,
                  onEntryFocus: _ctx.handleEntryFocus
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_dropdown_collection, null, {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "dropdown")
                      ]),
                      _: 3
                    })
                  ]),
                  _: 3
                }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])
              ]),
              _: 3
            }, 8, ["wrap-style", "view-class"])
          ]),
          _: 2
        }, [
          !_ctx.splitButton ? {
            name: "default",
            fn: withCtx(() => [
              createVNode(_component_el_only_child, {
                id: _ctx.triggerId,
                role: "button",
                tabindex: _ctx.tabindex
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["id", "tabindex"])
            ])
          } : void 0
        ]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "onBeforeShow", "onShow", "onBeforeHide"]),
        _ctx.splitButton ? (openBlock(), createBlock(_component_el_button_group, { key: 0 }, {
          default: withCtx(() => [
            createVNode(_component_el_button, mergeProps({ ref: "referenceElementRef" }, _ctx.buttonProps, {
              size: _ctx.dropdownSize,
              type: _ctx.type,
              disabled: _ctx.disabled,
              tabindex: _ctx.tabindex,
              onClick: _ctx.handlerMainButtonClick
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
            createVNode(_component_el_button, mergeProps({
              id: _ctx.triggerId,
              ref: "triggeringElementRef"
            }, _ctx.buttonProps, {
              role: "button",
              size: _ctx.dropdownSize,
              type: _ctx.type,
              class: _ctx.ns.e("caret-button"),
              disabled: _ctx.disabled,
              tabindex: _ctx.tabindex,
              "aria-label": _ctx.t("el.dropdown.toggleDropdown")
            }), {
              default: withCtx(() => [
                createVNode(_component_el_icon, {
                  class: normalizeClass(_ctx.ns.e("icon"))
                }, {
                  default: withCtx(() => [
                    createVNode(_component_arrow_down)
                  ]),
                  _: 1
                }, 8, ["class"])
              ]),
              _: 1
            }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
          ]),
          _: 3
        })) : createCommentVNode("v-if", true)
      ], 2);
    }
    var Dropdown = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$l], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown.vue"]]);
    const _sfc_main$16 = defineComponent({
      name: "DropdownItemImpl",
      components: {
        ElIcon
      },
      props: dropdownItemProps,
      emits: ["pointermove", "pointerleave", "click", "clickimpl"],
      setup(_2, { emit }) {
        const ns2 = useNamespace("dropdown");
        const { role: menuRole } = inject(DROPDOWN_INJECTION_KEY, void 0);
        const { collectionItemRef: dropdownCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY, void 0);
        const { collectionItemRef: rovingFocusCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY$1, void 0);
        const {
          rovingFocusGroupItemRef,
          tabIndex,
          handleFocus,
          handleKeydown: handleItemKeydown,
          handleMousedown
        } = inject(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, void 0);
        const itemRef = composeRefs(dropdownCollectionItemRef, rovingFocusCollectionItemRef, rovingFocusGroupItemRef);
        const role = computed(() => {
          if (menuRole.value === "menu") {
            return "menuitem";
          } else if (menuRole.value === "navigation") {
            return "link";
          }
          return "button";
        });
        const handleKeydown = composeEventHandlers((e) => {
          const { code: code2 } = e;
          if (code2 === EVENT_CODE.enter || code2 === EVENT_CODE.space) {
            e.preventDefault();
            e.stopImmediatePropagation();
            emit("clickimpl", e);
            return true;
          }
        }, handleItemKeydown);
        return {
          ns: ns2,
          itemRef,
          dataset: {
            [COLLECTION_ITEM_SIGN]: ""
          },
          role,
          tabIndex,
          handleFocus,
          handleKeydown,
          handleMousedown
        };
      }
    });
    const _hoisted_1$B = ["aria-disabled", "tabindex", "role"];
    function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_icon = resolveComponent("el-icon");
      return openBlock(), createElementBlock(Fragment, null, [
        _ctx.divided ? (openBlock(), createElementBlock("li", mergeProps({
          key: 0,
          role: "separator",
          class: _ctx.ns.bem("menu", "item", "divided")
        }, _ctx.$attrs), null, 16)) : createCommentVNode("v-if", true),
        createBaseVNode("li", mergeProps({ ref: _ctx.itemRef }, { ..._ctx.dataset, ..._ctx.$attrs }, {
          "aria-disabled": _ctx.disabled,
          class: [_ctx.ns.be("menu", "item"), _ctx.ns.is("disabled", _ctx.disabled)],
          tabindex: _ctx.tabIndex,
          role: _ctx.role,
          onClick: _cache[0] || (_cache[0] = (e) => _ctx.$emit("clickimpl", e)),
          onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
          onKeydown: _cache[2] || (_cache[2] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args)),
          onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.handleMousedown && _ctx.handleMousedown(...args)),
          onPointermove: _cache[4] || (_cache[4] = (e) => _ctx.$emit("pointermove", e)),
          onPointerleave: _cache[5] || (_cache[5] = (e) => _ctx.$emit("pointerleave", e))
        }), [
          _ctx.icon ? (openBlock(), createBlock(_component_el_icon, { key: 0 }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
            ]),
            _: 1
          })) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "default")
        ], 16, _hoisted_1$B)
      ], 64);
    }
    var ElDropdownItemImpl = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$k], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item-impl.vue"]]);
    const useDropdown = () => {
      const elDropdown = inject("elDropdown", {});
      const _elDropdownSize = computed(() => elDropdown == null ? void 0 : elDropdown.dropdownSize);
      return {
        elDropdown,
        _elDropdownSize
      };
    };
    const _sfc_main$15 = defineComponent({
      name: "ElDropdownItem",
      components: {
        ElDropdownCollectionItem: ElCollectionItem,
        ElRovingFocusItem,
        ElDropdownItemImpl
      },
      inheritAttrs: false,
      props: dropdownItemProps,
      emits: ["pointermove", "pointerleave", "click"],
      setup(props, { emit, attrs }) {
        const { elDropdown } = useDropdown();
        const _instance = getCurrentInstance();
        const itemRef = ref(null);
        const textContent = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = unref(itemRef)) == null ? void 0 : _a2.textContent) != null ? _b : "";
        });
        const { onItemEnter, onItemLeave } = inject(DROPDOWN_INJECTION_KEY, void 0);
        const handlePointerMove = composeEventHandlers((e) => {
          emit("pointermove", e);
          return e.defaultPrevented;
        }, whenMouse((e) => {
          var _a2;
          if (props.disabled) {
            onItemLeave(e);
          } else {
            onItemEnter(e);
            if (!e.defaultPrevented) {
              (_a2 = e.currentTarget) == null ? void 0 : _a2.focus();
            }
          }
        }));
        const handlePointerLeave = composeEventHandlers((e) => {
          emit("pointerleave", e);
          return e.defaultPrevented;
        }, whenMouse((e) => {
          onItemLeave(e);
        }));
        const handleClick = composeEventHandlers((e) => {
          emit("click", e);
          return e.type !== "keydown" && e.defaultPrevented;
        }, (e) => {
          var _a2, _b, _c;
          if (props.disabled) {
            e.stopImmediatePropagation();
            return;
          }
          if ((_a2 = elDropdown == null ? void 0 : elDropdown.hideOnClick) == null ? void 0 : _a2.value) {
            (_b = elDropdown.handleClick) == null ? void 0 : _b.call(elDropdown);
          }
          (_c = elDropdown.commandHandler) == null ? void 0 : _c.call(elDropdown, props.command, _instance, e);
        });
        const propsAndAttrs = computed(() => {
          return { ...props, ...attrs };
        });
        return {
          handleClick,
          handlePointerMove,
          handlePointerLeave,
          textContent,
          propsAndAttrs
        };
      }
    });
    function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
      var _a2;
      const _component_el_dropdown_item_impl = resolveComponent("el-dropdown-item-impl");
      const _component_el_roving_focus_item = resolveComponent("el-roving-focus-item");
      const _component_el_dropdown_collection_item = resolveComponent("el-dropdown-collection-item");
      return openBlock(), createBlock(_component_el_dropdown_collection_item, {
        disabled: _ctx.disabled,
        "text-value": (_a2 = _ctx.textValue) != null ? _a2 : _ctx.textContent
      }, {
        default: withCtx(() => [
          createVNode(_component_el_roving_focus_item, {
            focusable: !_ctx.disabled
          }, {
            default: withCtx(() => [
              createVNode(_component_el_dropdown_item_impl, mergeProps(_ctx.propsAndAttrs, {
                onPointerleave: _ctx.handlePointerLeave,
                onPointermove: _ctx.handlePointerMove,
                onClickimpl: _ctx.handleClick
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
            ]),
            _: 3
          }, 8, ["focusable"])
        ]),
        _: 3
      }, 8, ["disabled", "text-value"]);
    }
    var DropdownItem = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$j], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item.vue"]]);
    const _sfc_main$14 = defineComponent({
      name: "ElDropdownMenu",
      props: dropdownMenuProps,
      setup(props) {
        const ns2 = useNamespace("dropdown");
        const { _elDropdownSize } = useDropdown();
        const size2 = _elDropdownSize.value;
        const { focusTrapRef, onKeydown } = inject(FOCUS_TRAP_INJECTION_KEY, void 0);
        const { contentRef, role, triggerId } = inject(DROPDOWN_INJECTION_KEY, void 0);
        const { collectionRef: dropdownCollectionRef, getItems } = inject(COLLECTION_INJECTION_KEY, void 0);
        const {
          rovingFocusGroupRef,
          rovingFocusGroupRootStyle,
          tabIndex,
          onBlur,
          onFocus,
          onMousedown
        } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
        const { collectionRef: rovingFocusGroupCollectionRef } = inject(COLLECTION_INJECTION_KEY$1, void 0);
        const dropdownKls = computed(() => {
          return [ns2.b("menu"), ns2.bm("menu", size2 == null ? void 0 : size2.value)];
        });
        const dropdownListWrapperRef = composeRefs(contentRef, dropdownCollectionRef, focusTrapRef, rovingFocusGroupRef, rovingFocusGroupCollectionRef);
        const composedKeydown = composeEventHandlers((e) => {
          var _a2;
          (_a2 = props.onKeydown) == null ? void 0 : _a2.call(props, e);
        }, (e) => {
          const { currentTarget, code: code2, target } = e;
          currentTarget.contains(target);
          if (EVENT_CODE.tab === code2) {
            e.stopImmediatePropagation();
          }
          e.preventDefault();
          if (target !== unref(contentRef))
            return;
          if (!FIRST_LAST_KEYS.includes(code2))
            return;
          const items = getItems().filter((item) => !item.disabled);
          const targets = items.map((item) => item.ref);
          if (LAST_KEYS.includes(code2)) {
            targets.reverse();
          }
          focusFirst(targets);
        });
        const handleKeydown = (e) => {
          composedKeydown(e);
          onKeydown(e);
        };
        return {
          size: size2,
          rovingFocusGroupRootStyle,
          tabIndex,
          dropdownKls,
          role,
          triggerId,
          dropdownListWrapperRef,
          handleKeydown,
          onBlur,
          onFocus,
          onMousedown
        };
      }
    });
    const _hoisted_1$A = ["role", "aria-labelledby"];
    function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("ul", {
        ref: _ctx.dropdownListWrapperRef,
        class: normalizeClass(_ctx.dropdownKls),
        style: normalizeStyle(_ctx.rovingFocusGroupRootStyle),
        tabindex: -1,
        role: _ctx.role,
        "aria-labelledby": _ctx.triggerId,
        onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
        onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
        onKeydown: _cache[2] || (_cache[2] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args)),
        onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.onMousedown && _ctx.onMousedown(...args))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 46, _hoisted_1$A);
    }
    var DropdownMenu = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$i], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-menu.vue"]]);
    const ElDropdown = withInstall(Dropdown, {
      DropdownItem,
      DropdownMenu
    });
    const ElDropdownItem = withNoopInstall(DropdownItem);
    const ElDropdownMenu = withNoopInstall(DropdownMenu);
    let id = 0;
    const _sfc_main$13 = defineComponent({
      name: "ImgEmpty",
      setup() {
        const ns2 = useNamespace("empty");
        return {
          ns: ns2,
          id: ++id
        };
      }
    });
    const _hoisted_1$z = {
      viewBox: "0 0 79 86",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg",
      "xmlns:xlink": "http://www.w3.org/1999/xlink"
    };
    const _hoisted_2$n = ["id"];
    const _hoisted_3$b = ["stop-color"];
    const _hoisted_4$8 = ["stop-color"];
    const _hoisted_5$7 = ["id"];
    const _hoisted_6$3 = ["stop-color"];
    const _hoisted_7$1 = ["stop-color"];
    const _hoisted_8$1 = ["id"];
    const _hoisted_9$1 = {
      id: "Illustrations",
      stroke: "none",
      "stroke-width": "1",
      fill: "none",
      "fill-rule": "evenodd"
    };
    const _hoisted_10$1 = {
      id: "B-type",
      transform: "translate(-1268.000000, -535.000000)"
    };
    const _hoisted_11$1 = {
      id: "Group-2",
      transform: "translate(1268.000000, 535.000000)"
    };
    const _hoisted_12$1 = ["fill"];
    const _hoisted_13$1 = ["fill"];
    const _hoisted_14$1 = {
      id: "Group-Copy",
      transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"
    };
    const _hoisted_15$1 = ["fill"];
    const _hoisted_16$1 = ["fill"];
    const _hoisted_17$1 = ["fill"];
    const _hoisted_18$1 = ["fill"];
    const _hoisted_19$1 = ["fill"];
    const _hoisted_20$1 = {
      id: "Rectangle-Copy-17",
      transform: "translate(53.000000, 45.000000)"
    };
    const _hoisted_21$1 = ["fill", "xlink:href"];
    const _hoisted_22$1 = ["fill", "mask"];
    const _hoisted_23$1 = ["fill"];
    function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1$z, [
        createBaseVNode("defs", null, [
          createBaseVNode("linearGradient", {
            id: `linearGradient-1-${_ctx.id}`,
            x1: "38.8503086%",
            y1: "0%",
            x2: "61.1496914%",
            y2: "100%"
          }, [
            createBaseVNode("stop", {
              "stop-color": `var(${_ctx.ns.cssVarBlockName("fill-color-1")})`,
              offset: "0%"
            }, null, 8, _hoisted_3$b),
            createBaseVNode("stop", {
              "stop-color": `var(${_ctx.ns.cssVarBlockName("fill-color-4")})`,
              offset: "100%"
            }, null, 8, _hoisted_4$8)
          ], 8, _hoisted_2$n),
          createBaseVNode("linearGradient", {
            id: `linearGradient-2-${_ctx.id}`,
            x1: "0%",
            y1: "9.5%",
            x2: "100%",
            y2: "90.5%"
          }, [
            createBaseVNode("stop", {
              "stop-color": `var(${_ctx.ns.cssVarBlockName("fill-color-1")})`,
              offset: "0%"
            }, null, 8, _hoisted_6$3),
            createBaseVNode("stop", {
              "stop-color": `var(${_ctx.ns.cssVarBlockName("fill-color-6")})`,
              offset: "100%"
            }, null, 8, _hoisted_7$1)
          ], 8, _hoisted_5$7),
          createBaseVNode("rect", {
            id: `path-3-${_ctx.id}`,
            x: "0",
            y: "0",
            width: "17",
            height: "36"
          }, null, 8, _hoisted_8$1)
        ]),
        createBaseVNode("g", _hoisted_9$1, [
          createBaseVNode("g", _hoisted_10$1, [
            createBaseVNode("g", _hoisted_11$1, [
              createBaseVNode("path", {
                id: "Oval-Copy-2",
                d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
                fill: `var(${_ctx.ns.cssVarBlockName("fill-color-3")})`
              }, null, 8, _hoisted_12$1),
              createBaseVNode("polygon", {
                id: "Rectangle-Copy-14",
                fill: `var(${_ctx.ns.cssVarBlockName("fill-color-7")})`,
                transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
                points: "13 58 53 58 42 45 2 45"
              }, null, 8, _hoisted_13$1),
              createBaseVNode("g", _hoisted_14$1, [
                createBaseVNode("polygon", {
                  id: "Rectangle-Copy-10",
                  fill: `var(${_ctx.ns.cssVarBlockName("fill-color-7")})`,
                  transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
                  points: "2.84078316e-14 3 18 3 23 7 5 7"
                }, null, 8, _hoisted_15$1),
                createBaseVNode("polygon", {
                  id: "Rectangle-Copy-11",
                  fill: `var(${_ctx.ns.cssVarBlockName("fill-color-5")})`,
                  points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
                }, null, 8, _hoisted_16$1),
                createBaseVNode("rect", {
                  id: "Rectangle-Copy-12",
                  fill: `url(#linearGradient-1-${_ctx.id})`,
                  transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
                  x: "38",
                  y: "7",
                  width: "17",
                  height: "36"
                }, null, 8, _hoisted_17$1),
                createBaseVNode("polygon", {
                  id: "Rectangle-Copy-13",
                  fill: `var(${_ctx.ns.cssVarBlockName("fill-color-2")})`,
                  transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
                  points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
                }, null, 8, _hoisted_18$1)
              ]),
              createBaseVNode("rect", {
                id: "Rectangle-Copy-15",
                fill: `url(#linearGradient-2-${_ctx.id})`,
                x: "13",
                y: "45",
                width: "40",
                height: "36"
              }, null, 8, _hoisted_19$1),
              createBaseVNode("g", _hoisted_20$1, [
                createBaseVNode("use", {
                  id: "Mask",
                  fill: `var(${_ctx.ns.cssVarBlockName("fill-color-8")})`,
                  transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
                  "xlink:href": `#path-3-${_ctx.id}`
                }, null, 8, _hoisted_21$1),
                createBaseVNode("polygon", {
                  id: "Rectangle-Copy",
                  fill: `var(${_ctx.ns.cssVarBlockName("fill-color-9")})`,
                  mask: `url(#mask-4-${_ctx.id})`,
                  transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
                  points: "7 0 24 0 20 18 7 16.5"
                }, null, 8, _hoisted_22$1)
              ]),
              createBaseVNode("polygon", {
                id: "Rectangle-Copy-18",
                fill: `var(${_ctx.ns.cssVarBlockName("fill-color-2")})`,
                transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
                points: "62 45 79 45 70 58 53 58"
              }, null, 8, _hoisted_23$1)
            ])
          ])
        ])
      ]);
    }
    var ImgEmpty = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$h], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/img-empty.vue"]]);
    const emptyProps = {
      image: {
        type: String,
        default: ""
      },
      imageSize: Number,
      description: {
        type: String,
        default: ""
      }
    };
    const _hoisted_1$y = ["src"];
    const _hoisted_2$m = { key: 1 };
    const __default__$I = {
      name: "ElEmpty"
    };
    const _sfc_main$12 = /* @__PURE__ */ defineComponent({
      ...__default__$I,
      props: emptyProps,
      setup(__props) {
        const props = __props;
        const { t } = useLocale();
        const ns2 = useNamespace("empty");
        const emptyDescription = computed(() => props.description || t("el.table.emptyText"));
        const imageStyle = computed(() => ({
          width: props.imageSize ? `${props.imageSize}px` : ""
        }));
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(ns2).b())
          }, [
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("image")),
              style: normalizeStyle(unref(imageStyle))
            }, [
              _ctx.image ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: _ctx.image,
                ondragstart: "return false"
              }, null, 8, _hoisted_1$y)) : renderSlot(_ctx.$slots, "image", { key: 1 }, () => [
                createVNode(ImgEmpty)
              ])
            ], 6),
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("description"))
            }, [
              _ctx.$slots.description ? renderSlot(_ctx.$slots, "description", { key: 0 }) : (openBlock(), createElementBlock("p", _hoisted_2$m, toDisplayString$1(unref(emptyDescription)), 1))
            ], 2),
            _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(ns2).e("bottom"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    });
    var Empty = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/empty.vue"]]);
    const ElEmpty = withInstall(Empty);
    const formProps = buildProps({
      model: Object,
      rules: {
        type: definePropType(Object)
      },
      labelPosition: {
        type: String,
        values: ["left", "right", "top"],
        default: "right"
      },
      requireAsteriskPosition: {
        type: String,
        values: ["left", "right"],
        default: "left"
      },
      labelWidth: {
        type: [String, Number],
        default: ""
      },
      labelSuffix: {
        type: String,
        default: ""
      },
      inline: Boolean,
      inlineMessage: Boolean,
      statusIcon: Boolean,
      showMessage: {
        type: Boolean,
        default: true
      },
      size: {
        type: String,
        values: componentSizes
      },
      disabled: Boolean,
      validateOnRuleChange: {
        type: Boolean,
        default: true
      },
      hideRequiredAsterisk: {
        type: Boolean,
        default: false
      },
      scrollToError: Boolean
    });
    const formEmits = {
      validate: (prop, isValid, message2) => (isArray$4(prop) || isString$3(prop)) && isBoolean$2(isValid) && isString$3(message2)
    };
    function useFormLabelWidth() {
      const potentialLabelWidthArr = ref([]);
      const autoLabelWidth = computed(() => {
        if (!potentialLabelWidthArr.value.length)
          return "0";
        const max2 = Math.max(...potentialLabelWidthArr.value);
        return max2 ? `${max2}px` : "";
      });
      function getLabelWidthIndex(width) {
        const index2 = potentialLabelWidthArr.value.indexOf(width);
        return index2;
      }
      function registerLabelWidth(val, oldVal) {
        if (val && oldVal) {
          const index2 = getLabelWidthIndex(oldVal);
          potentialLabelWidthArr.value.splice(index2, 1, val);
        } else if (val) {
          potentialLabelWidthArr.value.push(val);
        }
      }
      function deregisterLabelWidth(val) {
        const index2 = getLabelWidthIndex(val);
        if (index2 > -1) {
          potentialLabelWidthArr.value.splice(index2, 1);
        }
      }
      return {
        autoLabelWidth,
        registerLabelWidth,
        deregisterLabelWidth
      };
    }
    const filterFields = (fields, props) => {
      const normalized = castArray$1(props);
      return normalized.length > 0 ? fields.filter((field) => field.prop && normalized.includes(field.prop)) : fields;
    };
    const __default__$H = {
      name: "ElForm"
    };
    const _sfc_main$11 = /* @__PURE__ */ defineComponent({
      ...__default__$H,
      props: formProps,
      emits: formEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const fields = [];
        const formSize = useSize();
        const ns2 = useNamespace("form");
        const formClasses = computed(() => {
          const { labelPosition, inline } = props;
          return [
            ns2.b(),
            ns2.m(formSize.value || "default"),
            {
              [ns2.m(`label-${labelPosition}`)]: labelPosition,
              [ns2.m("inline")]: inline
            }
          ];
        });
        const addField = (field) => {
          fields.push(field);
        };
        const removeField = (field) => {
          if (field.prop) {
            fields.splice(fields.indexOf(field), 1);
          }
        };
        const resetFields = (properties = []) => {
          if (!props.model) {
            return;
          }
          filterFields(fields, properties).forEach((field) => field.resetField());
        };
        const clearValidate = (props2 = []) => {
          filterFields(fields, props2).forEach((field) => field.clearValidate());
        };
        const isValidatable = computed(() => {
          const hasModel = !!props.model;
          return hasModel;
        });
        const obtainValidateFields = (props2) => {
          if (fields.length === 0)
            return [];
          const filteredFields = filterFields(fields, props2);
          if (!filteredFields.length) {
            return [];
          }
          return filteredFields;
        };
        const validate = async (callback) => validateField(void 0, callback);
        const doValidateField = async (props2 = []) => {
          if (!isValidatable.value)
            return false;
          const fields2 = obtainValidateFields(props2);
          if (fields2.length === 0)
            return true;
          let validationErrors = {};
          for (const field of fields2) {
            try {
              await field.validate("");
            } catch (fields3) {
              validationErrors = {
                ...validationErrors,
                ...fields3
              };
            }
          }
          if (Object.keys(validationErrors).length === 0)
            return true;
          return Promise.reject(validationErrors);
        };
        const validateField = async (modelProps = [], callback) => {
          const shouldThrow = !isFunction$4(callback);
          try {
            const result = await doValidateField(modelProps);
            if (result === true) {
              callback == null ? void 0 : callback(result);
            }
            return result;
          } catch (e) {
            const invalidFields = e;
            if (props.scrollToError) {
              scrollToField(Object.keys(invalidFields)[0]);
            }
            callback == null ? void 0 : callback(false, invalidFields);
            return shouldThrow && Promise.reject(invalidFields);
          }
        };
        const scrollToField = (prop) => {
          var _a2;
          const field = filterFields(fields, prop)[0];
          if (field) {
            (_a2 = field.$el) == null ? void 0 : _a2.scrollIntoView();
          }
        };
        watch(() => props.rules, () => {
          if (props.validateOnRuleChange) {
            validate().catch((err) => debugWarn());
          }
        }, { deep: true });
        provide(formContextKey, reactive({
          ...toRefs(props),
          emit,
          resetFields,
          clearValidate,
          validateField,
          addField,
          removeField,
          ...useFormLabelWidth()
        }));
        expose({
          validate,
          validateField,
          resetFields,
          clearValidate,
          scrollToField
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("form", {
            class: normalizeClass(unref(formClasses))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var Form = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]);
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a2 = [null];
          a2.push.apply(a2, args2);
          var Constructor = Function.bind.apply(Parent2, a2);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn2) {
      return Function.toString.call(fn2).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    var formatRegExp = /%[sdj%]/g;
    var warning = function warning2() {
    };
    if (typeof process !== "undefined" && process.env && false) {
      warning = function warning2(type2, errors) {
        if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
          if (errors.every(function(e) {
            return typeof e === "string";
          })) {
            console.warn(type2, errors);
          }
        }
      };
    }
    function convertFieldsError(errors) {
      if (!errors || !errors.length)
        return null;
      var fields = {};
      errors.forEach(function(error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }
    function format(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var i = 0;
      var len = args.length;
      if (typeof template === "function") {
        return template.apply(null, args);
      }
      if (typeof template === "string") {
        var str = template.replace(formatRegExp, function(x2) {
          if (x2 === "%%") {
            return "%";
          }
          if (i >= len) {
            return x2;
          }
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_2) {
                return "[Circular]";
              }
              break;
            default:
              return x2;
          }
        });
        return str;
      }
      return template;
    }
    function isNativeStringType(type2) {
      return type2 === "string" || type2 === "url" || type2 === "hex" || type2 === "email" || type2 === "date" || type2 === "pattern";
    }
    function isEmptyValue(value, type2) {
      if (value === void 0 || value === null) {
        return true;
      }
      if (type2 === "array" && Array.isArray(value) && !value.length) {
        return true;
      }
      if (isNativeStringType(type2) && typeof value === "string" && !value) {
        return true;
      }
      return false;
    }
    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total2 = 0;
      var arrLength = arr.length;
      function count(errors) {
        results.push.apply(results, errors || []);
        total2++;
        if (total2 === arrLength) {
          callback(results);
        }
      }
      arr.forEach(function(a2) {
        func(a2, count);
      });
    }
    function asyncSerialArray(arr, func, callback) {
      var index2 = 0;
      var arrLength = arr.length;
      function next(errors) {
        if (errors && errors.length) {
          callback(errors);
          return;
        }
        var original = index2;
        index2 = index2 + 1;
        if (original < arrLength) {
          func(arr[original], next);
        } else {
          callback([]);
        }
      }
      next([]);
    }
    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function(k) {
        ret.push.apply(ret, objArr[k] || []);
      });
      return ret;
    }
    var AsyncValidationError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(AsyncValidationError2, _Error);
      function AsyncValidationError2(errors, fields) {
        var _this;
        _this = _Error.call(this, "Async Validation Error") || this;
        _this.errors = errors;
        _this.fields = fields;
        return _this;
      }
      return AsyncValidationError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function(resolve2, reject) {
          var next = function next2(errors) {
            callback(errors);
            return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
          };
          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next);
        });
        _pending["catch"](function(e) {
          return e;
        });
        return _pending;
      }
      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total2 = 0;
      var results = [];
      var pending = new Promise(function(resolve2, reject) {
        var next = function next2(errors) {
          results.push.apply(results, errors);
          total2++;
          if (total2 === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
          }
        };
        if (!objArrKeys.length) {
          callback(results);
          resolve2(source);
        }
        objArrKeys.forEach(function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next);
          } else {
            asyncParallelArray(arr, func, next);
          }
        });
      });
      pending["catch"](function(e) {
        return e;
      });
      return pending;
    }
    function isErrorObj(obj) {
      return !!(obj && obj.message !== void 0);
    }
    function getValue(value, path) {
      var v2 = value;
      for (var i = 0; i < path.length; i++) {
        if (v2 == void 0) {
          return v2;
        }
        v2 = v2[path[i]];
      }
      return v2;
    }
    function complementError(rule, source) {
      return function(oe) {
        var fieldValue;
        if (rule.fullFields) {
          fieldValue = getValue(source, rule.fullFields);
        } else {
          fieldValue = source[oe.field || rule.fullField];
        }
        if (isErrorObj(oe)) {
          oe.field = oe.field || rule.fullField;
          oe.fieldValue = fieldValue;
          return oe;
        }
        return {
          message: typeof oe === "function" ? oe() : oe,
          fieldValue,
          field: oe.field || rule.fullField
        };
      };
    }
    function deepMerge(target, source) {
      if (source) {
        for (var s2 in source) {
          if (source.hasOwnProperty(s2)) {
            var value = source[s2];
            if (typeof value === "object" && typeof target[s2] === "object") {
              target[s2] = _extends({}, target[s2], value);
            } else {
              target[s2] = value;
            }
          }
        }
      }
      return target;
    }
    var required$1 = function required2(rule, value, source, errors, options, type2) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type2 || rule.type))) {
        errors.push(format(options.messages.required, rule.fullField));
      }
    };
    var whitespace = function whitespace2(rule, value, source, errors, options) {
      if (/^\s+$/.test(value) || value === "") {
        errors.push(format(options.messages.whitespace, rule.fullField));
      }
    };
    var urlReg;
    var getUrlRegex = function() {
      if (urlReg) {
        return urlReg;
      }
      var word = "[a-fA-F\\d:]";
      var b2 = function b3(options) {
        return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
      };
      var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      var v6seg = "[a-fA-F\\d]{1,4}";
      var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
      var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
      var v4exact = new RegExp("^" + v4 + "$");
      var v6exact = new RegExp("^" + v6 + "$");
      var ip = function ip2(options) {
        return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
      };
      ip.v4 = function(options) {
        return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
      };
      ip.v6 = function(options) {
        return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
      };
      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = "(?:\\S+(?::\\S*)?@)?";
      var ipv4 = ip.v4().source;
      var ipv6 = ip.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = "(?::\\d{2,5})?";
      var path = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
      urlReg = new RegExp("(?:^" + regex + "$)", "i");
      return urlReg;
    };
    var pattern$2 = {
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types = {
      integer: function integer2(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      "float": function float(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function array2(value) {
        return Array.isArray(value);
      },
      regexp: function regexp2(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e) {
          return false;
        }
      },
      date: function date2(value) {
        return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
      },
      number: function number2(value) {
        if (isNaN(value)) {
          return false;
        }
        return typeof value === "number";
      },
      object: function object2(value) {
        return typeof value === "object" && !types.array(value);
      },
      method: function method2(value) {
        return typeof value === "function";
      },
      email: function email(value) {
        return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
      },
      url: function url(value) {
        return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex(value) {
        return typeof value === "string" && !!value.match(pattern$2.hex);
      }
    };
    var type$1 = function type2(rule, value, source, errors, options) {
      if (rule.required && value === void 0) {
        required$1(rule, value, source, errors, options);
        return;
      }
      var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
      var ruleType = rule.type;
      if (custom.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      } else if (ruleType && typeof value !== rule.type) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    };
    var range = function range2(rule, value, source, errors, options) {
      var len = typeof rule.len === "number";
      var min2 = typeof rule.min === "number";
      var max2 = typeof rule.max === "number";
      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === "number";
      var str = typeof value === "string";
      var arr = Array.isArray(value);
      if (num) {
        key = "number";
      } else if (str) {
        key = "string";
      } else if (arr) {
        key = "array";
      }
      if (!key) {
        return false;
      }
      if (arr) {
        val = value.length;
      }
      if (str) {
        val = value.replace(spRegexp, "_").length;
      }
      if (len) {
        if (val !== rule.len) {
          errors.push(format(options.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min2 && !max2 && val < rule.min) {
        errors.push(format(options.messages[key].min, rule.fullField, rule.min));
      } else if (max2 && !min2 && val > rule.max) {
        errors.push(format(options.messages[key].max, rule.fullField, rule.max));
      } else if (min2 && max2 && (val < rule.min || val > rule.max)) {
        errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };
    var ENUM$1 = "enum";
    var enumerable$1 = function enumerable2(rule, value, source, errors, options) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
      if (rule[ENUM$1].indexOf(value) === -1) {
        errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
      }
    };
    var pattern$1 = function pattern2(rule, value, source, errors, options) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          rule.pattern.lastIndex = 0;
          if (!rule.pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === "string") {
          var _pattern = new RegExp(rule.pattern);
          if (!_pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };
    var rules = {
      required: required$1,
      whitespace,
      type: type$1,
      range,
      "enum": enumerable$1,
      pattern: pattern$1
    };
    var string = function string2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "string");
        if (!isEmptyValue(value, "string")) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
          rules.pattern(rule, value, source, errors, options);
          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var method = function method2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var number$1 = function number2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (value === "") {
          value = void 0;
        }
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var _boolean = function _boolean2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var regexp = function regexp2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var integer = function integer2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var floatFn = function floatFn2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var array = function array2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if ((value === void 0 || value === null) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "array");
        if (value !== void 0 && value !== null) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var object = function object2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var ENUM = "enum";
    var enumerable = function enumerable2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules[ENUM](rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var pattern = function pattern2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "string")) {
          rules.pattern(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var date = function date2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "date") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "date")) {
          var dateObject;
          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }
          rules.type(rule, dateObject, source, errors, options);
          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var required = function required2(rule, value, callback, source, options) {
      var errors = [];
      var type2 = Array.isArray(value) ? "array" : typeof value;
      rules.required(rule, value, source, errors, options, type2);
      callback(errors);
    };
    var type = function type2(rule, value, callback, source, options) {
      var ruleType = rule.type;
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, ruleType);
        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var any = function any2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
      }
      callback(errors);
    };
    var validators$2 = {
      string,
      method,
      number: number$1,
      "boolean": _boolean,
      regexp,
      integer,
      "float": floatFn,
      array,
      object,
      "enum": enumerable,
      pattern,
      date,
      url: type,
      hex: type,
      email: type,
      required,
      any
    };
    function newMessages() {
      return {
        "default": "Validation error on field %s",
        required: "%s is required",
        "enum": "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
          format: "%s date %s is invalid for format %s",
          parse: "%s date could not be parsed, %s is invalid ",
          invalid: "%s date %s is invalid"
        },
        types: {
          string: "%s is not a %s",
          method: "%s is not a %s (function)",
          array: "%s is not an %s",
          object: "%s is not an %s",
          number: "%s is not a %s",
          date: "%s is not a %s",
          "boolean": "%s is not a %s",
          integer: "%s is not an %s",
          "float": "%s is not a %s",
          regexp: "%s is not a valid %s",
          email: "%s is not a valid %s",
          url: "%s is not a valid %s",
          hex: "%s is not a valid %s"
        },
        string: {
          len: "%s must be exactly %s characters",
          min: "%s must be at least %s characters",
          max: "%s cannot be longer than %s characters",
          range: "%s must be between %s and %s characters"
        },
        number: {
          len: "%s must equal %s",
          min: "%s cannot be less than %s",
          max: "%s cannot be greater than %s",
          range: "%s must be between %s and %s"
        },
        array: {
          len: "%s must be exactly %s in length",
          min: "%s cannot be less than %s in length",
          max: "%s cannot be greater than %s in length",
          range: "%s must be between %s and %s in length"
        },
        pattern: {
          mismatch: "%s value %s does not match pattern %s"
        },
        clone: function clone2() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }
    var messages = newMessages();
    var Schema = /* @__PURE__ */ function() {
      function Schema2(descriptor) {
        this.rules = null;
        this._messages = messages;
        this.define(descriptor);
      }
      var _proto = Schema2.prototype;
      _proto.define = function define(rules2) {
        var _this = this;
        if (!rules2) {
          throw new Error("Cannot configure a schema with no rules");
        }
        if (typeof rules2 !== "object" || Array.isArray(rules2)) {
          throw new Error("Rules must be an object");
        }
        this.rules = {};
        Object.keys(rules2).forEach(function(name) {
          var item = rules2[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      };
      _proto.messages = function messages2(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }
        return this._messages;
      };
      _proto.validate = function validate(source_, o2, oc) {
        var _this2 = this;
        if (o2 === void 0) {
          o2 = {};
        }
        if (oc === void 0) {
          oc = function oc2() {
          };
        }
        var source = source_;
        var options = o2;
        var callback = oc;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }
          return Promise.resolve(source);
        }
        function complete(results) {
          var errors = [];
          var fields = {};
          function add2(e) {
            if (Array.isArray(e)) {
              var _errors;
              errors = (_errors = errors).concat.apply(_errors, e);
            } else {
              errors.push(e);
            }
          }
          for (var i = 0; i < results.length; i++) {
            add2(results[i]);
          }
          if (!errors.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors);
            callback(errors, fields);
          }
        }
        if (options.messages) {
          var messages$1 = this.messages();
          if (messages$1 === messages) {
            messages$1 = newMessages();
          }
          deepMerge(messages$1, options.messages);
          options.messages = messages$1;
        } else {
          options.messages = this.messages();
        }
        var series = {};
        var keys2 = options.keys || Object.keys(this.rules);
        keys2.forEach(function(z) {
          var arr = _this2.rules[z];
          var value = source[z];
          arr.forEach(function(r) {
            var rule = r;
            if (typeof rule.transform === "function") {
              if (source === source_) {
                source = _extends({}, source);
              }
              value = source[z] = rule.transform(value);
            }
            if (typeof rule === "function") {
              rule = {
                validator: rule
              };
            } else {
              rule = _extends({}, rule);
            }
            rule.validator = _this2.getValidationMethod(rule);
            if (!rule.validator) {
              return;
            }
            rule.field = z;
            rule.fullField = rule.fullField || z;
            rule.type = _this2.getType(rule);
            series[z] = series[z] || [];
            series[z].push({
              rule,
              value,
              source,
              field: z
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function(data, doIt) {
          var rule = data.rule;
          var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
          deep = deep && (rule.required || !rule.required && data.value);
          rule.field = data.field;
          function addFullField(key, schema) {
            return _extends({}, schema, {
              fullField: rule.fullField + "." + key,
              fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
            });
          }
          function cb(e) {
            if (e === void 0) {
              e = [];
            }
            var errorList = Array.isArray(e) ? e : [e];
            if (!options.suppressWarning && errorList.length) {
              Schema2.warning("async-validator:", errorList);
            }
            if (errorList.length && rule.message !== void 0) {
              errorList = [].concat(rule.message);
            }
            var filledErrors = errorList.map(complementError(rule, source));
            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }
            if (!deep) {
              doIt(filledErrors);
            } else {
              if (rule.required && !data.value) {
                if (rule.message !== void 0) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                }
                return doIt(filledErrors);
              }
              var fieldsSchema = {};
              if (rule.defaultField) {
                Object.keys(data.value).map(function(key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }
              fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function(field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema = new Schema2(paredFieldsSchema);
              schema.messages(options.messages);
              if (data.rule.options) {
                data.rule.options.messages = options.messages;
                data.rule.options.error = options.error;
              }
              schema.validate(data.value, data.rule.options || options, function(errs) {
                var finalErrors = [];
                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, filledErrors);
                }
                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, errs);
                }
                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }
          var res;
          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data.value, cb, data.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data.value, cb, data.source, options);
            } catch (error) {
              console.error == null ? void 0 : console.error(error);
              if (!options.suppressValidatorError) {
                setTimeout(function() {
                  throw error;
                }, 0);
              }
              cb(error.message);
            }
            if (res === true) {
              cb();
            } else if (res === false) {
              cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
            } else if (res instanceof Array) {
              cb(res);
            } else if (res instanceof Error) {
              cb(res.message);
            }
          }
          if (res && res.then) {
            res.then(function() {
              return cb();
            }, function(e) {
              return cb(e);
            });
          }
        }, function(results) {
          complete(results);
        }, source);
      };
      _proto.getType = function getType2(rule) {
        if (rule.type === void 0 && rule.pattern instanceof RegExp) {
          rule.type = "pattern";
        }
        if (typeof rule.validator !== "function" && rule.type && !validators$2.hasOwnProperty(rule.type)) {
          throw new Error(format("Unknown rule type %s", rule.type));
        }
        return rule.type || "string";
      };
      _proto.getValidationMethod = function getValidationMethod(rule) {
        if (typeof rule.validator === "function") {
          return rule.validator;
        }
        var keys2 = Object.keys(rule);
        var messageIndex = keys2.indexOf("message");
        if (messageIndex !== -1) {
          keys2.splice(messageIndex, 1);
        }
        if (keys2.length === 1 && keys2[0] === "required") {
          return validators$2.required;
        }
        return validators$2[this.getType(rule)] || void 0;
      };
      return Schema2;
    }();
    Schema.register = function register(type2, validator2) {
      if (typeof validator2 !== "function") {
        throw new Error("Cannot register a validator by type, validator is not a function");
      }
      validators$2[type2] = validator2;
    };
    Schema.warning = warning;
    Schema.messages = messages;
    Schema.validators = validators$2;
    const formItemValidateStates = [
      "",
      "error",
      "validating",
      "success"
    ];
    const formItemProps = buildProps({
      label: String,
      labelWidth: {
        type: [String, Number],
        default: ""
      },
      prop: {
        type: definePropType([String, Array])
      },
      required: {
        type: Boolean,
        default: void 0
      },
      rules: {
        type: definePropType([Object, Array])
      },
      error: String,
      validateStatus: {
        type: String,
        values: formItemValidateStates
      },
      for: String,
      inlineMessage: {
        type: [String, Boolean],
        default: ""
      },
      showMessage: {
        type: Boolean,
        default: true
      },
      size: {
        type: String,
        values: componentSizes
      }
    });
    const COMPONENT_NAME$9 = "ElLabelWrap";
    var FormLabelWrap = defineComponent({
      name: COMPONENT_NAME$9,
      props: {
        isAutoWidth: Boolean,
        updateAll: Boolean
      },
      setup(props, {
        slots
      }) {
        const formContext = inject(formContextKey, void 0);
        const formItemContext = inject(formItemContextKey);
        if (!formItemContext)
          throwError(COMPONENT_NAME$9, "usage: <el-form-item><label-wrap /></el-form-item>");
        const ns2 = useNamespace("form");
        const el = ref();
        const computedWidth = ref(0);
        const getLabelWidth = () => {
          var _a2;
          if ((_a2 = el.value) == null ? void 0 : _a2.firstElementChild) {
            const width = window.getComputedStyle(el.value.firstElementChild).width;
            return Math.ceil(Number.parseFloat(width));
          } else {
            return 0;
          }
        };
        const updateLabelWidth = (action = "update") => {
          nextTick(() => {
            if (slots.default && props.isAutoWidth) {
              if (action === "update") {
                computedWidth.value = getLabelWidth();
              } else if (action === "remove") {
                formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
              }
            }
          });
        };
        const updateLabelWidthFn = () => updateLabelWidth("update");
        onMounted(() => {
          updateLabelWidthFn();
        });
        onBeforeUnmount(() => {
          updateLabelWidth("remove");
        });
        onUpdated(() => updateLabelWidthFn());
        watch(computedWidth, (val, oldVal) => {
          if (props.updateAll) {
            formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
          }
        });
        useResizeObserver(computed(() => {
          var _a2, _b;
          return (_b = (_a2 = el.value) == null ? void 0 : _a2.firstElementChild) != null ? _b : null;
        }), updateLabelWidthFn);
        return () => {
          var _a2, _b;
          if (!slots)
            return null;
          const {
            isAutoWidth
          } = props;
          if (isAutoWidth) {
            const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
            const style2 = {};
            if (autoLabelWidth && autoLabelWidth !== "auto") {
              const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
              const marginPosition = formContext.labelPosition === "left" ? "marginRight" : "marginLeft";
              if (marginWidth) {
                style2[marginPosition] = `${marginWidth}px`;
              }
            }
            return createVNode("div", {
              "ref": el,
              "class": [ns2.be("item", "label-wrap")],
              "style": style2
            }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
          } else {
            return createVNode(Fragment, {
              "ref": el
            }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
          }
        };
      }
    });
    const _hoisted_1$x = ["role", "aria-labelledby"];
    const __default__$G = {
      name: "ElFormItem"
    };
    const _sfc_main$10 = /* @__PURE__ */ defineComponent({
      ...__default__$G,
      props: formItemProps,
      setup(__props, { expose }) {
        const props = __props;
        const slots = useSlots();
        const formContext = inject(formContextKey, void 0);
        const parentFormItemContext = inject(formItemContextKey, void 0);
        const _size = useSize(void 0, { formItem: false });
        const ns2 = useNamespace("form-item");
        const labelId = useId().value;
        const inputIds = ref([]);
        const validateState = ref("");
        const validateStateDebounced = refDebounced(validateState, 100);
        const validateMessage = ref("");
        const formItemRef = ref();
        let initialValue = void 0;
        let isResettingField = false;
        const labelStyle = computed(() => {
          if ((formContext == null ? void 0 : formContext.labelPosition) === "top") {
            return {};
          }
          const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
          if (labelWidth)
            return { width: labelWidth };
          return {};
        });
        const contentStyle = computed(() => {
          if ((formContext == null ? void 0 : formContext.labelPosition) === "top" || (formContext == null ? void 0 : formContext.inline)) {
            return {};
          }
          if (!props.label && !props.labelWidth && isNested) {
            return {};
          }
          const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
          if (!props.label && !slots.label) {
            return { marginLeft: labelWidth };
          }
          return {};
        });
        const formItemClasses = computed(() => [
          ns2.b(),
          ns2.m(_size.value),
          ns2.is("error", validateState.value === "error"),
          ns2.is("validating", validateState.value === "validating"),
          ns2.is("success", validateState.value === "success"),
          ns2.is("required", isRequired.value || props.required),
          ns2.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
          (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
          { [ns2.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon }
        ]);
        const _inlineMessage = computed(() => isBoolean$2(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
        const validateClasses = computed(() => [
          ns2.e("error"),
          { [ns2.em("error", "inline")]: _inlineMessage.value }
        ]);
        const propString = computed(() => {
          if (!props.prop)
            return "";
          return isString$3(props.prop) ? props.prop : props.prop.join(".");
        });
        const hasLabel = computed(() => {
          return !!(props.label || slots.label);
        });
        const labelFor = computed(() => {
          return props.for || inputIds.value.length === 1 ? inputIds.value[0] : void 0;
        });
        const isGroup = computed(() => {
          return !labelFor.value && hasLabel.value;
        });
        const isNested = !!parentFormItemContext;
        const fieldValue = computed(() => {
          const model = formContext == null ? void 0 : formContext.model;
          if (!model || !props.prop) {
            return;
          }
          return getProp(model, props.prop).value;
        });
        const _rules = computed(() => {
          const rules2 = props.rules ? castArray$1(props.rules) : [];
          const formRules = formContext == null ? void 0 : formContext.rules;
          if (formRules && props.prop) {
            const _rules2 = getProp(formRules, props.prop).value;
            if (_rules2) {
              rules2.push(...castArray$1(_rules2));
            }
          }
          if (props.required !== void 0) {
            rules2.push({ required: !!props.required });
          }
          return rules2;
        });
        const validateEnabled = computed(() => _rules.value.length > 0);
        const getFilteredRule = (trigger2) => {
          const rules2 = _rules.value;
          return rules2.filter((rule) => {
            if (!rule.trigger || !trigger2)
              return true;
            if (Array.isArray(rule.trigger)) {
              return rule.trigger.includes(trigger2);
            } else {
              return rule.trigger === trigger2;
            }
          }).map(({ trigger: trigger22, ...rule }) => rule);
        };
        const isRequired = computed(() => _rules.value.some((rule) => rule.required === true));
        const shouldShowError = computed(() => {
          var _a2;
          return validateStateDebounced.value === "error" && props.showMessage && ((_a2 = formContext == null ? void 0 : formContext.showMessage) != null ? _a2 : true);
        });
        const currentLabel = computed(() => `${props.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
        const setValidationState = (state) => {
          validateState.value = state;
        };
        const onValidationFailed = (error) => {
          var _a2, _b;
          const { errors, fields } = error;
          if (!errors || !fields) {
            console.error(error);
          }
          setValidationState("error");
          validateMessage.value = errors ? (_b = (_a2 = errors == null ? void 0 : errors[0]) == null ? void 0 : _a2.message) != null ? _b : `${props.prop} is required` : "";
          formContext == null ? void 0 : formContext.emit("validate", props.prop, false, validateMessage.value);
        };
        const onValidationSucceeded = () => {
          setValidationState("success");
          formContext == null ? void 0 : formContext.emit("validate", props.prop, true, "");
        };
        const doValidate = async (rules2) => {
          const modelName = propString.value;
          const validator2 = new Schema({
            [modelName]: rules2
          });
          return validator2.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
            onValidationSucceeded();
            return true;
          }).catch((err) => {
            onValidationFailed(err);
            return Promise.reject(err);
          });
        };
        const validate = async (trigger2, callback) => {
          if (isResettingField) {
            return false;
          }
          const hasCallback = isFunction$4(callback);
          if (!validateEnabled.value) {
            callback == null ? void 0 : callback(false);
            return false;
          }
          const rules2 = getFilteredRule(trigger2);
          if (rules2.length === 0) {
            callback == null ? void 0 : callback(true);
            return true;
          }
          setValidationState("validating");
          return doValidate(rules2).then(() => {
            callback == null ? void 0 : callback(true);
            return true;
          }).catch((err) => {
            const { fields } = err;
            callback == null ? void 0 : callback(false, fields);
            return hasCallback ? false : Promise.reject(fields);
          });
        };
        const clearValidate = () => {
          setValidationState("");
          validateMessage.value = "";
          isResettingField = false;
        };
        const resetField = async () => {
          const model = formContext == null ? void 0 : formContext.model;
          if (!model || !props.prop)
            return;
          const computedValue = getProp(model, props.prop);
          isResettingField = true;
          computedValue.value = clone(initialValue);
          await nextTick();
          clearValidate();
          isResettingField = false;
        };
        const addInputId = (id2) => {
          if (!inputIds.value.includes(id2)) {
            inputIds.value.push(id2);
          }
        };
        const removeInputId = (id2) => {
          inputIds.value = inputIds.value.filter((listId) => listId !== id2);
        };
        watch(() => props.error, (val) => {
          validateMessage.value = val || "";
          setValidationState(val ? "error" : "");
        }, { immediate: true });
        watch(() => props.validateStatus, (val) => setValidationState(val || ""));
        const context = reactive({
          ...toRefs(props),
          $el: formItemRef,
          size: _size,
          validateState,
          labelId,
          inputIds,
          isGroup,
          addInputId,
          removeInputId,
          resetField,
          clearValidate,
          validate
        });
        provide(formItemContextKey, context);
        onMounted(() => {
          if (props.prop) {
            formContext == null ? void 0 : formContext.addField(context);
            initialValue = clone(fieldValue.value);
          }
        });
        onBeforeUnmount(() => {
          formContext == null ? void 0 : formContext.removeField(context);
        });
        expose({
          size: _size,
          validateMessage,
          validateState,
          validate,
          clearValidate,
          resetField
        });
        return (_ctx, _cache) => {
          var _a2;
          return openBlock(), createElementBlock("div", {
            ref_key: "formItemRef",
            ref: formItemRef,
            class: normalizeClass(unref(formItemClasses)),
            role: unref(isGroup) ? "group" : void 0,
            "aria-labelledby": unref(isGroup) ? unref(labelId) : void 0
          }, [
            createVNode(unref(FormLabelWrap), {
              "is-auto-width": unref(labelStyle).width === "auto",
              "update-all": ((_a2 = unref(formContext)) == null ? void 0 : _a2.labelWidth) === "auto"
            }, {
              default: withCtx(() => [
                unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? "label" : "div"), {
                  key: 0,
                  id: unref(labelId),
                  for: unref(labelFor),
                  class: normalizeClass(unref(ns2).e("label")),
                  style: normalizeStyle(unref(labelStyle))
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "label", { label: unref(currentLabel) }, () => [
                      createTextVNode(toDisplayString$1(unref(currentLabel)), 1)
                    ])
                  ]),
                  _: 3
                }, 8, ["id", "for", "class", "style"])) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["is-auto-width", "update-all"]),
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("content")),
              style: normalizeStyle(unref(contentStyle))
            }, [
              renderSlot(_ctx.$slots, "default"),
              createVNode(Transition, {
                name: `${unref(ns2).namespace.value}-zoom-in-top`
              }, {
                default: withCtx(() => [
                  unref(shouldShowError) ? renderSlot(_ctx.$slots, "error", {
                    key: 0,
                    error: validateMessage.value
                  }, () => [
                    createBaseVNode("div", {
                      class: normalizeClass(unref(validateClasses))
                    }, toDisplayString$1(validateMessage.value), 3)
                  ]) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["name"])
            ], 6)
          ], 10, _hoisted_1$x);
        };
      }
    });
    var FormItem = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]);
    const ElForm = withInstall(Form, {
      FormItem
    });
    const ElFormItem = withNoopInstall(FormItem);
    const imageViewerProps = buildProps({
      urlList: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      zIndex: {
        type: Number
      },
      initialIndex: {
        type: Number,
        default: 0
      },
      infinite: {
        type: Boolean,
        default: true
      },
      hideOnClickModal: {
        type: Boolean,
        default: false
      },
      teleported: {
        type: Boolean,
        default: false
      },
      closeOnPressEscape: {
        type: Boolean,
        default: true
      }
    });
    const imageViewerEmits = {
      close: () => true,
      switch: (index2) => isNumber$2(index2)
    };
    const _hoisted_1$w = ["src"];
    const __default__$F = {
      name: "ElImageViewer"
    };
    const _sfc_main$$ = /* @__PURE__ */ defineComponent({
      ...__default__$F,
      props: imageViewerProps,
      emits: imageViewerEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const modes = {
          CONTAIN: {
            name: "contain",
            icon: markRaw(full_screen_default)
          },
          ORIGINAL: {
            name: "original",
            icon: markRaw(scale_to_original_default)
          }
        };
        const mousewheelEventName = isFirefox() ? "DOMMouseScroll" : "mousewheel";
        const { t } = useLocale();
        const ns2 = useNamespace("image-viewer");
        const { nextZIndex } = useZIndex();
        const wrapper = ref();
        const imgRefs = ref([]);
        const scopeEventListener = effectScope();
        const loading = ref(true);
        const activeIndex = ref(props.initialIndex);
        const mode = shallowRef(modes.CONTAIN);
        const transform2 = ref({
          scale: 1,
          deg: 0,
          offsetX: 0,
          offsetY: 0,
          enableTransition: false
        });
        const isSingle = computed(() => {
          const { urlList } = props;
          return urlList.length <= 1;
        });
        const isFirst = computed(() => {
          return activeIndex.value === 0;
        });
        const isLast = computed(() => {
          return activeIndex.value === props.urlList.length - 1;
        });
        const currentImg = computed(() => {
          return props.urlList[activeIndex.value];
        });
        const imgStyle = computed(() => {
          const { scale, deg, offsetX, offsetY, enableTransition } = transform2.value;
          let translateX = offsetX / scale;
          let translateY = offsetY / scale;
          switch (deg % 360) {
            case 90:
            case -270:
              [translateX, translateY] = [translateY, -translateX];
              break;
            case 180:
            case -180:
              [translateX, translateY] = [-translateX, -translateY];
              break;
            case 270:
            case -90:
              [translateX, translateY] = [-translateY, translateX];
              break;
          }
          const style2 = {
            transform: `scale(${scale}) rotate(${deg}deg) translate(${translateX}px, ${translateY}px)`,
            transition: enableTransition ? "transform .3s" : ""
          };
          if (mode.value.name === modes.CONTAIN.name) {
            style2.maxWidth = style2.maxHeight = "100%";
          }
          return style2;
        });
        const computedZIndex = computed(() => {
          return isNumber$2(props.zIndex) ? props.zIndex : nextZIndex();
        });
        function hide() {
          unregisterEventListener();
          emit("close");
        }
        function registerEventListener() {
          const keydownHandler = throttle((e) => {
            switch (e.code) {
              case EVENT_CODE.esc:
                props.closeOnPressEscape && hide();
                break;
              case EVENT_CODE.space:
                toggleMode();
                break;
              case EVENT_CODE.left:
                prev();
                break;
              case EVENT_CODE.up:
                handleActions("zoomIn");
                break;
              case EVENT_CODE.right:
                next();
                break;
              case EVENT_CODE.down:
                handleActions("zoomOut");
                break;
            }
          });
          const mousewheelHandler = throttle((e) => {
            const delta = e.wheelDelta ? e.wheelDelta : -e.detail;
            if (delta > 0) {
              handleActions("zoomIn", {
                zoomRate: 1.2,
                enableTransition: false
              });
            } else {
              handleActions("zoomOut", {
                zoomRate: 1.2,
                enableTransition: false
              });
            }
          });
          scopeEventListener.run(() => {
            useEventListener(document, "keydown", keydownHandler);
            useEventListener(document, mousewheelEventName, mousewheelHandler);
          });
        }
        function unregisterEventListener() {
          scopeEventListener.stop();
        }
        function handleImgLoad() {
          loading.value = false;
        }
        function handleImgError(e) {
          loading.value = false;
          e.target.alt = t("el.image.error");
        }
        function handleMouseDown(e) {
          if (loading.value || e.button !== 0 || !wrapper.value)
            return;
          transform2.value.enableTransition = false;
          const { offsetX, offsetY } = transform2.value;
          const startX = e.pageX;
          const startY = e.pageY;
          const dragHandler = throttle((ev) => {
            transform2.value = {
              ...transform2.value,
              offsetX: offsetX + ev.pageX - startX,
              offsetY: offsetY + ev.pageY - startY
            };
          });
          const removeMousemove = useEventListener(document, "mousemove", dragHandler);
          useEventListener(document, "mouseup", () => {
            removeMousemove();
          });
          e.preventDefault();
        }
        function reset2() {
          transform2.value = {
            scale: 1,
            deg: 0,
            offsetX: 0,
            offsetY: 0,
            enableTransition: false
          };
        }
        function toggleMode() {
          if (loading.value)
            return;
          const modeNames = keysOf(modes);
          const modeValues = Object.values(modes);
          const currentMode = mode.value.name;
          const index2 = modeValues.findIndex((i) => i.name === currentMode);
          const nextIndex = (index2 + 1) % modeNames.length;
          mode.value = modes[modeNames[nextIndex]];
          reset2();
        }
        function setActiveItem(index2) {
          const len = props.urlList.length;
          activeIndex.value = (index2 + len) % len;
        }
        function prev() {
          if (isFirst.value && !props.infinite)
            return;
          setActiveItem(activeIndex.value - 1);
        }
        function next() {
          if (isLast.value && !props.infinite)
            return;
          setActiveItem(activeIndex.value + 1);
        }
        function handleActions(action, options = {}) {
          if (loading.value)
            return;
          const { zoomRate, rotateDeg, enableTransition } = {
            zoomRate: 1.4,
            rotateDeg: 90,
            enableTransition: true,
            ...options
          };
          switch (action) {
            case "zoomOut":
              if (transform2.value.scale > 0.2) {
                transform2.value.scale = Number.parseFloat((transform2.value.scale / zoomRate).toFixed(3));
              }
              break;
            case "zoomIn":
              if (transform2.value.scale < 7) {
                transform2.value.scale = Number.parseFloat((transform2.value.scale * zoomRate).toFixed(3));
              }
              break;
            case "clockwise":
              transform2.value.deg += rotateDeg;
              break;
            case "anticlockwise":
              transform2.value.deg -= rotateDeg;
              break;
          }
          transform2.value.enableTransition = enableTransition;
        }
        watch(currentImg, () => {
          nextTick(() => {
            const $img = imgRefs.value[0];
            if (!($img == null ? void 0 : $img.complete)) {
              loading.value = true;
            }
          });
        });
        watch(activeIndex, (val) => {
          reset2();
          emit("switch", val);
        });
        onMounted(() => {
          var _a2, _b;
          registerEventListener();
          (_b = (_a2 = wrapper.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
        });
        expose({
          setActiveItem
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Teleport, {
            to: "body",
            disabled: !_ctx.teleported
          }, [
            createVNode(Transition, {
              name: "viewer-fade",
              appear: ""
            }, {
              default: withCtx(() => [
                createBaseVNode("div", {
                  ref_key: "wrapper",
                  ref: wrapper,
                  tabindex: -1,
                  class: normalizeClass(unref(ns2).e("wrapper")),
                  style: normalizeStyle({ zIndex: unref(computedZIndex) })
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns2).e("mask")),
                    onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.hideOnClickModal && hide(), ["self"]))
                  }, null, 2),
                  createCommentVNode(" CLOSE "),
                  createBaseVNode("span", {
                    class: normalizeClass([unref(ns2).e("btn"), unref(ns2).e("close")]),
                    onClick: hide
                  }, [
                    createVNode(unref(ElIcon), null, {
                      default: withCtx(() => [
                        createVNode(unref(close_default))
                      ]),
                      _: 1
                    })
                  ], 2),
                  createCommentVNode(" ARROW "),
                  !unref(isSingle) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createBaseVNode("span", {
                      class: normalizeClass([
                        unref(ns2).e("btn"),
                        unref(ns2).e("prev"),
                        unref(ns2).is("disabled", !_ctx.infinite && unref(isFirst))
                      ]),
                      onClick: prev
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(arrow_left_default))
                        ]),
                        _: 1
                      })
                    ], 2),
                    createBaseVNode("span", {
                      class: normalizeClass([
                        unref(ns2).e("btn"),
                        unref(ns2).e("next"),
                        unref(ns2).is("disabled", !_ctx.infinite && unref(isLast))
                      ]),
                      onClick: next
                    }, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(arrow_right_default))
                        ]),
                        _: 1
                      })
                    ], 2)
                  ], 64)) : createCommentVNode("v-if", true),
                  createCommentVNode(" ACTIONS "),
                  createBaseVNode("div", {
                    class: normalizeClass([unref(ns2).e("btn"), unref(ns2).e("actions")])
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(unref(ns2).e("actions__inner"))
                    }, [
                      createVNode(unref(ElIcon), {
                        onClick: _cache[1] || (_cache[1] = ($event) => handleActions("zoomOut"))
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(zoom_out_default))
                        ]),
                        _: 1
                      }),
                      createVNode(unref(ElIcon), {
                        onClick: _cache[2] || (_cache[2] = ($event) => handleActions("zoomIn"))
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(zoom_in_default))
                        ]),
                        _: 1
                      }),
                      createBaseVNode("i", {
                        class: normalizeClass(unref(ns2).e("actions__divider"))
                      }, null, 2),
                      createVNode(unref(ElIcon), { onClick: toggleMode }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(mode).icon)))
                        ]),
                        _: 1
                      }),
                      createBaseVNode("i", {
                        class: normalizeClass(unref(ns2).e("actions__divider"))
                      }, null, 2),
                      createVNode(unref(ElIcon), {
                        onClick: _cache[3] || (_cache[3] = ($event) => handleActions("anticlockwise"))
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(refresh_left_default))
                        ]),
                        _: 1
                      }),
                      createVNode(unref(ElIcon), {
                        onClick: _cache[4] || (_cache[4] = ($event) => handleActions("clockwise"))
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(refresh_right_default))
                        ]),
                        _: 1
                      })
                    ], 2)
                  ], 2),
                  createCommentVNode(" CANVAS "),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns2).e("canvas"))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.urlList, (url, i) => {
                      return withDirectives((openBlock(), createElementBlock("img", {
                        ref_for: true,
                        ref: (el) => imgRefs.value[i] = el,
                        key: url,
                        src: url,
                        style: normalizeStyle(unref(imgStyle)),
                        class: normalizeClass(unref(ns2).e("img")),
                        onLoad: handleImgLoad,
                        onError: handleImgError,
                        onMousedown: handleMouseDown
                      }, null, 46, _hoisted_1$w)), [
                        [vShow, i === activeIndex.value]
                      ]);
                    }), 128))
                  ], 2),
                  renderSlot(_ctx.$slots, "default")
                ], 6)
              ]),
              _: 3
            })
          ], 8, ["disabled"]);
        };
      }
    });
    var ImageViewer = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]);
    const ElImageViewer = withInstall(ImageViewer);
    const imageProps = buildProps({
      hideOnClickModal: {
        type: Boolean,
        default: false
      },
      src: {
        type: String,
        default: ""
      },
      fit: {
        type: String,
        values: ["", "contain", "cover", "fill", "none", "scale-down"],
        default: ""
      },
      loading: {
        type: String,
        values: ["eager", "lazy"]
      },
      lazy: {
        type: Boolean,
        default: false
      },
      scrollContainer: {
        type: definePropType([String, Object])
      },
      previewSrcList: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      previewTeleported: {
        type: Boolean,
        default: false
      },
      zIndex: {
        type: Number
      },
      initialIndex: {
        type: Number,
        default: 0
      },
      infinite: {
        type: Boolean,
        default: true
      },
      closeOnPressEscape: {
        type: Boolean,
        default: true
      }
    });
    const imageEmits = {
      load: (evt) => evt instanceof Event,
      error: (evt) => evt instanceof Event,
      switch: (val) => isNumber$2(val),
      close: () => true,
      show: () => true
    };
    const _hoisted_1$v = ["src", "loading"];
    const _hoisted_2$l = { key: 0 };
    const __default__$E = {
      name: "ElImage",
      inheritAttrs: false
    };
    const _sfc_main$_ = /* @__PURE__ */ defineComponent({
      ...__default__$E,
      props: imageProps,
      emits: imageEmits,
      setup(__props, { emit }) {
        const props = __props;
        let prevOverflow = "";
        const { t } = useLocale();
        const ns2 = useNamespace("image");
        const rawAttrs = useAttrs$1();
        const attrs = useAttrs();
        const imageSrc = ref();
        const hasLoadError = ref(false);
        const isLoading = ref(true);
        const showViewer = ref(false);
        const container = ref();
        const _scrollContainer = ref();
        const supportLoading = isClient && "loading" in HTMLImageElement.prototype;
        let stopScrollListener;
        let stopWheelListener;
        const containerStyle = computed(() => rawAttrs.style);
        const imageStyle = computed(() => {
          const { fit } = props;
          if (isClient && fit) {
            return { objectFit: fit };
          }
          return {};
        });
        const preview = computed(() => {
          const { previewSrcList } = props;
          return Array.isArray(previewSrcList) && previewSrcList.length > 0;
        });
        const imageIndex = computed(() => {
          const { previewSrcList, initialIndex } = props;
          let previewIndex = initialIndex;
          if (initialIndex > previewSrcList.length - 1) {
            previewIndex = 0;
          }
          return previewIndex;
        });
        const isManual = computed(() => {
          if (props.loading === "eager")
            return false;
          return !supportLoading && props.loading === "lazy" || props.lazy;
        });
        const loadImage = () => {
          if (!isClient)
            return;
          isLoading.value = true;
          hasLoadError.value = false;
          imageSrc.value = props.src;
        };
        function handleLoad(event) {
          isLoading.value = false;
          hasLoadError.value = false;
          emit("load", event);
        }
        function handleError2(event) {
          isLoading.value = false;
          hasLoadError.value = true;
          emit("error", event);
        }
        function handleLazyLoad() {
          if (isInContainer(container.value, _scrollContainer.value)) {
            loadImage();
            removeLazyLoadListener();
          }
        }
        const lazyLoadHandler = useThrottleFn(handleLazyLoad, 200);
        async function addLazyLoadListener() {
          var _a2;
          if (!isClient)
            return;
          await nextTick();
          const { scrollContainer } = props;
          if (isElement$1(scrollContainer)) {
            _scrollContainer.value = scrollContainer;
          } else if (isString$3(scrollContainer) && scrollContainer !== "") {
            _scrollContainer.value = (_a2 = document.querySelector(scrollContainer)) != null ? _a2 : void 0;
          } else if (container.value) {
            _scrollContainer.value = getScrollContainer(container.value);
          }
          if (_scrollContainer.value) {
            stopScrollListener = useEventListener(_scrollContainer, "scroll", lazyLoadHandler);
            setTimeout(() => handleLazyLoad(), 100);
          }
        }
        function removeLazyLoadListener() {
          if (!isClient || !_scrollContainer.value || !lazyLoadHandler)
            return;
          stopScrollListener == null ? void 0 : stopScrollListener();
          _scrollContainer.value = void 0;
        }
        function wheelHandler(e) {
          if (!e.ctrlKey)
            return;
          if (e.deltaY < 0) {
            e.preventDefault();
            return false;
          } else if (e.deltaY > 0) {
            e.preventDefault();
            return false;
          }
        }
        function clickHandler() {
          if (!preview.value)
            return;
          stopWheelListener = useEventListener("wheel", wheelHandler, {
            passive: false
          });
          prevOverflow = document.body.style.overflow;
          document.body.style.overflow = "hidden";
          showViewer.value = true;
          emit("show");
        }
        function closeViewer() {
          stopWheelListener == null ? void 0 : stopWheelListener();
          document.body.style.overflow = prevOverflow;
          showViewer.value = false;
          emit("close");
        }
        function switchViewer(val) {
          emit("switch", val);
        }
        watch(() => props.src, () => {
          if (isManual.value) {
            isLoading.value = true;
            hasLoadError.value = false;
            removeLazyLoadListener();
            addLazyLoadListener();
          } else {
            loadImage();
          }
        });
        onMounted(() => {
          if (isManual.value) {
            addLazyLoadListener();
          } else {
            loadImage();
          }
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "container",
            ref: container,
            class: normalizeClass([unref(ns2).b(), _ctx.$attrs.class]),
            style: normalizeStyle(unref(containerStyle))
          }, [
            imageSrc.value !== void 0 && !hasLoadError.value ? (openBlock(), createElementBlock("img", mergeProps({ key: 0 }, unref(attrs), {
              src: imageSrc.value,
              loading: _ctx.loading,
              style: unref(imageStyle),
              class: [
                unref(ns2).e("inner"),
                unref(preview) && unref(ns2).e("preview"),
                isLoading.value && unref(ns2).is("loading")
              ],
              onClick: clickHandler,
              onLoad: handleLoad,
              onError: handleError2
            }), null, 16, _hoisted_1$v)) : createCommentVNode("v-if", true),
            isLoading.value || hasLoadError.value ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(unref(ns2).e("wrapper"))
            }, [
              isLoading.value ? renderSlot(_ctx.$slots, "placeholder", { key: 0 }, () => [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns2).e("placeholder"))
                }, null, 2)
              ]) : hasLoadError.value ? renderSlot(_ctx.$slots, "error", { key: 1 }, () => [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns2).e("error"))
                }, toDisplayString$1(unref(t)("el.image.error")), 3)
              ]) : createCommentVNode("v-if", true)
            ], 2)) : createCommentVNode("v-if", true),
            unref(preview) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
              showViewer.value ? (openBlock(), createBlock(unref(ElImageViewer), {
                key: 0,
                "z-index": _ctx.zIndex,
                "initial-index": unref(imageIndex),
                infinite: _ctx.infinite,
                "url-list": _ctx.previewSrcList,
                "hide-on-click-modal": _ctx.hideOnClickModal,
                teleported: _ctx.previewTeleported,
                "close-on-press-escape": _ctx.closeOnPressEscape,
                onClose: closeViewer,
                onSwitch: switchViewer
              }, {
                default: withCtx(() => [
                  _ctx.$slots.viewer ? (openBlock(), createElementBlock("div", _hoisted_2$l, [
                    renderSlot(_ctx.$slots, "viewer")
                  ])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["z-index", "initial-index", "infinite", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : createCommentVNode("v-if", true)
            ], 64)) : createCommentVNode("v-if", true)
          ], 6);
        };
      }
    });
    var Image = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image/src/image.vue"]]);
    const ElImage = withInstall(Image);
    const inputNumberProps = buildProps({
      id: {
        type: String,
        default: void 0
      },
      step: {
        type: Number,
        default: 1
      },
      stepStrictly: Boolean,
      max: {
        type: Number,
        default: Number.POSITIVE_INFINITY
      },
      min: {
        type: Number,
        default: Number.NEGATIVE_INFINITY
      },
      modelValue: Number,
      readonly: Boolean,
      disabled: Boolean,
      size: useSizeProp,
      controls: {
        type: Boolean,
        default: true
      },
      controlsPosition: {
        type: String,
        default: "",
        values: ["", "right"]
      },
      valueOnClear: {
        type: [String, Number, null],
        validator: (val) => val === null || isNumber$2(val) || ["min", "max"].includes(val),
        default: null
      },
      name: String,
      label: String,
      placeholder: String,
      precision: {
        type: Number,
        validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
      },
      validateEvent: {
        type: Boolean,
        default: true
      }
    });
    const inputNumberEmits = {
      [CHANGE_EVENT]: (prev, cur) => prev !== cur,
      blur: (e) => e instanceof FocusEvent,
      focus: (e) => e instanceof FocusEvent,
      [INPUT_EVENT]: (val) => isNumber$2(val) || isNil(val),
      [UPDATE_MODEL_EVENT]: (val) => isNumber$2(val) || isNil(val)
    };
    const _hoisted_1$u = ["aria-label", "onKeydown"];
    const _hoisted_2$k = ["aria-label", "onKeydown"];
    const __default__$D = {
      name: "ElInputNumber"
    };
    const _sfc_main$Z = /* @__PURE__ */ defineComponent({
      ...__default__$D,
      props: inputNumberProps,
      emits: inputNumberEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const { t } = useLocale();
        const ns2 = useNamespace("input-number");
        const input = ref();
        const data = reactive({
          currentValue: props.modelValue,
          userInput: null
        });
        const { formItem } = useFormItem();
        const minDisabled = computed(() => isNumber$2(props.modelValue) && ensurePrecision(props.modelValue, -1) < props.min);
        const maxDisabled = computed(() => isNumber$2(props.modelValue) && ensurePrecision(props.modelValue) > props.max);
        const numPrecision = computed(() => {
          const stepPrecision = getPrecision(props.step);
          if (!isUndefined$1(props.precision)) {
            if (stepPrecision > props.precision)
              ;
            return props.precision;
          } else {
            return Math.max(getPrecision(props.modelValue), stepPrecision);
          }
        });
        const controlsAtRight = computed(() => {
          return props.controls && props.controlsPosition === "right";
        });
        const inputNumberSize = useSize();
        const inputNumberDisabled = useDisabled$1();
        const displayValue = computed(() => {
          if (data.userInput !== null) {
            return data.userInput;
          }
          let currentValue = data.currentValue;
          if (isNil(currentValue))
            return "";
          if (isNumber$2(currentValue)) {
            if (Number.isNaN(currentValue))
              return "";
            if (!isUndefined$1(props.precision)) {
              currentValue = currentValue.toFixed(props.precision);
            }
          }
          return currentValue;
        });
        const toPrecision = (num, pre) => {
          if (isUndefined$1(pre))
            pre = numPrecision.value;
          if (pre === 0)
            return Math.round(num);
          let snum = String(num);
          const pointPos = snum.indexOf(".");
          if (pointPos === -1)
            return num;
          const nums = snum.replace(".", "").split("");
          const datum = nums[pointPos + pre];
          if (!datum)
            return num;
          const length = snum.length;
          if (snum.charAt(length - 1) === "5") {
            snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
          }
          return Number.parseFloat(Number(snum).toFixed(pre));
        };
        const getPrecision = (value) => {
          if (isNil(value))
            return 0;
          const valueString = value.toString();
          const dotPosition = valueString.indexOf(".");
          let precision = 0;
          if (dotPosition !== -1) {
            precision = valueString.length - dotPosition - 1;
          }
          return precision;
        };
        const ensurePrecision = (val, coefficient = 1) => {
          if (!isNumber$2(val))
            return data.currentValue;
          return toPrecision(val + props.step * coefficient);
        };
        const increase = () => {
          if (props.readonly || inputNumberDisabled.value || maxDisabled.value)
            return;
          const value = props.modelValue || 0;
          const newVal = ensurePrecision(value);
          setCurrentValue(newVal);
        };
        const decrease = () => {
          if (props.readonly || inputNumberDisabled.value || minDisabled.value)
            return;
          const value = props.modelValue || 0;
          const newVal = ensurePrecision(value, -1);
          setCurrentValue(newVal);
        };
        const verifyValue = (value, update) => {
          const { max: max2, min: min2, step, precision, stepStrictly, valueOnClear } = props;
          let newVal = Number(value);
          if (isNil(value) || Number.isNaN(newVal)) {
            return null;
          }
          if (value === "") {
            if (valueOnClear === null) {
              return null;
            }
            newVal = isString$3(valueOnClear) ? { min: min2, max: max2 }[valueOnClear] : valueOnClear;
          }
          if (stepStrictly) {
            newVal = toPrecision(Math.round(newVal / step) * step, precision);
          }
          if (!isUndefined$1(precision)) {
            newVal = toPrecision(newVal, precision);
          }
          if (newVal > max2 || newVal < min2) {
            newVal = newVal > max2 ? max2 : min2;
            update && emit("update:modelValue", newVal);
          }
          return newVal;
        };
        const setCurrentValue = (value) => {
          var _a2;
          const oldVal = data.currentValue;
          const newVal = verifyValue(value);
          if (oldVal === newVal)
            return;
          data.userInput = null;
          emit("update:modelValue", newVal);
          emit("input", newVal);
          emit("change", newVal, oldVal);
          if (props.validateEvent) {
            (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
          }
          data.currentValue = newVal;
        };
        const handleInput = (value) => {
          return data.userInput = value;
        };
        const handleInputChange = (value) => {
          const newVal = value !== "" ? Number(value) : "";
          if (isNumber$2(newVal) && !Number.isNaN(newVal) || value === "") {
            setCurrentValue(newVal);
          }
          data.userInput = null;
        };
        const focus = () => {
          var _a2, _b;
          (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
        };
        const blur = () => {
          var _a2, _b;
          (_b = (_a2 = input.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
        };
        const handleFocus = (event) => {
          emit("focus", event);
        };
        const handleBlur = (event) => {
          var _a2;
          emit("blur", event);
          if (props.validateEvent) {
            (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
          }
        };
        watch(() => props.modelValue, (value) => {
          data.currentValue = verifyValue(value, true);
          data.userInput = null;
        }, { immediate: true });
        onMounted(() => {
          var _a2;
          const { min: min2, max: max2, modelValue } = props;
          const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
          innerInput.setAttribute("role", "spinbutton");
          if (Number.isFinite(max2)) {
            innerInput.setAttribute("aria-valuemax", String(max2));
          } else {
            innerInput.removeAttribute("aria-valuemax");
          }
          if (Number.isFinite(min2)) {
            innerInput.setAttribute("aria-valuemin", String(min2));
          } else {
            innerInput.removeAttribute("aria-valuemin");
          }
          innerInput.setAttribute("aria-valuenow", String(data.currentValue));
          innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
          if (!isNumber$2(modelValue) && modelValue != null) {
            let val = Number(modelValue);
            if (Number.isNaN(val)) {
              val = null;
            }
            emit("update:modelValue", val);
          }
        });
        onUpdated(() => {
          var _a2;
          const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
          innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${data.currentValue}`);
        });
        expose({
          focus,
          blur
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([
              unref(ns2).b(),
              unref(ns2).m(unref(inputNumberSize)),
              unref(ns2).is("disabled", unref(inputNumberDisabled)),
              unref(ns2).is("without-controls", !_ctx.controls),
              unref(ns2).is("controls-right", unref(controlsAtRight))
            ]),
            onDragstart: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["prevent"]))
          }, [
            _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
              key: 0,
              role: "button",
              "aria-label": unref(t)("el.inputNumber.decrease"),
              class: normalizeClass([unref(ns2).e("decrease"), unref(ns2).is("disabled", unref(minDisabled))]),
              onKeydown: withKeys(decrease, ["enter"])
            }, [
              createVNode(unref(ElIcon), null, {
                default: withCtx(() => [
                  unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_down_default), { key: 0 })) : (openBlock(), createBlock(unref(minus_default), { key: 1 }))
                ]),
                _: 1
              })
            ], 42, _hoisted_1$u)), [
              [unref(RepeatClick), decrease]
            ]) : createCommentVNode("v-if", true),
            _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
              key: 1,
              role: "button",
              "aria-label": unref(t)("el.inputNumber.increase"),
              class: normalizeClass([unref(ns2).e("increase"), unref(ns2).is("disabled", unref(maxDisabled))]),
              onKeydown: withKeys(increase, ["enter"])
            }, [
              createVNode(unref(ElIcon), null, {
                default: withCtx(() => [
                  unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_up_default), { key: 0 })) : (openBlock(), createBlock(unref(plus_default), { key: 1 }))
                ]),
                _: 1
              })
            ], 42, _hoisted_2$k)), [
              [unref(RepeatClick), increase]
            ]) : createCommentVNode("v-if", true),
            createVNode(unref(ElInput), {
              id: _ctx.id,
              ref_key: "input",
              ref: input,
              type: "number",
              step: _ctx.step,
              "model-value": unref(displayValue),
              placeholder: _ctx.placeholder,
              readonly: _ctx.readonly,
              disabled: unref(inputNumberDisabled),
              size: unref(inputNumberSize),
              max: _ctx.max,
              min: _ctx.min,
              name: _ctx.name,
              label: _ctx.label,
              "validate-event": false,
              onKeydown: [
                withKeys(withModifiers(increase, ["prevent"]), ["up"]),
                withKeys(withModifiers(decrease, ["prevent"]), ["down"])
              ],
              onBlur: handleBlur,
              onFocus: handleFocus,
              onInput: handleInput,
              onChange: handleInputChange
            }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])
          ], 34);
        };
      }
    });
    var InputNumber = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);
    const ElInputNumber = withInstall(InputNumber);
    const linkProps = buildProps({
      type: {
        type: String,
        values: ["primary", "success", "warning", "info", "danger", "default"],
        default: "default"
      },
      underline: {
        type: Boolean,
        default: true
      },
      disabled: { type: Boolean, default: false },
      href: { type: String, default: "" },
      icon: {
        type: iconPropType
      }
    });
    const linkEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    const _hoisted_1$t = ["href"];
    const __default__$C = {
      name: "ElLink"
    };
    const _sfc_main$Y = /* @__PURE__ */ defineComponent({
      ...__default__$C,
      props: linkProps,
      emits: linkEmits,
      setup(__props, { emit }) {
        const props = __props;
        const ns2 = useNamespace("link");
        function handleClick(event) {
          if (!props.disabled)
            emit("click", event);
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("a", {
            class: normalizeClass([
              unref(ns2).b(),
              unref(ns2).m(_ctx.type),
              unref(ns2).is("disabled", _ctx.disabled),
              unref(ns2).is("underline", _ctx.underline && !_ctx.disabled)
            ]),
            href: _ctx.disabled || !_ctx.href ? void 0 : _ctx.href,
            onClick: handleClick
          }, [
            _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
              ]),
              _: 1
            })) : createCommentVNode("v-if", true),
            _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
              key: 1,
              class: normalizeClass(unref(ns2).e("inner"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)) : createCommentVNode("v-if", true),
            _ctx.$slots.icon ? renderSlot(_ctx.$slots, "icon", { key: 2 }) : createCommentVNode("v-if", true)
          ], 10, _hoisted_1$t);
        };
      }
    });
    var Link = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/link/src/link.vue"]]);
    const ElLink = withInstall(Link);
    class SubMenu$1 {
      constructor(parent, domNode) {
        this.parent = parent;
        this.domNode = domNode;
        this.subIndex = 0;
        this.subIndex = 0;
        this.init();
      }
      init() {
        this.subMenuItems = this.domNode.querySelectorAll("li");
        this.addListeners();
      }
      gotoSubIndex(idx) {
        if (idx === this.subMenuItems.length) {
          idx = 0;
        } else if (idx < 0) {
          idx = this.subMenuItems.length - 1;
        }
        this.subMenuItems[idx].focus();
        this.subIndex = idx;
      }
      addListeners() {
        const parentNode = this.parent.domNode;
        Array.prototype.forEach.call(this.subMenuItems, (el) => {
          el.addEventListener("keydown", (event) => {
            let prevDef = false;
            switch (event.code) {
              case EVENT_CODE.down: {
                this.gotoSubIndex(this.subIndex + 1);
                prevDef = true;
                break;
              }
              case EVENT_CODE.up: {
                this.gotoSubIndex(this.subIndex - 1);
                prevDef = true;
                break;
              }
              case EVENT_CODE.tab: {
                triggerEvent(parentNode, "mouseleave");
                break;
              }
              case EVENT_CODE.enter:
              case EVENT_CODE.space: {
                prevDef = true;
                event.currentTarget.click();
                break;
              }
            }
            if (prevDef) {
              event.preventDefault();
              event.stopPropagation();
            }
            return false;
          });
        });
      }
    }
    class MenuItem$1 {
      constructor(domNode, namespace) {
        this.domNode = domNode;
        this.submenu = null;
        this.submenu = null;
        this.init(namespace);
      }
      init(namespace) {
        this.domNode.setAttribute("tabindex", "0");
        const menuChild = this.domNode.querySelector(`.${namespace}-menu`);
        if (menuChild) {
          this.submenu = new SubMenu$1(this, menuChild);
        }
        this.addListeners();
      }
      addListeners() {
        this.domNode.addEventListener("keydown", (event) => {
          let prevDef = false;
          switch (event.code) {
            case EVENT_CODE.down: {
              triggerEvent(event.currentTarget, "mouseenter");
              this.submenu && this.submenu.gotoSubIndex(0);
              prevDef = true;
              break;
            }
            case EVENT_CODE.up: {
              triggerEvent(event.currentTarget, "mouseenter");
              this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1);
              prevDef = true;
              break;
            }
            case EVENT_CODE.tab: {
              triggerEvent(event.currentTarget, "mouseleave");
              break;
            }
            case EVENT_CODE.enter:
            case EVENT_CODE.space: {
              prevDef = true;
              event.currentTarget.click();
              break;
            }
          }
          if (prevDef) {
            event.preventDefault();
          }
        });
      }
    }
    class Menu$1 {
      constructor(domNode, namespace) {
        this.domNode = domNode;
        this.init(namespace);
      }
      init(namespace) {
        const menuChildren = this.domNode.childNodes;
        Array.from(menuChildren).forEach((child) => {
          if (child.nodeType === 1) {
            new MenuItem$1(child, namespace);
          }
        });
      }
    }
    const _sfc_main$X = defineComponent({
      name: "ElMenuCollapseTransition",
      setup() {
        const ns2 = useNamespace("menu");
        const listeners = {
          onBeforeEnter: (el) => el.style.opacity = "0.2",
          onEnter(el, done) {
            addClass(el, `${ns2.namespace.value}-opacity-transition`);
            el.style.opacity = "1";
            done();
          },
          onAfterEnter(el) {
            removeClass(el, `${ns2.namespace.value}-opacity-transition`);
            el.style.opacity = "";
          },
          onBeforeLeave(el) {
            if (!el.dataset) {
              el.dataset = {};
            }
            if (hasClass(el, ns2.m("collapse"))) {
              removeClass(el, ns2.m("collapse"));
              el.dataset.oldOverflow = el.style.overflow;
              el.dataset.scrollWidth = el.clientWidth.toString();
              addClass(el, ns2.m("collapse"));
            } else {
              addClass(el, ns2.m("collapse"));
              el.dataset.oldOverflow = el.style.overflow;
              el.dataset.scrollWidth = el.clientWidth.toString();
              removeClass(el, ns2.m("collapse"));
            }
            el.style.width = `${el.scrollWidth}px`;
            el.style.overflow = "hidden";
          },
          onLeave(el) {
            addClass(el, "horizontal-collapse-transition");
            el.style.width = `${el.dataset.scrollWidth}px`;
          }
        };
        return {
          listeners
        };
      }
    });
    function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock(Transition, mergeProps({ mode: "out-in" }, _ctx.listeners), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    }
    var ElMenuCollapseTransition = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$g], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-collapse-transition.vue"]]);
    function useMenu(instance, currentIndex) {
      const indexPath = computed(() => {
        let parent = instance.parent;
        const path = [currentIndex.value];
        while (parent.type.name !== "ElMenu") {
          if (parent.props.index) {
            path.unshift(parent.props.index);
          }
          parent = parent.parent;
        }
        return path;
      });
      const parentMenu = computed(() => {
        let parent = instance.parent;
        while (parent && !["ElMenu", "ElSubMenu"].includes(parent.type.name)) {
          parent = parent.parent;
        }
        return parent;
      });
      return {
        parentMenu,
        indexPath
      };
    }
    function useMenuColor(props) {
      const menuBarColor = computed(() => {
        const color = props.backgroundColor;
        if (!color) {
          return "";
        } else {
          return new TinyColor(color).shade(20).toString();
        }
      });
      return menuBarColor;
    }
    const useMenuCssVar = (props, level) => {
      const ns2 = useNamespace("menu");
      return computed(() => {
        return ns2.cssVarBlock({
          "text-color": props.textColor || "",
          "hover-text-color": props.textColor || "",
          "bg-color": props.backgroundColor || "",
          "hover-bg-color": useMenuColor(props).value || "",
          "active-color": props.activeTextColor || "",
          level: `${level}`
        });
      });
    };
    const subMenuProps = buildProps({
      index: {
        type: String,
        required: true
      },
      showTimeout: {
        type: Number,
        default: 300
      },
      hideTimeout: {
        type: Number,
        default: 300
      },
      popperClass: String,
      disabled: Boolean,
      popperAppendToBody: {
        type: Boolean,
        default: void 0
      },
      popperOffset: {
        type: Number,
        default: 6
      },
      expandCloseIcon: {
        type: iconPropType
      },
      expandOpenIcon: {
        type: iconPropType
      },
      collapseCloseIcon: {
        type: iconPropType
      },
      collapseOpenIcon: {
        type: iconPropType
      }
    });
    const COMPONENT_NAME$8 = "ElSubMenu";
    var SubMenu = defineComponent({
      name: COMPONENT_NAME$8,
      props: subMenuProps,
      setup(props, { slots, expose }) {
        const instance = getCurrentInstance();
        const { indexPath, parentMenu } = useMenu(instance, computed(() => props.index));
        const nsMenu = useNamespace("menu");
        const nsSubMenu = useNamespace("sub-menu");
        const rootMenu = inject("rootMenu");
        if (!rootMenu)
          throwError(COMPONENT_NAME$8, "can not inject root menu");
        const subMenu = inject(`subMenu:${parentMenu.value.uid}`);
        if (!subMenu)
          throwError(COMPONENT_NAME$8, "can not inject sub menu");
        const items = ref({});
        const subMenus = ref({});
        let timeout;
        const mouseInChild = ref(false);
        const verticalTitleRef = ref();
        const vPopper = ref(null);
        const currentPlacement = computed(() => mode.value === "horizontal" && isFirstLevel.value ? "bottom-start" : "right-start");
        const subMenuTitleIcon = computed(() => {
          return mode.value === "horizontal" && isFirstLevel.value || mode.value === "vertical" && !rootMenu.props.collapse ? props.expandCloseIcon && props.expandOpenIcon ? opened.value ? props.expandOpenIcon : props.expandCloseIcon : arrow_down_default : props.collapseCloseIcon && props.collapseOpenIcon ? opened.value ? props.collapseOpenIcon : props.collapseCloseIcon : arrow_right_default;
        });
        const isFirstLevel = computed(() => {
          return subMenu.level === 0;
        });
        const appendToBody = computed(() => {
          return props.popperAppendToBody === void 0 ? isFirstLevel.value : Boolean(props.popperAppendToBody);
        });
        const menuTransitionName = computed(() => rootMenu.props.collapse ? `${nsMenu.namespace.value}-zoom-in-left` : `${nsMenu.namespace.value}-zoom-in-top`);
        const fallbackPlacements = computed(() => mode.value === "horizontal" && isFirstLevel.value ? [
          "bottom-start",
          "bottom-end",
          "top-start",
          "top-end",
          "right-start",
          "left-start"
        ] : [
          "right-start",
          "left-start",
          "bottom-start",
          "bottom-end",
          "top-start",
          "top-end"
        ]);
        const opened = computed(() => rootMenu.openedMenus.includes(props.index));
        const active = computed(() => {
          let isActive = false;
          Object.values(items.value).forEach((item2) => {
            if (item2.active) {
              isActive = true;
            }
          });
          Object.values(subMenus.value).forEach((subItem) => {
            if (subItem.active) {
              isActive = true;
            }
          });
          return isActive;
        });
        const backgroundColor = computed(() => rootMenu.props.backgroundColor || "");
        const activeTextColor = computed(() => rootMenu.props.activeTextColor || "");
        const textColor = computed(() => rootMenu.props.textColor || "");
        const mode = computed(() => rootMenu.props.mode);
        const item = reactive({
          index: props.index,
          indexPath,
          active
        });
        const titleStyle = computed(() => {
          if (mode.value !== "horizontal") {
            return {
              color: textColor.value
            };
          }
          return {
            borderBottomColor: active.value ? rootMenu.props.activeTextColor ? activeTextColor.value : "" : "transparent",
            color: active.value ? activeTextColor.value : textColor.value
          };
        });
        const doDestroy = () => {
          var _a2, _b, _c;
          return (_c = (_b = (_a2 = vPopper.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.popperInstanceRef) == null ? void 0 : _c.destroy();
        };
        const handleCollapseToggle = (value) => {
          if (!value) {
            doDestroy();
          }
        };
        const handleClick = () => {
          if (rootMenu.props.menuTrigger === "hover" && rootMenu.props.mode === "horizontal" || rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled)
            return;
          rootMenu.handleSubMenuClick({
            index: props.index,
            indexPath: indexPath.value,
            active: active.value
          });
        };
        const handleMouseenter = (event, showTimeout = props.showTimeout) => {
          var _a2;
          if (event.type === "focus") {
            return;
          }
          if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled) {
            return;
          }
          subMenu.mouseInChild.value = true;
          timeout == null ? void 0 : timeout();
          ({ stop: timeout } = useTimeoutFn(() => {
            rootMenu.openMenu(props.index, indexPath.value);
          }, showTimeout));
          if (appendToBody.value) {
            (_a2 = parentMenu.value.vnode.el) == null ? void 0 : _a2.dispatchEvent(new MouseEvent("mouseenter"));
          }
        };
        const handleMouseleave = (deepDispatch = false) => {
          var _a2, _b;
          if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical") {
            return;
          }
          timeout == null ? void 0 : timeout();
          subMenu.mouseInChild.value = false;
          ({ stop: timeout } = useTimeoutFn(() => !mouseInChild.value && rootMenu.closeMenu(props.index, indexPath.value), props.hideTimeout));
          if (appendToBody.value && deepDispatch) {
            if (((_a2 = instance.parent) == null ? void 0 : _a2.type.name) === "ElSubMenu") {
              (_b = subMenu.handleMouseleave) == null ? void 0 : _b.call(subMenu, true);
            }
          }
        };
        watch(() => rootMenu.props.collapse, (value) => handleCollapseToggle(Boolean(value)));
        {
          const addSubMenu = (item2) => {
            subMenus.value[item2.index] = item2;
          };
          const removeSubMenu = (item2) => {
            delete subMenus.value[item2.index];
          };
          provide(`subMenu:${instance.uid}`, {
            addSubMenu,
            removeSubMenu,
            handleMouseleave,
            mouseInChild,
            level: subMenu.level + 1
          });
        }
        expose({
          opened
        });
        onMounted(() => {
          rootMenu.addSubMenu(item);
          subMenu.addSubMenu(item);
        });
        onBeforeUnmount(() => {
          subMenu.removeSubMenu(item);
          rootMenu.removeSubMenu(item);
        });
        return () => {
          var _a2;
          const titleTag = [
            (_a2 = slots.title) == null ? void 0 : _a2.call(slots),
            h$1(ElIcon, {
              class: nsSubMenu.e("icon-arrow"),
              style: {
                transform: opened.value ? props.expandCloseIcon && props.expandOpenIcon || props.collapseCloseIcon && props.collapseOpenIcon && rootMenu.props.collapse ? "none" : "rotateZ(180deg)" : "none"
              }
            }, {
              default: () => isString$3(subMenuTitleIcon.value) ? h$1(instance.appContext.components[subMenuTitleIcon.value]) : h$1(subMenuTitleIcon.value)
            })
          ];
          const ulStyle = useMenuCssVar(rootMenu.props, subMenu.level + 1);
          const child = rootMenu.isMenuPopup ? h$1(ElTooltip, {
            ref: vPopper,
            visible: opened.value,
            effect: "light",
            pure: true,
            offset: props.popperOffset,
            showArrow: false,
            persistent: true,
            popperClass: props.popperClass,
            placement: currentPlacement.value,
            teleported: appendToBody.value,
            fallbackPlacements: fallbackPlacements.value,
            transition: menuTransitionName.value,
            gpuAcceleration: false
          }, {
            content: () => {
              var _a22;
              return h$1("div", {
                class: [
                  nsMenu.m(mode.value),
                  nsMenu.m("popup-container"),
                  props.popperClass
                ],
                onMouseenter: (evt) => handleMouseenter(evt, 100),
                onMouseleave: () => handleMouseleave(true),
                onFocus: (evt) => handleMouseenter(evt, 100)
              }, [
                h$1("ul", {
                  class: [
                    nsMenu.b(),
                    nsMenu.m("popup"),
                    nsMenu.m(`popup-${currentPlacement.value}`)
                  ],
                  style: ulStyle.value
                }, [(_a22 = slots.default) == null ? void 0 : _a22.call(slots)])
              ]);
            },
            default: () => h$1("div", {
              class: nsSubMenu.e("title"),
              style: [
                titleStyle.value,
                { backgroundColor: backgroundColor.value }
              ],
              onClick: handleClick
            }, titleTag)
          }) : h$1(Fragment, {}, [
            h$1("div", {
              class: nsSubMenu.e("title"),
              style: [
                titleStyle.value,
                { backgroundColor: backgroundColor.value }
              ],
              ref: verticalTitleRef,
              onClick: handleClick
            }, titleTag),
            h$1(_CollapseTransition, {}, {
              default: () => {
                var _a22;
                return withDirectives(h$1("ul", {
                  role: "menu",
                  class: [nsMenu.b(), nsMenu.m("inline")],
                  style: ulStyle.value
                }, [(_a22 = slots.default) == null ? void 0 : _a22.call(slots)]), [[vShow, opened.value]]);
              }
            })
          ]);
          return h$1("li", {
            class: [
              nsSubMenu.b(),
              nsSubMenu.is("active", active.value),
              nsSubMenu.is("opened", opened.value),
              nsSubMenu.is("disabled", props.disabled)
            ],
            role: "menuitem",
            ariaHaspopup: true,
            ariaExpanded: opened.value,
            onMouseenter: handleMouseenter,
            onMouseleave: () => handleMouseleave(true),
            onFocus: handleMouseenter
          }, [child]);
        };
      }
    });
    const menuProps = buildProps({
      mode: {
        type: String,
        values: ["horizontal", "vertical"],
        default: "vertical"
      },
      defaultActive: {
        type: String,
        default: ""
      },
      defaultOpeneds: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      uniqueOpened: Boolean,
      router: Boolean,
      menuTrigger: {
        type: String,
        values: ["hover", "click"],
        default: "hover"
      },
      collapse: Boolean,
      backgroundColor: String,
      textColor: String,
      activeTextColor: String,
      collapseTransition: {
        type: Boolean,
        default: true
      },
      ellipsis: {
        type: Boolean,
        default: true
      }
    });
    const checkIndexPath = (indexPath) => Array.isArray(indexPath) && indexPath.every((path) => isString$3(path));
    const menuEmits = {
      close: (index2, indexPath) => isString$3(index2) && checkIndexPath(indexPath),
      open: (index2, indexPath) => isString$3(index2) && checkIndexPath(indexPath),
      select: (index2, indexPath, item, routerResult) => isString$3(index2) && checkIndexPath(indexPath) && isObject$4(item) && (routerResult === void 0 || routerResult instanceof Promise)
    };
    var Menu = defineComponent({
      name: "ElMenu",
      props: menuProps,
      emits: menuEmits,
      setup(props, { emit, slots, expose }) {
        const instance = getCurrentInstance();
        const router = instance.appContext.config.globalProperties.$router;
        const menu = ref();
        const nsMenu = useNamespace("menu");
        const nsSubMenu = useNamespace("sub-menu");
        const sliceIndex = ref(-1);
        const openedMenus = ref(props.defaultOpeneds && !props.collapse ? props.defaultOpeneds.slice(0) : []);
        const activeIndex = ref(props.defaultActive);
        const items = ref({});
        const subMenus = ref({});
        const isMenuPopup = computed(() => {
          return props.mode === "horizontal" || props.mode === "vertical" && props.collapse;
        });
        const initMenu = () => {
          const activeItem = activeIndex.value && items.value[activeIndex.value];
          if (!activeItem || props.mode === "horizontal" || props.collapse)
            return;
          const indexPath = activeItem.indexPath;
          indexPath.forEach((index2) => {
            const subMenu = subMenus.value[index2];
            subMenu && openMenu(index2, subMenu.indexPath);
          });
        };
        const openMenu = (index2, indexPath) => {
          if (openedMenus.value.includes(index2))
            return;
          if (props.uniqueOpened) {
            openedMenus.value = openedMenus.value.filter((index22) => indexPath.includes(index22));
          }
          openedMenus.value.push(index2);
          emit("open", index2, indexPath);
        };
        const closeMenu = (index2, indexPath) => {
          const i = openedMenus.value.indexOf(index2);
          if (i !== -1) {
            openedMenus.value.splice(i, 1);
          }
          emit("close", index2, indexPath);
        };
        const handleSubMenuClick = ({
          index: index2,
          indexPath
        }) => {
          const isOpened = openedMenus.value.includes(index2);
          if (isOpened) {
            closeMenu(index2, indexPath);
          } else {
            openMenu(index2, indexPath);
          }
        };
        const handleMenuItemClick = (menuItem) => {
          if (props.mode === "horizontal" || props.collapse) {
            openedMenus.value = [];
          }
          const { index: index2, indexPath } = menuItem;
          if (index2 === void 0 || indexPath === void 0)
            return;
          if (props.router && router) {
            const route = menuItem.route || index2;
            const routerResult = router.push(route).then((res) => {
              if (!res)
                activeIndex.value = index2;
              return res;
            });
            emit("select", index2, indexPath, { index: index2, indexPath, route }, routerResult);
          } else {
            activeIndex.value = index2;
            emit("select", index2, indexPath, { index: index2, indexPath });
          }
        };
        const updateActiveIndex = (val) => {
          const itemsInData = items.value;
          const item = itemsInData[val] || activeIndex.value && itemsInData[activeIndex.value] || itemsInData[props.defaultActive];
          if (item) {
            activeIndex.value = item.index;
          } else {
            activeIndex.value = val;
          }
        };
        const calcSliceIndex = () => {
          var _a2, _b;
          if (!menu.value)
            return -1;
          const items2 = Array.from((_b = (_a2 = menu.value) == null ? void 0 : _a2.childNodes) != null ? _b : []).filter((item) => item.nodeName !== "#text" || item.nodeValue);
          const moreItemWidth = 64;
          const paddingLeft = Number.parseInt(getComputedStyle(menu.value).paddingLeft, 10);
          const paddingRight = Number.parseInt(getComputedStyle(menu.value).paddingRight, 10);
          const menuWidth = menu.value.clientWidth - paddingLeft - paddingRight;
          let calcWidth = 0;
          let sliceIndex2 = 0;
          items2.forEach((item, index2) => {
            calcWidth += item.offsetWidth || 0;
            if (calcWidth <= menuWidth - moreItemWidth) {
              sliceIndex2 = index2 + 1;
            }
          });
          return sliceIndex2 === items2.length ? -1 : sliceIndex2;
        };
        const debounce2 = (fn2, wait = 33.34) => {
          let timmer;
          return () => {
            timmer && clearTimeout(timmer);
            timmer = setTimeout(() => {
              fn2();
            }, wait);
          };
        };
        let isFirstTimeRender = true;
        const handleResize = () => {
          const callback = () => {
            sliceIndex.value = -1;
            nextTick(() => {
              sliceIndex.value = calcSliceIndex();
            });
          };
          isFirstTimeRender ? callback() : debounce2(callback)();
          isFirstTimeRender = false;
        };
        watch(() => props.defaultActive, (currentActive) => {
          if (!items.value[currentActive]) {
            activeIndex.value = "";
          }
          updateActiveIndex(currentActive);
        });
        watch(() => props.collapse, (value) => {
          if (value)
            openedMenus.value = [];
        });
        watch(items.value, initMenu);
        let resizeStopper;
        watchEffect(() => {
          if (props.mode === "horizontal" && props.ellipsis)
            resizeStopper = useResizeObserver(menu, handleResize).stop;
          else
            resizeStopper == null ? void 0 : resizeStopper();
        });
        {
          const addSubMenu = (item) => {
            subMenus.value[item.index] = item;
          };
          const removeSubMenu = (item) => {
            delete subMenus.value[item.index];
          };
          const addMenuItem = (item) => {
            items.value[item.index] = item;
          };
          const removeMenuItem = (item) => {
            delete items.value[item.index];
          };
          provide("rootMenu", reactive({
            props,
            openedMenus,
            items,
            subMenus,
            activeIndex,
            isMenuPopup,
            addMenuItem,
            removeMenuItem,
            addSubMenu,
            removeSubMenu,
            openMenu,
            closeMenu,
            handleMenuItemClick,
            handleSubMenuClick
          }));
          provide(`subMenu:${instance.uid}`, {
            addSubMenu,
            removeSubMenu,
            mouseInChild: ref(false),
            level: 0
          });
        }
        onMounted(() => {
          if (props.mode === "horizontal") {
            new Menu$1(instance.vnode.el, nsMenu.namespace.value);
          }
        });
        {
          const open = (index2) => {
            const { indexPath } = subMenus.value[index2];
            indexPath.forEach((i) => openMenu(i, indexPath));
          };
          expose({
            open,
            close: closeMenu,
            handleResize
          });
        }
        const flattedChildren = (children) => {
          const vnodes = Array.isArray(children) ? children : [children];
          const result = [];
          vnodes.forEach((child) => {
            if (Array.isArray(child.children)) {
              result.push(...flattedChildren(child.children));
            } else {
              result.push(child);
            }
          });
          return result;
        };
        return () => {
          var _a2, _b;
          let slot = (_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : [];
          const vShowMore = [];
          if (props.mode === "horizontal" && menu.value) {
            const originalSlot = flattedChildren(slot);
            const slotDefault = sliceIndex.value === -1 ? originalSlot : originalSlot.slice(0, sliceIndex.value);
            const slotMore = sliceIndex.value === -1 ? [] : originalSlot.slice(sliceIndex.value);
            if ((slotMore == null ? void 0 : slotMore.length) && props.ellipsis) {
              slot = slotDefault;
              vShowMore.push(h$1(SubMenu, {
                index: "sub-menu-more",
                class: nsSubMenu.e("hide-arrow")
              }, {
                title: () => h$1(ElIcon, {
                  class: nsSubMenu.e("icon-more")
                }, { default: () => h$1(more_default) }),
                default: () => slotMore
              }));
            }
          }
          const ulStyle = useMenuCssVar(props, 0);
          const vMenu = h$1("ul", {
            key: String(props.collapse),
            role: "menubar",
            ref: menu,
            style: ulStyle.value,
            class: {
              [nsMenu.b()]: true,
              [nsMenu.m(props.mode)]: true,
              [nsMenu.m("collapse")]: props.collapse
            }
          }, [...slot, ...vShowMore]);
          if (props.collapseTransition && props.mode === "vertical") {
            return h$1(ElMenuCollapseTransition, () => vMenu);
          }
          return vMenu;
        };
      }
    });
    const menuItemProps = buildProps({
      index: {
        type: definePropType([String, null]),
        default: null
      },
      route: {
        type: definePropType([String, Object])
      },
      disabled: Boolean
    });
    const menuItemEmits = {
      click: (item) => isString$3(item.index) && Array.isArray(item.indexPath)
    };
    const COMPONENT_NAME$7 = "ElMenuItem";
    const _sfc_main$W = defineComponent({
      name: COMPONENT_NAME$7,
      components: {
        ElTooltip
      },
      props: menuItemProps,
      emits: menuItemEmits,
      setup(props, { emit }) {
        const instance = getCurrentInstance();
        const rootMenu = inject("rootMenu");
        const nsMenu = useNamespace("menu");
        const nsMenuItem = useNamespace("menu-item");
        if (!rootMenu)
          throwError(COMPONENT_NAME$7, "can not inject root menu");
        const { parentMenu, indexPath } = useMenu(instance, toRef(props, "index"));
        const subMenu = inject(`subMenu:${parentMenu.value.uid}`);
        if (!subMenu)
          throwError(COMPONENT_NAME$7, "can not inject sub menu");
        const active = computed(() => props.index === rootMenu.activeIndex);
        const item = reactive({
          index: props.index,
          indexPath,
          active
        });
        const handleClick = () => {
          if (!props.disabled) {
            rootMenu.handleMenuItemClick({
              index: props.index,
              indexPath: indexPath.value,
              route: props.route
            });
            emit("click", item);
          }
        };
        onMounted(() => {
          subMenu.addSubMenu(item);
          rootMenu.addMenuItem(item);
        });
        onBeforeUnmount(() => {
          subMenu.removeSubMenu(item);
          rootMenu.removeMenuItem(item);
        });
        return {
          Effect,
          parentMenu,
          rootMenu,
          active,
          nsMenu,
          nsMenuItem,
          handleClick
        };
      }
    });
    function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_tooltip = resolveComponent("el-tooltip");
      return openBlock(), createElementBlock("li", {
        class: normalizeClass([
          _ctx.nsMenuItem.b(),
          _ctx.nsMenuItem.is("active", _ctx.active),
          _ctx.nsMenuItem.is("disabled", _ctx.disabled)
        ]),
        role: "menuitem",
        tabindex: "-1",
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
      }, [
        _ctx.parentMenu.type.name === "ElMenu" && _ctx.rootMenu.props.collapse && _ctx.$slots.title ? (openBlock(), createBlock(_component_el_tooltip, {
          key: 0,
          effect: _ctx.Effect.DARK,
          placement: "right",
          "fallback-placements": ["left"],
          persistent: ""
        }, {
          content: withCtx(() => [
            renderSlot(_ctx.$slots, "title")
          ]),
          default: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.nsMenu.be("tooltip", "trigger"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)
          ]),
          _: 3
        }, 8, ["effect"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          renderSlot(_ctx.$slots, "default"),
          renderSlot(_ctx.$slots, "title")
        ], 64))
      ], 2);
    }
    var MenuItem = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$f], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item.vue"]]);
    const menuItemGroupProps = {
      title: String
    };
    const COMPONENT_NAME$6 = "ElMenuItemGroup";
    const _sfc_main$V = defineComponent({
      name: COMPONENT_NAME$6,
      props: menuItemGroupProps,
      setup() {
        const ns2 = useNamespace("menu-item-group");
        return {
          ns: ns2
        };
      }
    });
    function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("li", {
        class: normalizeClass(_ctx.ns.b())
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.ns.e("title"))
        }, [
          !_ctx.$slots.title ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString$1(_ctx.title), 1)
          ], 64)) : renderSlot(_ctx.$slots, "title", { key: 1 })
        ], 2),
        createBaseVNode("ul", null, [
          renderSlot(_ctx.$slots, "default")
        ])
      ], 2);
    }
    var MenuItemGroup = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item-group.vue"]]);
    const ElMenu = withInstall(Menu, {
      MenuItem,
      MenuItemGroup,
      SubMenu
    });
    const ElMenuItem = withNoopInstall(MenuItem);
    const ElMenuItemGroup = withNoopInstall(MenuItemGroup);
    withNoopInstall(SubMenu);
    const pageHeaderProps = buildProps({
      icon: {
        type: iconPropType,
        default: () => back_default
      },
      title: String,
      content: {
        type: String,
        default: ""
      }
    });
    const pageHeaderEmits = {
      back: () => true
    };
    const _hoisted_1$s = ["aria-label"];
    const __default__$B = {
      name: "ElPageHeader"
    };
    const _sfc_main$U = /* @__PURE__ */ defineComponent({
      ...__default__$B,
      props: pageHeaderProps,
      emits: pageHeaderEmits,
      setup(__props, { emit }) {
        const slots = useSlots();
        const { t } = useLocale();
        const ns2 = useNamespace("page-header");
        const kls = computed(() => {
          return [
            ns2.b(),
            {
              [ns2.m("has-breadcrumb")]: !!slots.breadcrumb,
              [ns2.m("has-extra")]: !!slots.extra,
              [ns2.is("contentful")]: !!slots.default
            }
          ];
        });
        function handleClick() {
          emit("back");
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(kls))
          }, [
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("breadcrumb"))
            }, [
              renderSlot(_ctx.$slots, "breadcrumb")
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("header"))
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ns2).e("left"))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns2).e("back")),
                  role: "button",
                  tabindex: "0",
                  onClick: handleClick
                }, [
                  _ctx.icon || _ctx.$slots.icon ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    "aria-label": _ctx.title || unref(t)("el.pageHeader.title"),
                    class: normalizeClass(unref(ns2).e("icon"))
                  }, [
                    renderSlot(_ctx.$slots, "icon", {}, () => [
                      _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                        ]),
                        _: 1
                      })) : createCommentVNode("v-if", true)
                    ])
                  ], 10, _hoisted_1$s)) : createCommentVNode("v-if", true),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns2).e("title"))
                  }, [
                    renderSlot(_ctx.$slots, "title", {}, () => [
                      createTextVNode(toDisplayString$1(_ctx.title || unref(t)("el.pageHeader.title")), 1)
                    ])
                  ], 2)
                ], 2),
                createVNode(unref(ElDivider), { direction: "vertical" }),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns2).e("content"))
                }, [
                  renderSlot(_ctx.$slots, "content", {}, () => [
                    createTextVNode(toDisplayString$1(_ctx.content), 1)
                  ])
                ], 2)
              ], 2),
              _ctx.$slots.extra ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns2).e("extra"))
              }, [
                renderSlot(_ctx.$slots, "extra")
              ], 2)) : createCommentVNode("v-if", true)
            ], 2),
            _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(ns2).e("main"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    });
    var PageHeader = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/page-header/src/page-header.vue"]]);
    const ElPageHeader = withInstall(PageHeader);
    const paginationPrevProps = buildProps({
      disabled: Boolean,
      currentPage: {
        type: Number,
        default: 1
      },
      prevText: {
        type: String
      },
      prevIcon: {
        type: iconPropType
      }
    });
    const paginationPrevEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    const _hoisted_1$r = ["disabled", "aria-disabled"];
    const _hoisted_2$j = { key: 0 };
    const __default__$A = {
      name: "ElPaginationPrev"
    };
    const _sfc_main$T = /* @__PURE__ */ defineComponent({
      ...__default__$A,
      props: paginationPrevProps,
      emits: paginationPrevEmits,
      setup(__props) {
        const props = __props;
        const internalDisabled = computed(() => props.disabled || props.currentPage <= 1);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("button", {
            type: "button",
            class: "btn-prev",
            disabled: unref(internalDisabled),
            "aria-disabled": unref(internalDisabled),
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
          }, [
            _ctx.prevText ? (openBlock(), createElementBlock("span", _hoisted_2$j, toDisplayString$1(_ctx.prevText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.prevIcon)))
              ]),
              _: 1
            }))
          ], 8, _hoisted_1$r);
        };
      }
    });
    var Prev = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/prev.vue"]]);
    const paginationNextProps = buildProps({
      disabled: Boolean,
      currentPage: {
        type: Number,
        default: 1
      },
      pageCount: {
        type: Number,
        default: 50
      },
      nextText: {
        type: String
      },
      nextIcon: {
        type: iconPropType
      }
    });
    const _hoisted_1$q = ["disabled", "aria-disabled"];
    const _hoisted_2$i = { key: 0 };
    const __default__$z = {
      name: "ElPaginationNext"
    };
    const _sfc_main$S = /* @__PURE__ */ defineComponent({
      ...__default__$z,
      props: paginationNextProps,
      emits: ["click"],
      setup(__props) {
        const props = __props;
        const internalDisabled = computed(() => props.disabled || props.currentPage === props.pageCount || props.pageCount === 0);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("button", {
            type: "button",
            class: "btn-next",
            disabled: unref(internalDisabled),
            "aria-disabled": unref(internalDisabled),
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
          }, [
            _ctx.nextText ? (openBlock(), createElementBlock("span", _hoisted_2$i, toDisplayString$1(_ctx.nextText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.nextIcon)))
              ]),
              _: 1
            }))
          ], 8, _hoisted_1$q);
        };
      }
    });
    var Next = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/next.vue"]]);
    const selectGroupKey = "ElSelectGroup";
    const selectKey = "ElSelect";
    function useOption$1(props, states) {
      const select = inject(selectKey);
      const selectGroup = inject(selectGroupKey, { disabled: false });
      const isObject2 = computed(() => {
        return Object.prototype.toString.call(props.value).toLowerCase() === "[object object]";
      });
      const itemSelected = computed(() => {
        if (!select.props.multiple) {
          return isEqual2(props.value, select.props.modelValue);
        } else {
          return contains2(select.props.modelValue, props.value);
        }
      });
      const limitReached = computed(() => {
        if (select.props.multiple) {
          const modelValue = select.props.modelValue || [];
          return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
        } else {
          return false;
        }
      });
      const currentLabel = computed(() => {
        return props.label || (isObject2.value ? "" : props.value);
      });
      const currentValue = computed(() => {
        return props.value || props.label || "";
      });
      const isDisabled = computed(() => {
        return props.disabled || states.groupDisabled || limitReached.value;
      });
      const instance = getCurrentInstance();
      const contains2 = (arr = [], target) => {
        if (!isObject2.value) {
          return arr && arr.includes(target);
        } else {
          const valueKey = select.props.valueKey;
          return arr && arr.some((item) => {
            return toRaw(get(item, valueKey)) === get(target, valueKey);
          });
        }
      };
      const isEqual2 = (a2, b2) => {
        if (!isObject2.value) {
          return a2 === b2;
        } else {
          const { valueKey } = select.props;
          return get(a2, valueKey) === get(b2, valueKey);
        }
      };
      const hoverItem = () => {
        if (!props.disabled && !selectGroup.disabled) {
          select.hoverIndex = select.optionsArray.indexOf(instance.proxy);
        }
      };
      watch(() => currentLabel.value, () => {
        if (!props.created && !select.props.remote)
          select.setSelected();
      });
      watch(() => props.value, (val, oldVal) => {
        const { remote, valueKey } = select.props;
        if (!Object.is(val, oldVal)) {
          select.onOptionDestroy(oldVal, instance.proxy);
          select.onOptionCreate(instance.proxy);
        }
        if (!props.created && !remote) {
          if (valueKey && typeof val === "object" && typeof oldVal === "object" && val[valueKey] === oldVal[valueKey]) {
            return;
          }
          select.setSelected();
        }
      });
      watch(() => selectGroup.disabled, () => {
        states.groupDisabled = selectGroup.disabled;
      }, { immediate: true });
      const { queryChange } = toRaw(select);
      watch(queryChange, (changes) => {
        const { query } = unref(changes);
        const regexp2 = new RegExp(escapeStringRegexp(query), "i");
        states.visible = regexp2.test(currentLabel.value) || props.created;
        if (!states.visible) {
          select.filteredOptionsCount--;
        }
      });
      return {
        select,
        currentLabel,
        currentValue,
        itemSelected,
        isDisabled,
        hoverItem
      };
    }
    const _sfc_main$R = defineComponent({
      name: "ElOption",
      componentName: "ElOption",
      props: {
        value: {
          required: true,
          type: [String, Number, Boolean, Object]
        },
        label: [String, Number],
        created: Boolean,
        disabled: {
          type: Boolean,
          default: false
        }
      },
      setup(props) {
        const ns2 = useNamespace("select");
        const states = reactive({
          index: -1,
          groupDisabled: false,
          visible: true,
          hitState: false,
          hover: false
        });
        const { currentLabel, itemSelected, isDisabled, select, hoverItem } = useOption$1(props, states);
        const { visible, hover } = toRefs(states);
        const vm = getCurrentInstance().proxy;
        select.onOptionCreate(vm);
        onBeforeUnmount(() => {
          const key = vm.value;
          const { selected } = select;
          const selectedOptions = select.props.multiple ? selected : [selected];
          const doesSelected = selectedOptions.some((item) => {
            return item.value === vm.value;
          });
          nextTick(() => {
            if (select.cachedOptions.get(key) === vm && !doesSelected) {
              select.cachedOptions.delete(key);
            }
          });
          select.onOptionDestroy(key, vm);
        });
        function selectOptionClick() {
          if (props.disabled !== true && states.groupDisabled !== true) {
            select.handleOptionSelect(vm, true);
          }
        }
        return {
          ns: ns2,
          currentLabel,
          itemSelected,
          isDisabled,
          select,
          hoverItem,
          visible,
          hover,
          selectOptionClick,
          states
        };
      }
    });
    function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("li", {
        class: normalizeClass([
          _ctx.ns.be("dropdown", "item"),
          _ctx.ns.is("disabled", _ctx.isDisabled),
          {
            selected: _ctx.itemSelected,
            hover: _ctx.hover
          }
        ]),
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
        onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("span", null, toDisplayString$1(_ctx.currentLabel), 1)
        ])
      ], 34)), [
        [vShow, _ctx.visible]
      ]);
    }
    var Option = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$d], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
    const _sfc_main$Q = defineComponent({
      name: "ElSelectDropdown",
      componentName: "ElSelectDropdown",
      setup() {
        const select = inject(selectKey);
        const ns2 = useNamespace("select");
        const popperClass = computed(() => select.props.popperClass);
        const isMultiple = computed(() => select.props.multiple);
        const isFitInputWidth = computed(() => select.props.fitInputWidth);
        const minWidth = ref("");
        function updateMinWidth() {
          var _a2;
          minWidth.value = `${(_a2 = select.selectWrapper) == null ? void 0 : _a2.offsetWidth}px`;
        }
        onMounted(() => {
          updateMinWidth();
          useResizeObserver(select.selectWrapper, updateMinWidth);
        });
        return {
          ns: ns2,
          minWidth,
          popperClass,
          isMultiple,
          isFitInputWidth
        };
      }
    });
    function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
        style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 6);
    }
    var ElSelectMenu$1 = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$c], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
    function useSelectStates(props) {
      const { t } = useLocale();
      return reactive({
        options: /* @__PURE__ */ new Map(),
        cachedOptions: /* @__PURE__ */ new Map(),
        createdLabel: null,
        createdSelected: false,
        selected: props.multiple ? [] : {},
        inputLength: 20,
        inputWidth: 0,
        optionsCount: 0,
        filteredOptionsCount: 0,
        visible: false,
        softFocus: false,
        selectedLabel: "",
        hoverIndex: -1,
        query: "",
        previousQuery: null,
        inputHovering: false,
        cachedPlaceHolder: "",
        currentPlaceholder: t("el.select.placeholder"),
        menuVisibleOnFocus: false,
        isOnComposition: false,
        isSilentBlur: false,
        prefixWidth: 11,
        tagInMultiLine: false
      });
    }
    const useSelect$2 = (props, states, ctx) => {
      const { t } = useLocale();
      const ns2 = useNamespace("select");
      const reference = ref(null);
      const input = ref(null);
      const tooltipRef = ref(null);
      const tags = ref(null);
      const selectWrapper = ref(null);
      const scrollbar = ref(null);
      const hoverOption = ref(-1);
      const queryChange = shallowRef({ query: "" });
      const groupQueryChange = shallowRef("");
      const { form, formItem } = useFormItem();
      const readonly2 = computed(() => !props.filterable || props.multiple || !states.visible);
      const selectDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled));
      const showClose = computed(() => {
        const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
        const criteria = props.clearable && !selectDisabled.value && states.inputHovering && hasValue;
        return criteria;
      });
      const iconComponent = computed(() => props.remote && props.filterable ? "" : props.suffixIcon);
      const iconReverse = computed(() => ns2.is("reverse", iconComponent.value && states.visible));
      const debounce$1 = computed(() => props.remote ? 300 : 0);
      const emptyText = computed(() => {
        if (props.loading) {
          return props.loadingText || t("el.select.loading");
        } else {
          if (props.remote && states.query === "" && states.options.size === 0)
            return false;
          if (props.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {
            return props.noMatchText || t("el.select.noMatch");
          }
          if (states.options.size === 0) {
            return props.noDataText || t("el.select.noData");
          }
        }
        return null;
      });
      const optionsArray = computed(() => Array.from(states.options.values()));
      const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
      const showNewOption = computed(() => {
        const hasExistingOption = optionsArray.value.filter((option) => {
          return !option.created;
        }).some((option) => {
          return option.currentLabel === states.query;
        });
        return props.filterable && props.allowCreate && states.query !== "" && !hasExistingOption;
      });
      const selectSize = useSize();
      const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
      const dropMenuVisible = computed({
        get() {
          return states.visible && emptyText.value !== false;
        },
        set(val) {
          states.visible = val;
        }
      });
      watch([() => selectDisabled.value, () => selectSize.value, () => form == null ? void 0 : form.size], () => {
        nextTick(() => {
          resetInputHeight();
        });
      });
      watch(() => props.placeholder, (val) => {
        states.cachedPlaceHolder = states.currentPlaceholder = val;
      });
      watch(() => props.modelValue, (val, oldVal) => {
        if (props.multiple) {
          resetInputHeight();
          if (val && val.length > 0 || input.value && states.query !== "") {
            states.currentPlaceholder = "";
          } else {
            states.currentPlaceholder = states.cachedPlaceHolder;
          }
          if (props.filterable && !props.reserveKeyword) {
            states.query = "";
            handleQueryChange(states.query);
          }
        }
        setSelected();
        if (props.filterable && !props.multiple) {
          states.inputLength = 20;
        }
        if (!isEqual$1(val, oldVal) && props.validateEvent) {
          formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
        }
      }, {
        flush: "post",
        deep: true
      });
      watch(() => states.visible, (val) => {
        var _a2, _b, _c;
        if (!val) {
          input.value && input.value.blur();
          states.query = "";
          states.previousQuery = null;
          states.selectedLabel = "";
          states.inputLength = 20;
          states.menuVisibleOnFocus = false;
          resetHoverIndex();
          nextTick(() => {
            if (input.value && input.value.value === "" && states.selected.length === 0) {
              states.currentPlaceholder = states.cachedPlaceHolder;
            }
          });
          if (!props.multiple) {
            if (states.selected) {
              if (props.filterable && props.allowCreate && states.createdSelected && states.createdLabel) {
                states.selectedLabel = states.createdLabel;
              } else {
                states.selectedLabel = states.selected.currentLabel;
              }
              if (props.filterable)
                states.query = states.selectedLabel;
            }
            if (props.filterable) {
              states.currentPlaceholder = states.cachedPlaceHolder;
            }
          }
        } else {
          (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          if (props.filterable) {
            states.filteredOptionsCount = states.optionsCount;
            states.query = props.remote ? "" : states.selectedLabel;
            if (props.multiple) {
              (_c = input.value) == null ? void 0 : _c.focus();
            } else {
              if (states.selectedLabel) {
                states.currentPlaceholder = `${states.selectedLabel}`;
                states.selectedLabel = "";
              }
            }
            handleQueryChange(states.query);
            if (!props.multiple && !props.remote) {
              queryChange.value.query = "";
              triggerRef(queryChange);
              triggerRef(groupQueryChange);
            }
          }
        }
        ctx.emit("visible-change", val);
      });
      watch(() => states.options.entries(), () => {
        var _a2, _b, _c;
        if (!isClient)
          return;
        (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        if (props.multiple) {
          resetInputHeight();
        }
        const inputs = ((_c = selectWrapper.value) == null ? void 0 : _c.querySelectorAll("input")) || [];
        if (!Array.from(inputs).includes(document.activeElement)) {
          setSelected();
        }
        if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
          checkDefaultFirstOption();
        }
      }, {
        flush: "post"
      });
      watch(() => states.hoverIndex, (val) => {
        if (typeof val === "number" && val > -1) {
          hoverOption.value = optionsArray.value[val] || {};
        }
        optionsArray.value.forEach((option) => {
          option.hover = hoverOption.value === option;
        });
      });
      const resetInputHeight = () => {
        if (props.collapseTags && !props.filterable)
          return;
        nextTick(() => {
          var _a2, _b;
          if (!reference.value)
            return;
          const input2 = reference.value.$el.querySelector("input");
          const _tags = tags.value;
          const sizeInMap = getComponentSize(selectSize.value || (form == null ? void 0 : form.size));
          input2.style.height = `${(states.selected.length === 0 ? sizeInMap : Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)) - 2}px`;
          states.tagInMultiLine = Number.parseFloat(input2.style.height) >= sizeInMap;
          if (states.visible && emptyText.value !== false) {
            (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          }
        });
      };
      const handleQueryChange = async (val) => {
        if (states.previousQuery === val || states.isOnComposition)
          return;
        if (states.previousQuery === null && (typeof props.filterMethod === "function" || typeof props.remoteMethod === "function")) {
          states.previousQuery = val;
          return;
        }
        states.previousQuery = val;
        nextTick(() => {
          var _a2, _b;
          if (states.visible)
            (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        });
        states.hoverIndex = -1;
        if (props.multiple && props.filterable) {
          nextTick(() => {
            const length = input.value.value.length * 15 + 20;
            states.inputLength = props.collapseTags ? Math.min(50, length) : length;
            managePlaceholder();
            resetInputHeight();
          });
        }
        if (props.remote && typeof props.remoteMethod === "function") {
          states.hoverIndex = -1;
          props.remoteMethod(val);
        } else if (typeof props.filterMethod === "function") {
          props.filterMethod(val);
          triggerRef(groupQueryChange);
        } else {
          states.filteredOptionsCount = states.optionsCount;
          queryChange.value.query = val;
          triggerRef(queryChange);
          triggerRef(groupQueryChange);
        }
        if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
          await nextTick();
          checkDefaultFirstOption();
        }
      };
      const managePlaceholder = () => {
        if (states.currentPlaceholder !== "") {
          states.currentPlaceholder = input.value.value ? "" : states.cachedPlaceHolder;
        }
      };
      const checkDefaultFirstOption = () => {
        const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
        const userCreatedOption = optionsInDropdown.find((n) => n.created);
        const firstOriginOption = optionsInDropdown[0];
        states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
      };
      const setSelected = () => {
        var _a2;
        if (!props.multiple) {
          const option = getOption(props.modelValue);
          if ((_a2 = option.props) == null ? void 0 : _a2.created) {
            states.createdLabel = option.props.value;
            states.createdSelected = true;
          } else {
            states.createdSelected = false;
          }
          states.selectedLabel = option.currentLabel;
          states.selected = option;
          if (props.filterable)
            states.query = states.selectedLabel;
          return;
        } else {
          states.selectedLabel = "";
        }
        const result = [];
        if (Array.isArray(props.modelValue)) {
          props.modelValue.forEach((value) => {
            result.push(getOption(value));
          });
        }
        states.selected = result;
        nextTick(() => {
          resetInputHeight();
        });
      };
      const getOption = (value) => {
        let option;
        const isObjectValue = toRawType(value).toLowerCase() === "object";
        const isNull = toRawType(value).toLowerCase() === "null";
        const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
        for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
          const cachedOption = cachedOptionsArray.value[i];
          const isEqualValue = isObjectValue ? get(cachedOption.value, props.valueKey) === get(value, props.valueKey) : cachedOption.value === value;
          if (isEqualValue) {
            option = {
              value,
              currentLabel: cachedOption.currentLabel,
              isDisabled: cachedOption.isDisabled
            };
            break;
          }
        }
        if (option)
          return option;
        const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
        const newOption = {
          value,
          currentLabel: label
        };
        if (props.multiple) {
          newOption.hitState = false;
        }
        return newOption;
      };
      const resetHoverIndex = () => {
        setTimeout(() => {
          const valueKey = props.valueKey;
          if (!props.multiple) {
            states.hoverIndex = optionsArray.value.findIndex((item) => {
              return getValueKey(item) === getValueKey(states.selected);
            });
          } else {
            if (states.selected.length > 0) {
              states.hoverIndex = Math.min.apply(null, states.selected.map((selected) => {
                return optionsArray.value.findIndex((item) => {
                  return get(item, valueKey) === get(selected, valueKey);
                });
              }));
            } else {
              states.hoverIndex = -1;
            }
          }
        }, 300);
      };
      const handleResize = () => {
        var _a2, _b;
        resetInputWidth();
        (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        if (props.multiple && !props.filterable)
          resetInputHeight();
      };
      const resetInputWidth = () => {
        var _a2;
        states.inputWidth = (_a2 = reference.value) == null ? void 0 : _a2.$el.getBoundingClientRect().width;
      };
      const onInputChange = () => {
        if (props.filterable && states.query !== states.selectedLabel) {
          states.query = states.selectedLabel;
          handleQueryChange(states.query);
        }
      };
      const debouncedOnInputChange = debounce(() => {
        onInputChange();
      }, debounce$1.value);
      const debouncedQueryChange = debounce((e) => {
        handleQueryChange(e.target.value);
      }, debounce$1.value);
      const emitChange = (val) => {
        if (!isEqual$1(props.modelValue, val)) {
          ctx.emit(CHANGE_EVENT, val);
        }
      };
      const deletePrevTag = (e) => {
        if (e.target.value.length <= 0 && !toggleLastOptionHitState()) {
          const value = props.modelValue.slice();
          value.pop();
          ctx.emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
        }
        if (e.target.value.length === 1 && props.modelValue.length === 0) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      };
      const deleteTag = (event, tag) => {
        const index2 = states.selected.indexOf(tag);
        if (index2 > -1 && !selectDisabled.value) {
          const value = props.modelValue.slice();
          value.splice(index2, 1);
          ctx.emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          ctx.emit("remove-tag", tag.value);
        }
        event.stopPropagation();
      };
      const deleteSelected = (event) => {
        event.stopPropagation();
        const value = props.multiple ? [] : "";
        if (typeof value !== "string") {
          for (const item of states.selected) {
            if (item.isDisabled)
              value.push(item.value);
          }
        }
        ctx.emit(UPDATE_MODEL_EVENT, value);
        emitChange(value);
        states.visible = false;
        ctx.emit("clear");
      };
      const handleOptionSelect = (option, byClick) => {
        var _a2;
        if (props.multiple) {
          const value = (props.modelValue || []).slice();
          const optionIndex = getValueIndex(value, option.value);
          if (optionIndex > -1) {
            value.splice(optionIndex, 1);
          } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
            value.push(option.value);
          }
          ctx.emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          if (option.created) {
            states.query = "";
            handleQueryChange("");
            states.inputLength = 20;
          }
          if (props.filterable)
            (_a2 = input.value) == null ? void 0 : _a2.focus();
        } else {
          ctx.emit(UPDATE_MODEL_EVENT, option.value);
          emitChange(option.value);
          states.visible = false;
        }
        states.isSilentBlur = byClick;
        setSoftFocus();
        if (states.visible)
          return;
        nextTick(() => {
          scrollToOption(option);
        });
      };
      const getValueIndex = (arr = [], value) => {
        if (!isObject$4(value))
          return arr.indexOf(value);
        const valueKey = props.valueKey;
        let index2 = -1;
        arr.some((item, i) => {
          if (toRaw(get(item, valueKey)) === get(value, valueKey)) {
            index2 = i;
            return true;
          }
          return false;
        });
        return index2;
      };
      const setSoftFocus = () => {
        states.softFocus = true;
        const _input = input.value || reference.value;
        if (_input) {
          _input == null ? void 0 : _input.focus();
        }
      };
      const scrollToOption = (option) => {
        var _a2, _b, _c, _d, _e;
        const targetOption = Array.isArray(option) ? option[0] : option;
        let target = null;
        if (targetOption == null ? void 0 : targetOption.value) {
          const options = optionsArray.value.filter((item) => item.value === targetOption.value);
          if (options.length > 0) {
            target = options[0].$el;
          }
        }
        if (tooltipRef.value && target) {
          const menu = (_d = (_c = (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${ns2.be("dropdown", "wrap")}`);
          if (menu) {
            scrollIntoView(menu, target);
          }
        }
        (_e = scrollbar.value) == null ? void 0 : _e.handleScroll();
      };
      const onOptionCreate = (vm) => {
        states.optionsCount++;
        states.filteredOptionsCount++;
        states.options.set(vm.value, vm);
        states.cachedOptions.set(vm.value, vm);
      };
      const onOptionDestroy = (key, vm) => {
        if (states.options.get(key) === vm) {
          states.optionsCount--;
          states.filteredOptionsCount--;
          states.options.delete(key);
        }
      };
      const resetInputState = (e) => {
        if (e.code !== EVENT_CODE.backspace)
          toggleLastOptionHitState(false);
        states.inputLength = input.value.value.length * 15 + 20;
        resetInputHeight();
      };
      const toggleLastOptionHitState = (hit) => {
        if (!Array.isArray(states.selected))
          return;
        const option = states.selected[states.selected.length - 1];
        if (!option)
          return;
        if (hit === true || hit === false) {
          option.hitState = hit;
          return hit;
        }
        option.hitState = !option.hitState;
        return option.hitState;
      };
      const handleComposition = (event) => {
        const text = event.target.value;
        if (event.type === "compositionend") {
          states.isOnComposition = false;
          nextTick(() => handleQueryChange(text));
        } else {
          const lastCharacter = text[text.length - 1] || "";
          states.isOnComposition = !isKorean(lastCharacter);
        }
      };
      const handleMenuEnter = () => {
        nextTick(() => scrollToOption(states.selected));
      };
      const handleFocus = (event) => {
        if (!states.softFocus) {
          if (props.automaticDropdown || props.filterable) {
            if (props.filterable && !states.visible) {
              states.menuVisibleOnFocus = true;
            }
            states.visible = true;
          }
          ctx.emit("focus", event);
        } else {
          states.softFocus = false;
        }
      };
      const blur = () => {
        var _a2;
        states.visible = false;
        (_a2 = reference.value) == null ? void 0 : _a2.blur();
      };
      const handleBlur = (event) => {
        nextTick(() => {
          if (states.isSilentBlur) {
            states.isSilentBlur = false;
          } else {
            ctx.emit("blur", event);
          }
        });
        states.softFocus = false;
      };
      const handleClearClick = (event) => {
        deleteSelected(event);
      };
      const handleClose = () => {
        states.visible = false;
      };
      const handleKeydownEscape = (event) => {
        if (states.visible) {
          event.preventDefault();
          event.stopPropagation();
          states.visible = false;
        }
      };
      const toggleMenu = () => {
        var _a2;
        if (!selectDisabled.value) {
          if (states.menuVisibleOnFocus) {
            states.menuVisibleOnFocus = false;
          } else {
            states.visible = !states.visible;
          }
          if (states.visible) {
            (_a2 = input.value || reference.value) == null ? void 0 : _a2.focus();
          }
        }
      };
      const selectOption = () => {
        if (!states.visible) {
          toggleMenu();
        } else {
          if (optionsArray.value[states.hoverIndex]) {
            handleOptionSelect(optionsArray.value[states.hoverIndex], void 0);
          }
        }
      };
      const getValueKey = (item) => {
        return isObject$4(item.value) ? get(item.value, props.valueKey) : item.value;
      };
      const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
      const navigateOptions = (direction2) => {
        if (!states.visible) {
          states.visible = true;
          return;
        }
        if (states.options.size === 0 || states.filteredOptionsCount === 0)
          return;
        if (states.isOnComposition)
          return;
        if (!optionsAllDisabled.value) {
          if (direction2 === "next") {
            states.hoverIndex++;
            if (states.hoverIndex === states.options.size) {
              states.hoverIndex = 0;
            }
          } else if (direction2 === "prev") {
            states.hoverIndex--;
            if (states.hoverIndex < 0) {
              states.hoverIndex = states.options.size - 1;
            }
          }
          const option = optionsArray.value[states.hoverIndex];
          if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
            navigateOptions(direction2);
          }
          nextTick(() => scrollToOption(hoverOption.value));
        }
      };
      return {
        optionsArray,
        selectSize,
        handleResize,
        debouncedOnInputChange,
        debouncedQueryChange,
        deletePrevTag,
        deleteTag,
        deleteSelected,
        handleOptionSelect,
        scrollToOption,
        readonly: readonly2,
        resetInputHeight,
        showClose,
        iconComponent,
        iconReverse,
        showNewOption,
        collapseTagSize,
        setSelected,
        managePlaceholder,
        selectDisabled,
        emptyText,
        toggleLastOptionHitState,
        resetInputState,
        handleComposition,
        onOptionCreate,
        onOptionDestroy,
        handleMenuEnter,
        handleFocus,
        blur,
        handleBlur,
        handleClearClick,
        handleClose,
        handleKeydownEscape,
        toggleMenu,
        selectOption,
        getValueKey,
        navigateOptions,
        dropMenuVisible,
        queryChange,
        groupQueryChange,
        reference,
        input,
        tooltipRef,
        tags,
        selectWrapper,
        scrollbar
      };
    };
    const COMPONENT_NAME$5 = "ElSelect";
    const _sfc_main$P = defineComponent({
      name: COMPONENT_NAME$5,
      componentName: COMPONENT_NAME$5,
      components: {
        ElInput,
        ElSelectMenu: ElSelectMenu$1,
        ElOption: Option,
        ElTag,
        ElScrollbar,
        ElTooltip,
        ElIcon
      },
      directives: { ClickOutside },
      props: {
        name: String,
        id: String,
        modelValue: {
          type: [Array, String, Number, Boolean, Object],
          default: void 0
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        automaticDropdown: Boolean,
        size: {
          type: String,
          validator: isValidComponentSize
        },
        effect: {
          type: String,
          default: "light"
        },
        disabled: Boolean,
        clearable: Boolean,
        filterable: Boolean,
        allowCreate: Boolean,
        loading: Boolean,
        popperClass: {
          type: String,
          default: ""
        },
        remote: Boolean,
        loadingText: String,
        noMatchText: String,
        noDataText: String,
        remoteMethod: Function,
        filterMethod: Function,
        multiple: Boolean,
        multipleLimit: {
          type: Number,
          default: 0
        },
        placeholder: {
          type: String
        },
        defaultFirstOption: Boolean,
        reserveKeyword: {
          type: Boolean,
          default: true
        },
        valueKey: {
          type: String,
          default: "value"
        },
        collapseTags: Boolean,
        collapseTagsTooltip: {
          type: Boolean,
          default: false
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        },
        clearIcon: {
          type: [String, Object],
          default: circle_close_default
        },
        fitInputWidth: {
          type: Boolean,
          default: false
        },
        suffixIcon: {
          type: [String, Object],
          default: arrow_up_default
        },
        tagType: { ...tagProps.type, default: "info" },
        validateEvent: {
          type: Boolean,
          default: true
        }
      },
      emits: [
        UPDATE_MODEL_EVENT,
        CHANGE_EVENT,
        "remove-tag",
        "clear",
        "visible-change",
        "focus",
        "blur"
      ],
      setup(props, ctx) {
        const nsSelect = useNamespace("select");
        const nsInput = useNamespace("input");
        const { t } = useLocale();
        const states = useSelectStates(props);
        const {
          optionsArray,
          selectSize,
          readonly: readonly2,
          handleResize,
          collapseTagSize,
          debouncedOnInputChange,
          debouncedQueryChange,
          deletePrevTag,
          deleteTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          setSelected,
          resetInputHeight,
          managePlaceholder,
          showClose,
          selectDisabled,
          iconComponent,
          iconReverse,
          showNewOption,
          emptyText,
          toggleLastOptionHitState,
          resetInputState,
          handleComposition,
          onOptionCreate,
          onOptionDestroy,
          handleMenuEnter,
          handleFocus,
          blur,
          handleBlur,
          handleClearClick,
          handleClose,
          handleKeydownEscape,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          dropMenuVisible,
          reference,
          input,
          tooltipRef,
          tags,
          selectWrapper,
          scrollbar,
          queryChange,
          groupQueryChange
        } = useSelect$2(props, states, ctx);
        const { focus } = useFocus(reference);
        const {
          inputWidth,
          selected,
          inputLength,
          filteredOptionsCount,
          visible,
          softFocus,
          selectedLabel,
          hoverIndex,
          query,
          inputHovering,
          currentPlaceholder,
          menuVisibleOnFocus,
          isOnComposition,
          isSilentBlur,
          options,
          cachedOptions,
          optionsCount,
          prefixWidth,
          tagInMultiLine
        } = toRefs(states);
        const wrapperKls = computed(() => {
          const classList = [nsSelect.b()];
          const _selectSize = unref(selectSize);
          if (_selectSize) {
            classList.push(nsSelect.m(_selectSize));
          }
          if (props.disabled) {
            classList.push(nsSelect.m("disabled"));
          }
          return classList;
        });
        const selectTagsStyle = computed(() => ({
          maxWidth: `${unref(inputWidth) - 32}px`,
          width: "100%"
        }));
        provide(selectKey, reactive({
          props,
          options,
          optionsArray,
          cachedOptions,
          optionsCount,
          filteredOptionsCount,
          hoverIndex,
          handleOptionSelect,
          onOptionCreate,
          onOptionDestroy,
          selectWrapper,
          selected,
          setSelected,
          queryChange,
          groupQueryChange
        }));
        onMounted(() => {
          states.cachedPlaceHolder = currentPlaceholder.value = props.placeholder || t("el.select.placeholder");
          if (props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0) {
            currentPlaceholder.value = "";
          }
          useResizeObserver(selectWrapper, handleResize);
          if (props.remote && props.multiple) {
            resetInputHeight();
          }
          nextTick(() => {
            const refEl = reference.value && reference.value.$el;
            if (!refEl)
              return;
            inputWidth.value = refEl.getBoundingClientRect().width;
            if (ctx.slots.prefix) {
              const prefix = refEl.querySelector(`.${nsInput.e("prefix")}`);
              prefixWidth.value = Math.max(prefix.getBoundingClientRect().width + 5, 30);
            }
          });
          setSelected();
        });
        if (props.multiple && !Array.isArray(props.modelValue)) {
          ctx.emit(UPDATE_MODEL_EVENT, []);
        }
        if (!props.multiple && Array.isArray(props.modelValue)) {
          ctx.emit(UPDATE_MODEL_EVENT, "");
        }
        const popperPaneRef = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
        });
        return {
          tagInMultiLine,
          prefixWidth,
          selectSize,
          readonly: readonly2,
          handleResize,
          collapseTagSize,
          debouncedOnInputChange,
          debouncedQueryChange,
          deletePrevTag,
          deleteTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          inputWidth,
          selected,
          inputLength,
          filteredOptionsCount,
          visible,
          softFocus,
          selectedLabel,
          hoverIndex,
          query,
          inputHovering,
          currentPlaceholder,
          menuVisibleOnFocus,
          isOnComposition,
          isSilentBlur,
          options,
          resetInputHeight,
          managePlaceholder,
          showClose,
          selectDisabled,
          iconComponent,
          iconReverse,
          showNewOption,
          emptyText,
          toggleLastOptionHitState,
          resetInputState,
          handleComposition,
          handleMenuEnter,
          handleFocus,
          blur,
          handleBlur,
          handleClearClick,
          handleClose,
          handleKeydownEscape,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          dropMenuVisible,
          focus,
          reference,
          input,
          tooltipRef,
          popperPaneRef,
          tags,
          selectWrapper,
          scrollbar,
          wrapperKls,
          selectTagsStyle,
          nsSelect
        };
      }
    });
    const _hoisted_1$p = { class: "select-trigger" };
    const _hoisted_2$h = ["disabled", "autocomplete"];
    const _hoisted_3$a = { style: { "height": "100%", "display": "flex", "justify-content": "center", "align-items": "center" } };
    function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_tag = resolveComponent("el-tag");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_input = resolveComponent("el-input");
      const _component_el_option = resolveComponent("el-option");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_el_select_menu = resolveComponent("el-select-menu");
      const _directive_click_outside = resolveDirective("click-outside");
      return withDirectives((openBlock(), createElementBlock("div", {
        ref: "selectWrapper",
        class: normalizeClass(_ctx.wrapperKls),
        onClick: _cache[22] || (_cache[22] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
      }, [
        createVNode(_component_el_tooltip, {
          ref: "tooltipRef",
          visible: _ctx.dropMenuVisible,
          placement: "bottom-start",
          teleported: _ctx.teleported,
          "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
          "fallback-placements": ["bottom-start", "top-start", "right", "left"],
          effect: _ctx.effect,
          pure: "",
          trigger: "click",
          transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
          "stop-popper-mouse-event": false,
          "gpu-acceleration": false,
          persistent: _ctx.persistent,
          onShow: _ctx.handleMenuEnter
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_1$p, [
              _ctx.multiple ? (openBlock(), createElementBlock("div", {
                key: 0,
                ref: "tags",
                class: normalizeClass(_ctx.nsSelect.e("tags")),
                style: normalizeStyle(_ctx.selectTagsStyle)
              }, [
                _ctx.collapseTags && _ctx.selected.length ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: normalizeClass([
                    _ctx.nsSelect.b("tags-wrapper"),
                    { "has-prefix": _ctx.prefixWidth && _ctx.selected.length }
                  ])
                }, [
                  createVNode(_component_el_tag, {
                    closable: !_ctx.selectDisabled && !_ctx.selected[0].isDisabled,
                    size: _ctx.collapseTagSize,
                    hit: _ctx.selected[0].hitState,
                    type: _ctx.tagType,
                    "disable-transitions": "",
                    onClose: _cache[0] || (_cache[0] = ($event) => _ctx.deleteTag($event, _ctx.selected[0]))
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("span", {
                        class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                        style: normalizeStyle({ maxWidth: _ctx.inputWidth - 123 + "px" })
                      }, toDisplayString$1(_ctx.selected[0].currentLabel), 7)
                    ]),
                    _: 1
                  }, 8, ["closable", "size", "hit", "type"]),
                  _ctx.selected.length > 1 ? (openBlock(), createBlock(_component_el_tag, {
                    key: 0,
                    closable: false,
                    size: _ctx.collapseTagSize,
                    type: _ctx.tagType,
                    "disable-transitions": ""
                  }, {
                    default: withCtx(() => [
                      _ctx.collapseTagsTooltip ? (openBlock(), createBlock(_component_el_tooltip, {
                        key: 0,
                        disabled: _ctx.dropMenuVisible,
                        "fallback-placements": ["bottom", "top", "right", "left"],
                        effect: _ctx.effect,
                        placement: "bottom",
                        teleported: _ctx.teleported
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("span", {
                            class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                          }, "+ " + toDisplayString$1(_ctx.selected.length - 1), 3)
                        ]),
                        content: withCtx(() => [
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.nsSelect.e("collapse-tags"))
                          }, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selected.slice(1), (item, idx) => {
                              return openBlock(), createElementBlock("div", {
                                key: idx,
                                class: normalizeClass(_ctx.nsSelect.e("collapse-tag"))
                              }, [
                                (openBlock(), createBlock(_component_el_tag, {
                                  key: _ctx.getValueKey(item),
                                  class: "in-tooltip",
                                  closable: !_ctx.selectDisabled && !item.isDisabled,
                                  size: _ctx.collapseTagSize,
                                  hit: item.hitState,
                                  type: _ctx.tagType,
                                  "disable-transitions": "",
                                  style: { margin: "2px" },
                                  onClose: ($event) => _ctx.deleteTag($event, item)
                                }, {
                                  default: withCtx(() => [
                                    createBaseVNode("span", {
                                      class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                                      style: normalizeStyle({
                                        maxWidth: _ctx.inputWidth - 75 + "px"
                                      })
                                    }, toDisplayString$1(item.currentLabel), 7)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "hit", "type", "onClose"]))
                              ], 2);
                            }), 128))
                          ], 2)
                        ]),
                        _: 1
                      }, 8, ["disabled", "effect", "teleported"])) : (openBlock(), createElementBlock("span", {
                        key: 1,
                        class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                      }, "+ " + toDisplayString$1(_ctx.selected.length - 1), 3))
                    ]),
                    _: 1
                  }, 8, ["size", "type"])) : createCommentVNode("v-if", true)
                ], 2)) : createCommentVNode("v-if", true),
                createCommentVNode(" <div> "),
                !_ctx.collapseTags ? (openBlock(), createBlock(Transition, {
                  key: 1,
                  onAfterLeave: _ctx.resetInputHeight
                }, {
                  default: withCtx(() => [
                    createBaseVNode("span", {
                      class: normalizeClass([
                        _ctx.nsSelect.b("tags-wrapper"),
                        { "has-prefix": _ctx.prefixWidth && _ctx.selected.length }
                      ])
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selected, (item) => {
                        return openBlock(), createBlock(_component_el_tag, {
                          key: _ctx.getValueKey(item),
                          closable: !_ctx.selectDisabled && !item.isDisabled,
                          size: _ctx.collapseTagSize,
                          hit: item.hitState,
                          type: _ctx.tagType,
                          "disable-transitions": "",
                          onClose: ($event) => _ctx.deleteTag($event, item)
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", {
                              class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                              style: normalizeStyle({ maxWidth: _ctx.inputWidth - 75 + "px" })
                            }, toDisplayString$1(item.currentLabel), 7)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "hit", "type", "onClose"]);
                      }), 128))
                    ], 2)
                  ]),
                  _: 1
                }, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
                createCommentVNode(" </div> "),
                _ctx.filterable ? withDirectives((openBlock(), createElementBlock("input", {
                  key: 2,
                  ref: "input",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.query = $event),
                  type: "text",
                  class: normalizeClass([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
                  disabled: _ctx.selectDisabled,
                  autocomplete: _ctx.autocomplete,
                  style: normalizeStyle({
                    marginLeft: _ctx.prefixWidth && !_ctx.selected.length || _ctx.tagInMultiLine ? `${_ctx.prefixWidth}px` : "",
                    flexGrow: 1,
                    width: `${_ctx.inputLength / (_ctx.inputWidth - 32)}%`,
                    maxWidth: `${_ctx.inputWidth - 42}px`
                  }),
                  onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                  onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                  onKeyup: _cache[4] || (_cache[4] = (...args) => _ctx.managePlaceholder && _ctx.managePlaceholder(...args)),
                  onKeydown: [
                    _cache[5] || (_cache[5] = (...args) => _ctx.resetInputState && _ctx.resetInputState(...args)),
                    _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["prevent"]), ["down"])),
                    _cache[7] || (_cache[7] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["prevent"]), ["up"])),
                    _cache[8] || (_cache[8] = withKeys((...args) => _ctx.handleKeydownEscape && _ctx.handleKeydownEscape(...args), ["esc"])),
                    _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                    _cache[10] || (_cache[10] = withKeys((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["delete"])),
                    _cache[11] || (_cache[11] = withKeys(($event) => _ctx.visible = false, ["tab"]))
                  ],
                  onCompositionstart: _cache[12] || (_cache[12] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                  onCompositionupdate: _cache[13] || (_cache[13] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                  onCompositionend: _cache[14] || (_cache[14] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                  onInput: _cache[15] || (_cache[15] = (...args) => _ctx.debouncedQueryChange && _ctx.debouncedQueryChange(...args))
                }, null, 46, _hoisted_2$h)), [
                  [vModelText, _ctx.query]
                ]) : createCommentVNode("v-if", true)
              ], 6)) : createCommentVNode("v-if", true),
              createVNode(_component_el_input, {
                id: _ctx.id,
                ref: "reference",
                modelValue: _ctx.selectedLabel,
                "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => _ctx.selectedLabel = $event),
                type: "text",
                placeholder: _ctx.currentPlaceholder,
                name: _ctx.name,
                autocomplete: _ctx.autocomplete,
                size: _ctx.selectSize,
                disabled: _ctx.selectDisabled,
                readonly: _ctx.readonly,
                "validate-event": false,
                class: normalizeClass([_ctx.nsSelect.is("focus", _ctx.visible)]),
                tabindex: _ctx.multiple && _ctx.filterable ? -1 : void 0,
                onFocus: _ctx.handleFocus,
                onBlur: _ctx.handleBlur,
                onInput: _ctx.debouncedOnInputChange,
                onPaste: _ctx.debouncedOnInputChange,
                onCompositionstart: _ctx.handleComposition,
                onCompositionupdate: _ctx.handleComposition,
                onCompositionend: _ctx.handleComposition,
                onKeydown: [
                  _cache[17] || (_cache[17] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                  _cache[18] || (_cache[18] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                  withKeys(withModifiers(_ctx.selectOption, ["stop", "prevent"]), ["enter"]),
                  withKeys(_ctx.handleKeydownEscape, ["esc"]),
                  _cache[19] || (_cache[19] = withKeys(($event) => _ctx.visible = false, ["tab"]))
                ],
                onMouseenter: _cache[20] || (_cache[20] = ($event) => _ctx.inputHovering = true),
                onMouseleave: _cache[21] || (_cache[21] = ($event) => _ctx.inputHovering = false)
              }, createSlots({
                suffix: withCtx(() => [
                  _ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
                    key: 0,
                    class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 1,
                    class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                    onClick: _ctx.handleClearClick
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ]),
                _: 2
              }, [
                _ctx.$slots.prefix ? {
                  name: "prefix",
                  fn: withCtx(() => [
                    createBaseVNode("div", _hoisted_3$a, [
                      renderSlot(_ctx.$slots, "prefix")
                    ])
                  ])
                } : void 0
              ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
            ])
          ]),
          content: withCtx(() => [
            createVNode(_component_el_select_menu, null, {
              default: withCtx(() => [
                withDirectives(createVNode(_component_el_scrollbar, {
                  ref: "scrollbar",
                  tag: "ul",
                  "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                  "view-class": _ctx.nsSelect.be("dropdown", "list"),
                  class: normalizeClass([
                    _ctx.nsSelect.is("empty", !_ctx.allowCreate && Boolean(_ctx.query) && _ctx.filteredOptionsCount === 0)
                  ])
                }, {
                  default: withCtx(() => [
                    _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                      key: 0,
                      value: _ctx.query,
                      created: true
                    }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["wrap-class", "view-class", "class"]), [
                  [vShow, _ctx.options.size > 0 && !_ctx.loading]
                ]),
                _ctx.emptyText && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && _ctx.options.size === 0) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  _ctx.$slots.empty ? renderSlot(_ctx.$slots, "empty", { key: 0 }) : (openBlock(), createElementBlock("p", {
                    key: 1,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                  }, toDisplayString$1(_ctx.emptyText), 3))
                ], 64)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 8, ["visible", "teleported", "popper-class", "effect", "transition", "persistent", "onShow"])
      ], 2)), [
        [_directive_click_outside, _ctx.handleClose, _ctx.popperPaneRef]
      ]);
    }
    var Select$1 = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$b], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
    const _sfc_main$O = defineComponent({
      name: "ElOptionGroup",
      componentName: "ElOptionGroup",
      props: {
        label: String,
        disabled: {
          type: Boolean,
          default: false
        }
      },
      setup(props) {
        const ns2 = useNamespace("select");
        const visible = ref(true);
        const instance = getCurrentInstance();
        const children = ref([]);
        provide(selectGroupKey, reactive({
          ...toRefs(props)
        }));
        const select = inject(selectKey);
        onMounted(() => {
          children.value = flattedChildren(instance.subTree);
        });
        const flattedChildren = (node) => {
          const children2 = [];
          if (Array.isArray(node.children)) {
            node.children.forEach((child) => {
              var _a2;
              if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
                children2.push(child.component.proxy);
              } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
                children2.push(...flattedChildren(child));
              }
            });
          }
          return children2;
        };
        const { groupQueryChange } = toRaw(select);
        watch(groupQueryChange, () => {
          visible.value = children.value.some((option) => option.visible === true);
        });
        return {
          visible,
          ns: ns2
        };
      }
    });
    function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("ul", {
        class: normalizeClass(_ctx.ns.be("group", "wrap"))
      }, [
        createBaseVNode("li", {
          class: normalizeClass(_ctx.ns.be("group", "title"))
        }, toDisplayString$1(_ctx.label), 3),
        createBaseVNode("li", null, [
          createBaseVNode("ul", {
            class: normalizeClass(_ctx.ns.b("group"))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2)
        ])
      ], 2)), [
        [vShow, _ctx.visible]
      ]);
    }
    var OptionGroup = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$a], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
    const ElSelect = withInstall(Select$1, {
      Option,
      OptionGroup
    });
    const ElOption = withNoopInstall(Option);
    const ElOptionGroup = withNoopInstall(OptionGroup);
    const usePagination = () => inject(elPaginationKey, {});
    const paginationSizesProps = buildProps({
      pageSize: {
        type: Number,
        required: true
      },
      pageSizes: {
        type: definePropType(Array),
        default: () => mutable([10, 20, 30, 40, 50, 100])
      },
      popperClass: {
        type: String
      },
      disabled: Boolean,
      size: {
        type: String,
        default: "default"
      }
    });
    const __default__$y = {
      name: "ElPaginationSizes"
    };
    const _sfc_main$N = /* @__PURE__ */ defineComponent({
      ...__default__$y,
      props: paginationSizesProps,
      emits: ["page-size-change"],
      setup(__props, { emit }) {
        const props = __props;
        const { t } = useLocale();
        const ns2 = useNamespace("pagination");
        const pagination = usePagination();
        const innerPageSize = ref(props.pageSize);
        watch(() => props.pageSizes, (newVal, oldVal) => {
          if (isEqual$1(newVal, oldVal))
            return;
          if (Array.isArray(newVal)) {
            const pageSize = newVal.includes(props.pageSize) ? props.pageSize : props.pageSizes[0];
            emit("page-size-change", pageSize);
          }
        });
        watch(() => props.pageSize, (newVal) => {
          innerPageSize.value = newVal;
        });
        const innerPageSizes = computed(() => props.pageSizes);
        function handleChange(val) {
          var _a2;
          if (val !== innerPageSize.value) {
            innerPageSize.value = val;
            (_a2 = pagination.handleSizeChange) == null ? void 0 : _a2.call(pagination, Number(val));
          }
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            class: normalizeClass(unref(ns2).e("sizes"))
          }, [
            createVNode(unref(ElSelect), {
              "model-value": innerPageSize.value,
              disabled: _ctx.disabled,
              "popper-class": _ctx.popperClass,
              size: _ctx.size,
              "validate-event": false,
              onChange: handleChange
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(innerPageSizes), (item) => {
                  return openBlock(), createBlock(unref(ElOption), {
                    key: item,
                    value: item,
                    label: item + unref(t)("el.pagination.pagesize")
                  }, null, 8, ["value", "label"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["model-value", "disabled", "popper-class", "size"])
          ], 2);
        };
      }
    });
    var Sizes = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/sizes.vue"]]);
    const _hoisted_1$o = ["disabled"];
    const __default__$x = {
      name: "ElPaginationJumper"
    };
    const _sfc_main$M = /* @__PURE__ */ defineComponent({
      ...__default__$x,
      setup(__props) {
        const { t } = useLocale();
        const ns2 = useNamespace("pagination");
        const { pageCount, disabled, currentPage, changeEvent } = usePagination();
        const userInput = ref();
        const innerValue = computed(() => {
          var _a2;
          return (_a2 = userInput.value) != null ? _a2 : currentPage == null ? void 0 : currentPage.value;
        });
        function handleInput(val) {
          userInput.value = +val;
        }
        function handleChange(val) {
          val = Math.trunc(+val);
          changeEvent == null ? void 0 : changeEvent(+val);
          userInput.value = void 0;
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            class: normalizeClass(unref(ns2).e("jump")),
            disabled: unref(disabled)
          }, [
            createTextVNode(toDisplayString$1(unref(t)("el.pagination.goto")) + " ", 1),
            createVNode(unref(ElInput), {
              size: "small",
              class: normalizeClass([unref(ns2).e("editor"), unref(ns2).is("in-pagination")]),
              min: 1,
              max: unref(pageCount),
              disabled: unref(disabled),
              "model-value": unref(innerValue),
              "validate-event": false,
              type: "number",
              "onUpdate:modelValue": handleInput,
              onChange: handleChange
            }, null, 8, ["class", "max", "disabled", "model-value"]),
            createTextVNode(" " + toDisplayString$1(unref(t)("el.pagination.pageClassifier")), 1)
          ], 10, _hoisted_1$o);
        };
      }
    });
    var Jumper = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/jumper.vue"]]);
    const paginationTotalProps = buildProps({
      total: {
        type: Number,
        default: 1e3
      }
    });
    const _hoisted_1$n = ["disabled"];
    const __default__$w = {
      name: "ElPaginationTotal"
    };
    const _sfc_main$L = /* @__PURE__ */ defineComponent({
      ...__default__$w,
      props: paginationTotalProps,
      setup(__props) {
        const { t } = useLocale();
        const ns2 = useNamespace("pagination");
        const { disabled } = usePagination();
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            class: normalizeClass(unref(ns2).e("total")),
            disabled: unref(disabled)
          }, toDisplayString$1(unref(t)("el.pagination.total", {
            total: _ctx.total
          })), 11, _hoisted_1$n);
        };
      }
    });
    var Total = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/total.vue"]]);
    const paginationPagerProps = buildProps({
      currentPage: {
        type: Number,
        default: 1
      },
      pageCount: {
        type: Number,
        required: true
      },
      pagerCount: {
        type: Number,
        default: 7
      },
      disabled: Boolean
    });
    const _hoisted_1$m = ["onKeyup"];
    const _hoisted_2$g = ["aria-current", "tabindex"];
    const _hoisted_3$9 = ["tabindex"];
    const _hoisted_4$7 = ["aria-current", "tabindex"];
    const _hoisted_5$6 = ["tabindex"];
    const _hoisted_6$2 = ["aria-current", "tabindex"];
    const __default__$v = {
      name: "ElPaginationPager"
    };
    const _sfc_main$K = /* @__PURE__ */ defineComponent({
      ...__default__$v,
      props: paginationPagerProps,
      emits: ["change"],
      setup(__props, { emit }) {
        const props = __props;
        const nsPager = useNamespace("pager");
        const nsIcon = useNamespace("icon");
        const showPrevMore = ref(false);
        const showNextMore = ref(false);
        const quickPrevHover = ref(false);
        const quickNextHover = ref(false);
        const quickPrevFocus = ref(false);
        const quickNextFocus = ref(false);
        const pagers = computed(() => {
          const pagerCount = props.pagerCount;
          const halfPagerCount = (pagerCount - 1) / 2;
          const currentPage = Number(props.currentPage);
          const pageCount = Number(props.pageCount);
          let showPrevMore2 = false;
          let showNextMore2 = false;
          if (pageCount > pagerCount) {
            if (currentPage > pagerCount - halfPagerCount) {
              showPrevMore2 = true;
            }
            if (currentPage < pageCount - halfPagerCount) {
              showNextMore2 = true;
            }
          }
          const array2 = [];
          if (showPrevMore2 && !showNextMore2) {
            const startPage = pageCount - (pagerCount - 2);
            for (let i = startPage; i < pageCount; i++) {
              array2.push(i);
            }
          } else if (!showPrevMore2 && showNextMore2) {
            for (let i = 2; i < pagerCount; i++) {
              array2.push(i);
            }
          } else if (showPrevMore2 && showNextMore2) {
            const offset2 = Math.floor(pagerCount / 2) - 1;
            for (let i = currentPage - offset2; i <= currentPage + offset2; i++) {
              array2.push(i);
            }
          } else {
            for (let i = 2; i < pageCount; i++) {
              array2.push(i);
            }
          }
          return array2;
        });
        const tabindex = computed(() => props.disabled ? -1 : 0);
        watchEffect(() => {
          const halfPagerCount = (props.pagerCount - 1) / 2;
          showPrevMore.value = false;
          showNextMore.value = false;
          if (props.pageCount > props.pagerCount) {
            if (props.currentPage > props.pagerCount - halfPagerCount) {
              showPrevMore.value = true;
            }
            if (props.currentPage < props.pageCount - halfPagerCount) {
              showNextMore.value = true;
            }
          }
        });
        function onMouseEnter(forward = false) {
          if (props.disabled)
            return;
          if (forward) {
            quickPrevHover.value = true;
          } else {
            quickNextHover.value = true;
          }
        }
        function onFocus(forward = false) {
          if (forward) {
            quickPrevFocus.value = true;
          } else {
            quickNextFocus.value = true;
          }
        }
        function onEnter(e) {
          const target = e.target;
          if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("number")) {
            const newPage = Number(target.textContent);
            if (newPage !== props.currentPage) {
              emit("change", newPage);
            }
          } else if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("more")) {
            onPagerClick(e);
          }
        }
        function onPagerClick(event) {
          const target = event.target;
          if (target.tagName.toLowerCase() === "ul" || props.disabled) {
            return;
          }
          let newPage = Number(target.textContent);
          const pageCount = props.pageCount;
          const currentPage = props.currentPage;
          const pagerCountOffset = props.pagerCount - 2;
          if (target.className.includes("more")) {
            if (target.className.includes("quickprev")) {
              newPage = currentPage - pagerCountOffset;
            } else if (target.className.includes("quicknext")) {
              newPage = currentPage + pagerCountOffset;
            }
          }
          if (!Number.isNaN(+newPage)) {
            if (newPage < 1) {
              newPage = 1;
            }
            if (newPage > pageCount) {
              newPage = pageCount;
            }
          }
          if (newPage !== currentPage) {
            emit("change", newPage);
          }
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("ul", {
            class: normalizeClass(unref(nsPager).b()),
            onClick: onPagerClick,
            onKeyup: withKeys(onEnter, ["enter"])
          }, [
            _ctx.pageCount > 0 ? (openBlock(), createElementBlock("li", {
              key: 0,
              class: normalizeClass([[
                unref(nsPager).is("active", _ctx.currentPage === 1),
                unref(nsPager).is("disabled", _ctx.disabled)
              ], "number"]),
              "aria-current": _ctx.currentPage === 1,
              tabindex: unref(tabindex)
            }, " 1 ", 10, _hoisted_2$g)) : createCommentVNode("v-if", true),
            showPrevMore.value ? (openBlock(), createElementBlock("li", {
              key: 1,
              class: normalizeClass([
                "more",
                "btn-quickprev",
                unref(nsIcon).b(),
                unref(nsPager).is("disabled", _ctx.disabled)
              ]),
              tabindex: unref(tabindex),
              onMouseenter: _cache[0] || (_cache[0] = ($event) => onMouseEnter(true)),
              onMouseleave: _cache[1] || (_cache[1] = ($event) => quickPrevHover.value = false),
              onFocus: _cache[2] || (_cache[2] = ($event) => onFocus(true)),
              onBlur: _cache[3] || (_cache[3] = ($event) => quickPrevFocus.value = false)
            }, [
              quickPrevHover.value || quickPrevFocus.value ? (openBlock(), createBlock(unref(d_arrow_left_default), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default), { key: 1 }))
            ], 42, _hoisted_3$9)) : createCommentVNode("v-if", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(pagers), (pager) => {
              return openBlock(), createElementBlock("li", {
                key: pager,
                class: normalizeClass([[
                  unref(nsPager).is("active", _ctx.currentPage === pager),
                  unref(nsPager).is("disabled", _ctx.disabled)
                ], "number"]),
                "aria-current": _ctx.currentPage === pager,
                tabindex: unref(tabindex)
              }, toDisplayString$1(pager), 11, _hoisted_4$7);
            }), 128)),
            showNextMore.value ? (openBlock(), createElementBlock("li", {
              key: 2,
              class: normalizeClass([
                "more",
                "btn-quicknext",
                unref(nsIcon).b(),
                unref(nsPager).is("disabled", _ctx.disabled)
              ]),
              tabindex: unref(tabindex),
              onMouseenter: _cache[4] || (_cache[4] = ($event) => onMouseEnter()),
              onMouseleave: _cache[5] || (_cache[5] = ($event) => quickNextHover.value = false),
              onFocus: _cache[6] || (_cache[6] = ($event) => onFocus()),
              onBlur: _cache[7] || (_cache[7] = ($event) => quickNextFocus.value = false)
            }, [
              quickNextHover.value || quickNextFocus.value ? (openBlock(), createBlock(unref(d_arrow_right_default), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default), { key: 1 }))
            ], 42, _hoisted_5$6)) : createCommentVNode("v-if", true),
            _ctx.pageCount > 1 ? (openBlock(), createElementBlock("li", {
              key: 3,
              class: normalizeClass([[
                unref(nsPager).is("active", _ctx.currentPage === _ctx.pageCount),
                unref(nsPager).is("disabled", _ctx.disabled)
              ], "number"]),
              "aria-current": _ctx.currentPage === _ctx.pageCount,
              tabindex: unref(tabindex)
            }, toDisplayString$1(_ctx.pageCount), 11, _hoisted_6$2)) : createCommentVNode("v-if", true)
          ], 42, _hoisted_1$m);
        };
      }
    });
    var Pager = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/pager.vue"]]);
    const isAbsent = (v2) => typeof v2 !== "number";
    const paginationProps = buildProps({
      total: Number,
      pageSize: Number,
      defaultPageSize: Number,
      currentPage: Number,
      defaultCurrentPage: Number,
      pageCount: Number,
      pagerCount: {
        type: Number,
        validator: (value) => {
          return typeof value === "number" && Math.trunc(value) === value && value > 4 && value < 22 && value % 2 === 1;
        },
        default: 7
      },
      layout: {
        type: String,
        default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
      },
      pageSizes: {
        type: definePropType(Array),
        default: () => mutable([10, 20, 30, 40, 50, 100])
      },
      popperClass: {
        type: String,
        default: ""
      },
      prevText: {
        type: String,
        default: ""
      },
      prevIcon: {
        type: iconPropType,
        default: () => arrow_left_default
      },
      nextText: {
        type: String,
        default: ""
      },
      nextIcon: {
        type: iconPropType,
        default: () => arrow_right_default
      },
      small: Boolean,
      background: Boolean,
      disabled: Boolean,
      hideOnSinglePage: Boolean
    });
    const paginationEmits = {
      "update:current-page": (val) => typeof val === "number",
      "update:page-size": (val) => typeof val === "number",
      "size-change": (val) => typeof val === "number",
      "current-change": (val) => typeof val === "number",
      "prev-click": (val) => typeof val === "number",
      "next-click": (val) => typeof val === "number"
    };
    const componentName = "ElPagination";
    var Pagination = defineComponent({
      name: componentName,
      props: paginationProps,
      emits: paginationEmits,
      setup(props, { emit, slots }) {
        const { t } = useLocale();
        const ns2 = useNamespace("pagination");
        const vnodeProps = getCurrentInstance().vnode.props || {};
        const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
        const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
        const assertValidUsage = computed(() => {
          if (isAbsent(props.total) && isAbsent(props.pageCount))
            return false;
          if (!isAbsent(props.currentPage) && !hasCurrentPageListener)
            return false;
          if (props.layout.includes("sizes")) {
            if (!isAbsent(props.pageCount)) {
              if (!hasPageSizeListener)
                return false;
            } else if (!isAbsent(props.total)) {
              if (!isAbsent(props.pageSize)) {
                if (!hasPageSizeListener) {
                  return false;
                }
              }
            }
          }
          return true;
        });
        const innerPageSize = ref(isAbsent(props.defaultPageSize) ? 10 : props.defaultPageSize);
        const innerCurrentPage = ref(isAbsent(props.defaultCurrentPage) ? 1 : props.defaultCurrentPage);
        const pageSizeBridge = computed({
          get() {
            return isAbsent(props.pageSize) ? innerPageSize.value : props.pageSize;
          },
          set(v2) {
            if (isAbsent(props.pageSize)) {
              innerPageSize.value = v2;
            }
            if (hasPageSizeListener) {
              emit("update:page-size", v2);
              emit("size-change", v2);
            }
          }
        });
        const pageCountBridge = computed(() => {
          let pageCount = 0;
          if (!isAbsent(props.pageCount)) {
            pageCount = props.pageCount;
          } else if (!isAbsent(props.total)) {
            pageCount = Math.max(1, Math.ceil(props.total / pageSizeBridge.value));
          }
          return pageCount;
        });
        const currentPageBridge = computed({
          get() {
            return isAbsent(props.currentPage) ? innerCurrentPage.value : props.currentPage;
          },
          set(v2) {
            let newCurrentPage = v2;
            if (v2 < 1) {
              newCurrentPage = 1;
            } else if (v2 > pageCountBridge.value) {
              newCurrentPage = pageCountBridge.value;
            }
            if (isAbsent(props.currentPage)) {
              innerCurrentPage.value = newCurrentPage;
            }
            if (hasCurrentPageListener) {
              emit("update:current-page", newCurrentPage);
              emit("current-change", newCurrentPage);
            }
          }
        });
        watch(pageCountBridge, (val) => {
          if (currentPageBridge.value > val)
            currentPageBridge.value = val;
        });
        function handleCurrentChange(val) {
          currentPageBridge.value = val;
        }
        function handleSizeChange(val) {
          pageSizeBridge.value = val;
          const newPageCount = pageCountBridge.value;
          if (currentPageBridge.value > newPageCount) {
            currentPageBridge.value = newPageCount;
          }
        }
        function prev() {
          if (props.disabled)
            return;
          currentPageBridge.value -= 1;
          emit("prev-click", currentPageBridge.value);
        }
        function next() {
          if (props.disabled)
            return;
          currentPageBridge.value += 1;
          emit("next-click", currentPageBridge.value);
        }
        function addClass2(element, cls) {
          if (element) {
            if (!element.props) {
              element.props = {};
            }
            element.props.class = [element.props.class, cls].join(" ");
          }
        }
        provide(elPaginationKey, {
          pageCount: pageCountBridge,
          disabled: computed(() => props.disabled),
          currentPage: currentPageBridge,
          changeEvent: handleCurrentChange,
          handleSizeChange
        });
        return () => {
          var _a2, _b;
          if (!assertValidUsage.value) {
            debugWarn(componentName, t("el.pagination.deprecationWarning"));
            return null;
          }
          if (!props.layout)
            return null;
          if (props.hideOnSinglePage && pageCountBridge.value <= 1)
            return null;
          const rootChildren = [];
          const rightWrapperChildren = [];
          const rightWrapperRoot = h$1("div", { class: ns2.e("rightwrapper") }, rightWrapperChildren);
          const TEMPLATE_MAP = {
            prev: h$1(Prev, {
              disabled: props.disabled,
              currentPage: currentPageBridge.value,
              prevText: props.prevText,
              prevIcon: props.prevIcon,
              onClick: prev
            }),
            jumper: h$1(Jumper),
            pager: h$1(Pager, {
              currentPage: currentPageBridge.value,
              pageCount: pageCountBridge.value,
              pagerCount: props.pagerCount,
              onChange: handleCurrentChange,
              disabled: props.disabled
            }),
            next: h$1(Next, {
              disabled: props.disabled,
              currentPage: currentPageBridge.value,
              pageCount: pageCountBridge.value,
              nextText: props.nextText,
              nextIcon: props.nextIcon,
              onClick: next
            }),
            sizes: h$1(Sizes, {
              pageSize: pageSizeBridge.value,
              pageSizes: props.pageSizes,
              popperClass: props.popperClass,
              disabled: props.disabled,
              size: props.small ? "small" : "default"
            }),
            slot: (_b = (_a2 = slots == null ? void 0 : slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : null,
            total: h$1(Total, { total: isAbsent(props.total) ? 0 : props.total })
          };
          const components = props.layout.split(",").map((item) => item.trim());
          let haveRightWrapper = false;
          components.forEach((c2) => {
            if (c2 === "->") {
              haveRightWrapper = true;
              return;
            }
            if (!haveRightWrapper) {
              rootChildren.push(TEMPLATE_MAP[c2]);
            } else {
              rightWrapperChildren.push(TEMPLATE_MAP[c2]);
            }
          });
          addClass2(rootChildren[0], ns2.is("first"));
          addClass2(rootChildren[rootChildren.length - 1], ns2.is("last"));
          if (haveRightWrapper && rightWrapperChildren.length > 0) {
            addClass2(rightWrapperChildren[0], ns2.is("first"));
            addClass2(rightWrapperChildren[rightWrapperChildren.length - 1], ns2.is("last"));
            rootChildren.push(rightWrapperRoot);
          }
          return h$1("div", {
            role: "pagination",
            "aria-label": "pagination",
            class: [
              ns2.b(),
              ns2.is("background", props.background),
              {
                [ns2.m("small")]: props.small
              }
            ]
          }, rootChildren);
        };
      }
    });
    const ElPagination = withInstall(Pagination);
    const popconfirmProps = buildProps({
      title: String,
      confirmButtonText: String,
      cancelButtonText: String,
      confirmButtonType: {
        type: String,
        values: buttonTypes,
        default: "primary"
      },
      cancelButtonType: {
        type: String,
        values: buttonTypes,
        default: "text"
      },
      icon: {
        type: iconPropType,
        default: () => question_filled_default
      },
      iconColor: {
        type: String,
        default: "#f90"
      },
      hideIcon: {
        type: Boolean,
        default: false
      },
      hideAfter: {
        type: Number,
        default: 200
      },
      onConfirm: {
        type: definePropType(Function)
      },
      onCancel: {
        type: definePropType(Function)
      },
      teleported: useTooltipContentProps.teleported,
      persistent: useTooltipContentProps.persistent,
      width: {
        type: [String, Number],
        default: 150
      }
    });
    const __default__$u = {
      name: "ElPopconfirm"
    };
    const _sfc_main$J = /* @__PURE__ */ defineComponent({
      ...__default__$u,
      props: popconfirmProps,
      setup(__props) {
        const props = __props;
        const { t } = useLocale();
        const ns2 = useNamespace("popconfirm");
        const tooltipRef = ref();
        const hidePopper = () => {
          var _a2, _b;
          (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.onClose) == null ? void 0 : _b.call(_a2);
        };
        const style2 = computed(() => {
          return {
            width: addUnit(props.width)
          };
        });
        const confirm = (e) => {
          var _a2;
          (_a2 = props.onConfirm) == null ? void 0 : _a2.call(props, e);
          hidePopper();
        };
        const cancel = (e) => {
          var _a2;
          (_a2 = props.onCancel) == null ? void 0 : _a2.call(props, e);
          hidePopper();
        };
        const finalConfirmButtonText = computed(() => props.confirmButtonText || t("el.popconfirm.confirmButtonText"));
        const finalCancelButtonText = computed(() => props.cancelButtonText || t("el.popconfirm.cancelButtonText"));
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElTooltip), mergeProps({
            ref_key: "tooltipRef",
            ref: tooltipRef,
            trigger: "click",
            effect: "light"
          }, _ctx.$attrs, {
            "popper-class": `${unref(ns2).namespace.value}-popover`,
            "popper-style": unref(style2),
            teleported: _ctx.teleported,
            "fallback-placements": ["bottom", "top", "right", "left"],
            "hide-after": _ctx.hideAfter,
            persistent: _ctx.persistent
          }), {
            content: withCtx(() => [
              createBaseVNode("div", {
                class: normalizeClass(unref(ns2).b())
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns2).e("main"))
                }, [
                  !_ctx.hideIcon && _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns2).e("icon")),
                    style: normalizeStyle({ color: _ctx.iconColor })
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                    ]),
                    _: 1
                  }, 8, ["class", "style"])) : createCommentVNode("v-if", true),
                  createTextVNode(" " + toDisplayString$1(_ctx.title), 1)
                ], 2),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns2).e("action"))
                }, [
                  createVNode(unref(ElButton), {
                    size: "small",
                    type: _ctx.cancelButtonType === "text" ? "" : _ctx.cancelButtonType,
                    text: _ctx.cancelButtonType === "text",
                    onClick: cancel
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString$1(unref(finalCancelButtonText)), 1)
                    ]),
                    _: 1
                  }, 8, ["type", "text"]),
                  createVNode(unref(ElButton), {
                    size: "small",
                    type: _ctx.confirmButtonType === "text" ? "" : _ctx.confirmButtonType,
                    text: _ctx.confirmButtonType === "text",
                    onClick: confirm
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString$1(unref(finalConfirmButtonText)), 1)
                    ]),
                    _: 1
                  }, 8, ["type", "text"])
                ], 2)
              ], 2)
            ]),
            default: withCtx(() => [
              _ctx.$slots.reference ? renderSlot(_ctx.$slots, "reference", { key: 0 }) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 16, ["popper-class", "popper-style", "teleported", "hide-after", "persistent"]);
        };
      }
    });
    var Popconfirm = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popconfirm/src/popconfirm.vue"]]);
    const ElPopconfirm = withInstall(Popconfirm);
    const popoverProps = buildProps({
      trigger: useTooltipTriggerProps.trigger,
      placement: dropdownProps.placement,
      disabled: useTooltipTriggerProps.disabled,
      visible: useTooltipContentProps.visible,
      transition: useTooltipContentProps.transition,
      popperOptions: dropdownProps.popperOptions,
      tabindex: dropdownProps.tabindex,
      content: useTooltipContentProps.content,
      popperStyle: useTooltipContentProps.popperStyle,
      popperClass: useTooltipContentProps.popperClass,
      enterable: {
        ...useTooltipContentProps.enterable,
        default: true
      },
      effect: {
        ...useTooltipContentProps.effect,
        default: "light"
      },
      teleported: useTooltipContentProps.teleported,
      title: String,
      width: {
        type: [String, Number],
        default: 150
      },
      offset: {
        type: Number,
        default: void 0
      },
      showAfter: {
        type: Number,
        default: 0
      },
      hideAfter: {
        type: Number,
        default: 200
      },
      autoClose: {
        type: Number,
        default: 0
      },
      showArrow: {
        type: Boolean,
        default: true
      },
      persistent: {
        type: Boolean,
        default: true
      },
      "onUpdate:visible": {
        type: Function
      }
    });
    const popoverEmits = {
      "update:visible": (value) => isBoolean$2(value),
      "before-enter": () => true,
      "before-leave": () => true,
      "after-enter": () => true,
      "after-leave": () => true
    };
    const __default__$t = {
      name: "ElPopover"
    };
    const _sfc_main$I = /* @__PURE__ */ defineComponent({
      ...__default__$t,
      props: popoverProps,
      emits: popoverEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const updateEventKeyRaw = `onUpdate:visible`;
        const onUpdateVisible = computed(() => {
          return props[updateEventKeyRaw];
        });
        const ns2 = useNamespace("popover");
        const tooltipRef = ref();
        const popperRef = computed(() => {
          var _a2;
          return (_a2 = unref(tooltipRef)) == null ? void 0 : _a2.popperRef;
        });
        const style2 = computed(() => {
          return [
            {
              width: addUnit(props.width)
            },
            props.popperStyle
          ];
        });
        const kls = computed(() => {
          return [ns2.b(), props.popperClass, { [ns2.m("plain")]: !!props.content }];
        });
        const gpuAcceleration = computed(() => {
          return props.transition === `${ns2.namespace.value}-fade-in-linear`;
        });
        const hide = () => {
          var _a2;
          (_a2 = tooltipRef.value) == null ? void 0 : _a2.hide();
        };
        const beforeEnter = () => {
          emit("before-enter");
        };
        const beforeLeave = () => {
          emit("before-leave");
        };
        const afterEnter = () => {
          emit("after-enter");
        };
        const afterLeave = () => {
          emit("update:visible", false);
          emit("after-leave");
        };
        expose({
          popperRef,
          hide
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElTooltip), mergeProps({
            ref_key: "tooltipRef",
            ref: tooltipRef
          }, _ctx.$attrs, {
            trigger: _ctx.trigger,
            placement: _ctx.placement,
            disabled: _ctx.disabled,
            visible: _ctx.visible,
            transition: _ctx.transition,
            "popper-options": _ctx.popperOptions,
            tabindex: _ctx.tabindex,
            content: _ctx.content,
            offset: _ctx.offset,
            "show-after": _ctx.showAfter,
            "hide-after": _ctx.hideAfter,
            "auto-close": _ctx.autoClose,
            "show-arrow": _ctx.showArrow,
            "aria-label": _ctx.title,
            effect: _ctx.effect,
            enterable: _ctx.enterable,
            "popper-class": unref(kls),
            "popper-style": unref(style2),
            teleported: _ctx.teleported,
            persistent: _ctx.persistent,
            "gpu-acceleration": unref(gpuAcceleration),
            "onUpdate:visible": unref(onUpdateVisible),
            onBeforeShow: beforeEnter,
            onBeforeHide: beforeLeave,
            onShow: afterEnter,
            onHide: afterLeave
          }), {
            content: withCtx(() => [
              _ctx.title ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns2).e("title")),
                role: "title"
              }, toDisplayString$1(_ctx.title), 3)) : createCommentVNode("v-if", true),
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(toDisplayString$1(_ctx.content), 1)
              ])
            ]),
            default: withCtx(() => [
              _ctx.$slots.reference ? renderSlot(_ctx.$slots, "reference", { key: 0 }) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]);
        };
      }
    });
    var Popover = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
    const attachEvents = (el, binding) => {
      const popperComponent = binding.arg || binding.value;
      const popover = popperComponent == null ? void 0 : popperComponent.popperRef;
      if (popover) {
        popover.triggerRef = el;
      }
    };
    var PopoverDirective = {
      mounted(el, binding) {
        attachEvents(el, binding);
      },
      updated(el, binding) {
        attachEvents(el, binding);
      }
    };
    const VPopover = "popover";
    const ElPopoverDirective = withInstallDirective(PopoverDirective, VPopover);
    const ElPopover = withInstall(Popover, {
      directive: ElPopoverDirective
    });
    const progressProps = buildProps({
      type: {
        type: String,
        default: "line",
        values: ["line", "circle", "dashboard"]
      },
      percentage: {
        type: Number,
        default: 0,
        validator: (val) => val >= 0 && val <= 100
      },
      status: {
        type: String,
        default: "",
        values: ["", "success", "exception", "warning"]
      },
      indeterminate: {
        type: Boolean,
        default: false
      },
      duration: {
        type: Number,
        default: 3
      },
      strokeWidth: {
        type: Number,
        default: 6
      },
      strokeLinecap: {
        type: definePropType(String),
        default: "round"
      },
      textInside: {
        type: Boolean,
        default: false
      },
      width: {
        type: Number,
        default: 126
      },
      showText: {
        type: Boolean,
        default: true
      },
      color: {
        type: definePropType([
          String,
          Array,
          Function
        ]),
        default: ""
      },
      format: {
        type: definePropType(Function),
        default: (percentage) => `${percentage}%`
      }
    });
    const _hoisted_1$l = ["aria-valuenow"];
    const _hoisted_2$f = { viewBox: "0 0 100 100" };
    const _hoisted_3$8 = ["d", "stroke", "stroke-width"];
    const _hoisted_4$6 = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"];
    const _hoisted_5$5 = { key: 0 };
    const __default__$s = {
      name: "ElProgress"
    };
    const _sfc_main$H = /* @__PURE__ */ defineComponent({
      ...__default__$s,
      props: progressProps,
      setup(__props) {
        const props = __props;
        const STATUS_COLOR_MAP = {
          success: "#13ce66",
          exception: "#ff4949",
          warning: "#e6a23c",
          default: "#20a0ff"
        };
        const ns2 = useNamespace("progress");
        const barStyle = computed(() => ({
          width: `${props.percentage}%`,
          animationDuration: `${props.duration}s`,
          backgroundColor: getCurrentColor(props.percentage)
        }));
        const relativeStrokeWidth = computed(() => (props.strokeWidth / props.width * 100).toFixed(1));
        const radius = computed(() => {
          if (["circle", "dashboard"].includes(props.type)) {
            return Number.parseInt(`${50 - Number.parseFloat(relativeStrokeWidth.value) / 2}`, 10);
          }
          return 0;
        });
        const trackPath = computed(() => {
          const r = radius.value;
          const isDashboard = props.type === "dashboard";
          return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
        });
        const perimeter = computed(() => 2 * Math.PI * radius.value);
        const rate = computed(() => props.type === "dashboard" ? 0.75 : 1);
        const strokeDashoffset = computed(() => {
          const offset2 = -1 * perimeter.value * (1 - rate.value) / 2;
          return `${offset2}px`;
        });
        const trailPathStyle = computed(() => ({
          strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
          strokeDashoffset: strokeDashoffset.value
        }));
        const circlePathStyle = computed(() => ({
          strokeDasharray: `${perimeter.value * rate.value * (props.percentage / 100)}px, ${perimeter.value}px`,
          strokeDashoffset: strokeDashoffset.value,
          transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
        }));
        const stroke = computed(() => {
          let ret;
          if (props.color) {
            ret = getCurrentColor(props.percentage);
          } else {
            ret = STATUS_COLOR_MAP[props.status] || STATUS_COLOR_MAP.default;
          }
          return ret;
        });
        const statusIcon = computed(() => {
          if (props.status === "warning") {
            return warning_filled_default;
          }
          if (props.type === "line") {
            return props.status === "success" ? circle_check_default : circle_close_default;
          } else {
            return props.status === "success" ? check_default : close_default;
          }
        });
        const progressTextSize = computed(() => {
          return props.type === "line" ? 12 + props.strokeWidth * 0.4 : props.width * 0.111111 + 2;
        });
        const content = computed(() => props.format(props.percentage));
        function getColors(color) {
          const span = 100 / color.length;
          const seriesColors = color.map((seriesColor, index2) => {
            if (isString$3(seriesColor)) {
              return {
                color: seriesColor,
                percentage: (index2 + 1) * span
              };
            }
            return seriesColor;
          });
          return seriesColors.sort((a2, b2) => a2.percentage - b2.percentage);
        }
        const getCurrentColor = (percentage) => {
          var _a2;
          const { color } = props;
          if (isFunction$4(color)) {
            return color(percentage);
          } else if (isString$3(color)) {
            return color;
          } else {
            const colors = getColors(color);
            for (const color2 of colors) {
              if (color2.percentage > percentage)
                return color2.color;
            }
            return (_a2 = colors[colors.length - 1]) == null ? void 0 : _a2.color;
          }
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([
              unref(ns2).b(),
              unref(ns2).m(_ctx.type),
              unref(ns2).is(_ctx.status),
              {
                [unref(ns2).m("without-text")]: !_ctx.showText,
                [unref(ns2).m("text-inside")]: _ctx.textInside
              }
            ]),
            role: "progressbar",
            "aria-valuenow": _ctx.percentage,
            "aria-valuemin": "0",
            "aria-valuemax": "100"
          }, [
            _ctx.type === "line" ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(ns2).b("bar"))
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ns2).be("bar", "outer")),
                style: normalizeStyle({ height: `${_ctx.strokeWidth}px` })
              }, [
                createBaseVNode("div", {
                  class: normalizeClass([
                    unref(ns2).be("bar", "inner"),
                    { [unref(ns2).bem("bar", "inner", "indeterminate")]: _ctx.indeterminate }
                  ]),
                  style: normalizeStyle(unref(barStyle))
                }, [
                  (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(unref(ns2).be("bar", "innerText"))
                  }, [
                    renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                      createBaseVNode("span", null, toDisplayString$1(unref(content)), 1)
                    ])
                  ], 2)) : createCommentVNode("v-if", true)
                ], 6)
              ], 6)
            ], 2)) : (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(unref(ns2).b("circle")),
              style: normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
            }, [
              (openBlock(), createElementBlock("svg", _hoisted_2$f, [
                createBaseVNode("path", {
                  class: normalizeClass(unref(ns2).be("circle", "track")),
                  d: unref(trackPath),
                  stroke: `var(${unref(ns2).cssVarName("fill-color-light")}, #e5e9f2)`,
                  "stroke-width": unref(relativeStrokeWidth),
                  fill: "none",
                  style: normalizeStyle(unref(trailPathStyle))
                }, null, 14, _hoisted_3$8),
                createBaseVNode("path", {
                  class: normalizeClass(unref(ns2).be("circle", "path")),
                  d: unref(trackPath),
                  stroke: unref(stroke),
                  fill: "none",
                  opacity: _ctx.percentage ? 1 : 0,
                  "stroke-linecap": _ctx.strokeLinecap,
                  "stroke-width": unref(relativeStrokeWidth),
                  style: normalizeStyle(unref(circlePathStyle))
                }, null, 14, _hoisted_4$6)
              ]))
            ], 6)),
            (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(unref(ns2).e("text")),
              style: normalizeStyle({ fontSize: `${unref(progressTextSize)}px` })
            }, [
              renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                !_ctx.status ? (openBlock(), createElementBlock("span", _hoisted_5$5, toDisplayString$1(unref(content)), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(statusIcon))))
                  ]),
                  _: 1
                }))
              ])
            ], 6)) : createCommentVNode("v-if", true)
          ], 10, _hoisted_1$l);
        };
      }
    });
    var Progress = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
    const ElProgress = withInstall(Progress);
    const rateProps = buildProps({
      modelValue: {
        type: Number,
        default: 0
      },
      id: {
        type: String,
        default: void 0
      },
      lowThreshold: {
        type: Number,
        default: 2
      },
      highThreshold: {
        type: Number,
        default: 4
      },
      max: {
        type: Number,
        default: 5
      },
      colors: {
        type: definePropType([Array, Object]),
        default: () => mutable(["", "", ""])
      },
      voidColor: {
        type: String,
        default: ""
      },
      disabledVoidColor: {
        type: String,
        default: ""
      },
      icons: {
        type: definePropType([Array, Object]),
        default: () => [star_filled_default, star_filled_default, star_filled_default]
      },
      voidIcon: {
        type: iconPropType,
        default: () => star_default
      },
      disabledVoidIcon: {
        type: iconPropType,
        default: () => star_filled_default
      },
      disabled: {
        type: Boolean
      },
      allowHalf: {
        type: Boolean
      },
      showText: {
        type: Boolean
      },
      showScore: {
        type: Boolean
      },
      textColor: {
        type: String,
        default: ""
      },
      texts: {
        type: definePropType(Array),
        default: () => mutable([
          "Extremely bad",
          "Disappointed",
          "Fair",
          "Satisfied",
          "Surprise"
        ])
      },
      scoreTemplate: {
        type: String,
        default: "{value}"
      },
      size: {
        type: String,
        validator: isValidComponentSize
      },
      label: {
        type: String,
        default: void 0
      }
    });
    const rateEmits = {
      [CHANGE_EVENT]: (value) => isNumber$2(value),
      [UPDATE_MODEL_EVENT]: (value) => isNumber$2(value)
    };
    const _hoisted_1$k = ["id", "aria-label", "aria-labelledby", "aria-valuenow", "aria-valuetext", "aria-valuemax"];
    const _hoisted_2$e = ["onMousemove", "onClick"];
    const __default__$r = {
      name: "ElRate"
    };
    const _sfc_main$G = /* @__PURE__ */ defineComponent({
      ...__default__$r,
      props: rateProps,
      emits: rateEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        function getValueFromMap(value, map) {
          const isExcludedObject = (val) => isObject$4(val);
          const matchedKeys = Object.keys(map).map((key) => +key).filter((key) => {
            const val = map[key];
            const excluded = isExcludedObject(val) ? val.excluded : false;
            return excluded ? value < key : value <= key;
          }).sort((a2, b2) => a2 - b2);
          const matchedValue = map[matchedKeys[0]];
          return isExcludedObject(matchedValue) && matchedValue.value || matchedValue;
        }
        const formContext = inject(formContextKey, void 0);
        const formItemContext = inject(formItemContextKey, void 0);
        const rateSize = useSize();
        const ns2 = useNamespace("rate");
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext
        });
        const currentValue = ref(props.modelValue);
        const hoverIndex = ref(-1);
        const pointerAtLeftHalf = ref(true);
        const rateClasses = computed(() => [ns2.b(), ns2.m(rateSize.value)]);
        const rateDisabled = computed(() => props.disabled || (formContext == null ? void 0 : formContext.disabled));
        const rateStyles = computed(() => {
          return ns2.cssVarBlock({
            "void-color": props.voidColor,
            "disabled-void-color": props.disabledVoidColor,
            "fill-color": activeColor.value
          });
        });
        const text = computed(() => {
          let result = "";
          if (props.showScore) {
            result = props.scoreTemplate.replace(/\{\s*value\s*\}/, rateDisabled.value ? `${props.modelValue}` : `${currentValue.value}`);
          } else if (props.showText) {
            result = props.texts[Math.ceil(currentValue.value) - 1];
          }
          return result;
        });
        const valueDecimal = computed(() => props.modelValue * 100 - Math.floor(props.modelValue) * 100);
        const colorMap = computed(() => isArray$4(props.colors) ? {
          [props.lowThreshold]: props.colors[0],
          [props.highThreshold]: { value: props.colors[1], excluded: true },
          [props.max]: props.colors[2]
        } : props.colors);
        const activeColor = computed(() => {
          const color = getValueFromMap(currentValue.value, colorMap.value);
          return isObject$4(color) ? "" : color;
        });
        const decimalStyle = computed(() => {
          let width = "";
          if (rateDisabled.value) {
            width = `${valueDecimal.value}%`;
          } else if (props.allowHalf) {
            width = "50%";
          }
          return {
            color: activeColor.value,
            width
          };
        });
        const componentMap = computed(() => isArray$4(props.icons) ? {
          [props.lowThreshold]: props.icons[0],
          [props.highThreshold]: {
            value: props.icons[1],
            excluded: true
          },
          [props.max]: props.icons[2]
        } : props.icons);
        const decimalIconComponent = computed(() => getValueFromMap(props.modelValue, componentMap.value));
        const voidComponent = computed(() => rateDisabled.value ? props.disabledVoidIcon : props.voidIcon);
        const activeComponent = computed(() => getValueFromMap(currentValue.value, componentMap.value));
        const iconComponents = computed(() => {
          const result = Array.from({ length: props.max });
          const threshold = currentValue.value;
          result.fill(activeComponent.value, 0, threshold);
          result.fill(voidComponent.value, threshold, props.max);
          return result;
        });
        function showDecimalIcon(item) {
          const showWhenDisabled = rateDisabled.value && valueDecimal.value > 0 && item - 1 < props.modelValue && item > props.modelValue;
          const showWhenAllowHalf = props.allowHalf && pointerAtLeftHalf.value && item - 0.5 <= currentValue.value && item > currentValue.value;
          return showWhenDisabled || showWhenAllowHalf;
        }
        function selectValue(value) {
          if (rateDisabled.value) {
            return;
          }
          if (props.allowHalf && pointerAtLeftHalf.value) {
            emit(UPDATE_MODEL_EVENT, currentValue.value);
            if (props.modelValue !== currentValue.value) {
              emit("change", currentValue.value);
            }
          } else {
            emit(UPDATE_MODEL_EVENT, value);
            if (props.modelValue !== value) {
              emit("change", value);
            }
          }
        }
        function handleKey(e) {
          if (rateDisabled.value) {
            return;
          }
          let _currentValue = currentValue.value;
          const code2 = e.code;
          if (code2 === EVENT_CODE.up || code2 === EVENT_CODE.right) {
            if (props.allowHalf) {
              _currentValue += 0.5;
            } else {
              _currentValue += 1;
            }
            e.stopPropagation();
            e.preventDefault();
          } else if (code2 === EVENT_CODE.left || code2 === EVENT_CODE.down) {
            if (props.allowHalf) {
              _currentValue -= 0.5;
            } else {
              _currentValue -= 1;
            }
            e.stopPropagation();
            e.preventDefault();
          }
          _currentValue = _currentValue < 0 ? 0 : _currentValue;
          _currentValue = _currentValue > props.max ? props.max : _currentValue;
          emit(UPDATE_MODEL_EVENT, _currentValue);
          emit("change", _currentValue);
          return _currentValue;
        }
        function setCurrentValue(value, event) {
          if (rateDisabled.value) {
            return;
          }
          if (props.allowHalf) {
            let target = event.target;
            if (hasClass(target, ns2.e("item"))) {
              target = target.querySelector(`.${ns2.e("icon")}`);
            }
            if (target.clientWidth === 0 || hasClass(target, ns2.e("decimal"))) {
              target = target.parentNode;
            }
            pointerAtLeftHalf.value = event.offsetX * 2 <= target.clientWidth;
            currentValue.value = pointerAtLeftHalf.value ? value - 0.5 : value;
          } else {
            currentValue.value = value;
          }
          hoverIndex.value = value;
        }
        function resetCurrentValue() {
          if (rateDisabled.value) {
            return;
          }
          if (props.allowHalf) {
            pointerAtLeftHalf.value = props.modelValue !== Math.floor(props.modelValue);
          }
          currentValue.value = props.modelValue;
          hoverIndex.value = -1;
        }
        watch(() => props.modelValue, (val) => {
          currentValue.value = val;
          pointerAtLeftHalf.value = props.modelValue !== Math.floor(props.modelValue);
        });
        if (!props.modelValue) {
          emit(UPDATE_MODEL_EVENT, 0);
        }
        expose({
          setCurrentValue,
          resetCurrentValue
        });
        return (_ctx, _cache) => {
          var _a2;
          return openBlock(), createElementBlock("div", {
            id: unref(inputId),
            class: normalizeClass([unref(rateClasses), unref(ns2).is("disabled", unref(rateDisabled))]),
            role: "slider",
            "aria-label": !unref(isLabeledByFormItem) ? _ctx.label || "rating" : void 0,
            "aria-labelledby": unref(isLabeledByFormItem) ? (_a2 = unref(formItemContext)) == null ? void 0 : _a2.labelId : void 0,
            "aria-valuenow": currentValue.value,
            "aria-valuetext": unref(text) || void 0,
            "aria-valuemin": "0",
            "aria-valuemax": _ctx.max,
            tabindex: "0",
            style: normalizeStyle(unref(rateStyles)),
            onKeydown: handleKey
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.max, (item, key) => {
              return openBlock(), createElementBlock("span", {
                key,
                class: normalizeClass(unref(ns2).e("item")),
                onMousemove: ($event) => setCurrentValue(item, $event),
                onMouseleave: resetCurrentValue,
                onClick: ($event) => selectValue(item)
              }, [
                createVNode(unref(ElIcon), {
                  class: normalizeClass([
                    unref(ns2).e("icon"),
                    { hover: hoverIndex.value === item },
                    unref(ns2).is("active", item <= currentValue.value)
                  ])
                }, {
                  default: withCtx(() => [
                    !showDecimalIcon(item) ? (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponents)[item - 1]), { key: 0 })) : createCommentVNode("v-if", true),
                    showDecimalIcon(item) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 1,
                      style: normalizeStyle(unref(decimalStyle)),
                      class: normalizeClass([unref(ns2).e("icon"), unref(ns2).e("decimal")])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(decimalIconComponent))))
                      ]),
                      _: 1
                    }, 8, ["style", "class"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 2
                }, 1032, ["class"])
              ], 42, _hoisted_2$e);
            }), 128)),
            _ctx.showText || _ctx.showScore ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(ns2).e("text"))
            }, toDisplayString$1(unref(text)), 3)) : createCommentVNode("v-if", true)
          ], 46, _hoisted_1$k);
        };
      }
    });
    var Rate = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/rate/src/rate.vue"]]);
    const ElRate = withInstall(Rate);
    const IconMap = {
      success: "icon-success",
      warning: "icon-warning",
      error: "icon-error",
      info: "icon-info"
    };
    const IconComponentMap = {
      [IconMap.success]: circle_check_filled_default,
      [IconMap.warning]: warning_filled_default,
      [IconMap.error]: circle_close_filled_default,
      [IconMap.info]: info_filled_default
    };
    const resultProps = buildProps({
      title: {
        type: String,
        default: ""
      },
      subTitle: {
        type: String,
        default: ""
      },
      icon: {
        type: String,
        values: ["success", "warning", "info", "error"],
        default: "info"
      }
    });
    const __default__$q = {
      name: "ElResult"
    };
    const _sfc_main$F = /* @__PURE__ */ defineComponent({
      ...__default__$q,
      props: resultProps,
      setup(__props) {
        const props = __props;
        const ns2 = useNamespace("result");
        const resultIcon = computed(() => {
          const icon = props.icon;
          const iconClass = icon && IconMap[icon] ? IconMap[icon] : "icon-info";
          const iconComponent = IconComponentMap[iconClass] || IconComponentMap["icon-info"];
          return {
            class: iconClass,
            component: iconComponent
          };
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(ns2).b())
          }, [
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("icon"))
            }, [
              renderSlot(_ctx.$slots, "icon", {}, () => [
                unref(resultIcon).component ? (openBlock(), createBlock(resolveDynamicComponent(unref(resultIcon).component), {
                  key: 0,
                  class: normalizeClass(unref(resultIcon).class)
                }, null, 8, ["class"])) : createCommentVNode("v-if", true)
              ])
            ], 2),
            _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(ns2).e("title"))
            }, [
              renderSlot(_ctx.$slots, "title", {}, () => [
                createBaseVNode("p", null, toDisplayString$1(_ctx.title), 1)
              ])
            ], 2)) : createCommentVNode("v-if", true),
            _ctx.subTitle || _ctx.$slots["sub-title"] ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(unref(ns2).e("subtitle"))
            }, [
              renderSlot(_ctx.$slots, "sub-title", {}, () => [
                createBaseVNode("p", null, toDisplayString$1(_ctx.subTitle), 1)
              ])
            ], 2)) : createCommentVNode("v-if", true),
            _ctx.$slots.extra ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(unref(ns2).e("extra"))
            }, [
              renderSlot(_ctx.$slots, "extra")
            ], 2)) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    });
    var Result = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/result/src/result.vue"]]);
    const ElResult = withInstall(Result);
    const RowJustify = [
      "start",
      "center",
      "end",
      "space-around",
      "space-between",
      "space-evenly"
    ];
    const RowAlign = ["top", "middle", "bottom"];
    const rowProps = buildProps({
      tag: {
        type: String,
        default: "div"
      },
      gutter: {
        type: Number,
        default: 0
      },
      justify: {
        type: String,
        values: RowJustify,
        default: "start"
      },
      align: {
        type: String,
        values: RowAlign,
        default: "top"
      }
    });
    const __default__$p = {
      name: "ElRow"
    };
    const _sfc_main$E = /* @__PURE__ */ defineComponent({
      ...__default__$p,
      props: rowProps,
      setup(__props) {
        const props = __props;
        const ns2 = useNamespace("row");
        const gutter = computed(() => props.gutter);
        provide(rowContextKey, {
          gutter
        });
        const style2 = computed(() => {
          const styles = {};
          if (!props.gutter) {
            return styles;
          }
          styles.marginRight = styles.marginLeft = `-${props.gutter / 2}px`;
          return styles;
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
            class: normalizeClass([
              unref(ns2).b(),
              unref(ns2).is(`justify-${props.justify}`, _ctx.justify !== "start"),
              unref(ns2).is(`align-${props.align}`, _ctx.align !== "top")
            ]),
            style: normalizeStyle(unref(style2))
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"]);
        };
      }
    });
    var Row = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/row/src/row.vue"]]);
    const ElRow = withInstall(Row);
    var safeIsNaN = Number.isNaN || function ponyfill(value) {
      return typeof value === "number" && value !== value;
    };
    function isEqual(first, second) {
      if (first === second) {
        return true;
      }
      if (safeIsNaN(first) && safeIsNaN(second)) {
        return true;
      }
      return false;
    }
    function areInputsEqual(newInputs, lastInputs) {
      if (newInputs.length !== lastInputs.length) {
        return false;
      }
      for (var i = 0; i < newInputs.length; i++) {
        if (!isEqual(newInputs[i], lastInputs[i])) {
          return false;
        }
      }
      return true;
    }
    function memoizeOne(resultFn, isEqual2) {
      if (isEqual2 === void 0) {
        isEqual2 = areInputsEqual;
      }
      var cache2 = null;
      function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          newArgs[_i] = arguments[_i];
        }
        if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
          return cache2.lastResult;
        }
        var lastResult = resultFn.apply(this, newArgs);
        cache2 = {
          lastResult,
          lastArgs: newArgs,
          lastThis: this
        };
        return lastResult;
      }
      memoized.clear = function clear2() {
        cache2 = null;
      };
      return memoized;
    }
    const useCache = () => {
      const vm = getCurrentInstance();
      const props = vm.proxy.$props;
      return computed(() => {
        const _getItemStyleCache = (_2, __, ___) => ({});
        return props.perfMode ? memoize(_getItemStyleCache) : memoizeOne(_getItemStyleCache);
      });
    };
    const DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;
    const ITEM_RENDER_EVT = "itemRendered";
    const SCROLL_EVT = "scroll";
    const FORWARD = "forward";
    const BACKWARD = "backward";
    const AUTO_ALIGNMENT = "auto";
    const SMART_ALIGNMENT = "smart";
    const START_ALIGNMENT = "start";
    const CENTERED_ALIGNMENT = "center";
    const END_ALIGNMENT = "end";
    const HORIZONTAL = "horizontal";
    const VERTICAL = "vertical";
    const LTR = "ltr";
    const RTL = "rtl";
    const RTL_OFFSET_NAG = "negative";
    const RTL_OFFSET_POS_ASC = "positive-ascending";
    const RTL_OFFSET_POS_DESC = "positive-descending";
    const ScrollbarDirKey = {
      [HORIZONTAL]: "left",
      [VERTICAL]: "top"
    };
    const SCROLLBAR_MIN_SIZE = 20;
    const LayoutKeys = {
      [HORIZONTAL]: "deltaX",
      [VERTICAL]: "deltaY"
    };
    const useWheel = ({ atEndEdge, atStartEdge, layout: layout2 }, onWheelDelta) => {
      let frameHandle;
      let offset2 = 0;
      const hasReachedEdge = (offset22) => {
        const edgeReached = offset22 < 0 && atStartEdge.value || offset22 > 0 && atEndEdge.value;
        return edgeReached;
      };
      const onWheel = (e) => {
        cAF(frameHandle);
        const newOffset = e[LayoutKeys[layout2.value]];
        if (hasReachedEdge(offset2) && hasReachedEdge(offset2 + newOffset))
          return;
        offset2 += newOffset;
        if (!isFirefox()) {
          e.preventDefault();
        }
        frameHandle = rAF(() => {
          onWheelDelta(offset2);
          offset2 = 0;
        });
      };
      return {
        hasReachedEdge,
        onWheel
      };
    };
    const itemSize = buildProp({
      type: definePropType([Number, Function]),
      required: true
    });
    const estimatedItemSize = buildProp({
      type: Number
    });
    const cache$1 = buildProp({
      type: Number,
      default: 2
    });
    const direction = buildProp({
      type: String,
      values: ["ltr", "rtl"],
      default: "ltr"
    });
    const initScrollOffset = buildProp({
      type: Number,
      default: 0
    });
    const total = buildProp({
      type: Number,
      required: true
    });
    const layout = buildProp({
      type: String,
      values: ["horizontal", "vertical"],
      default: VERTICAL
    });
    const virtualizedProps = buildProps({
      className: {
        type: String,
        default: ""
      },
      containerElement: {
        type: definePropType([String, Object]),
        default: "div"
      },
      data: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      direction,
      height: {
        type: [String, Number],
        required: true
      },
      innerElement: {
        type: [String, Object],
        default: "div"
      },
      style: {
        type: definePropType([Object, String, Array])
      },
      useIsScrolling: {
        type: Boolean,
        default: false
      },
      width: {
        type: [Number, String],
        required: false
      },
      perfMode: {
        type: Boolean,
        default: true
      },
      scrollbarAlwaysOn: {
        type: Boolean,
        default: false
      }
    });
    const virtualizedListProps = buildProps({
      cache: cache$1,
      estimatedItemSize,
      layout,
      initScrollOffset,
      total,
      itemSize,
      ...virtualizedProps
    });
    const scrollbarSize = {
      type: Number,
      default: 6
    };
    const startGap = { type: Number, default: 0 };
    const endGap = { type: Number, default: 2 };
    const virtualizedGridProps = buildProps({
      columnCache: cache$1,
      columnWidth: itemSize,
      estimatedColumnWidth: estimatedItemSize,
      estimatedRowHeight: estimatedItemSize,
      initScrollLeft: initScrollOffset,
      initScrollTop: initScrollOffset,
      itemKey: {
        type: definePropType(Function),
        default: ({ columnIndex, rowIndex }) => `${rowIndex}:${columnIndex}`
      },
      rowCache: cache$1,
      rowHeight: itemSize,
      totalColumn: total,
      totalRow: total,
      hScrollbarSize: scrollbarSize,
      vScrollbarSize: scrollbarSize,
      scrollbarStartGap: startGap,
      scrollbarEndGap: endGap,
      ...virtualizedProps
    });
    const virtualizedScrollbarProps = buildProps({
      alwaysOn: Boolean,
      class: String,
      layout,
      total,
      ratio: {
        type: Number,
        required: true
      },
      clientSize: {
        type: Number,
        required: true
      },
      scrollFrom: {
        type: Number,
        required: true
      },
      scrollbarSize,
      startGap,
      endGap,
      visible: Boolean
    });
    const getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;
    const isHorizontal = (dir) => dir === LTR || dir === RTL || dir === HORIZONTAL;
    const isRTL = (dir) => dir === RTL;
    let cachedRTLResult = null;
    function getRTLOffsetType(recalculate = false) {
      if (cachedRTLResult === null || recalculate) {
        const outerDiv = document.createElement("div");
        const outerStyle = outerDiv.style;
        outerStyle.width = "50px";
        outerStyle.height = "50px";
        outerStyle.overflow = "scroll";
        outerStyle.direction = "rtl";
        const innerDiv = document.createElement("div");
        const innerStyle = innerDiv.style;
        innerStyle.width = "100px";
        innerStyle.height = "100px";
        outerDiv.appendChild(innerDiv);
        document.body.appendChild(outerDiv);
        if (outerDiv.scrollLeft > 0) {
          cachedRTLResult = RTL_OFFSET_POS_DESC;
        } else {
          outerDiv.scrollLeft = 1;
          if (outerDiv.scrollLeft === 0) {
            cachedRTLResult = RTL_OFFSET_NAG;
          } else {
            cachedRTLResult = RTL_OFFSET_POS_ASC;
          }
        }
        document.body.removeChild(outerDiv);
        return cachedRTLResult;
      }
      return cachedRTLResult;
    }
    function renderThumbStyle({ move, size: size2, bar }, layout2) {
      const style2 = {};
      const translate2 = `translate${bar.axis}(${move}px)`;
      style2[bar.size] = size2;
      style2.transform = translate2;
      style2.msTransform = translate2;
      style2.webkitTransform = translate2;
      if (layout2 === "horizontal") {
        style2.height = "100%";
      } else {
        style2.width = "100%";
      }
      return style2;
    }
    const ScrollBar = defineComponent({
      name: "ElVirtualScrollBar",
      props: virtualizedScrollbarProps,
      emits: ["scroll", "start-move", "stop-move"],
      setup(props, { emit }) {
        const GAP2 = computed(() => props.startGap + props.endGap);
        const nsVirtualScrollbar = useNamespace("virtual-scrollbar");
        const nsScrollbar = useNamespace("scrollbar");
        const trackRef = ref();
        const thumbRef = ref();
        let frameHandle = null;
        let onselectstartStore = null;
        const state = reactive({
          isDragging: false,
          traveled: 0
        });
        const bar = computed(() => BAR_MAP[props.layout]);
        const trackSize = computed(() => props.clientSize - unref(GAP2));
        const trackStyle = computed(() => ({
          position: "absolute",
          width: `${HORIZONTAL === props.layout ? trackSize.value : props.scrollbarSize}px`,
          height: `${HORIZONTAL === props.layout ? props.scrollbarSize : trackSize.value}px`,
          [ScrollbarDirKey[props.layout]]: "2px",
          right: "2px",
          bottom: "2px",
          borderRadius: "4px"
        }));
        const thumbSize = computed(() => {
          const ratio = props.ratio;
          const clientSize = props.clientSize;
          if (ratio >= 100) {
            return Number.POSITIVE_INFINITY;
          }
          if (ratio >= 50) {
            return ratio * clientSize / 100;
          }
          const SCROLLBAR_MAX_SIZE = clientSize / 3;
          return Math.floor(Math.min(Math.max(ratio * clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));
        });
        const thumbStyle = computed(() => {
          if (!Number.isFinite(thumbSize.value)) {
            return {
              display: "none"
            };
          }
          const thumb = `${thumbSize.value}px`;
          const style2 = renderThumbStyle({
            bar: bar.value,
            size: thumb,
            move: state.traveled
          }, props.layout);
          return style2;
        });
        const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - unref(GAP2)));
        const attachEvents2 = () => {
          window.addEventListener("mousemove", onMouseMove);
          window.addEventListener("mouseup", onMouseUp);
          const thumbEl = unref(thumbRef);
          if (!thumbEl)
            return;
          onselectstartStore = document.onselectstart;
          document.onselectstart = () => false;
          thumbEl.addEventListener("touchmove", onMouseMove);
          thumbEl.addEventListener("touchend", onMouseUp);
        };
        const detachEvents = () => {
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("mouseup", onMouseUp);
          document.onselectstart = onselectstartStore;
          onselectstartStore = null;
          const thumbEl = unref(thumbRef);
          if (!thumbEl)
            return;
          thumbEl.removeEventListener("touchmove", onMouseMove);
          thumbEl.removeEventListener("touchend", onMouseUp);
        };
        const onThumbMouseDown = (e) => {
          e.stopImmediatePropagation();
          if (e.ctrlKey || [1, 2].includes(e.button)) {
            return;
          }
          state.isDragging = true;
          state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);
          emit("start-move");
          attachEvents2();
        };
        const onMouseUp = () => {
          state.isDragging = false;
          state[bar.value.axis] = 0;
          emit("stop-move");
          detachEvents();
        };
        const onMouseMove = (e) => {
          const { isDragging: isDragging2 } = state;
          if (!isDragging2)
            return;
          if (!thumbRef.value || !trackRef.value)
            return;
          const prevPage = state[bar.value.axis];
          if (!prevPage)
            return;
          cAF(frameHandle);
          const offset2 = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
          const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;
          const distance = offset2 - thumbClickPosition;
          frameHandle = rAF(() => {
            state.traveled = Math.max(props.startGap, Math.min(distance, totalSteps.value));
            emit("scroll", distance, totalSteps.value);
          });
        };
        const clickTrackHandler = (e) => {
          const offset2 = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
          const thumbHalf = thumbRef.value[bar.value.offset] / 2;
          const distance = offset2 - thumbHalf;
          state.traveled = Math.max(0, Math.min(distance, totalSteps.value));
          emit("scroll", distance, totalSteps.value);
        };
        watch(() => props.scrollFrom, (v2) => {
          if (state.isDragging)
            return;
          state.traveled = Math.ceil(v2 * totalSteps.value);
        });
        onBeforeUnmount(() => {
          detachEvents();
        });
        return () => {
          return h$1("div", {
            role: "presentation",
            ref: trackRef,
            class: [
              nsVirtualScrollbar.b(),
              props.class,
              (props.alwaysOn || state.isDragging) && "always-on"
            ],
            style: trackStyle.value,
            onMousedown: withModifiers(clickTrackHandler, ["stop", "prevent"]),
            onTouchstartPrevent: onThumbMouseDown
          }, h$1("div", {
            ref: thumbRef,
            class: nsScrollbar.e("thumb"),
            style: thumbStyle.value,
            onMousedown: onThumbMouseDown
          }, []));
        };
      }
    });
    const createList = ({
      name,
      getOffset: getOffset2,
      getItemSize,
      getItemOffset,
      getEstimatedTotalSize: getEstimatedTotalSize2,
      getStartIndexForOffset,
      getStopIndexForStartIndex,
      initCache,
      clearCache,
      validateProps
    }) => {
      return defineComponent({
        name: name != null ? name : "ElVirtualList",
        props: virtualizedListProps,
        emits: [ITEM_RENDER_EVT, SCROLL_EVT],
        setup(props, { emit, expose }) {
          validateProps(props);
          const instance = getCurrentInstance();
          const ns2 = useNamespace("vl");
          const dynamicSizeCache = ref(initCache(props, instance));
          const getItemStyleCache = useCache();
          const windowRef = ref();
          const innerRef = ref();
          const scrollbarRef = ref();
          const states = ref({
            isScrolling: false,
            scrollDir: "forward",
            scrollOffset: isNumber$2(props.initScrollOffset) ? props.initScrollOffset : 0,
            updateRequested: false,
            isScrollbarDragging: false,
            scrollbarAlwaysOn: props.scrollbarAlwaysOn
          });
          const itemsToRender = computed(() => {
            const { total: total2, cache: cache2 } = props;
            const { isScrolling, scrollDir, scrollOffset } = unref(states);
            if (total2 === 0) {
              return [0, 0, 0, 0];
            }
            const startIndex = getStartIndexForOffset(props, scrollOffset, unref(dynamicSizeCache));
            const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, unref(dynamicSizeCache));
            const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache2) : 1;
            const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache2) : 1;
            return [
              Math.max(0, startIndex - cacheBackward),
              Math.max(0, Math.min(total2 - 1, stopIndex + cacheForward)),
              startIndex,
              stopIndex
            ];
          });
          const estimatedTotalSize = computed(() => getEstimatedTotalSize2(props, unref(dynamicSizeCache)));
          const _isHorizontal = computed(() => isHorizontal(props.layout));
          const windowStyle = computed(() => [
            {
              position: "relative",
              [`overflow-${_isHorizontal.value ? "x" : "y"}`]: "scroll",
              WebkitOverflowScrolling: "touch",
              willChange: "transform"
            },
            {
              direction: props.direction,
              height: isNumber$2(props.height) ? `${props.height}px` : props.height,
              width: isNumber$2(props.width) ? `${props.width}px` : props.width
            },
            props.style
          ]);
          const innerStyle = computed(() => {
            const size2 = unref(estimatedTotalSize);
            const horizontal = unref(_isHorizontal);
            return {
              height: horizontal ? "100%" : `${size2}px`,
              pointerEvents: unref(states).isScrolling ? "none" : void 0,
              width: horizontal ? `${size2}px` : "100%"
            };
          });
          const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);
          const { onWheel } = useWheel({
            atStartEdge: computed(() => states.value.scrollOffset <= 0),
            atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),
            layout: computed(() => props.layout)
          }, (offset2) => {
            var _a2, _b;
            (_b = (_a2 = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a2);
            scrollTo(Math.min(states.value.scrollOffset + offset2, estimatedTotalSize.value - clientSize.value));
          });
          const emitEvents = () => {
            const { total: total2 } = props;
            if (total2 > 0) {
              const [cacheStart, cacheEnd, visibleStart, visibleEnd] = unref(itemsToRender);
              emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);
            }
            const { scrollDir, scrollOffset, updateRequested } = unref(states);
            emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);
          };
          const scrollVertically = (e) => {
            const { clientHeight, scrollHeight, scrollTop } = e.currentTarget;
            const _states = unref(states);
            if (_states.scrollOffset === scrollTop) {
              return;
            }
            const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
            states.value = {
              ..._states,
              isScrolling: true,
              scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
              scrollOffset,
              updateRequested: false
            };
            nextTick(resetIsScrolling);
          };
          const scrollHorizontally = (e) => {
            const { clientWidth, scrollLeft, scrollWidth } = e.currentTarget;
            const _states = unref(states);
            if (_states.scrollOffset === scrollLeft) {
              return;
            }
            const { direction: direction2 } = props;
            let scrollOffset = scrollLeft;
            if (direction2 === RTL) {
              switch (getRTLOffsetType()) {
                case RTL_OFFSET_NAG: {
                  scrollOffset = -scrollLeft;
                  break;
                }
                case RTL_OFFSET_POS_DESC: {
                  scrollOffset = scrollWidth - clientWidth - scrollLeft;
                  break;
                }
              }
            }
            scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
            states.value = {
              ..._states,
              isScrolling: true,
              scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
              scrollOffset,
              updateRequested: false
            };
            nextTick(resetIsScrolling);
          };
          const onScroll = (e) => {
            unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);
            emitEvents();
          };
          const onScrollbarScroll = (distanceToGo, totalSteps) => {
            const offset2 = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;
            scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset2));
          };
          const scrollTo = (offset2) => {
            offset2 = Math.max(offset2, 0);
            if (offset2 === unref(states).scrollOffset) {
              return;
            }
            states.value = {
              ...unref(states),
              scrollOffset: offset2,
              scrollDir: getScrollDir(unref(states).scrollOffset, offset2),
              updateRequested: true
            };
            nextTick(resetIsScrolling);
          };
          const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {
            const { scrollOffset } = unref(states);
            idx = Math.max(0, Math.min(idx, props.total - 1));
            scrollTo(getOffset2(props, idx, alignment, scrollOffset, unref(dynamicSizeCache)));
          };
          const getItemStyle = (idx) => {
            const { direction: direction2, itemSize: itemSize2, layout: layout2 } = props;
            const itemStyleCache = getItemStyleCache.value(clearCache && itemSize2, clearCache && layout2, clearCache && direction2);
            let style2;
            if (hasOwn$1(itemStyleCache, String(idx))) {
              style2 = itemStyleCache[idx];
            } else {
              const offset2 = getItemOffset(props, idx, unref(dynamicSizeCache));
              const size2 = getItemSize(props, idx, unref(dynamicSizeCache));
              const horizontal = unref(_isHorizontal);
              const isRtl = direction2 === RTL;
              const offsetHorizontal = horizontal ? offset2 : 0;
              itemStyleCache[idx] = style2 = {
                position: "absolute",
                left: isRtl ? void 0 : `${offsetHorizontal}px`,
                right: isRtl ? `${offsetHorizontal}px` : void 0,
                top: !horizontal ? `${offset2}px` : 0,
                height: !horizontal ? `${size2}px` : "100%",
                width: horizontal ? `${size2}px` : "100%"
              };
            }
            return style2;
          };
          const resetIsScrolling = () => {
            states.value.isScrolling = false;
            nextTick(() => {
              getItemStyleCache.value(-1, null, null);
            });
          };
          const resetScrollTop = () => {
            const window2 = windowRef.value;
            if (window2) {
              window2.scrollTop = 0;
            }
          };
          onMounted(() => {
            if (!isClient)
              return;
            const { initScrollOffset: initScrollOffset2 } = props;
            const windowElement = unref(windowRef);
            if (isNumber$2(initScrollOffset2) && windowElement) {
              if (unref(_isHorizontal)) {
                windowElement.scrollLeft = initScrollOffset2;
              } else {
                windowElement.scrollTop = initScrollOffset2;
              }
            }
            emitEvents();
          });
          onUpdated(() => {
            const { direction: direction2, layout: layout2 } = props;
            const { scrollOffset, updateRequested } = unref(states);
            const windowElement = unref(windowRef);
            if (updateRequested && windowElement) {
              if (layout2 === HORIZONTAL) {
                if (direction2 === RTL) {
                  switch (getRTLOffsetType()) {
                    case RTL_OFFSET_NAG: {
                      windowElement.scrollLeft = -scrollOffset;
                      break;
                    }
                    case RTL_OFFSET_POS_ASC: {
                      windowElement.scrollLeft = scrollOffset;
                      break;
                    }
                    default: {
                      const { clientWidth, scrollWidth } = windowElement;
                      windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                      break;
                    }
                  }
                } else {
                  windowElement.scrollLeft = scrollOffset;
                }
              } else {
                windowElement.scrollTop = scrollOffset;
              }
            }
          });
          const api = {
            ns: ns2,
            clientSize,
            estimatedTotalSize,
            windowStyle,
            windowRef,
            innerRef,
            innerStyle,
            itemsToRender,
            scrollbarRef,
            states,
            getItemStyle,
            onScroll,
            onScrollbarScroll,
            onWheel,
            scrollTo,
            scrollToItem,
            resetScrollTop
          };
          expose({
            windowRef,
            innerRef,
            getItemStyleCache,
            scrollTo,
            scrollToItem,
            resetScrollTop,
            states
          });
          return api;
        },
        render(ctx) {
          var _a2;
          const {
            $slots,
            className,
            clientSize,
            containerElement,
            data,
            getItemStyle,
            innerElement,
            itemsToRender,
            innerStyle,
            layout: layout2,
            total: total2,
            onScroll,
            onScrollbarScroll,
            onWheel,
            states,
            useIsScrolling,
            windowStyle,
            ns: ns2
          } = ctx;
          const [start, end2] = itemsToRender;
          const Container2 = resolveDynamicComponent(containerElement);
          const Inner = resolveDynamicComponent(innerElement);
          const children = [];
          if (total2 > 0) {
            for (let i = start; i <= end2; i++) {
              children.push((_a2 = $slots.default) == null ? void 0 : _a2.call($slots, {
                data,
                key: i,
                index: i,
                isScrolling: useIsScrolling ? states.isScrolling : void 0,
                style: getItemStyle(i)
              }));
            }
          }
          const InnerNode = [
            h$1(Inner, {
              style: innerStyle,
              ref: "innerRef"
            }, !isString$3(Inner) ? {
              default: () => children
            } : children)
          ];
          const scrollbar = h$1(ScrollBar, {
            ref: "scrollbarRef",
            clientSize,
            layout: layout2,
            onScroll: onScrollbarScroll,
            ratio: clientSize * 100 / this.estimatedTotalSize,
            scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),
            total: total2
          });
          const listContainer = h$1(Container2, {
            class: [ns2.e("window"), className],
            style: windowStyle,
            onScroll,
            onWheel,
            ref: "windowRef",
            key: 0
          }, !isString$3(Container2) ? { default: () => [InnerNode] } : [InnerNode]);
          return h$1("div", {
            key: 0,
            class: [ns2.e("wrapper"), states.scrollbarAlwaysOn ? "always-on" : ""]
          }, [listContainer, scrollbar]);
        }
      });
    };
    const FixedSizeList = createList({
      name: "ElFixedSizeList",
      getItemOffset: ({ itemSize: itemSize2 }, index2) => index2 * itemSize2,
      getItemSize: ({ itemSize: itemSize2 }) => itemSize2,
      getEstimatedTotalSize: ({ total: total2, itemSize: itemSize2 }) => itemSize2 * total2,
      getOffset: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, index2, alignment, scrollOffset) => {
        const size2 = isHorizontal(layout2) ? width : height;
        const lastItemOffset = Math.max(0, total2 * itemSize2 - size2);
        const maxOffset = Math.min(lastItemOffset, index2 * itemSize2);
        const minOffset = Math.max(0, (index2 + 1) * itemSize2 - size2);
        if (alignment === SMART_ALIGNMENT) {
          if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
            alignment = AUTO_ALIGNMENT;
          } else {
            alignment = CENTERED_ALIGNMENT;
          }
        }
        switch (alignment) {
          case START_ALIGNMENT: {
            return maxOffset;
          }
          case END_ALIGNMENT: {
            return minOffset;
          }
          case CENTERED_ALIGNMENT: {
            const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
            if (middleOffset < Math.ceil(size2 / 2)) {
              return 0;
            } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
              return lastItemOffset;
            } else {
              return middleOffset;
            }
          }
          case AUTO_ALIGNMENT:
          default: {
            if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
              return scrollOffset;
            } else if (scrollOffset < minOffset) {
              return minOffset;
            } else {
              return maxOffset;
            }
          }
        }
      },
      getStartIndexForOffset: ({ total: total2, itemSize: itemSize2 }, offset2) => Math.max(0, Math.min(total2 - 1, Math.floor(offset2 / itemSize2))),
      getStopIndexForStartIndex: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, startIndex, scrollOffset) => {
        const offset2 = startIndex * itemSize2;
        const size2 = isHorizontal(layout2) ? width : height;
        const numVisibleItems = Math.ceil((size2 + scrollOffset - offset2) / itemSize2);
        return Math.max(0, Math.min(total2 - 1, startIndex + numVisibleItems - 1));
      },
      initCache() {
        return void 0;
      },
      clearCache: true,
      validateProps() {
      }
    });
    const getItemFromCache$1 = (props, index2, listCache) => {
      const { itemSize: itemSize2 } = props;
      const { items, lastVisitedIndex } = listCache;
      if (index2 > lastVisitedIndex) {
        let offset2 = 0;
        if (lastVisitedIndex >= 0) {
          const item = items[lastVisitedIndex];
          offset2 = item.offset + item.size;
        }
        for (let i = lastVisitedIndex + 1; i <= index2; i++) {
          const size2 = itemSize2(i);
          items[i] = {
            offset: offset2,
            size: size2
          };
          offset2 += size2;
        }
        listCache.lastVisitedIndex = index2;
      }
      return items[index2];
    };
    const findItem$1 = (props, listCache, offset2) => {
      const { items, lastVisitedIndex } = listCache;
      const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;
      if (lastVisitedOffset >= offset2) {
        return bs$1(props, listCache, 0, lastVisitedIndex, offset2);
      }
      return es$1(props, listCache, Math.max(0, lastVisitedIndex), offset2);
    };
    const bs$1 = (props, listCache, low, high, offset2) => {
      while (low <= high) {
        const mid = low + Math.floor((high - low) / 2);
        const currentOffset = getItemFromCache$1(props, mid, listCache).offset;
        if (currentOffset === offset2) {
          return mid;
        } else if (currentOffset < offset2) {
          low = mid + 1;
        } else if (currentOffset > offset2) {
          high = mid - 1;
        }
      }
      return Math.max(0, low - 1);
    };
    const es$1 = (props, listCache, index2, offset2) => {
      const { total: total2 } = props;
      let exponent = 1;
      while (index2 < total2 && getItemFromCache$1(props, index2, listCache).offset < offset2) {
        index2 += exponent;
        exponent *= 2;
      }
      return bs$1(props, listCache, Math.floor(index2 / 2), Math.min(index2, total2 - 1), offset2);
    };
    const getEstimatedTotalSize = ({ total: total2 }, { items, estimatedItemSize: estimatedItemSize2, lastVisitedIndex }) => {
      let totalSizeOfMeasuredItems = 0;
      if (lastVisitedIndex >= total2) {
        lastVisitedIndex = total2 - 1;
      }
      if (lastVisitedIndex >= 0) {
        const item = items[lastVisitedIndex];
        totalSizeOfMeasuredItems = item.offset + item.size;
      }
      const numUnmeasuredItems = total2 - lastVisitedIndex - 1;
      const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize2;
      return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
    };
    const DynamicSizeList = createList({
      name: "ElDynamicSizeList",
      getItemOffset: (props, index2, listCache) => getItemFromCache$1(props, index2, listCache).offset,
      getItemSize: (_2, index2, { items }) => items[index2].size,
      getEstimatedTotalSize,
      getOffset: (props, index2, alignment, scrollOffset, listCache) => {
        const { height, layout: layout2, width } = props;
        const size2 = isHorizontal(layout2) ? width : height;
        const item = getItemFromCache$1(props, index2, listCache);
        const estimatedTotalSize = getEstimatedTotalSize(props, listCache);
        const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size2, item.offset));
        const minOffset = Math.max(0, item.offset - size2 + item.size);
        if (alignment === SMART_ALIGNMENT) {
          if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
            alignment = AUTO_ALIGNMENT;
          } else {
            alignment = CENTERED_ALIGNMENT;
          }
        }
        switch (alignment) {
          case START_ALIGNMENT: {
            return maxOffset;
          }
          case END_ALIGNMENT: {
            return minOffset;
          }
          case CENTERED_ALIGNMENT: {
            return Math.round(minOffset + (maxOffset - minOffset) / 2);
          }
          case AUTO_ALIGNMENT:
          default: {
            if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
              return scrollOffset;
            } else if (scrollOffset < minOffset) {
              return minOffset;
            } else {
              return maxOffset;
            }
          }
        }
      },
      getStartIndexForOffset: (props, offset2, listCache) => findItem$1(props, listCache, offset2),
      getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {
        const { height, total: total2, layout: layout2, width } = props;
        const size2 = isHorizontal(layout2) ? width : height;
        const item = getItemFromCache$1(props, startIndex, listCache);
        const maxOffset = scrollOffset + size2;
        let offset2 = item.offset + item.size;
        let stopIndex = startIndex;
        while (stopIndex < total2 - 1 && offset2 < maxOffset) {
          stopIndex++;
          offset2 += getItemFromCache$1(props, stopIndex, listCache).size;
        }
        return stopIndex;
      },
      initCache({ estimatedItemSize: estimatedItemSize2 = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {
        const cache2 = {
          items: {},
          estimatedItemSize: estimatedItemSize2,
          lastVisitedIndex: -1
        };
        cache2.clearCacheAfterIndex = (index2, forceUpdate = true) => {
          var _a2, _b;
          cache2.lastVisitedIndex = Math.min(cache2.lastVisitedIndex, index2 - 1);
          (_a2 = instance.exposed) == null ? void 0 : _a2.getItemStyleCache(-1);
          if (forceUpdate) {
            (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();
          }
        };
        return cache2;
      },
      clearCache: false,
      validateProps: ({ itemSize: itemSize2 }) => {
      }
    });
    const useGridWheel = ({ atXEndEdge, atXStartEdge, atYEndEdge, atYStartEdge }, onWheelDelta) => {
      let frameHandle = null;
      let xOffset = 0;
      let yOffset = 0;
      const hasReachedEdge = (x2, y) => {
        const xEdgeReached = x2 < 0 && atXStartEdge.value || x2 > 0 && atXEndEdge.value;
        const yEdgeReached = y < 0 && atYStartEdge.value || y > 0 && atYEndEdge.value;
        return xEdgeReached && yEdgeReached;
      };
      const onWheel = (e) => {
        cAF(frameHandle);
        let x2 = e.deltaX;
        let y = e.deltaY;
        if (Math.abs(x2) > Math.abs(y)) {
          y = 0;
        } else {
          x2 = 0;
        }
        if (e.shiftKey && y !== 0) {
          x2 = y;
          y = 0;
        }
        if (hasReachedEdge(xOffset, yOffset) && hasReachedEdge(xOffset + x2, yOffset + y))
          return;
        xOffset += x2;
        yOffset += y;
        if (!isFirefox()) {
          e.preventDefault();
        }
        frameHandle = rAF(() => {
          onWheelDelta(xOffset, yOffset);
          xOffset = 0;
          yOffset = 0;
        });
      };
      return {
        hasReachedEdge,
        onWheel
      };
    };
    const createGrid = ({
      name,
      clearCache,
      getColumnPosition,
      getColumnStartIndexForOffset,
      getColumnStopIndexForStartIndex,
      getEstimatedTotalHeight: getEstimatedTotalHeight2,
      getEstimatedTotalWidth: getEstimatedTotalWidth2,
      getColumnOffset,
      getRowOffset,
      getRowPosition,
      getRowStartIndexForOffset,
      getRowStopIndexForStartIndex,
      initCache,
      injectToInstance,
      validateProps
    }) => {
      return defineComponent({
        name: name != null ? name : "ElVirtualList",
        props: virtualizedGridProps,
        emits: [ITEM_RENDER_EVT, SCROLL_EVT],
        setup(props, { emit, expose, slots }) {
          const ns2 = useNamespace("vl");
          validateProps(props);
          const instance = getCurrentInstance();
          const cache2 = ref(initCache(props, instance));
          injectToInstance == null ? void 0 : injectToInstance(instance, cache2);
          const windowRef = ref();
          const hScrollbar = ref();
          const vScrollbar = ref();
          const innerRef = ref(null);
          const states = ref({
            isScrolling: false,
            scrollLeft: isNumber$2(props.initScrollLeft) ? props.initScrollLeft : 0,
            scrollTop: isNumber$2(props.initScrollTop) ? props.initScrollTop : 0,
            updateRequested: false,
            xAxisScrollDir: FORWARD,
            yAxisScrollDir: FORWARD
          });
          const getItemStyleCache = useCache();
          const parsedHeight = computed(() => Number.parseInt(`${props.height}`, 10));
          const parsedWidth = computed(() => Number.parseInt(`${props.width}`, 10));
          const columnsToRender = computed(() => {
            const { totalColumn, totalRow, columnCache } = props;
            const { isScrolling, xAxisScrollDir, scrollLeft } = unref(states);
            if (totalColumn === 0 || totalRow === 0) {
              return [0, 0, 0, 0];
            }
            const startIndex = getColumnStartIndexForOffset(props, scrollLeft, unref(cache2));
            const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, unref(cache2));
            const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;
            const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;
            return [
              Math.max(0, startIndex - cacheBackward),
              Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)),
              startIndex,
              stopIndex
            ];
          });
          const rowsToRender = computed(() => {
            const { totalColumn, totalRow, rowCache } = props;
            const { isScrolling, yAxisScrollDir, scrollTop } = unref(states);
            if (totalColumn === 0 || totalRow === 0) {
              return [0, 0, 0, 0];
            }
            const startIndex = getRowStartIndexForOffset(props, scrollTop, unref(cache2));
            const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, unref(cache2));
            const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;
            const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;
            return [
              Math.max(0, startIndex - cacheBackward),
              Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)),
              startIndex,
              stopIndex
            ];
          });
          const estimatedTotalHeight = computed(() => getEstimatedTotalHeight2(props, unref(cache2)));
          const estimatedTotalWidth = computed(() => getEstimatedTotalWidth2(props, unref(cache2)));
          const windowStyle = computed(() => {
            var _a2;
            return [
              {
                position: "relative",
                overflow: "hidden",
                WebkitOverflowScrolling: "touch",
                willChange: "transform"
              },
              {
                direction: props.direction,
                height: isNumber$2(props.height) ? `${props.height}px` : props.height,
                width: isNumber$2(props.width) ? `${props.width}px` : props.width
              },
              (_a2 = props.style) != null ? _a2 : {}
            ];
          });
          const innerStyle = computed(() => {
            const width = `${unref(estimatedTotalWidth)}px`;
            const height = `${unref(estimatedTotalHeight)}px`;
            return {
              height,
              pointerEvents: unref(states).isScrolling ? "none" : void 0,
              width
            };
          });
          const emitEvents = () => {
            const { totalColumn, totalRow } = props;
            if (totalColumn > 0 && totalRow > 0) {
              const [
                columnCacheStart,
                columnCacheEnd,
                columnVisibleStart,
                columnVisibleEnd
              ] = unref(columnsToRender);
              const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = unref(rowsToRender);
              emit(ITEM_RENDER_EVT, {
                columnCacheStart,
                columnCacheEnd,
                rowCacheStart,
                rowCacheEnd,
                columnVisibleStart,
                columnVisibleEnd,
                rowVisibleStart,
                rowVisibleEnd
              });
            }
            const {
              scrollLeft,
              scrollTop,
              updateRequested,
              xAxisScrollDir,
              yAxisScrollDir
            } = unref(states);
            emit(SCROLL_EVT, {
              xAxisScrollDir,
              scrollLeft,
              yAxisScrollDir,
              scrollTop,
              updateRequested
            });
          };
          const onScroll = (e) => {
            const {
              clientHeight,
              clientWidth,
              scrollHeight,
              scrollLeft,
              scrollTop,
              scrollWidth
            } = e.currentTarget;
            const _states = unref(states);
            if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {
              return;
            }
            let _scrollLeft = scrollLeft;
            if (isRTL(props.direction)) {
              switch (getRTLOffsetType()) {
                case RTL_OFFSET_NAG:
                  _scrollLeft = -scrollLeft;
                  break;
                case RTL_OFFSET_POS_DESC:
                  _scrollLeft = scrollWidth - clientWidth - scrollLeft;
                  break;
              }
            }
            states.value = {
              ..._states,
              isScrolling: true,
              scrollLeft: _scrollLeft,
              scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),
              updateRequested: true,
              xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),
              yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)
            };
            nextTick(() => resetIsScrolling());
            onUpdated2();
            emitEvents();
          };
          const onVerticalScroll = (distance, totalSteps) => {
            const height = unref(parsedHeight);
            const offset2 = (estimatedTotalHeight.value - height) / totalSteps * distance;
            scrollTo({
              scrollTop: Math.min(estimatedTotalHeight.value - height, offset2)
            });
          };
          const onHorizontalScroll = (distance, totalSteps) => {
            const width = unref(parsedWidth);
            const offset2 = (estimatedTotalWidth.value - width) / totalSteps * distance;
            scrollTo({
              scrollLeft: Math.min(estimatedTotalWidth.value - width, offset2)
            });
          };
          const { onWheel } = useGridWheel({
            atXStartEdge: computed(() => states.value.scrollLeft <= 0),
            atXEndEdge: computed(() => states.value.scrollLeft >= estimatedTotalWidth.value),
            atYStartEdge: computed(() => states.value.scrollTop <= 0),
            atYEndEdge: computed(() => states.value.scrollTop >= estimatedTotalHeight.value)
          }, (x2, y) => {
            var _a2, _b, _c, _d;
            (_b = (_a2 = hScrollbar.value) == null ? void 0 : _a2.onMouseUp) == null ? void 0 : _b.call(_a2);
            (_d = (_c = hScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);
            const width = unref(parsedWidth);
            const height = unref(parsedHeight);
            scrollTo({
              scrollLeft: Math.min(states.value.scrollLeft + x2, estimatedTotalWidth.value - width),
              scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)
            });
          });
          const scrollTo = ({
            scrollLeft = states.value.scrollLeft,
            scrollTop = states.value.scrollTop
          }) => {
            scrollLeft = Math.max(scrollLeft, 0);
            scrollTop = Math.max(scrollTop, 0);
            const _states = unref(states);
            if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {
              return;
            }
            states.value = {
              ..._states,
              xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),
              yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),
              scrollLeft,
              scrollTop,
              updateRequested: true
            };
            nextTick(() => resetIsScrolling());
            onUpdated2();
            emitEvents();
          };
          const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {
            const _states = unref(states);
            columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));
            rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));
            const scrollBarWidth2 = getScrollBarWidth(ns2.namespace.value);
            const _cache = unref(cache2);
            const estimatedHeight = getEstimatedTotalHeight2(props, _cache);
            const estimatedWidth = getEstimatedTotalWidth2(props, _cache);
            scrollTo({
              scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth2 : 0),
              scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth2 : 0)
            });
          };
          const getItemStyle = (rowIndex, columnIndex) => {
            const { columnWidth, direction: direction2, rowHeight } = props;
            const itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction2);
            const key = `${rowIndex},${columnIndex}`;
            if (hasOwn$1(itemStyleCache, key)) {
              return itemStyleCache[key];
            } else {
              const [, left2] = getColumnPosition(props, columnIndex, unref(cache2));
              const _cache = unref(cache2);
              const rtl = isRTL(direction2);
              const [height, top] = getRowPosition(props, rowIndex, _cache);
              const [width] = getColumnPosition(props, columnIndex, _cache);
              itemStyleCache[key] = {
                position: "absolute",
                left: rtl ? void 0 : `${left2}px`,
                right: rtl ? `${left2}px` : void 0,
                top: `${top}px`,
                height: `${height}px`,
                width: `${width}px`
              };
              return itemStyleCache[key];
            }
          };
          const resetIsScrolling = () => {
            states.value.isScrolling = false;
            nextTick(() => {
              getItemStyleCache.value(-1, null, null);
            });
          };
          onMounted(() => {
            if (!isClient)
              return;
            const { initScrollLeft, initScrollTop } = props;
            const windowElement = unref(windowRef);
            if (windowElement) {
              if (isNumber$2(initScrollLeft)) {
                windowElement.scrollLeft = initScrollLeft;
              }
              if (isNumber$2(initScrollTop)) {
                windowElement.scrollTop = initScrollTop;
              }
            }
            emitEvents();
          });
          const onUpdated2 = () => {
            const { direction: direction2 } = props;
            const { scrollLeft, scrollTop, updateRequested } = unref(states);
            const windowElement = unref(windowRef);
            if (updateRequested && windowElement) {
              if (direction2 === RTL) {
                switch (getRTLOffsetType()) {
                  case RTL_OFFSET_NAG: {
                    windowElement.scrollLeft = -scrollLeft;
                    break;
                  }
                  case RTL_OFFSET_POS_ASC: {
                    windowElement.scrollLeft = scrollLeft;
                    break;
                  }
                  default: {
                    const { clientWidth, scrollWidth } = windowElement;
                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;
                    break;
                  }
                }
              } else {
                windowElement.scrollLeft = Math.max(0, scrollLeft);
              }
              windowElement.scrollTop = Math.max(0, scrollTop);
            }
          };
          const { resetAfterColumnIndex, resetAfterRowIndex, resetAfter } = instance.proxy;
          expose({
            windowRef,
            innerRef,
            getItemStyleCache,
            scrollTo,
            scrollToItem,
            states,
            resetAfterColumnIndex,
            resetAfterRowIndex,
            resetAfter
          });
          const renderScrollbars = () => {
            const {
              scrollbarAlwaysOn,
              scrollbarStartGap,
              scrollbarEndGap,
              totalColumn,
              totalRow
            } = props;
            const width = unref(parsedWidth);
            const height = unref(parsedHeight);
            const estimatedWidth = unref(estimatedTotalWidth);
            const estimatedHeight = unref(estimatedTotalHeight);
            const { scrollLeft, scrollTop } = unref(states);
            const horizontalScrollbar = h$1(ScrollBar, {
              ref: hScrollbar,
              alwaysOn: scrollbarAlwaysOn,
              startGap: scrollbarStartGap,
              endGap: scrollbarEndGap,
              class: ns2.e("horizontal"),
              clientSize: width,
              layout: "horizontal",
              onScroll: onHorizontalScroll,
              ratio: width * 100 / estimatedWidth,
              scrollFrom: scrollLeft / (estimatedWidth - width),
              total: totalRow,
              visible: true
            });
            const verticalScrollbar = h$1(ScrollBar, {
              ref: vScrollbar,
              alwaysOn: scrollbarAlwaysOn,
              startGap: scrollbarStartGap,
              endGap: scrollbarEndGap,
              class: ns2.e("vertical"),
              clientSize: height,
              layout: "vertical",
              onScroll: onVerticalScroll,
              ratio: height * 100 / estimatedHeight,
              scrollFrom: scrollTop / (estimatedHeight - height),
              total: totalColumn,
              visible: true
            });
            return {
              horizontalScrollbar,
              verticalScrollbar
            };
          };
          const renderItems = () => {
            var _a2;
            const [columnStart, columnEnd] = unref(columnsToRender);
            const [rowStart, rowEnd] = unref(rowsToRender);
            const { data, totalColumn, totalRow, useIsScrolling, itemKey } = props;
            const children = [];
            if (totalRow > 0 && totalColumn > 0) {
              for (let row = rowStart; row <= rowEnd; row++) {
                for (let column = columnStart; column <= columnEnd; column++) {
                  children.push((_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
                    columnIndex: column,
                    data,
                    key: itemKey({ columnIndex: column, data, rowIndex: row }),
                    isScrolling: useIsScrolling ? unref(states).isScrolling : void 0,
                    style: getItemStyle(row, column),
                    rowIndex: row
                  }));
                }
              }
            }
            return children;
          };
          const renderInner = () => {
            const Inner = resolveDynamicComponent(props.innerElement);
            const children = renderItems();
            return [
              h$1(Inner, {
                style: unref(innerStyle),
                ref: innerRef
              }, !isString$3(Inner) ? {
                default: () => children
              } : children)
            ];
          };
          const renderWindow = () => {
            const Container2 = resolveDynamicComponent(props.containerElement);
            const { horizontalScrollbar, verticalScrollbar } = renderScrollbars();
            const Inner = renderInner();
            return h$1("div", {
              key: 0,
              class: ns2.e("wrapper")
            }, [
              h$1(Container2, {
                class: props.className,
                style: unref(windowStyle),
                onScroll,
                onWheel,
                ref: windowRef
              }, !isString$3(Container2) ? { default: () => Inner } : Inner),
              horizontalScrollbar,
              verticalScrollbar
            ]);
          };
          return renderWindow;
        }
      });
    };
    const FixedSizeGrid = createGrid({
      name: "ElFixedSizeGrid",
      getColumnPosition: ({ columnWidth }, index2) => [
        columnWidth,
        index2 * columnWidth
      ],
      getRowPosition: ({ rowHeight }, index2) => [
        rowHeight,
        index2 * rowHeight
      ],
      getEstimatedTotalHeight: ({ totalRow, rowHeight }) => rowHeight * totalRow,
      getEstimatedTotalWidth: ({ totalColumn, columnWidth }) => columnWidth * totalColumn,
      getColumnOffset: ({ totalColumn, columnWidth, width }, columnIndex, alignment, scrollLeft, _2, scrollBarWidth2) => {
        width = Number(width);
        const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);
        const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);
        const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth2 + columnWidth);
        if (alignment === "smart") {
          if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {
            alignment = AUTO_ALIGNMENT;
          } else {
            alignment = CENTERED_ALIGNMENT;
          }
        }
        switch (alignment) {
          case START_ALIGNMENT:
            return maxOffset;
          case END_ALIGNMENT:
            return minOffset;
          case CENTERED_ALIGNMENT: {
            const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
            if (middleOffset < Math.ceil(width / 2)) {
              return 0;
            } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {
              return lastColumnOffset;
            } else {
              return middleOffset;
            }
          }
          case AUTO_ALIGNMENT:
          default:
            if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {
              return scrollLeft;
            } else if (minOffset > maxOffset) {
              return minOffset;
            } else if (scrollLeft < minOffset) {
              return minOffset;
            } else {
              return maxOffset;
            }
        }
      },
      getRowOffset: ({ rowHeight, height, totalRow }, rowIndex, align, scrollTop, _2, scrollBarWidth2) => {
        height = Number(height);
        const lastRowOffset = Math.max(0, totalRow * rowHeight - height);
        const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);
        const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth2 + rowHeight);
        if (align === SMART_ALIGNMENT) {
          if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {
            align = AUTO_ALIGNMENT;
          } else {
            align = CENTERED_ALIGNMENT;
          }
        }
        switch (align) {
          case START_ALIGNMENT:
            return maxOffset;
          case END_ALIGNMENT:
            return minOffset;
          case CENTERED_ALIGNMENT: {
            const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
            if (middleOffset < Math.ceil(height / 2)) {
              return 0;
            } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {
              return lastRowOffset;
            } else {
              return middleOffset;
            }
          }
          case AUTO_ALIGNMENT:
          default:
            if (scrollTop >= minOffset && scrollTop <= maxOffset) {
              return scrollTop;
            } else if (minOffset > maxOffset) {
              return minOffset;
            } else if (scrollTop < minOffset) {
              return minOffset;
            } else {
              return maxOffset;
            }
        }
      },
      getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),
      getColumnStopIndexForStartIndex: ({ columnWidth, totalColumn, width }, startIndex, scrollLeft) => {
        const left2 = startIndex * columnWidth;
        const visibleColumnsCount = Math.ceil((width + scrollLeft - left2) / columnWidth);
        return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));
      },
      getRowStartIndexForOffset: ({ rowHeight, totalRow }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),
      getRowStopIndexForStartIndex: ({ rowHeight, totalRow, height }, startIndex, scrollTop) => {
        const top = startIndex * rowHeight;
        const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);
        return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));
      },
      initCache: () => void 0,
      clearCache: true,
      validateProps: ({ columnWidth, rowHeight }) => {
      }
    });
    const { max, min, floor } = Math;
    const ACCESS_SIZER_KEY_MAP = {
      column: "columnWidth",
      row: "rowHeight"
    };
    const ACCESS_LAST_VISITED_KEY_MAP = {
      column: "lastVisitedColumnIndex",
      row: "lastVisitedRowIndex"
    };
    const getItemFromCache = (props, index2, gridCache, type2) => {
      const [cachedItems, sizer, lastVisited] = [
        gridCache[type2],
        props[ACCESS_SIZER_KEY_MAP[type2]],
        gridCache[ACCESS_LAST_VISITED_KEY_MAP[type2]]
      ];
      if (index2 > lastVisited) {
        let offset2 = 0;
        if (lastVisited >= 0) {
          const item = cachedItems[lastVisited];
          offset2 = item.offset + item.size;
        }
        for (let i = lastVisited + 1; i <= index2; i++) {
          const size2 = sizer(i);
          cachedItems[i] = {
            offset: offset2,
            size: size2
          };
          offset2 += size2;
        }
        gridCache[ACCESS_LAST_VISITED_KEY_MAP[type2]] = index2;
      }
      return cachedItems[index2];
    };
    const bs = (props, gridCache, low, high, offset2, type2) => {
      while (low <= high) {
        const mid = low + floor((high - low) / 2);
        const currentOffset = getItemFromCache(props, mid, gridCache, type2).offset;
        if (currentOffset === offset2) {
          return mid;
        } else if (currentOffset < offset2) {
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }
      return max(0, low - 1);
    };
    const es = (props, gridCache, idx, offset2, type2) => {
      const total2 = type2 === "column" ? props.totalColumn : props.totalRow;
      let exponent = 1;
      while (idx < total2 && getItemFromCache(props, idx, gridCache, type2).offset < offset2) {
        idx += exponent;
        exponent *= 2;
      }
      return bs(props, gridCache, floor(idx / 2), min(idx, total2 - 1), offset2, type2);
    };
    const findItem = (props, gridCache, offset2, type2) => {
      const [cache2, lastVisitedIndex] = [
        gridCache[type2],
        gridCache[ACCESS_LAST_VISITED_KEY_MAP[type2]]
      ];
      const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache2[lastVisitedIndex].offset : 0;
      if (lastVisitedItemOffset >= offset2) {
        return bs(props, gridCache, 0, lastVisitedIndex, offset2, type2);
      }
      return es(props, gridCache, max(0, lastVisitedIndex), offset2, type2);
    };
    const getEstimatedTotalHeight = ({ totalRow }, { estimatedRowHeight, lastVisitedRowIndex, row }) => {
      let sizeOfVisitedRows = 0;
      if (lastVisitedRowIndex >= totalRow) {
        lastVisitedRowIndex = totalRow - 1;
      }
      if (lastVisitedRowIndex >= 0) {
        const item = row[lastVisitedRowIndex];
        sizeOfVisitedRows = item.offset + item.size;
      }
      const unvisitedItems = totalRow - lastVisitedRowIndex - 1;
      const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;
      return sizeOfVisitedRows + sizeOfUnvisitedItems;
    };
    const getEstimatedTotalWidth = ({ totalColumn }, { column, estimatedColumnWidth, lastVisitedColumnIndex }) => {
      let sizeOfVisitedColumns = 0;
      if (lastVisitedColumnIndex > totalColumn) {
        lastVisitedColumnIndex = totalColumn - 1;
      }
      if (lastVisitedColumnIndex >= 0) {
        const item = column[lastVisitedColumnIndex];
        sizeOfVisitedColumns = item.offset + item.size;
      }
      const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;
      const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;
      return sizeOfVisitedColumns + sizeOfUnvisitedItems;
    };
    const ACCESS_ESTIMATED_SIZE_KEY_MAP = {
      column: getEstimatedTotalWidth,
      row: getEstimatedTotalHeight
    };
    const getOffset$1 = (props, index2, alignment, scrollOffset, cache2, type2, scrollBarWidth2) => {
      const [size2, estimatedSizeAssociates] = [
        type2 === "row" ? props.height : props.width,
        ACCESS_ESTIMATED_SIZE_KEY_MAP[type2]
      ];
      const item = getItemFromCache(props, index2, cache2, type2);
      const estimatedSize = estimatedSizeAssociates(props, cache2);
      const maxOffset = max(0, min(estimatedSize - size2, item.offset));
      const minOffset = max(0, item.offset - size2 + scrollBarWidth2 + item.size);
      if (alignment === SMART_ALIGNMENT) {
        if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
          alignment = AUTO_ALIGNMENT;
        } else {
          alignment = CENTERED_ALIGNMENT;
        }
      }
      switch (alignment) {
        case START_ALIGNMENT: {
          return maxOffset;
        }
        case END_ALIGNMENT: {
          return minOffset;
        }
        case CENTERED_ALIGNMENT: {
          return Math.round(minOffset + (maxOffset - minOffset) / 2);
        }
        case AUTO_ALIGNMENT:
        default: {
          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
            return scrollOffset;
          } else if (minOffset > maxOffset) {
            return minOffset;
          } else if (scrollOffset < minOffset) {
            return minOffset;
          } else {
            return maxOffset;
          }
        }
      }
    };
    const DynamicSizeGrid = createGrid({
      name: "ElDynamicSizeGrid",
      getColumnPosition: (props, idx, cache2) => {
        const item = getItemFromCache(props, idx, cache2, "column");
        return [item.size, item.offset];
      },
      getRowPosition: (props, idx, cache2) => {
        const item = getItemFromCache(props, idx, cache2, "row");
        return [item.size, item.offset];
      },
      getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache2, scrollBarWidth2) => getOffset$1(props, columnIndex, alignment, scrollLeft, cache2, "column", scrollBarWidth2),
      getRowOffset: (props, rowIndex, alignment, scrollTop, cache2, scrollBarWidth2) => getOffset$1(props, rowIndex, alignment, scrollTop, cache2, "row", scrollBarWidth2),
      getColumnStartIndexForOffset: (props, scrollLeft, cache2) => findItem(props, cache2, scrollLeft, "column"),
      getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache2) => {
        const item = getItemFromCache(props, startIndex, cache2, "column");
        const maxOffset = scrollLeft + props.width;
        let offset2 = item.offset + item.size;
        let stopIndex = startIndex;
        while (stopIndex < props.totalColumn - 1 && offset2 < maxOffset) {
          stopIndex++;
          offset2 += getItemFromCache(props, startIndex, cache2, "column").size;
        }
        return stopIndex;
      },
      getEstimatedTotalHeight,
      getEstimatedTotalWidth,
      getRowStartIndexForOffset: (props, scrollTop, cache2) => findItem(props, cache2, scrollTop, "row"),
      getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache2) => {
        const { totalRow, height } = props;
        const item = getItemFromCache(props, startIndex, cache2, "row");
        const maxOffset = scrollTop + height;
        let offset2 = item.size + item.offset;
        let stopIndex = startIndex;
        while (stopIndex < totalRow - 1 && offset2 < maxOffset) {
          stopIndex++;
          offset2 += getItemFromCache(props, stopIndex, cache2, "row").size;
        }
        return stopIndex;
      },
      injectToInstance: (instance, cache2) => {
        const resetAfter = ({ columnIndex, rowIndex }, forceUpdate) => {
          var _a2, _b;
          forceUpdate = isUndefined$1(forceUpdate) ? true : forceUpdate;
          if (isNumber$2(columnIndex)) {
            cache2.value.lastVisitedColumnIndex = Math.min(cache2.value.lastVisitedColumnIndex, columnIndex - 1);
          }
          if (isNumber$2(rowIndex)) {
            cache2.value.lastVisitedRowIndex = Math.min(cache2.value.lastVisitedRowIndex, rowIndex - 1);
          }
          (_a2 = instance.exposed) == null ? void 0 : _a2.getItemStyleCache.value(-1, null, null);
          if (forceUpdate)
            (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();
        };
        const resetAfterColumnIndex = (columnIndex, forceUpdate) => {
          resetAfter({
            columnIndex
          }, forceUpdate);
        };
        const resetAfterRowIndex = (rowIndex, forceUpdate) => {
          resetAfter({
            rowIndex
          }, forceUpdate);
        };
        Object.assign(instance.proxy, {
          resetAfterColumnIndex,
          resetAfterRowIndex,
          resetAfter
        });
      },
      initCache: ({
        estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,
        estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE
      }) => {
        const cache2 = {
          column: {},
          estimatedColumnWidth,
          estimatedRowHeight,
          lastVisitedColumnIndex: -1,
          lastVisitedRowIndex: -1,
          row: {}
        };
        return cache2;
      },
      clearCache: false,
      validateProps: ({ columnWidth, rowHeight }) => {
      }
    });
    const _sfc_main$D = defineComponent({
      props: {
        item: {
          type: Object,
          required: true
        },
        style: Object,
        height: Number
      },
      setup() {
        const ns2 = useNamespace("select");
        return {
          ns: ns2
        };
      }
    });
    function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
      return _ctx.item.isTitle ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.ns.be("group", "title")),
        style: normalizeStyle([_ctx.style, { lineHeight: `${_ctx.height}px` }])
      }, toDisplayString$1(_ctx.item.label), 7)) : (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(_ctx.ns.be("group", "split")),
        style: normalizeStyle(_ctx.style)
      }, [
        createBaseVNode("span", {
          class: normalizeClass(_ctx.ns.be("group", "split-dash")),
          style: normalizeStyle({ top: `${_ctx.height / 2}px` })
        }, null, 6)
      ], 6));
    }
    var GroupItem = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$9], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/group-item.vue"]]);
    function useOption(props, { emit }) {
      return {
        hoverItem: () => {
          if (!props.disabled) {
            emit("hover", props.index);
          }
        },
        selectOptionClick: () => {
          if (!props.disabled) {
            emit("select", props.item, props.index);
          }
        }
      };
    }
    const SelectProps = {
      allowCreate: Boolean,
      autocomplete: {
        type: String,
        default: "none"
      },
      automaticDropdown: Boolean,
      clearable: Boolean,
      clearIcon: {
        type: [String, Object],
        default: circle_close_default
      },
      effect: {
        type: String,
        default: "light"
      },
      collapseTags: Boolean,
      collapseTagsTooltip: {
        type: Boolean,
        default: false
      },
      defaultFirstOption: Boolean,
      disabled: Boolean,
      estimatedOptionHeight: {
        type: Number,
        default: void 0
      },
      filterable: Boolean,
      filterMethod: Function,
      height: {
        type: Number,
        default: 170
      },
      itemHeight: {
        type: Number,
        default: 34
      },
      id: String,
      loading: Boolean,
      loadingText: String,
      label: String,
      modelValue: [Array, String, Number, Boolean, Object],
      multiple: Boolean,
      multipleLimit: {
        type: Number,
        default: 0
      },
      name: String,
      noDataText: String,
      noMatchText: String,
      remoteMethod: Function,
      reserveKeyword: {
        type: Boolean,
        default: true
      },
      options: {
        type: Array,
        required: true
      },
      placeholder: {
        type: String
      },
      teleported: useTooltipContentProps.teleported,
      persistent: {
        type: Boolean,
        default: true
      },
      popperClass: {
        type: String,
        default: ""
      },
      popperOptions: {
        type: Object,
        default: () => ({})
      },
      remote: Boolean,
      size: {
        type: String,
        validator: isValidComponentSize
      },
      valueKey: {
        type: String,
        default: "value"
      },
      scrollbarAlwaysOn: {
        type: Boolean,
        default: false
      },
      validateEvent: {
        type: Boolean,
        default: true
      }
    };
    const OptionProps = {
      data: Array,
      disabled: Boolean,
      hovering: Boolean,
      item: Object,
      index: Number,
      style: Object,
      selected: Boolean,
      created: Boolean
    };
    const _sfc_main$C = defineComponent({
      props: OptionProps,
      emits: ["select", "hover"],
      setup(props, { emit }) {
        const ns2 = useNamespace("select");
        const { hoverItem, selectOptionClick } = useOption(props, { emit });
        return {
          ns: ns2,
          hoverItem,
          selectOptionClick
        };
      }
    });
    const _hoisted_1$j = ["aria-selected"];
    function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("li", {
        "aria-selected": _ctx.selected,
        style: normalizeStyle(_ctx.style),
        class: normalizeClass([
          _ctx.ns.be("dropdown", "option-item"),
          _ctx.ns.is("selected", _ctx.selected),
          _ctx.ns.is("disabled", _ctx.disabled),
          _ctx.ns.is("created", _ctx.created),
          { hover: _ctx.hovering }
        ]),
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
        onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
      }, [
        renderSlot(_ctx.$slots, "default", {
          item: _ctx.item,
          index: _ctx.index,
          disabled: _ctx.disabled
        }, () => [
          createBaseVNode("span", null, toDisplayString$1(_ctx.item.label), 1)
        ])
      ], 46, _hoisted_1$j);
    }
    var OptionItem = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$8], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/option-item.vue"]]);
    const selectV2InjectionKey = "ElSelectV2Injection";
    var ElSelectMenu = defineComponent({
      name: "ElSelectDropdown",
      props: {
        data: {
          type: Array,
          required: true
        },
        hoveringIndex: Number,
        width: Number
      },
      setup(props, {
        slots,
        expose
      }) {
        const select = inject(selectV2InjectionKey);
        const ns2 = useNamespace("select");
        const cachedHeights = ref([]);
        const listRef = ref();
        const isSized = computed(() => isUndefined$1(select.props.estimatedOptionHeight));
        const listProps = computed(() => {
          if (isSized.value) {
            return {
              itemSize: select.props.itemHeight
            };
          }
          return {
            estimatedSize: select.props.estimatedOptionHeight,
            itemSize: (idx) => cachedHeights.value[idx]
          };
        });
        const contains2 = (arr = [], target) => {
          const {
            props: {
              valueKey
            }
          } = select;
          if (!isObject$4(target)) {
            return arr.includes(target);
          }
          return arr && arr.some((item) => {
            return get(item, valueKey) === get(target, valueKey);
          });
        };
        const isEqual2 = (selected, target) => {
          if (!isObject$4(target)) {
            return selected === target;
          } else {
            const {
              valueKey
            } = select.props;
            return get(selected, valueKey) === get(target, valueKey);
          }
        };
        const isItemSelected = (modelValue, target) => {
          const {
            valueKey
          } = select.props;
          if (select.props.multiple) {
            return contains2(modelValue, get(target, valueKey));
          }
          return isEqual2(modelValue, get(target, valueKey));
        };
        const isItemDisabled = (modelValue, selected) => {
          const {
            disabled,
            multiple,
            multipleLimit
          } = select.props;
          return disabled || !selected && (multiple ? multipleLimit > 0 && modelValue.length >= multipleLimit : false);
        };
        const isItemHovering = (target) => props.hoveringIndex === target;
        const scrollToItem = (index2) => {
          const list = listRef.value;
          if (list) {
            list.scrollToItem(index2);
          }
        };
        const resetScrollTop = () => {
          const list = listRef.value;
          if (list) {
            list.resetScrollTop();
          }
        };
        expose({
          listRef,
          isSized,
          isItemDisabled,
          isItemHovering,
          isItemSelected,
          scrollToItem,
          resetScrollTop
        });
        const Item = (itemProps) => {
          const {
            index: index2,
            data,
            style: style2
          } = itemProps;
          const sized = unref(isSized);
          const {
            itemSize: itemSize2,
            estimatedSize
          } = unref(listProps);
          const {
            modelValue
          } = select.props;
          const {
            onSelect,
            onHover
          } = select;
          const item = data[index2];
          if (item.type === "Group") {
            return createVNode(GroupItem, {
              "item": item,
              "style": style2,
              "height": sized ? itemSize2 : estimatedSize
            }, null);
          }
          const isSelected = isItemSelected(modelValue, item);
          const isDisabled = isItemDisabled(modelValue, isSelected);
          const isHovering = isItemHovering(index2);
          return createVNode(OptionItem, mergeProps(itemProps, {
            "selected": isSelected,
            "disabled": item.disabled || isDisabled,
            "created": !!item.created,
            "hovering": isHovering,
            "item": item,
            "onSelect": onSelect,
            "onHover": onHover
          }), {
            default: (props2) => {
              var _a2;
              return ((_a2 = slots.default) == null ? void 0 : _a2.call(slots, props2)) || createVNode("span", null, [item.label]);
            }
          });
        };
        const {
          onKeyboardNavigate,
          onKeyboardSelect
        } = select;
        const onForward = () => {
          onKeyboardNavigate("forward");
        };
        const onBackward = () => {
          onKeyboardNavigate("backward");
        };
        const onEscOrTab = () => {
          select.expanded = false;
        };
        const onKeydown = (e) => {
          const {
            code: code2
          } = e;
          const {
            tab,
            esc,
            down: down2,
            up: up2,
            enter
          } = EVENT_CODE;
          if (code2 !== tab) {
            e.preventDefault();
            e.stopPropagation();
          }
          switch (code2) {
            case tab:
            case esc: {
              onEscOrTab();
              break;
            }
            case down2: {
              onForward();
              break;
            }
            case up2: {
              onBackward();
              break;
            }
            case enter: {
              onKeyboardSelect();
              break;
            }
          }
        };
        return () => {
          var _a2;
          const {
            data,
            width
          } = props;
          const {
            height,
            multiple,
            scrollbarAlwaysOn
          } = select.props;
          if (data.length === 0) {
            return createVNode("div", {
              "class": ns2.b("dropdown"),
              "style": {
                width: `${width}px`
              }
            }, [(_a2 = slots.empty) == null ? void 0 : _a2.call(slots)]);
          }
          const List = unref(isSized) ? FixedSizeList : DynamicSizeList;
          return createVNode("div", {
            "class": [ns2.b("dropdown"), ns2.is("multiple", multiple)]
          }, [createVNode(List, mergeProps({
            "ref": listRef
          }, unref(listProps), {
            "className": ns2.be("dropdown", "list"),
            "scrollbarAlwaysOn": scrollbarAlwaysOn,
            "data": data,
            "height": height,
            "width": width,
            "total": data.length,
            "onKeydown": onKeydown
          }), {
            default: (props2) => createVNode(Item, props2, null)
          })]);
        };
      }
    });
    function useAllowCreate(props, states) {
      const createOptionCount = ref(0);
      const cachedSelectedOption = ref(null);
      const enableAllowCreateMode = computed(() => {
        return props.allowCreate && props.filterable;
      });
      function hasExistingOption(query) {
        const hasValue = (option) => option.value === query;
        return props.options && props.options.some(hasValue) || states.createdOptions.some(hasValue);
      }
      function selectNewOption(option) {
        if (!enableAllowCreateMode.value) {
          return;
        }
        if (props.multiple && option.created) {
          createOptionCount.value++;
        } else {
          cachedSelectedOption.value = option;
        }
      }
      function createNewOption(query) {
        if (enableAllowCreateMode.value) {
          if (query && query.length > 0 && !hasExistingOption(query)) {
            const newOption = {
              value: query,
              label: query,
              created: true,
              disabled: false
            };
            if (states.createdOptions.length >= createOptionCount.value) {
              states.createdOptions[createOptionCount.value] = newOption;
            } else {
              states.createdOptions.push(newOption);
            }
          } else {
            if (props.multiple) {
              states.createdOptions.length = createOptionCount.value;
            } else {
              const selectedOption = cachedSelectedOption.value;
              states.createdOptions.length = 0;
              if (selectedOption && selectedOption.created) {
                states.createdOptions.push(selectedOption);
              }
            }
          }
        }
      }
      function removeNewOption(option) {
        if (!enableAllowCreateMode.value || !option || !option.created || option.created && props.reserveKeyword && states.inputValue === option.label) {
          return;
        }
        const idx = states.createdOptions.findIndex((it2) => it2.value === option.value);
        if (~idx) {
          states.createdOptions.splice(idx, 1);
          createOptionCount.value--;
        }
      }
      function clearAllNewOption() {
        if (enableAllowCreateMode.value) {
          states.createdOptions.length = 0;
          createOptionCount.value = 0;
        }
      }
      return {
        createNewOption,
        removeNewOption,
        selectNewOption,
        clearAllNewOption
      };
    }
    const flattenOptions = (options) => {
      const flattened = [];
      options.forEach((option) => {
        if (isArray$4(option.options)) {
          flattened.push({
            label: option.label,
            isTitle: true,
            type: "Group"
          });
          option.options.forEach((o2) => {
            flattened.push(o2);
          });
          flattened.push({
            type: "Group"
          });
        } else {
          flattened.push(option);
        }
      });
      return flattened;
    };
    function useInput(handleInput) {
      const isComposing = ref(false);
      const handleCompositionStart = () => {
        isComposing.value = true;
      };
      const handleCompositionUpdate = (event) => {
        const text = event.target.value;
        const lastCharacter = text[text.length - 1] || "";
        isComposing.value = !isKorean(lastCharacter);
      };
      const handleCompositionEnd = (event) => {
        if (isComposing.value) {
          isComposing.value = false;
          if (isFunction$4(handleInput)) {
            handleInput(event);
          }
        }
      };
      return {
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd
      };
    }
    const DEFAULT_INPUT_PLACEHOLDER = "";
    const MINIMUM_INPUT_WIDTH = 11;
    const TAG_BASE_WIDTH = {
      larget: 51,
      default: 42,
      small: 33
    };
    const useSelect$1 = (props, emit) => {
      const { t } = useLocale();
      const nsSelectV2 = useNamespace("select-v2");
      const nsInput = useNamespace("input");
      const { form: elForm, formItem: elFormItem } = useFormItem();
      const states = reactive({
        inputValue: DEFAULT_INPUT_PLACEHOLDER,
        displayInputValue: DEFAULT_INPUT_PLACEHOLDER,
        calculatedWidth: 0,
        cachedPlaceholder: "",
        cachedOptions: [],
        createdOptions: [],
        createdLabel: "",
        createdSelected: false,
        currentPlaceholder: "",
        hoveringIndex: -1,
        comboBoxHovering: false,
        isOnComposition: false,
        isSilentBlur: false,
        isComposing: false,
        inputLength: 20,
        selectWidth: 200,
        initialInputHeight: 0,
        previousQuery: null,
        previousValue: "",
        query: "",
        selectedLabel: "",
        softFocus: false,
        tagInMultiLine: false
      });
      const selectedIndex = ref(-1);
      const popperSize = ref(-1);
      const controlRef = ref(null);
      const inputRef = ref(null);
      const menuRef = ref(null);
      const popper = ref(null);
      const selectRef = ref(null);
      const selectionRef = ref(null);
      const calculatorRef = ref(null);
      const expanded = ref(false);
      const selectDisabled = computed(() => props.disabled || (elForm == null ? void 0 : elForm.disabled));
      const popupHeight = computed(() => {
        const totalHeight = filteredOptions.value.length * 34;
        return totalHeight > props.height ? props.height : totalHeight;
      });
      const hasModelValue = computed(() => {
        return props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
      });
      const showClearBtn = computed(() => {
        const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : hasModelValue.value;
        const criteria = props.clearable && !selectDisabled.value && states.comboBoxHovering && hasValue;
        return criteria;
      });
      const iconComponent = computed(() => props.remote && props.filterable ? "" : arrow_up_default);
      const iconReverse = computed(() => iconComponent.value && nsSelectV2.is("reverse", expanded.value));
      const validateState = computed(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
      const validateIcon = computed(() => ValidateComponentsMap[validateState.value]);
      const debounce$1 = computed(() => props.remote ? 300 : 0);
      const emptyText = computed(() => {
        const options = filteredOptions.value;
        if (props.loading) {
          return props.loadingText || t("el.select.loading");
        } else {
          if (props.remote && states.inputValue === "" && options.length === 0)
            return false;
          if (props.filterable && states.inputValue && options.length > 0) {
            return props.noMatchText || t("el.select.noMatch");
          }
          if (options.length === 0) {
            return props.noDataText || t("el.select.noData");
          }
        }
        return null;
      });
      const filteredOptions = computed(() => {
        const isValidOption = (o2) => {
          var _a2;
          const query = states.inputValue;
          const containsQueryString = query ? (_a2 = o2.label) == null ? void 0 : _a2.includes(query) : true;
          return containsQueryString;
        };
        if (props.loading) {
          return [];
        }
        return flattenOptions(props.options.concat(states.createdOptions).map((v2) => {
          if (isArray$4(v2.options)) {
            const filtered = v2.options.filter(isValidOption);
            if (filtered.length > 0) {
              return {
                ...v2,
                options: filtered
              };
            }
          } else {
            if (props.remote || isValidOption(v2)) {
              return v2;
            }
          }
          return null;
        }).filter((v2) => v2 !== null));
      });
      const optionsAllDisabled = computed(() => filteredOptions.value.every((option) => option.disabled));
      const selectSize = useSize();
      const collapseTagSize = computed(() => selectSize.value === "small" ? "small" : "default");
      const tagMaxWidth = computed(() => {
        const select = selectionRef.value;
        const size2 = collapseTagSize.value || "default";
        const paddingLeft = select ? Number.parseInt(getComputedStyle(select).paddingLeft) : 0;
        const paddingRight = select ? Number.parseInt(getComputedStyle(select).paddingRight) : 0;
        return states.selectWidth - paddingRight - paddingLeft - TAG_BASE_WIDTH[size2];
      });
      const calculatePopperSize = () => {
        var _a2;
        popperSize.value = ((_a2 = selectRef.value) == null ? void 0 : _a2.offsetWidth) || 200;
      };
      const inputWrapperStyle = computed(() => {
        return {
          width: `${states.calculatedWidth === 0 ? MINIMUM_INPUT_WIDTH : Math.ceil(states.calculatedWidth) + MINIMUM_INPUT_WIDTH}px`
        };
      });
      const shouldShowPlaceholder = computed(() => {
        if (isArray$4(props.modelValue)) {
          return props.modelValue.length === 0 && !states.displayInputValue;
        }
        return props.filterable ? states.displayInputValue.length === 0 : true;
      });
      const currentPlaceholder = computed(() => {
        const _placeholder = props.placeholder || t("el.select.placeholder");
        return props.multiple ? _placeholder : states.selectedLabel || _placeholder;
      });
      const popperRef = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = popper.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
      });
      const indexRef = computed(() => {
        if (props.multiple) {
          const len = props.modelValue.length;
          if (props.modelValue.length > 0) {
            return filteredOptions.value.findIndex((o2) => o2.value === props.modelValue[len - 1]);
          }
        } else {
          if (props.modelValue) {
            return filteredOptions.value.findIndex((o2) => o2.value === props.modelValue);
          }
        }
        return -1;
      });
      const dropdownMenuVisible = computed({
        get() {
          return expanded.value && emptyText.value !== false;
        },
        set(val) {
          expanded.value = val;
        }
      });
      const {
        createNewOption,
        removeNewOption,
        selectNewOption,
        clearAllNewOption
      } = useAllowCreate(props, states);
      const {
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd
      } = useInput((e) => onInput(e));
      const focusAndUpdatePopup = () => {
        var _a2, _b, _c;
        (_b = (_a2 = inputRef.value).focus) == null ? void 0 : _b.call(_a2);
        (_c = popper.value) == null ? void 0 : _c.updatePopper();
      };
      const toggleMenu = () => {
        if (props.automaticDropdown)
          return;
        if (!selectDisabled.value) {
          if (states.isComposing)
            states.softFocus = true;
          return nextTick(() => {
            var _a2, _b;
            expanded.value = !expanded.value;
            (_b = (_a2 = inputRef.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
          });
        }
      };
      const onInputChange = () => {
        if (props.filterable && states.inputValue !== states.selectedLabel) {
          states.query = states.selectedLabel;
        }
        handleQueryChange(states.inputValue);
        return nextTick(() => {
          createNewOption(states.inputValue);
        });
      };
      const debouncedOnInputChange = debounce(onInputChange, debounce$1.value);
      const handleQueryChange = (val) => {
        if (states.previousQuery === val) {
          return;
        }
        states.previousQuery = val;
        if (props.filterable && isFunction$4(props.filterMethod)) {
          props.filterMethod(val);
        } else if (props.filterable && props.remote && isFunction$4(props.remoteMethod)) {
          props.remoteMethod(val);
        }
      };
      const emitChange = (val) => {
        if (!isEqual$1(props.modelValue, val)) {
          emit(CHANGE_EVENT, val);
        }
      };
      const update = (val) => {
        emit(UPDATE_MODEL_EVENT, val);
        emitChange(val);
        states.previousValue = val.toString();
      };
      const getValueIndex = (arr = [], value) => {
        if (!isObject$4(value)) {
          return arr.indexOf(value);
        }
        const valueKey = props.valueKey;
        let index2 = -1;
        arr.some((item, i) => {
          if (get(item, valueKey) === get(value, valueKey)) {
            index2 = i;
            return true;
          }
          return false;
        });
        return index2;
      };
      const getValueKey = (item) => {
        return isObject$4(item) ? get(item, props.valueKey) : item;
      };
      const getLabel = (item) => {
        return isObject$4(item) ? item.label : item;
      };
      const resetInputHeight = () => {
        if (props.collapseTags && !props.filterable) {
          return;
        }
        return nextTick(() => {
          var _a2, _b;
          if (!inputRef.value)
            return;
          const selection = selectionRef.value;
          selectRef.value.height = selection.offsetHeight;
          if (expanded.value && emptyText.value !== false) {
            (_b = (_a2 = popper.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          }
        });
      };
      const handleResize = () => {
        var _a2, _b;
        resetInputWidth();
        calculatePopperSize();
        (_b = (_a2 = popper.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        if (props.multiple) {
          return resetInputHeight();
        }
      };
      const resetInputWidth = () => {
        const select = selectionRef.value;
        if (select) {
          states.selectWidth = select.getBoundingClientRect().width;
        }
      };
      const onSelect = (option, idx, byClick = true) => {
        var _a2, _b;
        if (props.multiple) {
          let selectedOptions = props.modelValue.slice();
          const index2 = getValueIndex(selectedOptions, getValueKey(option));
          if (index2 > -1) {
            selectedOptions = [
              ...selectedOptions.slice(0, index2),
              ...selectedOptions.slice(index2 + 1)
            ];
            states.cachedOptions.splice(index2, 1);
            removeNewOption(option);
          } else if (props.multipleLimit <= 0 || selectedOptions.length < props.multipleLimit) {
            selectedOptions = [...selectedOptions, getValueKey(option)];
            states.cachedOptions.push(option);
            selectNewOption(option);
            updateHoveringIndex(idx);
          }
          update(selectedOptions);
          if (option.created) {
            states.query = "";
            handleQueryChange("");
            states.inputLength = 20;
          }
          if (props.filterable && !props.reserveKeyword) {
            (_b = (_a2 = inputRef.value).focus) == null ? void 0 : _b.call(_a2);
            onUpdateInputValue("");
          }
          if (props.filterable) {
            states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
          }
          resetInputHeight();
          setSoftFocus();
        } else {
          selectedIndex.value = idx;
          states.selectedLabel = option.label;
          update(getValueKey(option));
          expanded.value = false;
          states.isComposing = false;
          states.isSilentBlur = byClick;
          selectNewOption(option);
          if (!option.created) {
            clearAllNewOption();
          }
          updateHoveringIndex(idx);
        }
      };
      const deleteTag = (event, tag) => {
        const { valueKey } = props;
        const index2 = props.modelValue.indexOf(get(tag, valueKey));
        if (index2 > -1 && !selectDisabled.value) {
          const value = [
            ...props.modelValue.slice(0, index2),
            ...props.modelValue.slice(index2 + 1)
          ];
          states.cachedOptions.splice(index2, 1);
          update(value);
          emit("remove-tag", get(tag, valueKey));
          states.softFocus = true;
          removeNewOption(tag);
          return nextTick(focusAndUpdatePopup);
        }
        event.stopPropagation();
      };
      const handleFocus = (event) => {
        const focused = states.isComposing;
        states.isComposing = true;
        if (!states.softFocus) {
          if (!focused)
            emit("focus", event);
        } else {
          states.softFocus = false;
        }
      };
      const handleBlur = (event) => {
        states.softFocus = false;
        return nextTick(() => {
          var _a2, _b;
          (_b = (_a2 = inputRef.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
          if (calculatorRef.value) {
            states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
          }
          if (states.isSilentBlur) {
            states.isSilentBlur = false;
          } else {
            if (states.isComposing) {
              emit("blur", event);
            }
          }
          states.isComposing = false;
        });
      };
      const handleEsc = () => {
        if (states.displayInputValue.length > 0) {
          onUpdateInputValue("");
        } else {
          expanded.value = false;
        }
      };
      const handleDel = (e) => {
        if (states.displayInputValue.length === 0) {
          e.preventDefault();
          const selected = props.modelValue.slice();
          selected.pop();
          removeNewOption(states.cachedOptions.pop());
          update(selected);
        }
      };
      const handleClear = () => {
        let emptyValue;
        if (isArray$4(props.modelValue)) {
          emptyValue = [];
        } else {
          emptyValue = "";
        }
        states.softFocus = true;
        if (props.multiple) {
          states.cachedOptions = [];
        } else {
          states.selectedLabel = "";
        }
        expanded.value = false;
        update(emptyValue);
        emit("clear");
        clearAllNewOption();
        return nextTick(focusAndUpdatePopup);
      };
      const onUpdateInputValue = (val) => {
        states.displayInputValue = val;
        states.inputValue = val;
      };
      const onKeyboardNavigate = (direction2, hoveringIndex = void 0) => {
        const options = filteredOptions.value;
        if (!["forward", "backward"].includes(direction2) || selectDisabled.value || options.length <= 0 || optionsAllDisabled.value) {
          return;
        }
        if (!expanded.value) {
          return toggleMenu();
        }
        if (hoveringIndex === void 0) {
          hoveringIndex = states.hoveringIndex;
        }
        let newIndex = -1;
        if (direction2 === "forward") {
          newIndex = hoveringIndex + 1;
          if (newIndex >= options.length) {
            newIndex = 0;
          }
        } else if (direction2 === "backward") {
          newIndex = hoveringIndex - 1;
          if (newIndex < 0) {
            newIndex = options.length - 1;
          }
        }
        const option = options[newIndex];
        if (option.disabled || option.type === "Group") {
          return onKeyboardNavigate(direction2, newIndex);
        } else {
          updateHoveringIndex(newIndex);
          scrollToItem(newIndex);
        }
      };
      const onKeyboardSelect = () => {
        if (!expanded.value) {
          return toggleMenu();
        } else if (~states.hoveringIndex && filteredOptions.value[states.hoveringIndex]) {
          onSelect(filteredOptions.value[states.hoveringIndex], states.hoveringIndex, false);
        }
      };
      const updateHoveringIndex = (idx) => {
        states.hoveringIndex = idx;
      };
      const resetHoveringIndex = () => {
        states.hoveringIndex = -1;
      };
      const setSoftFocus = () => {
        var _a2;
        const _input = inputRef.value;
        if (_input) {
          (_a2 = _input.focus) == null ? void 0 : _a2.call(_input);
        }
      };
      const onInput = (event) => {
        const value = event.target.value;
        onUpdateInputValue(value);
        if (states.displayInputValue.length > 0 && !expanded.value) {
          expanded.value = true;
        }
        states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
        if (props.multiple) {
          resetInputHeight();
        }
        if (props.remote) {
          debouncedOnInputChange();
        } else {
          return onInputChange();
        }
      };
      const handleClickOutside = () => {
        expanded.value = false;
        return handleBlur();
      };
      const handleMenuEnter = () => {
        states.inputValue = states.displayInputValue;
        return nextTick(() => {
          if (~indexRef.value) {
            updateHoveringIndex(indexRef.value);
            scrollToItem(states.hoveringIndex);
          }
        });
      };
      const scrollToItem = (index2) => {
        menuRef.value.scrollToItem(index2);
      };
      const initStates = () => {
        resetHoveringIndex();
        if (props.multiple) {
          if (props.modelValue.length > 0) {
            let initHovering = false;
            states.cachedOptions.length = 0;
            states.previousValue = props.modelValue.toString();
            props.modelValue.forEach((selected) => {
              const itemIndex = filteredOptions.value.findIndex((option) => getValueKey(option) === selected);
              if (~itemIndex) {
                states.cachedOptions.push(filteredOptions.value[itemIndex]);
                if (!initHovering) {
                  updateHoveringIndex(itemIndex);
                }
                initHovering = true;
              }
            });
          } else {
            states.cachedOptions = [];
            states.previousValue = "";
          }
        } else {
          if (hasModelValue.value) {
            states.previousValue = props.modelValue;
            const options = filteredOptions.value;
            const selectedItemIndex = options.findIndex((option) => getValueKey(option) === getValueKey(props.modelValue));
            if (~selectedItemIndex) {
              states.selectedLabel = options[selectedItemIndex].label;
              updateHoveringIndex(selectedItemIndex);
            } else {
              states.selectedLabel = `${props.modelValue}`;
            }
          } else {
            states.selectedLabel = "";
            states.previousValue = "";
          }
        }
        clearAllNewOption();
        calculatePopperSize();
      };
      watch(expanded, (val) => {
        var _a2, _b;
        emit("visible-change", val);
        if (val) {
          (_b = (_a2 = popper.value).update) == null ? void 0 : _b.call(_a2);
        } else {
          states.displayInputValue = "";
          states.previousQuery = null;
          createNewOption("");
        }
      });
      watch(() => props.modelValue, (val, oldVal) => {
        var _a2;
        if (!val || val.toString() !== states.previousValue) {
          initStates();
        }
        if (!isEqual$1(val, oldVal) && props.validateEvent) {
          (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
        }
      }, {
        deep: true
      });
      watch(() => props.options, () => {
        const input = inputRef.value;
        if (!input || input && document.activeElement !== input) {
          initStates();
        }
      }, {
        deep: true
      });
      watch(filteredOptions, () => {
        return nextTick(menuRef.value.resetScrollTop);
      });
      onMounted(() => {
        initStates();
      });
      useResizeObserver(selectRef, handleResize);
      return {
        collapseTagSize,
        currentPlaceholder,
        expanded,
        emptyText,
        popupHeight,
        debounce: debounce$1,
        filteredOptions,
        iconComponent,
        iconReverse,
        inputWrapperStyle,
        popperSize,
        dropdownMenuVisible,
        hasModelValue,
        shouldShowPlaceholder,
        selectDisabled,
        selectSize,
        showClearBtn,
        states,
        tagMaxWidth,
        nsSelectV2,
        nsInput,
        calculatorRef,
        controlRef,
        inputRef,
        menuRef,
        popper,
        selectRef,
        selectionRef,
        popperRef,
        validateState,
        validateIcon,
        debouncedOnInputChange,
        deleteTag,
        getLabel,
        getValueKey,
        handleBlur,
        handleClear,
        handleClickOutside,
        handleDel,
        handleEsc,
        handleFocus,
        handleMenuEnter,
        handleResize,
        toggleMenu,
        scrollTo: scrollToItem,
        onInput,
        onKeyboardNavigate,
        onKeyboardSelect,
        onSelect,
        onHover: updateHoveringIndex,
        onUpdateInputValue,
        handleCompositionStart,
        handleCompositionEnd,
        handleCompositionUpdate
      };
    };
    const _sfc_main$B = defineComponent({
      name: "ElSelectV2",
      components: {
        ElSelectMenu,
        ElTag,
        ElTooltip,
        ElIcon
      },
      directives: { ClickOutside, ModelText: vModelText },
      props: SelectProps,
      emits: [
        UPDATE_MODEL_EVENT,
        CHANGE_EVENT,
        "remove-tag",
        "clear",
        "visible-change",
        "focus",
        "blur"
      ],
      setup(props, { emit }) {
        const API = useSelect$1(props, emit);
        provide(selectV2InjectionKey, {
          props: reactive({
            ...toRefs(props),
            height: API.popupHeight
          }),
          onSelect: API.onSelect,
          onHover: API.onHover,
          onKeyboardNavigate: API.onKeyboardNavigate,
          onKeyboardSelect: API.onKeyboardSelect
        });
        return API;
      }
    });
    const _hoisted_1$i = { key: 0 };
    const _hoisted_2$d = ["id", "autocomplete", "aria-expanded", "aria-labelledby", "disabled", "readonly", "name", "unselectable"];
    const _hoisted_3$7 = ["textContent"];
    const _hoisted_4$5 = ["id", "aria-labelledby", "aria-expanded", "autocomplete", "disabled", "name", "readonly", "unselectable"];
    const _hoisted_5$4 = ["textContent"];
    function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_tag = resolveComponent("el-tag");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_select_menu = resolveComponent("el-select-menu");
      const _directive_model_text = resolveDirective("model-text");
      const _directive_click_outside = resolveDirective("click-outside");
      return withDirectives((openBlock(), createElementBlock("div", {
        ref: "selectRef",
        class: normalizeClass([_ctx.nsSelectV2.b(), _ctx.nsSelectV2.m(_ctx.selectSize)]),
        onClick: _cache[25] || (_cache[25] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"])),
        onMouseenter: _cache[26] || (_cache[26] = ($event) => _ctx.states.comboBoxHovering = true),
        onMouseleave: _cache[27] || (_cache[27] = ($event) => _ctx.states.comboBoxHovering = false)
      }, [
        createVNode(_component_el_tooltip, {
          ref: "popper",
          visible: _ctx.dropdownMenuVisible,
          teleported: _ctx.teleported,
          "popper-class": [_ctx.nsSelectV2.e("popper"), _ctx.popperClass],
          "gpu-acceleration": false,
          "stop-popper-mouse-event": false,
          "popper-options": _ctx.popperOptions,
          "fallback-placements": ["bottom-start", "top-start", "right", "left"],
          effect: _ctx.effect,
          placement: "bottom-start",
          pure: "",
          transition: `${_ctx.nsSelectV2.namespace.value}-zoom-in-top`,
          trigger: "click",
          persistent: _ctx.persistent,
          onBeforeShow: _ctx.handleMenuEnter,
          onHide: _cache[24] || (_cache[24] = ($event) => _ctx.states.inputValue = _ctx.states.displayInputValue)
        }, {
          default: withCtx(() => {
            var _a2;
            return [
              createBaseVNode("div", {
                ref: "selectionRef",
                class: normalizeClass([
                  _ctx.nsSelectV2.e("wrapper"),
                  _ctx.nsSelectV2.is("focused", _ctx.states.isComposing),
                  _ctx.nsSelectV2.is("hovering", _ctx.states.comboBoxHovering),
                  _ctx.nsSelectV2.is("filterable", _ctx.filterable),
                  _ctx.nsSelectV2.is("disabled", _ctx.selectDisabled)
                ])
              }, [
                _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", _hoisted_1$i, [
                  renderSlot(_ctx.$slots, "prefix")
                ])) : createCommentVNode("v-if", true),
                _ctx.multiple ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(_ctx.nsSelectV2.e("selection"))
                }, [
                  _ctx.collapseTags && _ctx.modelValue.length > 0 ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                  }, [
                    createVNode(_component_el_tag, {
                      closable: !_ctx.selectDisabled && !((_a2 = _ctx.states.cachedOptions[0]) == null ? void 0 : _a2.disable),
                      size: _ctx.collapseTagSize,
                      type: "info",
                      "disable-transitions": "",
                      onClose: _cache[0] || (_cache[0] = ($event) => _ctx.deleteTag($event, _ctx.states.cachedOptions[0]))
                    }, {
                      default: withCtx(() => {
                        var _a22;
                        return [
                          createBaseVNode("span", {
                            class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                            style: normalizeStyle({
                              maxWidth: `${_ctx.tagMaxWidth}px`
                            })
                          }, toDisplayString$1((_a22 = _ctx.states.cachedOptions[0]) == null ? void 0 : _a22.label), 7)
                        ];
                      }),
                      _: 1
                    }, 8, ["closable", "size"]),
                    _ctx.modelValue.length > 1 ? (openBlock(), createBlock(_component_el_tag, {
                      key: 0,
                      closable: false,
                      size: _ctx.collapseTagSize,
                      type: "info",
                      "disable-transitions": ""
                    }, {
                      default: withCtx(() => [
                        _ctx.collapseTagsTooltip ? (openBlock(), createBlock(_component_el_tooltip, {
                          key: 0,
                          disabled: _ctx.dropdownMenuVisible,
                          "fallback-placements": ["bottom", "top", "right", "left"],
                          effect: _ctx.effect,
                          placement: "bottom",
                          teleported: false
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", {
                              class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                              style: normalizeStyle({
                                maxWidth: `${_ctx.tagMaxWidth}px`
                              })
                            }, "+ " + toDisplayString$1(_ctx.modelValue.length - 1), 7)
                          ]),
                          content: withCtx(() => [
                            createBaseVNode("div", {
                              class: normalizeClass(_ctx.nsSelectV2.e("selection"))
                            }, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.states.cachedOptions.slice(1), (selected, idx) => {
                                return openBlock(), createElementBlock("div", {
                                  key: idx,
                                  class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                                }, [
                                  (openBlock(), createBlock(_component_el_tag, {
                                    key: _ctx.getValueKey(selected),
                                    closable: !_ctx.selectDisabled && !selected.disabled,
                                    size: _ctx.collapseTagSize,
                                    class: "in-tooltip",
                                    type: "info",
                                    "disable-transitions": "",
                                    onClose: ($event) => _ctx.deleteTag($event, selected)
                                  }, {
                                    default: withCtx(() => [
                                      createBaseVNode("span", {
                                        class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                                        style: normalizeStyle({
                                          maxWidth: `${_ctx.tagMaxWidth}px`
                                        })
                                      }, toDisplayString$1(_ctx.getLabel(selected)), 7)
                                    ]),
                                    _: 2
                                  }, 1032, ["closable", "size", "onClose"]))
                                ], 2);
                              }), 128))
                            ], 2)
                          ]),
                          _: 1
                        }, 8, ["disabled", "effect"])) : (openBlock(), createElementBlock("span", {
                          key: 1,
                          class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                          style: normalizeStyle({
                            maxWidth: `${_ctx.tagMaxWidth}px`
                          })
                        }, "+ " + toDisplayString$1(_ctx.modelValue.length - 1), 7))
                      ]),
                      _: 1
                    }, 8, ["size"])) : createCommentVNode("v-if", true)
                  ], 2)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.states.cachedOptions, (selected, idx) => {
                    return openBlock(), createElementBlock("div", {
                      key: idx,
                      class: normalizeClass(_ctx.nsSelectV2.e("selected-item"))
                    }, [
                      (openBlock(), createBlock(_component_el_tag, {
                        key: _ctx.getValueKey(selected),
                        closable: !_ctx.selectDisabled && !selected.disabled,
                        size: _ctx.collapseTagSize,
                        type: "info",
                        "disable-transitions": "",
                        onClose: ($event) => _ctx.deleteTag($event, selected)
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("span", {
                            class: normalizeClass(_ctx.nsSelectV2.e("tags-text")),
                            style: normalizeStyle({
                              maxWidth: `${_ctx.tagMaxWidth}px`
                            })
                          }, toDisplayString$1(_ctx.getLabel(selected)), 7)
                        ]),
                        _: 2
                      }, 1032, ["closable", "size", "onClose"]))
                    ], 2);
                  }), 128)),
                  createBaseVNode("div", {
                    class: normalizeClass([
                      _ctx.nsSelectV2.e("selected-item"),
                      _ctx.nsSelectV2.e("input-wrapper")
                    ]),
                    style: normalizeStyle(_ctx.inputWrapperStyle)
                  }, [
                    withDirectives(createBaseVNode("input", {
                      id: _ctx.id,
                      ref: "inputRef",
                      autocomplete: _ctx.autocomplete,
                      "aria-autocomplete": "list",
                      "aria-haspopup": "listbox",
                      autocapitalize: "off",
                      "aria-expanded": _ctx.expanded,
                      "aria-labelledby": _ctx.label,
                      class: normalizeClass([
                        _ctx.nsSelectV2.is(_ctx.selectSize),
                        _ctx.nsSelectV2.e("combobox-input")
                      ]),
                      disabled: _ctx.disabled,
                      role: "combobox",
                      readonly: !_ctx.filterable,
                      spellcheck: "false",
                      type: "text",
                      name: _ctx.name,
                      unselectable: _ctx.expanded ? "on" : void 0,
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args)),
                      onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                      onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                      onInput: _cache[4] || (_cache[4] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                      onCompositionstart: _cache[5] || (_cache[5] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                      onCompositionupdate: _cache[6] || (_cache[6] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                      onCompositionend: _cache[7] || (_cache[7] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                      onKeydown: [
                        _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                        _cache[9] || (_cache[9] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                        _cache[10] || (_cache[10] = withKeys(withModifiers((...args) => _ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args), ["stop", "prevent"]), ["enter"])),
                        _cache[11] || (_cache[11] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                        _cache[12] || (_cache[12] = withKeys(withModifiers((...args) => _ctx.handleDel && _ctx.handleDel(...args), ["stop"]), ["delete"]))
                      ]
                    }, null, 42, _hoisted_2$d), [
                      [_directive_model_text, _ctx.states.displayInputValue]
                    ]),
                    _ctx.filterable ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      ref: "calculatorRef",
                      "aria-hidden": "true",
                      class: normalizeClass(_ctx.nsSelectV2.e("input-calculator")),
                      textContent: toDisplayString$1(_ctx.states.displayInputValue)
                    }, null, 10, _hoisted_3$7)) : createCommentVNode("v-if", true)
                  ], 6)
                ], 2)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                  createBaseVNode("div", {
                    class: normalizeClass([
                      _ctx.nsSelectV2.e("selected-item"),
                      _ctx.nsSelectV2.e("input-wrapper")
                    ])
                  }, [
                    withDirectives(createBaseVNode("input", {
                      id: _ctx.id,
                      ref: "inputRef",
                      "aria-autocomplete": "list",
                      "aria-haspopup": "listbox",
                      "aria-labelledby": _ctx.label,
                      "aria-expanded": _ctx.expanded,
                      autocapitalize: "off",
                      autocomplete: _ctx.autocomplete,
                      class: normalizeClass(_ctx.nsSelectV2.e("combobox-input")),
                      disabled: _ctx.disabled,
                      name: _ctx.name,
                      role: "combobox",
                      readonly: !_ctx.filterable,
                      spellcheck: "false",
                      type: "text",
                      unselectable: _ctx.expanded ? "on" : void 0,
                      onCompositionstart: _cache[13] || (_cache[13] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                      onCompositionupdate: _cache[14] || (_cache[14] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                      onCompositionend: _cache[15] || (_cache[15] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                      onFocus: _cache[16] || (_cache[16] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                      onBlur: _cache[17] || (_cache[17] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                      onInput: _cache[18] || (_cache[18] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                      onKeydown: [
                        _cache[19] || (_cache[19] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                        _cache[20] || (_cache[20] = withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                        _cache[21] || (_cache[21] = withKeys(withModifiers((...args) => _ctx.onKeyboardSelect && _ctx.onKeyboardSelect(...args), ["stop", "prevent"]), ["enter"])),
                        _cache[22] || (_cache[22] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"]))
                      ],
                      "onUpdate:modelValue": _cache[23] || (_cache[23] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args))
                    }, null, 42, _hoisted_4$5), [
                      [_directive_model_text, _ctx.states.displayInputValue]
                    ])
                  ], 2),
                  _ctx.filterable ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    ref: "calculatorRef",
                    "aria-hidden": "true",
                    class: normalizeClass([
                      _ctx.nsSelectV2.e("selected-item"),
                      _ctx.nsSelectV2.e("input-calculator")
                    ]),
                    textContent: toDisplayString$1(_ctx.states.displayInputValue)
                  }, null, 10, _hoisted_5$4)) : createCommentVNode("v-if", true)
                ], 64)),
                _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("span", {
                  key: 3,
                  class: normalizeClass([
                    _ctx.nsSelectV2.e("placeholder"),
                    _ctx.nsSelectV2.is("transparent", _ctx.states.isComposing || (_ctx.placeholder && _ctx.multiple ? _ctx.modelValue.length === 0 : !_ctx.hasModelValue))
                  ])
                }, toDisplayString$1(_ctx.currentPlaceholder), 3)) : createCommentVNode("v-if", true),
                createBaseVNode("span", {
                  class: normalizeClass(_ctx.nsSelectV2.e("suffix"))
                }, [
                  _ctx.iconComponent ? withDirectives((openBlock(), createBlock(_component_el_icon, {
                    key: 0,
                    class: normalizeClass([_ctx.nsSelectV2.e("caret"), _ctx.nsInput.e("icon"), _ctx.iconReverse])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                    ]),
                    _: 1
                  }, 8, ["class"])), [
                    [vShow, !_ctx.showClearBtn]
                  ]) : createCommentVNode("v-if", true),
                  _ctx.showClearBtn && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 1,
                    class: normalizeClass([_ctx.nsSelectV2.e("caret"), _ctx.nsInput.e("icon")]),
                    onClick: withModifiers(_ctx.handleClear, ["prevent", "stop"])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                  _ctx.validateState && _ctx.validateIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 2,
                    class: normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 2)
              ], 2)
            ];
          }),
          content: withCtx(() => [
            createVNode(_component_el_select_menu, {
              ref: "menuRef",
              data: _ctx.filteredOptions,
              width: _ctx.popperSize,
              "hovering-index": _ctx.states.hoveringIndex,
              "scrollbar-always-on": _ctx.scrollbarAlwaysOn
            }, {
              default: withCtx((scope) => [
                renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(scope)))
              ]),
              empty: withCtx(() => [
                renderSlot(_ctx.$slots, "empty", {}, () => [
                  createBaseVNode("p", {
                    class: normalizeClass(_ctx.nsSelectV2.e("empty"))
                  }, toDisplayString$1(_ctx.emptyText ? _ctx.emptyText : ""), 3)
                ])
              ]),
              _: 3
            }, 8, ["data", "width", "hovering-index", "scrollbar-always-on"])
          ]),
          _: 3
        }, 8, ["visible", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onBeforeShow"])
      ], 34)), [
        [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
      ]);
    }
    var Select = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/select.vue"]]);
    Select.install = (app2) => {
      app2.component(Select.name, Select);
    };
    const _Select = Select;
    const ElSelectV2 = _Select;
    const skeletonProps = buildProps({
      animated: {
        type: Boolean,
        default: false
      },
      count: {
        type: Number,
        default: 1
      },
      rows: {
        type: Number,
        default: 3
      },
      loading: {
        type: Boolean,
        default: true
      },
      throttle: {
        type: Number
      }
    });
    const skeletonItemProps = buildProps({
      variant: {
        type: String,
        values: [
          "circle",
          "rect",
          "h1",
          "h3",
          "text",
          "caption",
          "p",
          "image",
          "button"
        ],
        default: "text"
      }
    });
    const __default__$o = {
      name: "ElSkeletonItem"
    };
    const _sfc_main$A = /* @__PURE__ */ defineComponent({
      ...__default__$o,
      props: skeletonItemProps,
      setup(__props) {
        const ns2 = useNamespace("skeleton");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([unref(ns2).e("item"), unref(ns2).e(_ctx.variant)])
          }, [
            _ctx.variant === "image" ? (openBlock(), createBlock(unref(picture_filled_default), { key: 0 })) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    });
    var SkeletonItem = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton-item.vue"]]);
    const __default__$n = {
      name: "ElSkeleton"
    };
    const _sfc_main$z = /* @__PURE__ */ defineComponent({
      ...__default__$n,
      props: skeletonProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns2 = useNamespace("skeleton");
        const uiLoading = useThrottleRender(toRef(props, "loading"), props.throttle);
        expose({
          uiLoading
        });
        return (_ctx, _cache) => {
          return unref(uiLoading) ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            class: [unref(ns2).b(), unref(ns2).is("animated", _ctx.animated)]
          }, _ctx.$attrs), [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.count, (i) => {
              return openBlock(), createElementBlock(Fragment, { key: i }, [
                _ctx.loading ? renderSlot(_ctx.$slots, "template", { key: i }, () => [
                  createVNode(SkeletonItem, {
                    class: normalizeClass(unref(ns2).is("first")),
                    variant: "p"
                  }, null, 8, ["class"]),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (item) => {
                    return openBlock(), createBlock(SkeletonItem, {
                      key: item,
                      class: normalizeClass([
                        unref(ns2).e("paragraph"),
                        unref(ns2).is("last", item === _ctx.rows && _ctx.rows > 1)
                      ]),
                      variant: "p"
                    }, null, 8, ["class"]);
                  }), 128))
                ]) : createCommentVNode("v-if", true)
              ], 64);
            }), 128))
          ], 16)) : renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 1 }, _ctx.$attrs)));
        };
      }
    });
    var Skeleton = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton.vue"]]);
    const ElSkeleton = withInstall(Skeleton, {
      SkeletonItem
    });
    const ElSkeletonItem = withNoopInstall(SkeletonItem);
    const sliderProps = buildProps({
      modelValue: {
        type: definePropType([Number, Array]),
        default: 0
      },
      id: {
        type: String,
        default: void 0
      },
      min: {
        type: Number,
        default: 0
      },
      max: {
        type: Number,
        default: 100
      },
      step: {
        type: Number,
        default: 1
      },
      showInput: Boolean,
      showInputControls: {
        type: Boolean,
        default: true
      },
      size: useSizeProp,
      inputSize: useSizeProp,
      showStops: Boolean,
      showTooltip: {
        type: Boolean,
        default: true
      },
      formatTooltip: {
        type: definePropType(Function),
        default: void 0
      },
      disabled: Boolean,
      range: Boolean,
      vertical: Boolean,
      height: String,
      debounce: {
        type: Number,
        default: 300
      },
      label: {
        type: String,
        default: void 0
      },
      rangeStartLabel: {
        type: String,
        default: void 0
      },
      rangeEndLabel: {
        type: String,
        default: void 0
      },
      formatValueText: {
        type: definePropType(Function),
        default: void 0
      },
      tooltipClass: {
        type: String,
        default: void 0
      },
      placement: {
        type: String,
        values: Ee,
        default: "top"
      },
      marks: {
        type: definePropType(Object)
      },
      validateEvent: {
        type: Boolean,
        default: true
      }
    });
    const isValidValue$1 = (value) => isNumber$2(value) || isArray$4(value) && value.every(isNumber$2);
    const sliderEmits = {
      [UPDATE_MODEL_EVENT]: isValidValue$1,
      [INPUT_EVENT]: isValidValue$1,
      [CHANGE_EVENT]: isValidValue$1
    };
    const useLifecycle = (props, initData, resetSize) => {
      const sliderWrapper = ref();
      onMounted(async () => {
        if (props.range) {
          if (Array.isArray(props.modelValue)) {
            initData.firstValue = Math.max(props.min, props.modelValue[0]);
            initData.secondValue = Math.min(props.max, props.modelValue[1]);
          } else {
            initData.firstValue = props.min;
            initData.secondValue = props.max;
          }
          initData.oldValue = [initData.firstValue, initData.secondValue];
        } else {
          if (typeof props.modelValue !== "number" || Number.isNaN(props.modelValue)) {
            initData.firstValue = props.min;
          } else {
            initData.firstValue = Math.min(props.max, Math.max(props.min, props.modelValue));
          }
          initData.oldValue = initData.firstValue;
        }
        useEventListener(window, "resize", resetSize);
        await nextTick();
        resetSize();
      });
      return {
        sliderWrapper
      };
    };
    const useMarks = (props) => {
      return computed(() => {
        if (!props.marks) {
          return [];
        }
        const marksKeys = Object.keys(props.marks);
        return marksKeys.map(Number.parseFloat).sort((a2, b2) => a2 - b2).filter((point) => point <= props.max && point >= props.min).map((point) => ({
          point,
          position: (point - props.min) * 100 / (props.max - props.min),
          mark: props.marks[point]
        }));
      });
    };
    const useSlide = (props, initData, emit) => {
      const { form: elForm, formItem: elFormItem } = useFormItem();
      const slider = shallowRef();
      const firstButton = ref();
      const secondButton = ref();
      const buttonRefs = {
        firstButton,
        secondButton
      };
      const sliderDisabled = computed(() => {
        return props.disabled || (elForm == null ? void 0 : elForm.disabled) || false;
      });
      const minValue = computed(() => {
        return Math.min(initData.firstValue, initData.secondValue);
      });
      const maxValue = computed(() => {
        return Math.max(initData.firstValue, initData.secondValue);
      });
      const barSize = computed(() => {
        return props.range ? `${100 * (maxValue.value - minValue.value) / (props.max - props.min)}%` : `${100 * (initData.firstValue - props.min) / (props.max - props.min)}%`;
      });
      const barStart = computed(() => {
        return props.range ? `${100 * (minValue.value - props.min) / (props.max - props.min)}%` : "0%";
      });
      const runwayStyle = computed(() => {
        return props.vertical ? { height: props.height } : {};
      });
      const barStyle = computed(() => {
        return props.vertical ? {
          height: barSize.value,
          bottom: barStart.value
        } : {
          width: barSize.value,
          left: barStart.value
        };
      });
      const resetSize = () => {
        if (slider.value) {
          initData.sliderSize = slider.value[`client${props.vertical ? "Height" : "Width"}`];
        }
      };
      const getButtonRefByPercent = (percent) => {
        const targetValue = props.min + percent * (props.max - props.min) / 100;
        if (!props.range) {
          return firstButton;
        }
        let buttonRefName;
        if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) {
          buttonRefName = initData.firstValue < initData.secondValue ? "firstButton" : "secondButton";
        } else {
          buttonRefName = initData.firstValue > initData.secondValue ? "firstButton" : "secondButton";
        }
        return buttonRefs[buttonRefName];
      };
      const setPosition = (percent) => {
        const buttonRef = getButtonRefByPercent(percent);
        buttonRef.value.setPosition(percent);
        return buttonRef;
      };
      const setFirstValue = (firstValue) => {
        initData.firstValue = firstValue;
        _emit(props.range ? [minValue.value, maxValue.value] : firstValue);
      };
      const setSecondValue = (secondValue) => {
        initData.secondValue = secondValue;
        if (props.range) {
          _emit([minValue.value, maxValue.value]);
        }
      };
      const _emit = (val) => {
        emit(UPDATE_MODEL_EVENT, val);
        emit(INPUT_EVENT, val);
      };
      const emitChange = async () => {
        await nextTick();
        emit(CHANGE_EVENT, props.range ? [minValue.value, maxValue.value] : props.modelValue);
      };
      const handleSliderPointerEvent = (event) => {
        var _a2, _b, _c, _d, _e, _f;
        if (sliderDisabled.value || initData.dragging)
          return;
        resetSize();
        let newPercent = 0;
        if (props.vertical) {
          const clientY = (_c = (_b = (_a2 = event.touches) == null ? void 0 : _a2.item(0)) == null ? void 0 : _b.clientY) != null ? _c : event.clientY;
          const sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;
          newPercent = (sliderOffsetBottom - clientY) / initData.sliderSize * 100;
        } else {
          const clientX = (_f = (_e = (_d = event.touches) == null ? void 0 : _d.item(0)) == null ? void 0 : _e.clientX) != null ? _f : event.clientX;
          const sliderOffsetLeft = slider.value.getBoundingClientRect().left;
          newPercent = (clientX - sliderOffsetLeft) / initData.sliderSize * 100;
        }
        if (newPercent < 0 || newPercent > 100)
          return;
        return setPosition(newPercent);
      };
      const onSliderWrapperPrevent = (event) => {
        var _a2, _b;
        if (((_a2 = buttonRefs["firstButton"].value) == null ? void 0 : _a2.dragging) || ((_b = buttonRefs["secondButton"].value) == null ? void 0 : _b.dragging)) {
          event.preventDefault();
        }
      };
      const onSliderDown = async (event) => {
        const buttonRef = handleSliderPointerEvent(event);
        if (buttonRef) {
          await nextTick();
          buttonRef.value.onButtonDown(event);
        }
      };
      const onSliderClick = (event) => {
        const buttonRef = handleSliderPointerEvent(event);
        if (buttonRef) {
          emitChange();
        }
      };
      return {
        elFormItem,
        slider,
        firstButton,
        secondButton,
        sliderDisabled,
        minValue,
        maxValue,
        runwayStyle,
        barStyle,
        resetSize,
        setPosition,
        emitChange,
        onSliderWrapperPrevent,
        onSliderClick,
        onSliderDown,
        setFirstValue,
        setSecondValue
      };
    };
    const { left, down, right, up, home, end, pageUp, pageDown } = EVENT_CODE;
    const useTooltip = (props, formatTooltip, showTooltip) => {
      const tooltip = ref();
      const tooltipVisible = ref(false);
      const enableFormat = computed(() => {
        return formatTooltip.value instanceof Function;
      });
      const formatValue = computed(() => {
        return enableFormat.value && formatTooltip.value(props.modelValue) || props.modelValue;
      });
      const displayTooltip = debounce(() => {
        showTooltip.value && (tooltipVisible.value = true);
      }, 50);
      const hideTooltip = debounce(() => {
        showTooltip.value && (tooltipVisible.value = false);
      }, 50);
      return {
        tooltip,
        tooltipVisible,
        formatValue,
        displayTooltip,
        hideTooltip
      };
    };
    const useSliderButton = (props, initData, emit) => {
      const {
        disabled,
        min: min2,
        max: max2,
        step,
        showTooltip,
        precision,
        sliderSize,
        formatTooltip,
        emitChange,
        resetSize,
        updateDragging
      } = inject(sliderContextKey);
      const { tooltip, tooltipVisible, formatValue, displayTooltip, hideTooltip } = useTooltip(props, formatTooltip, showTooltip);
      const button = ref();
      const currentPosition = computed(() => {
        return `${(props.modelValue - min2.value) / (max2.value - min2.value) * 100}%`;
      });
      const wrapperStyle = computed(() => {
        return props.vertical ? { bottom: currentPosition.value } : { left: currentPosition.value };
      });
      const handleMouseEnter = () => {
        initData.hovering = true;
        displayTooltip();
      };
      const handleMouseLeave = () => {
        initData.hovering = false;
        if (!initData.dragging) {
          hideTooltip();
        }
      };
      const onButtonDown = (event) => {
        if (disabled.value)
          return;
        event.preventDefault();
        onDragStart(event);
        window.addEventListener("mousemove", onDragging);
        window.addEventListener("touchmove", onDragging);
        window.addEventListener("mouseup", onDragEnd);
        window.addEventListener("touchend", onDragEnd);
        window.addEventListener("contextmenu", onDragEnd);
        button.value.focus();
      };
      const incrementPosition = (amount) => {
        if (disabled.value)
          return;
        initData.newPosition = Number.parseFloat(currentPosition.value) + amount / (max2.value - min2.value) * 100;
        setPosition(initData.newPosition);
        emitChange();
      };
      const onLeftKeyDown = () => {
        incrementPosition(-step.value);
      };
      const onRightKeyDown = () => {
        incrementPosition(step.value);
      };
      const onPageDownKeyDown = () => {
        incrementPosition(-step.value * 4);
      };
      const onPageUpKeyDown = () => {
        incrementPosition(step.value * 4);
      };
      const onHomeKeyDown = () => {
        if (disabled.value)
          return;
        setPosition(0);
        emitChange();
      };
      const onEndKeyDown = () => {
        if (disabled.value)
          return;
        setPosition(100);
        emitChange();
      };
      const onKeyDown = (event) => {
        let isPreventDefault = true;
        if ([left, down].includes(event.key)) {
          onLeftKeyDown();
        } else if ([right, up].includes(event.key)) {
          onRightKeyDown();
        } else if (event.key === home) {
          onHomeKeyDown();
        } else if (event.key === end) {
          onEndKeyDown();
        } else if (event.key === pageDown) {
          onPageDownKeyDown();
        } else if (event.key === pageUp) {
          onPageUpKeyDown();
        } else {
          isPreventDefault = false;
        }
        isPreventDefault && event.preventDefault();
      };
      const getClientXY2 = (event) => {
        let clientX;
        let clientY;
        if (event.type.startsWith("touch")) {
          clientY = event.touches[0].clientY;
          clientX = event.touches[0].clientX;
        } else {
          clientY = event.clientY;
          clientX = event.clientX;
        }
        return {
          clientX,
          clientY
        };
      };
      const onDragStart = (event) => {
        initData.dragging = true;
        initData.isClick = true;
        const { clientX, clientY } = getClientXY2(event);
        if (props.vertical) {
          initData.startY = clientY;
        } else {
          initData.startX = clientX;
        }
        initData.startPosition = Number.parseFloat(currentPosition.value);
        initData.newPosition = initData.startPosition;
      };
      const onDragging = (event) => {
        if (initData.dragging) {
          initData.isClick = false;
          displayTooltip();
          resetSize();
          let diff;
          const { clientX, clientY } = getClientXY2(event);
          if (props.vertical) {
            initData.currentY = clientY;
            diff = (initData.startY - initData.currentY) / sliderSize.value * 100;
          } else {
            initData.currentX = clientX;
            diff = (initData.currentX - initData.startX) / sliderSize.value * 100;
          }
          initData.newPosition = initData.startPosition + diff;
          setPosition(initData.newPosition);
        }
      };
      const onDragEnd = () => {
        if (initData.dragging) {
          setTimeout(() => {
            initData.dragging = false;
            if (!initData.hovering) {
              hideTooltip();
            }
            if (!initData.isClick) {
              setPosition(initData.newPosition);
            }
            emitChange();
          }, 0);
          window.removeEventListener("mousemove", onDragging);
          window.removeEventListener("touchmove", onDragging);
          window.removeEventListener("mouseup", onDragEnd);
          window.removeEventListener("touchend", onDragEnd);
          window.removeEventListener("contextmenu", onDragEnd);
        }
      };
      const setPosition = async (newPosition) => {
        if (newPosition === null || Number.isNaN(+newPosition))
          return;
        if (newPosition < 0) {
          newPosition = 0;
        } else if (newPosition > 100) {
          newPosition = 100;
        }
        const lengthPerStep = 100 / ((max2.value - min2.value) / step.value);
        const steps = Math.round(newPosition / lengthPerStep);
        let value = steps * lengthPerStep * (max2.value - min2.value) * 0.01 + min2.value;
        value = Number.parseFloat(value.toFixed(precision.value));
        if (value !== props.modelValue) {
          emit(UPDATE_MODEL_EVENT, value);
        }
        if (!initData.dragging && props.modelValue !== initData.oldValue) {
          initData.oldValue = props.modelValue;
        }
        await nextTick();
        initData.dragging && displayTooltip();
        tooltip.value.updatePopper();
      };
      watch(() => initData.dragging, (val) => {
        updateDragging(val);
      });
      return {
        disabled,
        button,
        tooltip,
        tooltipVisible,
        showTooltip,
        wrapperStyle,
        formatValue,
        handleMouseEnter,
        handleMouseLeave,
        onButtonDown,
        onKeyDown,
        setPosition
      };
    };
    const useStops = (props, initData, minValue, maxValue) => {
      const stops = computed(() => {
        if (!props.showStops || props.min > props.max)
          return [];
        if (props.step === 0) {
          return [];
        }
        const stopCount = (props.max - props.min) / props.step;
        const stepWidth = 100 * props.step / (props.max - props.min);
        const result = Array.from({ length: stopCount - 1 }).map((_2, index2) => (index2 + 1) * stepWidth);
        if (props.range) {
          return result.filter((step) => {
            return step < 100 * (minValue.value - props.min) / (props.max - props.min) || step > 100 * (maxValue.value - props.min) / (props.max - props.min);
          });
        } else {
          return result.filter((step) => step > 100 * (initData.firstValue - props.min) / (props.max - props.min));
        }
      });
      const getStopStyle = (position) => {
        return props.vertical ? { bottom: `${position}%` } : { left: `${position}%` };
      };
      return {
        stops,
        getStopStyle
      };
    };
    const useWatch = (props, initData, minValue, maxValue, emit, elFormItem) => {
      const _emit = (val) => {
        emit(UPDATE_MODEL_EVENT, val);
        emit(INPUT_EVENT, val);
      };
      const valueChanged = () => {
        if (props.range) {
          return ![minValue.value, maxValue.value].every((item, index2) => item === initData.oldValue[index2]);
        } else {
          return props.modelValue !== initData.oldValue;
        }
      };
      const setValues = () => {
        var _a2, _b;
        if (props.min > props.max) {
          throwError("Slider", "min should not be greater than max.");
          return;
        }
        const val = props.modelValue;
        if (props.range && Array.isArray(val)) {
          if (val[1] < props.min) {
            _emit([props.min, props.min]);
          } else if (val[0] > props.max) {
            _emit([props.max, props.max]);
          } else if (val[0] < props.min) {
            _emit([props.min, val[1]]);
          } else if (val[1] > props.max) {
            _emit([val[0], props.max]);
          } else {
            initData.firstValue = val[0];
            initData.secondValue = val[1];
            if (valueChanged()) {
              if (props.validateEvent) {
                (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
              }
              initData.oldValue = val.slice();
            }
          }
        } else if (!props.range && typeof val === "number" && !Number.isNaN(val)) {
          if (val < props.min) {
            _emit(props.min);
          } else if (val > props.max) {
            _emit(props.max);
          } else {
            initData.firstValue = val;
            if (valueChanged()) {
              if (props.validateEvent) {
                (_b = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _b.call(elFormItem, "change").catch((err) => debugWarn());
              }
              initData.oldValue = val;
            }
          }
        }
      };
      setValues();
      watch(() => initData.dragging, (val) => {
        if (!val) {
          setValues();
        }
      });
      watch(() => props.modelValue, (val, oldVal) => {
        if (initData.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item, index2) => item === oldVal[index2]) && initData.firstValue === val[0] && initData.secondValue === val[1]) {
          return;
        }
        setValues();
      }, {
        deep: true
      });
      watch(() => [props.min, props.max], () => {
        setValues();
      });
    };
    const sliderButtonProps = buildProps({
      modelValue: {
        type: Number,
        default: 0
      },
      vertical: Boolean,
      tooltipClass: String,
      placement: {
        type: String,
        values: Ee,
        default: "top"
      }
    });
    const sliderButtonEmits = {
      [UPDATE_MODEL_EVENT]: (value) => isNumber$2(value)
    };
    const _hoisted_1$h = ["tabindex"];
    const __default__$m = {
      name: "ElSliderButton"
    };
    const _sfc_main$y = /* @__PURE__ */ defineComponent({
      ...__default__$m,
      props: sliderButtonProps,
      emits: sliderButtonEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const ns2 = useNamespace("slider");
        const initData = reactive({
          hovering: false,
          dragging: false,
          isClick: false,
          startX: 0,
          currentX: 0,
          startY: 0,
          currentY: 0,
          startPosition: 0,
          newPosition: 0,
          oldValue: props.modelValue
        });
        const {
          disabled,
          button,
          tooltip,
          showTooltip,
          tooltipVisible,
          wrapperStyle,
          formatValue,
          handleMouseEnter,
          handleMouseLeave,
          onButtonDown,
          onKeyDown,
          setPosition
        } = useSliderButton(props, initData, emit);
        const { hovering, dragging } = toRefs(initData);
        expose({
          onButtonDown,
          onKeyDown,
          setPosition,
          hovering,
          dragging
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "button",
            ref: button,
            class: normalizeClass([unref(ns2).e("button-wrapper"), { hover: unref(hovering), dragging: unref(dragging) }]),
            style: normalizeStyle(unref(wrapperStyle)),
            tabindex: unref(disabled) ? -1 : 0,
            onMouseenter: _cache[0] || (_cache[0] = (...args) => unref(handleMouseEnter) && unref(handleMouseEnter)(...args)),
            onMouseleave: _cache[1] || (_cache[1] = (...args) => unref(handleMouseLeave) && unref(handleMouseLeave)(...args)),
            onMousedown: _cache[2] || (_cache[2] = (...args) => unref(onButtonDown) && unref(onButtonDown)(...args)),
            onTouchstart: _cache[3] || (_cache[3] = (...args) => unref(onButtonDown) && unref(onButtonDown)(...args)),
            onFocus: _cache[4] || (_cache[4] = (...args) => unref(handleMouseEnter) && unref(handleMouseEnter)(...args)),
            onBlur: _cache[5] || (_cache[5] = (...args) => unref(handleMouseLeave) && unref(handleMouseLeave)(...args)),
            onKeydown: _cache[6] || (_cache[6] = (...args) => unref(onKeyDown) && unref(onKeyDown)(...args))
          }, [
            createVNode(unref(ElTooltip), {
              ref_key: "tooltip",
              ref: tooltip,
              visible: unref(tooltipVisible),
              placement: _ctx.placement,
              "fallback-placements": ["top", "bottom", "right", "left"],
              "stop-popper-mouse-event": false,
              "popper-class": _ctx.tooltipClass,
              disabled: !unref(showTooltip),
              persistent: ""
            }, {
              content: withCtx(() => [
                createBaseVNode("span", null, toDisplayString$1(unref(formatValue)), 1)
              ]),
              default: withCtx(() => [
                createBaseVNode("div", {
                  class: normalizeClass([unref(ns2).e("button"), { hover: unref(hovering), dragging: unref(dragging) }])
                }, null, 2)
              ]),
              _: 1
            }, 8, ["visible", "placement", "popper-class", "disabled"])
          ], 46, _hoisted_1$h);
        };
      }
    });
    var SliderButton = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);
    const sliderMarkerProps = buildProps({
      mark: {
        type: definePropType([String, Object]),
        default: void 0
      }
    });
    var SliderMarker = defineComponent({
      name: "ElSliderMarker",
      props: sliderMarkerProps,
      setup(props) {
        const ns2 = useNamespace("slider");
        const label = computed(() => {
          return isString$3(props.mark) ? props.mark : props.mark.label;
        });
        const style2 = computed(() => isString$3(props.mark) ? void 0 : props.mark.style);
        return () => h$1("div", {
          class: ns2.e("marks-text"),
          style: style2.value
        }, label.value);
      }
    });
    const _hoisted_1$g = ["id", "role", "aria-label", "aria-labelledby"];
    const _hoisted_2$c = { key: 1 };
    const __default__$l = {
      name: "ElSlider"
    };
    const _sfc_main$x = /* @__PURE__ */ defineComponent({
      ...__default__$l,
      props: sliderProps,
      emits: sliderEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const ns2 = useNamespace("slider");
        const { t } = useLocale();
        const initData = reactive({
          firstValue: 0,
          secondValue: 0,
          oldValue: 0,
          dragging: false,
          sliderSize: 1
        });
        const {
          elFormItem,
          slider,
          firstButton,
          secondButton,
          sliderDisabled,
          minValue,
          maxValue,
          runwayStyle,
          barStyle,
          resetSize,
          emitChange,
          onSliderWrapperPrevent,
          onSliderClick,
          onSliderDown,
          setFirstValue,
          setSecondValue
        } = useSlide(props, initData, emit);
        const { stops, getStopStyle } = useStops(props, initData, minValue, maxValue);
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: elFormItem
        });
        const sliderWrapperSize = useSize();
        const sliderInputSize = computed(() => props.inputSize || sliderWrapperSize.value);
        const groupLabel = computed(() => {
          return props.label || t("el.slider.defaultLabel", {
            min: props.min,
            max: props.max
          });
        });
        const firstButtonLabel = computed(() => {
          if (props.range) {
            return props.rangeStartLabel || t("el.slider.defaultRangeStartLabel");
          } else {
            return groupLabel.value;
          }
        });
        const firstValueText = computed(() => {
          return props.formatValueText ? props.formatValueText(firstValue.value) : `${firstValue.value}`;
        });
        const secondButtonLabel = computed(() => {
          return props.rangeEndLabel || t("el.slider.defaultRangeEndLabel");
        });
        const secondValueText = computed(() => {
          return props.formatValueText ? props.formatValueText(secondValue.value) : `${secondValue.value}`;
        });
        const sliderKls = computed(() => [
          ns2.b(),
          ns2.m(sliderWrapperSize.value),
          ns2.is("vertical", props.vertical),
          { [ns2.m("with-input")]: props.showInput }
        ]);
        const markList = useMarks(props);
        useWatch(props, initData, minValue, maxValue, emit, elFormItem);
        const precision = computed(() => {
          const precisions = [props.min, props.max, props.step].map((item) => {
            const decimal = `${item}`.split(".")[1];
            return decimal ? decimal.length : 0;
          });
          return Math.max.apply(null, precisions);
        });
        const { sliderWrapper } = useLifecycle(props, initData, resetSize);
        const { firstValue, secondValue, sliderSize } = toRefs(initData);
        const updateDragging = (val) => {
          initData.dragging = val;
        };
        provide(sliderContextKey, {
          ...toRefs(props),
          sliderSize,
          disabled: sliderDisabled,
          precision,
          emitChange,
          resetSize,
          updateDragging
        });
        expose({
          onSliderClick
        });
        return (_ctx, _cache) => {
          var _a2, _b;
          return openBlock(), createElementBlock("div", {
            id: _ctx.range ? unref(inputId) : void 0,
            ref_key: "sliderWrapper",
            ref: sliderWrapper,
            class: normalizeClass(unref(sliderKls)),
            role: _ctx.range ? "group" : void 0,
            "aria-label": _ctx.range && !unref(isLabeledByFormItem) ? unref(groupLabel) : void 0,
            "aria-labelledby": _ctx.range && unref(isLabeledByFormItem) ? (_a2 = unref(elFormItem)) == null ? void 0 : _a2.labelId : void 0,
            onTouchstart: _cache[2] || (_cache[2] = (...args) => unref(onSliderWrapperPrevent) && unref(onSliderWrapperPrevent)(...args)),
            onTouchmove: _cache[3] || (_cache[3] = (...args) => unref(onSliderWrapperPrevent) && unref(onSliderWrapperPrevent)(...args))
          }, [
            createBaseVNode("div", {
              ref_key: "slider",
              ref: slider,
              class: normalizeClass([
                unref(ns2).e("runway"),
                { "show-input": _ctx.showInput && !_ctx.range },
                unref(ns2).is("disabled", unref(sliderDisabled))
              ]),
              style: normalizeStyle(unref(runwayStyle)),
              onMousedown: _cache[0] || (_cache[0] = (...args) => unref(onSliderDown) && unref(onSliderDown)(...args)),
              onTouchstart: _cache[1] || (_cache[1] = (...args) => unref(onSliderDown) && unref(onSliderDown)(...args))
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ns2).e("bar")),
                style: normalizeStyle(unref(barStyle))
              }, null, 6),
              createVNode(SliderButton, {
                id: !_ctx.range ? unref(inputId) : void 0,
                ref_key: "firstButton",
                ref: firstButton,
                "model-value": unref(firstValue),
                vertical: _ctx.vertical,
                "tooltip-class": _ctx.tooltipClass,
                placement: _ctx.placement,
                role: "slider",
                "aria-label": _ctx.range || !unref(isLabeledByFormItem) ? unref(firstButtonLabel) : void 0,
                "aria-labelledby": !_ctx.range && unref(isLabeledByFormItem) ? (_b = unref(elFormItem)) == null ? void 0 : _b.labelId : void 0,
                "aria-valuemin": _ctx.min,
                "aria-valuemax": _ctx.range ? unref(secondValue) : _ctx.max,
                "aria-valuenow": unref(firstValue),
                "aria-valuetext": unref(firstValueText),
                "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                "aria-disabled": unref(sliderDisabled),
                "onUpdate:modelValue": unref(setFirstValue)
              }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
              _ctx.range ? (openBlock(), createBlock(SliderButton, {
                key: 0,
                ref_key: "secondButton",
                ref: secondButton,
                "model-value": unref(secondValue),
                vertical: _ctx.vertical,
                "tooltip-class": _ctx.tooltipClass,
                placement: _ctx.placement,
                role: "slider",
                "aria-label": unref(secondButtonLabel),
                "aria-valuemin": unref(firstValue),
                "aria-valuemax": _ctx.max,
                "aria-valuenow": unref(secondValue),
                "aria-valuetext": unref(secondValueText),
                "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                "aria-disabled": unref(sliderDisabled),
                "onUpdate:modelValue": unref(setSecondValue)
              }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : createCommentVNode("v-if", true),
              _ctx.showStops ? (openBlock(), createElementBlock("div", _hoisted_2$c, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(stops), (item, key) => {
                  return openBlock(), createElementBlock("div", {
                    key,
                    class: normalizeClass(unref(ns2).e("stop")),
                    style: normalizeStyle(unref(getStopStyle)(item))
                  }, null, 6);
                }), 128))
              ])) : createCommentVNode("v-if", true),
              unref(markList).length > 0 ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                createBaseVNode("div", null, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(markList), (item, key) => {
                    return openBlock(), createElementBlock("div", {
                      key,
                      style: normalizeStyle(unref(getStopStyle)(item.position)),
                      class: normalizeClass([unref(ns2).e("stop"), unref(ns2).e("marks-stop")])
                    }, null, 6);
                  }), 128))
                ]),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns2).e("marks"))
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(markList), (item, key) => {
                    return openBlock(), createBlock(unref(SliderMarker), {
                      key,
                      mark: item.mark,
                      style: normalizeStyle(unref(getStopStyle)(item.position))
                    }, null, 8, ["mark", "style"]);
                  }), 128))
                ], 2)
              ], 64)) : createCommentVNode("v-if", true)
            ], 38),
            _ctx.showInput && !_ctx.range ? (openBlock(), createBlock(unref(ElInputNumber), {
              key: 0,
              ref: "input",
              "model-value": unref(firstValue),
              class: normalizeClass(unref(ns2).e("input")),
              step: _ctx.step,
              disabled: unref(sliderDisabled),
              controls: _ctx.showInputControls,
              min: _ctx.min,
              max: _ctx.max,
              debounce: _ctx.debounce,
              size: unref(sliderInputSize),
              "onUpdate:modelValue": unref(setFirstValue),
              onChange: unref(emitChange)
            }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : createCommentVNode("v-if", true)
          ], 42, _hoisted_1$g);
        };
      }
    });
    var Slider = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);
    const ElSlider = withInstall(Slider);
    const spaceItemProps = buildProps({
      prefixCls: {
        type: String
      }
    });
    const SpaceItem = defineComponent({
      name: "ElSpaceItem",
      props: spaceItemProps,
      setup(props, { slots }) {
        const ns2 = useNamespace("space");
        const classes = computed(() => `${props.prefixCls || ns2.b()}__item`);
        return () => h$1("div", { class: classes.value }, renderSlot(slots, "default"));
      }
    });
    const SIZE_MAP = {
      small: 8,
      default: 12,
      large: 16
    };
    function useSpace(props) {
      const ns2 = useNamespace("space");
      const classes = computed(() => [ns2.b(), ns2.m(props.direction), props.class]);
      const horizontalSize = ref(0);
      const verticalSize = ref(0);
      const containerStyle = computed(() => {
        const wrapKls = props.wrap || props.fill ? { flexWrap: "wrap", marginBottom: `-${verticalSize.value}px` } : {};
        const alignment = {
          alignItems: props.alignment
        };
        return [wrapKls, alignment, props.style];
      });
      const itemStyle = computed(() => {
        const itemBaseStyle = {
          paddingBottom: `${verticalSize.value}px`,
          marginRight: `${horizontalSize.value}px`
        };
        const fillStyle = props.fill ? { flexGrow: 1, minWidth: `${props.fillRatio}%` } : {};
        return [itemBaseStyle, fillStyle];
      });
      watchEffect(() => {
        const { size: size2 = "small", wrap, direction: dir, fill } = props;
        if (isArray$4(size2)) {
          const [h2 = 0, v2 = 0] = size2;
          horizontalSize.value = h2;
          verticalSize.value = v2;
        } else {
          let val;
          if (isNumber$2(size2)) {
            val = size2;
          } else {
            val = SIZE_MAP[size2 || "small"] || SIZE_MAP.small;
          }
          if ((wrap || fill) && dir === "horizontal") {
            horizontalSize.value = verticalSize.value = val;
          } else {
            if (dir === "horizontal") {
              horizontalSize.value = val;
              verticalSize.value = 0;
            } else {
              verticalSize.value = val;
              horizontalSize.value = 0;
            }
          }
        }
      });
      return {
        classes,
        containerStyle,
        itemStyle
      };
    }
    const spaceProps = buildProps({
      direction: {
        type: String,
        values: ["horizontal", "vertical"],
        default: "horizontal"
      },
      class: {
        type: definePropType([
          String,
          Object,
          Array
        ]),
        default: ""
      },
      style: {
        type: definePropType([String, Array, Object]),
        default: ""
      },
      alignment: {
        type: definePropType(String),
        default: "center"
      },
      prefixCls: {
        type: String
      },
      spacer: {
        type: definePropType([Object, String, Number, Array]),
        default: null,
        validator: (val) => isVNode$1(val) || isNumber$2(val) || isString$3(val)
      },
      wrap: Boolean,
      fill: Boolean,
      fillRatio: {
        type: Number,
        default: 100
      },
      size: {
        type: [String, Array, Number],
        values: componentSizes,
        validator: (val) => {
          return isNumber$2(val) || isArray$4(val) && val.length === 2 && val.every(isNumber$2);
        }
      }
    });
    var Space = defineComponent({
      name: "ElSpace",
      props: spaceProps,
      setup(props, { slots }) {
        const { classes, containerStyle, itemStyle } = useSpace(props);
        function extractChildren(children, parentKey = "", extractedChildren = []) {
          const { prefixCls } = props;
          children.forEach((child, loopKey) => {
            if (isFragment(child)) {
              if (isArray$4(child.children)) {
                child.children.forEach((nested, key) => {
                  if (isFragment(nested) && isArray$4(nested.children)) {
                    extractChildren(nested.children, `${parentKey + key}-`, extractedChildren);
                  } else {
                    extractedChildren.push(createVNode(SpaceItem, {
                      style: itemStyle.value,
                      prefixCls,
                      key: `nested-${parentKey + key}`
                    }, {
                      default: () => [nested]
                    }, PatchFlags.PROPS | PatchFlags.STYLE, ["style", "prefixCls"]));
                  }
                });
              }
            } else if (isValidElementNode(child)) {
              extractedChildren.push(createVNode(SpaceItem, {
                style: itemStyle.value,
                prefixCls,
                key: `LoopKey${parentKey + loopKey}`
              }, {
                default: () => [child]
              }, PatchFlags.PROPS | PatchFlags.STYLE, ["style", "prefixCls"]));
            }
          });
          return extractedChildren;
        }
        return () => {
          var _a2;
          const { spacer, direction: direction2 } = props;
          const children = renderSlot(slots, "default", { key: 0 }, () => []);
          if (((_a2 = children.children) != null ? _a2 : []).length === 0)
            return null;
          if (isArray$4(children.children)) {
            let extractedChildren = extractChildren(children.children);
            if (spacer) {
              const len = extractedChildren.length - 1;
              extractedChildren = extractedChildren.reduce((acc, child, idx) => {
                const children2 = [...acc, child];
                if (idx !== len) {
                  children2.push(createVNode("span", {
                    style: [
                      itemStyle.value,
                      direction2 === "vertical" ? "width: 100%" : null
                    ],
                    key: idx
                  }, [
                    isVNode$1(spacer) ? spacer : createTextVNode(spacer, PatchFlags.TEXT)
                  ], PatchFlags.STYLE));
                }
                return children2;
              }, []);
            }
            return createVNode("div", {
              class: classes.value,
              style: containerStyle.value
            }, extractedChildren, PatchFlags.STYLE | PatchFlags.CLASS);
          }
          return children.children;
        };
      }
    });
    const ElSpace = withInstall(Space);
    const stepsProps = buildProps({
      space: {
        type: [Number, String],
        default: ""
      },
      active: {
        type: Number,
        default: 0
      },
      direction: {
        type: String,
        default: "horizontal",
        values: ["horizontal", "vertical"]
      },
      alignCenter: {
        type: Boolean
      },
      simple: {
        type: Boolean
      },
      finishStatus: {
        type: String,
        values: ["wait", "process", "finish", "error", "success"],
        default: "finish"
      },
      processStatus: {
        type: String,
        values: ["wait", "process", "finish", "error", "success"],
        default: "process"
      }
    });
    const stepsEmits = {
      [CHANGE_EVENT]: (newVal, oldVal) => [newVal, oldVal].every(isNumber$2)
    };
    const __default__$k = {
      name: "ElSteps"
    };
    const _sfc_main$w = /* @__PURE__ */ defineComponent({
      ...__default__$k,
      props: stepsProps,
      emits: stepsEmits,
      setup(__props, { emit }) {
        const props = __props;
        const ns2 = useNamespace("steps");
        const steps = ref([]);
        watch(steps, () => {
          steps.value.forEach((instance, index2) => {
            instance.setIndex(index2);
          });
        });
        provide("ElSteps", { props, steps });
        watch(() => props.active, (newVal, oldVal) => {
          emit(CHANGE_EVENT, newVal, oldVal);
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([unref(ns2).b(), unref(ns2).m(_ctx.simple ? "simple" : _ctx.direction)])
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var Steps = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/steps.vue"]]);
    const stepProps = buildProps({
      title: {
        type: String,
        default: ""
      },
      icon: {
        type: iconPropType
      },
      description: {
        type: String,
        default: ""
      },
      status: {
        type: String,
        values: ["", "wait", "process", "finish", "error", "success"],
        default: ""
      }
    });
    const __default__$j = {
      name: "ElStep"
    };
    const _sfc_main$v = defineComponent({
      ...__default__$j,
      props: stepProps,
      setup(__props) {
        const props = __props;
        const ns2 = useNamespace("step");
        const index2 = ref(-1);
        const lineStyle = ref({});
        const internalStatus = ref("");
        const parent = inject("ElSteps");
        const currentInstance2 = getCurrentInstance();
        onMounted(() => {
          watch([
            () => parent.props.active,
            () => parent.props.processStatus,
            () => parent.props.finishStatus
          ], ([active]) => {
            updateStatus(active);
          }, { immediate: true });
        });
        onBeforeUnmount(() => {
          parent.steps.value = parent.steps.value.filter((instance) => instance.uid !== (currentInstance2 == null ? void 0 : currentInstance2.uid));
        });
        const currentStatus = computed(() => {
          return props.status || internalStatus.value;
        });
        const prevStatus = computed(() => {
          const prevStep = parent.steps.value[index2.value - 1];
          return prevStep ? prevStep.currentStatus : "wait";
        });
        const isCenter = computed(() => {
          return parent.props.alignCenter;
        });
        const isVertical = computed(() => {
          return parent.props.direction === "vertical";
        });
        const isSimple = computed(() => {
          return parent.props.simple;
        });
        const stepsCount = computed(() => {
          return parent.steps.value.length;
        });
        const isLast = computed(() => {
          var _a2;
          return ((_a2 = parent.steps.value[stepsCount.value - 1]) == null ? void 0 : _a2.uid) === (currentInstance2 == null ? void 0 : currentInstance2.uid);
        });
        const space = computed(() => {
          return isSimple.value ? "" : parent.props.space;
        });
        const style2 = computed(() => {
          const style22 = {
            flexBasis: typeof space.value === "number" ? `${space.value}px` : space.value ? space.value : `${100 / (stepsCount.value - (isCenter.value ? 0 : 1))}%`
          };
          if (isVertical.value)
            return style22;
          if (isLast.value) {
            style22.maxWidth = `${100 / stepsCount.value}%`;
          }
          return style22;
        });
        const setIndex = (val) => {
          index2.value = val;
        };
        const calcProgress = (status) => {
          let step = 100;
          const style22 = {};
          style22.transitionDelay = `${150 * index2.value}ms`;
          if (status === parent.props.processStatus) {
            step = 0;
          } else if (status === "wait") {
            step = 0;
            style22.transitionDelay = `${-150 * index2.value}ms`;
          }
          style22.borderWidth = step && !isSimple.value ? "1px" : 0;
          style22[parent.props.direction === "vertical" ? "height" : "width"] = `${step}%`;
          lineStyle.value = style22;
        };
        const updateStatus = (activeIndex) => {
          if (activeIndex > index2.value) {
            internalStatus.value = parent.props.finishStatus;
          } else if (activeIndex === index2.value && prevStatus.value !== "error") {
            internalStatus.value = parent.props.processStatus;
          } else {
            internalStatus.value = "wait";
          }
          const prevChild = parent.steps.value[stepsCount.value - 1];
          if (prevChild)
            prevChild.calcProgress(internalStatus.value);
        };
        const stepItemState = reactive({
          uid: computed(() => currentInstance2 == null ? void 0 : currentInstance2.uid),
          currentStatus,
          setIndex,
          calcProgress
        });
        parent.steps.value = [...parent.steps.value, stepItemState];
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            style: normalizeStyle(unref(style2)),
            class: normalizeClass([
              unref(ns2).b(),
              unref(ns2).is(unref(isSimple) ? "simple" : unref(parent).props.direction),
              unref(ns2).is("flex", unref(isLast) && !unref(space) && !unref(isCenter)),
              unref(ns2).is("center", unref(isCenter) && !unref(isVertical) && !unref(isSimple))
            ])
          }, [
            createCommentVNode(" icon & line "),
            createBaseVNode("div", {
              class: normalizeClass([unref(ns2).e("head"), unref(ns2).is(unref(currentStatus))])
            }, [
              !unref(isSimple) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns2).e("line"))
              }, [
                createBaseVNode("i", {
                  class: normalizeClass(unref(ns2).e("line-inner")),
                  style: normalizeStyle(lineStyle.value)
                }, null, 6)
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                class: normalizeClass([unref(ns2).e("icon"), unref(ns2).is(_ctx.icon || _ctx.$slots.icon ? "icon" : "text")])
              }, [
                unref(currentStatus) !== "success" && unref(currentStatus) !== "error" ? renderSlot(_ctx.$slots, "icon", { key: 0 }, () => [
                  _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns2).e("icon-inner"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  !_ctx.icon && !unref(isSimple) ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(unref(ns2).e("icon-inner"))
                  }, toDisplayString$1(index2.value + 1), 3)) : createCommentVNode("v-if", true)
                ]) : (openBlock(), createBlock(unref(ElIcon), {
                  key: 1,
                  class: normalizeClass([unref(ns2).e("icon-inner"), unref(ns2).is("status")])
                }, {
                  default: withCtx(() => [
                    unref(currentStatus) === "success" ? (openBlock(), createBlock(unref(check_default), { key: 0 })) : (openBlock(), createBlock(unref(close_default), { key: 1 }))
                  ]),
                  _: 1
                }, 8, ["class"]))
              ], 2)
            ], 2),
            createCommentVNode(" title & description "),
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("main"))
            }, [
              createBaseVNode("div", {
                class: normalizeClass([unref(ns2).e("title"), unref(ns2).is(unref(currentStatus))])
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString$1(_ctx.title), 1)
                ])
              ], 2),
              unref(isSimple) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns2).e("arrow"))
              }, null, 2)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass([unref(ns2).e("description"), unref(ns2).is(unref(currentStatus))])
              }, [
                renderSlot(_ctx.$slots, "description", {}, () => [
                  createTextVNode(toDisplayString$1(_ctx.description), 1)
                ])
              ], 2))
            ], 2)
          ], 6);
        };
      }
    });
    var Step = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/item.vue"]]);
    const ElSteps = withInstall(Steps, {
      Step
    });
    const ElStep = withNoopInstall(Step);
    const switchProps = buildProps({
      modelValue: {
        type: [Boolean, String, Number],
        default: false
      },
      value: {
        type: [Boolean, String, Number],
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      width: {
        type: [String, Number],
        default: ""
      },
      inlinePrompt: {
        type: Boolean,
        default: false
      },
      activeIcon: {
        type: iconPropType
      },
      inactiveIcon: {
        type: iconPropType
      },
      activeText: {
        type: String,
        default: ""
      },
      inactiveText: {
        type: String,
        default: ""
      },
      activeColor: {
        type: String,
        default: ""
      },
      inactiveColor: {
        type: String,
        default: ""
      },
      borderColor: {
        type: String,
        default: ""
      },
      activeValue: {
        type: [Boolean, String, Number],
        default: true
      },
      inactiveValue: {
        type: [Boolean, String, Number],
        default: false
      },
      name: {
        type: String,
        default: ""
      },
      validateEvent: {
        type: Boolean,
        default: true
      },
      id: String,
      loading: {
        type: Boolean,
        default: false
      },
      beforeChange: {
        type: definePropType(Function)
      },
      size: {
        type: String,
        validator: isValidComponentSize
      },
      tabindex: {
        type: [String, Number]
      }
    });
    const switchEmits = {
      [UPDATE_MODEL_EVENT]: (val) => isBoolean$2(val) || isString$3(val) || isNumber$2(val),
      [CHANGE_EVENT]: (val) => isBoolean$2(val) || isString$3(val) || isNumber$2(val),
      [INPUT_EVENT]: (val) => isBoolean$2(val) || isString$3(val) || isNumber$2(val)
    };
    const _hoisted_1$f = ["onClick"];
    const _hoisted_2$b = ["id", "aria-checked", "aria-disabled", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"];
    const _hoisted_3$6 = ["aria-hidden"];
    const _hoisted_4$4 = ["aria-hidden"];
    const _hoisted_5$3 = ["aria-hidden"];
    const _hoisted_6$1 = ["aria-hidden"];
    const __default__$i = {
      name: "ElSwitch"
    };
    const _sfc_main$u = /* @__PURE__ */ defineComponent({
      ...__default__$i,
      props: switchProps,
      emits: switchEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const COMPONENT_NAME2 = "ElSwitch";
        const vm = getCurrentInstance();
        const { formItem } = useFormItem();
        const switchSize = useSize();
        const ns2 = useNamespace("switch");
        useDeprecated({
          from: '"value"',
          replacement: '"model-value" or "v-model"',
          scope: COMPONENT_NAME2,
          version: "2.3.0",
          ref: "https://element-plus.org/en-US/component/switch.html#attributes",
          type: "Attribute"
        }, computed(() => {
          var _a2;
          return !!((_a2 = vm.vnode.props) == null ? void 0 : _a2.value);
        }));
        const { inputId } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const switchDisabled = useDisabled$1(computed(() => props.loading));
        const isControlled = ref(props.modelValue !== false);
        const input = ref();
        const core2 = ref();
        const switchKls = computed(() => [
          ns2.b(),
          ns2.m(switchSize.value),
          ns2.is("disabled", switchDisabled.value),
          ns2.is("checked", checked.value)
        ]);
        const coreStyle = computed(() => ({
          width: addUnit(props.width)
        }));
        watch(() => props.modelValue, () => {
          isControlled.value = true;
        });
        watch(() => props.value, () => {
          isControlled.value = false;
        });
        const actualValue = computed(() => {
          return isControlled.value ? props.modelValue : props.value;
        });
        const checked = computed(() => actualValue.value === props.activeValue);
        if (![props.activeValue, props.inactiveValue].includes(actualValue.value)) {
          emit(UPDATE_MODEL_EVENT, props.inactiveValue);
          emit(CHANGE_EVENT, props.inactiveValue);
          emit(INPUT_EVENT, props.inactiveValue);
        }
        watch(checked, (val) => {
          var _a2;
          input.value.checked = val;
          if (props.validateEvent) {
            (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
          }
        });
        const handleChange = () => {
          const val = checked.value ? props.inactiveValue : props.activeValue;
          emit(UPDATE_MODEL_EVENT, val);
          emit(CHANGE_EVENT, val);
          emit(INPUT_EVENT, val);
          nextTick(() => {
            input.value.checked = checked.value;
          });
        };
        const switchValue = () => {
          if (switchDisabled.value)
            return;
          const { beforeChange } = props;
          if (!beforeChange) {
            handleChange();
            return;
          }
          const shouldChange = beforeChange();
          const isPromiseOrBool = [
            isPromise(shouldChange),
            isBoolean$2(shouldChange)
          ].includes(true);
          if (!isPromiseOrBool) {
            throwError(COMPONENT_NAME2, "beforeChange must return type `Promise<boolean>` or `boolean`");
          }
          if (isPromise(shouldChange)) {
            shouldChange.then((result) => {
              if (result) {
                handleChange();
              }
            }).catch((e) => {
            });
          } else if (shouldChange) {
            handleChange();
          }
        };
        const styles = computed(() => {
          return ns2.cssVarBlock({
            ...props.activeColor ? { "on-color": props.activeColor } : null,
            ...props.inactiveColor ? { "off-color": props.inactiveColor } : null,
            ...props.borderColor ? { "border-color": props.borderColor } : null
          });
        });
        const focus = () => {
          var _a2, _b;
          (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
        };
        onMounted(() => {
          input.value.checked = checked.value;
        });
        expose({
          focus,
          checked
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(switchKls)),
            style: normalizeStyle(unref(styles)),
            onClick: withModifiers(switchValue, ["prevent"])
          }, [
            createBaseVNode("input", {
              id: unref(inputId),
              ref_key: "input",
              ref: input,
              class: normalizeClass(unref(ns2).e("input")),
              type: "checkbox",
              role: "switch",
              "aria-checked": unref(checked),
              "aria-disabled": unref(switchDisabled),
              name: _ctx.name,
              "true-value": _ctx.activeValue,
              "false-value": _ctx.inactiveValue,
              disabled: unref(switchDisabled),
              tabindex: _ctx.tabindex,
              onChange: handleChange,
              onKeydown: withKeys(switchValue, ["enter"])
            }, null, 42, _hoisted_2$b),
            !_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass([
                unref(ns2).e("label"),
                unref(ns2).em("label", "left"),
                unref(ns2).is("active", !unref(checked))
              ])
            }, [
              _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveIcon)))
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              !_ctx.inactiveIcon && _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                key: 1,
                "aria-hidden": unref(checked)
              }, toDisplayString$1(_ctx.inactiveText), 9, _hoisted_3$6)) : createCommentVNode("v-if", true)
            ], 2)) : createCommentVNode("v-if", true),
            createBaseVNode("span", {
              ref_key: "core",
              ref: core2,
              class: normalizeClass(unref(ns2).e("core")),
              style: normalizeStyle(unref(coreStyle))
            }, [
              _ctx.inlinePrompt ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns2).e("inner"))
              }, [
                _ctx.activeIcon || _ctx.inactiveIcon ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  _ctx.activeIcon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass([unref(ns2).is("icon"), unref(checked) ? unref(ns2).is("show") : unref(ns2).is("hide")])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass([unref(ns2).is("icon"), !unref(checked) ? unref(ns2).is("show") : unref(ns2).is("hide")])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 64)) : _ctx.activeText || _ctx.inactiveIcon ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  _ctx.activeText ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass([unref(ns2).is("text"), unref(checked) ? unref(ns2).is("show") : unref(ns2).is("hide")]),
                    "aria-hidden": !unref(checked)
                  }, toDisplayString$1(_ctx.activeText.substring(0, 3)), 11, _hoisted_4$4)) : createCommentVNode("v-if", true),
                  _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass([unref(ns2).is("text"), !unref(checked) ? unref(ns2).is("show") : unref(ns2).is("hide")]),
                    "aria-hidden": unref(checked)
                  }, toDisplayString$1(_ctx.inactiveText.substring(0, 3)), 11, _hoisted_5$3)) : createCommentVNode("v-if", true)
                ], 64)) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns2).e("action"))
              }, [
                _ctx.loading ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(ns2).is("loading"))
                }, {
                  default: withCtx(() => [
                    createVNode(unref(loading_default))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true)
              ], 2)
            ], 6),
            !_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? (openBlock(), createElementBlock("span", {
              key: 1,
              class: normalizeClass([
                unref(ns2).e("label"),
                unref(ns2).em("label", "right"),
                unref(ns2).is("active", unref(checked))
              ])
            }, [
              _ctx.activeIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeIcon)))
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              !_ctx.activeIcon && _ctx.activeText ? (openBlock(), createElementBlock("span", {
                key: 1,
                "aria-hidden": !unref(checked)
              }, toDisplayString$1(_ctx.activeText), 9, _hoisted_6$1)) : createCommentVNode("v-if", true)
            ], 2)) : createCommentVNode("v-if", true)
          ], 14, _hoisted_1$f);
        };
      }
    });
    var Switch = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]]);
    const ElSwitch = withInstall(Switch);
    /*!
     * escape-html
     * Copyright(c) 2012-2013 TJ Holowaychuk
     * Copyright(c) 2015 Andreas Lubbe
     * Copyright(c) 2015 Tiancheng "Timothy" Gu
     * MIT Licensed
     */
    var matchHtmlRegExp = /["'&<>]/;
    var escapeHtml_1 = escapeHtml$1;
    function escapeHtml$1(string2) {
      var str = "" + string2;
      var match = matchHtmlRegExp.exec(str);
      if (!match) {
        return str;
      }
      var escape2;
      var html = "";
      var index2 = 0;
      var lastIndex = 0;
      for (index2 = match.index; index2 < str.length; index2++) {
        switch (str.charCodeAt(index2)) {
          case 34:
            escape2 = "&quot;";
            break;
          case 38:
            escape2 = "&amp;";
            break;
          case 39:
            escape2 = "&#39;";
            break;
          case 60:
            escape2 = "&lt;";
            break;
          case 62:
            escape2 = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index2) {
          html += str.substring(lastIndex, index2);
        }
        lastIndex = index2 + 1;
        html += escape2;
      }
      return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
    }
    const getCell = function(event) {
      var _a2;
      return (_a2 = event.target) == null ? void 0 : _a2.closest("td");
    };
    const isObject$2 = function(obj) {
      return obj !== null && typeof obj === "object";
    };
    const orderBy = function(array2, sortKey, reverse, sortMethod, sortBy) {
      if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
        return array2;
      }
      if (typeof reverse === "string") {
        reverse = reverse === "descending" ? -1 : 1;
      } else {
        reverse = reverse && reverse < 0 ? -1 : 1;
      }
      const getKey = sortMethod ? null : function(value, index2) {
        if (sortBy) {
          if (!Array.isArray(sortBy)) {
            sortBy = [sortBy];
          }
          return sortBy.map((by) => {
            if (typeof by === "string") {
              return get(value, by);
            } else {
              return by(value, index2, array2);
            }
          });
        }
        if (sortKey !== "$key") {
          if (isObject$2(value) && "$value" in value)
            value = value.$value;
        }
        return [isObject$2(value) ? get(value, sortKey) : value];
      };
      const compare = function(a2, b2) {
        if (sortMethod) {
          return sortMethod(a2.value, b2.value);
        }
        for (let i = 0, len = a2.key.length; i < len; i++) {
          if (a2.key[i] < b2.key[i]) {
            return -1;
          }
          if (a2.key[i] > b2.key[i]) {
            return 1;
          }
        }
        return 0;
      };
      return array2.map((value, index2) => {
        return {
          value,
          index: index2,
          key: getKey ? getKey(value, index2) : null
        };
      }).sort((a2, b2) => {
        let order = compare(a2, b2);
        if (!order) {
          order = a2.index - b2.index;
        }
        return order * +reverse;
      }).map((item) => item.value);
    };
    const getColumnById = function(table, columnId) {
      let column = null;
      table.columns.forEach((item) => {
        if (item.id === columnId) {
          column = item;
        }
      });
      return column;
    };
    const getColumnByKey = function(table, columnKey) {
      let column = null;
      for (let i = 0; i < table.columns.length; i++) {
        const item = table.columns[i];
        if (item.columnKey === columnKey) {
          column = item;
          break;
        }
      }
      return column;
    };
    const getColumnByCell = function(table, cell, namespace) {
      const matches = (cell.className || "").match(new RegExp(`${namespace}-table_[^\\s]+`, "gm"));
      if (matches) {
        return getColumnById(table, matches[0]);
      }
      return null;
    };
    const getRowIdentity = (row, rowKey2) => {
      if (!row)
        throw new Error("Row is required when get row identity");
      if (typeof rowKey2 === "string") {
        if (!rowKey2.includes(".")) {
          return `${row[rowKey2]}`;
        }
        const key = rowKey2.split(".");
        let current = row;
        for (const element of key) {
          current = current[element];
        }
        return `${current}`;
      } else if (typeof rowKey2 === "function") {
        return rowKey2.call(null, row);
      }
    };
    const getKeysMap = function(array2, rowKey2) {
      const arrayMap2 = {};
      (array2 || []).forEach((row, index2) => {
        arrayMap2[getRowIdentity(row, rowKey2)] = { row, index: index2 };
      });
      return arrayMap2;
    };
    function mergeOptions(defaults2, config) {
      const options = {};
      let key;
      for (key in defaults2) {
        options[key] = defaults2[key];
      }
      for (key in config) {
        if (hasOwn$1(config, key)) {
          const value = config[key];
          if (typeof value !== "undefined") {
            options[key] = value;
          }
        }
      }
      return options;
    }
    function parseWidth(width) {
      if (width === "")
        return width;
      if (width !== void 0) {
        width = Number.parseInt(width, 10);
        if (Number.isNaN(width)) {
          width = "";
        }
      }
      return width;
    }
    function parseMinWidth(minWidth) {
      if (minWidth === "")
        return minWidth;
      if (minWidth !== void 0) {
        minWidth = parseWidth(minWidth);
        if (Number.isNaN(minWidth)) {
          minWidth = 80;
        }
      }
      return minWidth;
    }
    function parseHeight(height) {
      if (typeof height === "number") {
        return height;
      }
      if (typeof height === "string") {
        if (/^\d+(?:px)?$/.test(height)) {
          return Number.parseInt(height, 10);
        } else {
          return height;
        }
      }
      return null;
    }
    function compose(...funcs) {
      if (funcs.length === 0) {
        return (arg) => arg;
      }
      if (funcs.length === 1) {
        return funcs[0];
      }
      return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
    }
    function toggleRowStatus(statusArr, row, newVal) {
      let changed = false;
      const index2 = statusArr.indexOf(row);
      const included = index2 !== -1;
      const addRow = () => {
        statusArr.push(row);
        changed = true;
      };
      const removeRow = () => {
        statusArr.splice(index2, 1);
        changed = true;
      };
      if (typeof newVal === "boolean") {
        if (newVal && !included) {
          addRow();
        } else if (!newVal && included) {
          removeRow();
        }
      } else {
        if (included) {
          removeRow();
        } else {
          addRow();
        }
      }
      return changed;
    }
    function walkTreeNode(root2, cb, childrenKey = "children", lazyKey = "hasChildren") {
      const isNil2 = (array2) => !(Array.isArray(array2) && array2.length);
      function _walker(parent, children, level) {
        cb(parent, children, level);
        children.forEach((item) => {
          if (item[lazyKey]) {
            cb(item, null, level + 1);
            return;
          }
          const children2 = item[childrenKey];
          if (!isNil2(children2)) {
            _walker(item, children2, level + 1);
          }
        });
      }
      root2.forEach((item) => {
        if (item[lazyKey]) {
          cb(item, null, 0);
          return;
        }
        const children = item[childrenKey];
        if (!isNil2(children)) {
          _walker(item, children, 0);
        }
      });
    }
    let removePopper;
    function createTablePopper(parentNode, trigger2, popperContent, popperOptions2, tooltipEffect) {
      const { nextZIndex } = useZIndex();
      const ns2 = parentNode == null ? void 0 : parentNode.dataset.prefix;
      const scrollContainer = parentNode == null ? void 0 : parentNode.querySelector(`.${ns2}-scrollbar__wrap`);
      function renderContent() {
        const isLight = tooltipEffect === "light";
        const content2 = document.createElement("div");
        content2.className = `${ns2}-popper ${isLight ? "is-light" : "is-dark"}`;
        popperContent = escapeHtml_1(popperContent);
        content2.innerHTML = popperContent;
        content2.style.zIndex = String(nextZIndex());
        parentNode == null ? void 0 : parentNode.appendChild(content2);
        return content2;
      }
      function renderArrow() {
        const arrow22 = document.createElement("div");
        arrow22.className = `${ns2}-popper__arrow`;
        return arrow22;
      }
      function showPopper() {
        popperInstance && popperInstance.update();
      }
      removePopper == null ? void 0 : removePopper();
      removePopper = () => {
        try {
          popperInstance && popperInstance.destroy();
          content && (parentNode == null ? void 0 : parentNode.removeChild(content));
          trigger2.removeEventListener("mouseenter", showPopper);
          trigger2.removeEventListener("mouseleave", removePopper);
          scrollContainer == null ? void 0 : scrollContainer.removeEventListener("scroll", removePopper);
          removePopper = void 0;
        } catch (e) {
        }
      };
      let popperInstance = null;
      const content = renderContent();
      const arrow2 = renderArrow();
      content.appendChild(arrow2);
      popperInstance = yn(trigger2, content, {
        strategy: "absolute",
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [0, 8]
            }
          },
          {
            name: "arrow",
            options: {
              element: arrow2,
              padding: 10
            }
          }
        ],
        ...popperOptions2
      });
      trigger2.addEventListener("mouseenter", showPopper);
      trigger2.addEventListener("mouseleave", removePopper);
      scrollContainer == null ? void 0 : scrollContainer.addEventListener("scroll", removePopper);
      return popperInstance;
    }
    const isFixedColumn = (index2, fixed, store, realColumns) => {
      let start = 0;
      let after = index2;
      if (realColumns) {
        if (realColumns[index2].colSpan > 1) {
          return {};
        }
        for (let i = 0; i < index2; i++) {
          start += realColumns[i].colSpan;
        }
        after = start + realColumns[index2].colSpan - 1;
      } else {
        start = index2;
      }
      let fixedLayout;
      const columns2 = store.states.columns;
      switch (fixed) {
        case "left":
          if (after < store.states.fixedLeafColumnsLength.value) {
            fixedLayout = "left";
          }
          break;
        case "right":
          if (start >= columns2.value.length - store.states.rightFixedLeafColumnsLength.value) {
            fixedLayout = "right";
          }
          break;
        default:
          if (after < store.states.fixedLeafColumnsLength.value) {
            fixedLayout = "left";
          } else if (start >= columns2.value.length - store.states.rightFixedLeafColumnsLength.value) {
            fixedLayout = "right";
          }
      }
      return fixedLayout ? {
        direction: fixedLayout,
        start,
        after
      } : {};
    };
    const getFixedColumnsClass = (namespace, index2, fixed, store, realColumns) => {
      const classes = [];
      const { direction: direction2, start } = isFixedColumn(index2, fixed, store, realColumns);
      if (direction2) {
        const isLeft = direction2 === "left";
        classes.push(`${namespace}-fixed-column--${direction2}`);
        if (isLeft && start === store.states.fixedLeafColumnsLength.value - 1) {
          classes.push("is-last-column");
        } else if (!isLeft && start === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
          classes.push("is-first-column");
        }
      }
      return classes;
    };
    function getOffset(offset2, column) {
      return offset2 + (column.realWidth === null || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);
    }
    const getFixedColumnOffset = (index2, fixed, store, realColumns) => {
      const { direction: direction2, start = 0 } = isFixedColumn(index2, fixed, store, realColumns);
      if (!direction2) {
        return;
      }
      const styles = {};
      const isLeft = direction2 === "left";
      const columns2 = store.states.columns.value;
      if (isLeft) {
        styles.left = columns2.slice(0, index2).reduce(getOffset, 0);
      } else {
        styles.right = columns2.slice(start + 1).reverse().reduce(getOffset, 0);
      }
      return styles;
    };
    const ensurePosition = (style2, key) => {
      if (!style2)
        return;
      if (!Number.isNaN(style2[key])) {
        style2[key] = `${style2[key]}px`;
      }
    };
    function useExpand(watcherData) {
      const instance = getCurrentInstance();
      const defaultExpandAll = ref(false);
      const expandRows = ref([]);
      const updateExpandRows = () => {
        const data = watcherData.data.value || [];
        const rowKey2 = watcherData.rowKey.value;
        if (defaultExpandAll.value) {
          expandRows.value = data.slice();
        } else if (rowKey2) {
          const expandRowsMap = getKeysMap(expandRows.value, rowKey2);
          expandRows.value = data.reduce((prev, row) => {
            const rowId = getRowIdentity(row, rowKey2);
            const rowInfo = expandRowsMap[rowId];
            if (rowInfo) {
              prev.push(row);
            }
            return prev;
          }, []);
        } else {
          expandRows.value = [];
        }
      };
      const toggleRowExpansion = (row, expanded) => {
        const changed = toggleRowStatus(expandRows.value, row, expanded);
        if (changed) {
          instance.emit("expand-change", row, expandRows.value.slice());
        }
      };
      const setExpandRowKeys = (rowKeys) => {
        instance.store.assertRowKey();
        const data = watcherData.data.value || [];
        const rowKey2 = watcherData.rowKey.value;
        const keysMap = getKeysMap(data, rowKey2);
        expandRows.value = rowKeys.reduce((prev, cur) => {
          const info = keysMap[cur];
          if (info) {
            prev.push(info.row);
          }
          return prev;
        }, []);
      };
      const isRowExpanded = (row) => {
        const rowKey2 = watcherData.rowKey.value;
        if (rowKey2) {
          const expandMap = getKeysMap(expandRows.value, rowKey2);
          return !!expandMap[getRowIdentity(row, rowKey2)];
        }
        return expandRows.value.includes(row);
      };
      return {
        updateExpandRows,
        toggleRowExpansion,
        setExpandRowKeys,
        isRowExpanded,
        states: {
          expandRows,
          defaultExpandAll
        }
      };
    }
    function useCurrent(watcherData) {
      const instance = getCurrentInstance();
      const _currentRowKey = ref(null);
      const currentRow = ref(null);
      const setCurrentRowKey = (key) => {
        instance.store.assertRowKey();
        _currentRowKey.value = key;
        setCurrentRowByKey(key);
      };
      const restoreCurrentRowKey = () => {
        _currentRowKey.value = null;
      };
      const setCurrentRowByKey = (key) => {
        const { data, rowKey: rowKey2 } = watcherData;
        let _currentRow = null;
        if (rowKey2.value) {
          _currentRow = (unref(data) || []).find((item) => getRowIdentity(item, rowKey2.value) === key);
        }
        currentRow.value = _currentRow;
        instance.emit("current-change", currentRow.value, null);
      };
      const updateCurrentRow = (_currentRow) => {
        const oldCurrentRow = currentRow.value;
        if (_currentRow && _currentRow !== oldCurrentRow) {
          currentRow.value = _currentRow;
          instance.emit("current-change", currentRow.value, oldCurrentRow);
          return;
        }
        if (!_currentRow && oldCurrentRow) {
          currentRow.value = null;
          instance.emit("current-change", null, oldCurrentRow);
        }
      };
      const updateCurrentRowData = () => {
        const rowKey2 = watcherData.rowKey.value;
        const data = watcherData.data.value || [];
        const oldCurrentRow = currentRow.value;
        if (!data.includes(oldCurrentRow) && oldCurrentRow) {
          if (rowKey2) {
            const currentRowKey = getRowIdentity(oldCurrentRow, rowKey2);
            setCurrentRowByKey(currentRowKey);
          } else {
            currentRow.value = null;
          }
          if (currentRow.value === null) {
            instance.emit("current-change", null, oldCurrentRow);
          }
        } else if (_currentRowKey.value) {
          setCurrentRowByKey(_currentRowKey.value);
          restoreCurrentRowKey();
        }
      };
      return {
        setCurrentRowKey,
        restoreCurrentRowKey,
        setCurrentRowByKey,
        updateCurrentRow,
        updateCurrentRowData,
        states: {
          _currentRowKey,
          currentRow
        }
      };
    }
    function useTree$2(watcherData) {
      const expandRowKeys = ref([]);
      const treeData = ref({});
      const indent = ref(16);
      const lazy = ref(false);
      const lazyTreeNodeMap = ref({});
      const lazyColumnIdentifier = ref("hasChildren");
      const childrenColumnName = ref("children");
      const instance = getCurrentInstance();
      const normalizedData = computed(() => {
        if (!watcherData.rowKey.value)
          return {};
        const data = watcherData.data.value || [];
        return normalize(data);
      });
      const normalizedLazyNode = computed(() => {
        const rowKey2 = watcherData.rowKey.value;
        const keys2 = Object.keys(lazyTreeNodeMap.value);
        const res = {};
        if (!keys2.length)
          return res;
        keys2.forEach((key) => {
          if (lazyTreeNodeMap.value[key].length) {
            const item = { children: [] };
            lazyTreeNodeMap.value[key].forEach((row) => {
              const currentRowKey = getRowIdentity(row, rowKey2);
              item.children.push(currentRowKey);
              if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
                res[currentRowKey] = { children: [] };
              }
            });
            res[key] = item;
          }
        });
        return res;
      });
      const normalize = (data) => {
        const rowKey2 = watcherData.rowKey.value;
        const res = {};
        walkTreeNode(data, (parent, children, level) => {
          const parentId = getRowIdentity(parent, rowKey2);
          if (Array.isArray(children)) {
            res[parentId] = {
              children: children.map((row) => getRowIdentity(row, rowKey2)),
              level
            };
          } else if (lazy.value) {
            res[parentId] = {
              children: [],
              lazy: true,
              level
            };
          }
        }, childrenColumnName.value, lazyColumnIdentifier.value);
        return res;
      };
      const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll = ((_a2) => (_a2 = instance.store) == null ? void 0 : _a2.states.defaultExpandAll.value)()) => {
        var _a2;
        const nested = normalizedData.value;
        const normalizedLazyNode_ = normalizedLazyNode.value;
        const keys2 = Object.keys(nested);
        const newTreeData = {};
        if (keys2.length) {
          const oldTreeData = unref(treeData);
          const rootLazyRowKeys = [];
          const getExpanded = (oldValue, key) => {
            if (ifChangeExpandRowKeys) {
              if (expandRowKeys.value) {
                return ifExpandAll || expandRowKeys.value.includes(key);
              } else {
                return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
              }
            } else {
              const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);
              return !!((oldValue == null ? void 0 : oldValue.expanded) || included);
            }
          };
          keys2.forEach((key) => {
            const oldValue = oldTreeData[key];
            const newValue = { ...nested[key] };
            newValue.expanded = getExpanded(oldValue, key);
            if (newValue.lazy) {
              const { loaded = false, loading = false } = oldValue || {};
              newValue.loaded = !!loaded;
              newValue.loading = !!loading;
              rootLazyRowKeys.push(key);
            }
            newTreeData[key] = newValue;
          });
          const lazyKeys = Object.keys(normalizedLazyNode_);
          if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
            lazyKeys.forEach((key) => {
              const oldValue = oldTreeData[key];
              const lazyNodeChildren = normalizedLazyNode_[key].children;
              if (rootLazyRowKeys.includes(key)) {
                if (newTreeData[key].children.length !== 0) {
                  throw new Error("[ElTable]children must be an empty array.");
                }
                newTreeData[key].children = lazyNodeChildren;
              } else {
                const { loaded = false, loading = false } = oldValue || {};
                newTreeData[key] = {
                  lazy: true,
                  loaded: !!loaded,
                  loading: !!loading,
                  expanded: getExpanded(oldValue, key),
                  children: lazyNodeChildren,
                  level: ""
                };
              }
            });
          }
        }
        treeData.value = newTreeData;
        (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();
      };
      watch(() => expandRowKeys.value, () => {
        updateTreeData(true);
      });
      watch(() => normalizedData.value, () => {
        updateTreeData();
      });
      watch(() => normalizedLazyNode.value, () => {
        updateTreeData();
      });
      const updateTreeExpandKeys = (value) => {
        expandRowKeys.value = value;
        updateTreeData();
      };
      const toggleTreeExpansion = (row, expanded) => {
        instance.store.assertRowKey();
        const rowKey2 = watcherData.rowKey.value;
        const id2 = getRowIdentity(row, rowKey2);
        const data = id2 && treeData.value[id2];
        if (id2 && data && "expanded" in data) {
          const oldExpanded = data.expanded;
          expanded = typeof expanded === "undefined" ? !data.expanded : expanded;
          treeData.value[id2].expanded = expanded;
          if (oldExpanded !== expanded) {
            instance.emit("expand-change", row, expanded);
          }
          instance.store.updateTableScrollY();
        }
      };
      const loadOrToggle = (row) => {
        instance.store.assertRowKey();
        const rowKey2 = watcherData.rowKey.value;
        const id2 = getRowIdentity(row, rowKey2);
        const data = treeData.value[id2];
        if (lazy.value && data && "loaded" in data && !data.loaded) {
          loadData(row, id2, data);
        } else {
          toggleTreeExpansion(row, void 0);
        }
      };
      const loadData = (row, key, treeNode) => {
        const { load } = instance.props;
        if (load && !treeData.value[key].loaded) {
          treeData.value[key].loading = true;
          load(row, treeNode, (data) => {
            if (!Array.isArray(data)) {
              throw new TypeError("[ElTable] data must be an array");
            }
            treeData.value[key].loading = false;
            treeData.value[key].loaded = true;
            treeData.value[key].expanded = true;
            if (data.length) {
              lazyTreeNodeMap.value[key] = data;
            }
            instance.emit("expand-change", row, true);
          });
        }
      };
      return {
        loadData,
        loadOrToggle,
        toggleTreeExpansion,
        updateTreeExpandKeys,
        updateTreeData,
        normalize,
        states: {
          expandRowKeys,
          treeData,
          indent,
          lazy,
          lazyTreeNodeMap,
          lazyColumnIdentifier,
          childrenColumnName
        }
      };
    }
    const sortData = (data, states) => {
      const sortingColumn = states.sortingColumn;
      if (!sortingColumn || typeof sortingColumn.sortable === "string") {
        return data;
      }
      return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
    };
    const doFlattenColumns = (columns2) => {
      const result = [];
      columns2.forEach((column) => {
        if (column.children) {
          result.push.apply(result, doFlattenColumns(column.children));
        } else {
          result.push(column);
        }
      });
      return result;
    };
    function useWatcher$1() {
      var _a2;
      const instance = getCurrentInstance();
      const { size: tableSize } = toRefs((_a2 = instance.proxy) == null ? void 0 : _a2.$props);
      const rowKey2 = ref(null);
      const data = ref([]);
      const _data = ref([]);
      const isComplex = ref(false);
      const _columns = ref([]);
      const originColumns = ref([]);
      const columns2 = ref([]);
      const fixedColumns = ref([]);
      const rightFixedColumns = ref([]);
      const leafColumns = ref([]);
      const fixedLeafColumns = ref([]);
      const rightFixedLeafColumns = ref([]);
      const leafColumnsLength = ref(0);
      const fixedLeafColumnsLength = ref(0);
      const rightFixedLeafColumnsLength = ref(0);
      const isAllSelected = ref(false);
      const selection = ref([]);
      const reserveSelection = ref(false);
      const selectOnIndeterminate = ref(false);
      const selectable = ref(null);
      const filters = ref({});
      const filteredData = ref(null);
      const sortingColumn = ref(null);
      const sortProp = ref(null);
      const sortOrder = ref(null);
      const hoverRow = ref(null);
      watch(data, () => instance.state && scheduleLayout(false), {
        deep: true
      });
      const assertRowKey = () => {
        if (!rowKey2.value)
          throw new Error("[ElTable] prop row-key is required");
      };
      const updateColumns = () => {
        fixedColumns.value = _columns.value.filter((column) => column.fixed === true || column.fixed === "left");
        rightFixedColumns.value = _columns.value.filter((column) => column.fixed === "right");
        if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === "selection" && !_columns.value[0].fixed) {
          _columns.value[0].fixed = true;
          fixedColumns.value.unshift(_columns.value[0]);
        }
        const notFixedColumns = _columns.value.filter((column) => !column.fixed);
        originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
        const leafColumns2 = doFlattenColumns(notFixedColumns);
        const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
        const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
        leafColumnsLength.value = leafColumns2.length;
        fixedLeafColumnsLength.value = fixedLeafColumns2.length;
        rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
        columns2.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
        isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
      };
      const scheduleLayout = (needUpdateColumns, immediate = false) => {
        if (needUpdateColumns) {
          updateColumns();
        }
        if (immediate) {
          instance.state.doLayout();
        } else {
          instance.state.debouncedUpdateLayout();
        }
      };
      const isSelected = (row) => {
        return selection.value.includes(row);
      };
      const clearSelection = () => {
        isAllSelected.value = false;
        const oldSelection = selection.value;
        if (oldSelection.length) {
          selection.value = [];
          instance.emit("selection-change", []);
        }
      };
      const cleanSelection = () => {
        let deleted;
        if (rowKey2.value) {
          deleted = [];
          const selectedMap = getKeysMap(selection.value, rowKey2.value);
          const dataMap = getKeysMap(data.value, rowKey2.value);
          for (const key in selectedMap) {
            if (hasOwn$1(selectedMap, key) && !dataMap[key]) {
              deleted.push(selectedMap[key].row);
            }
          }
        } else {
          deleted = selection.value.filter((item) => !data.value.includes(item));
        }
        if (deleted.length) {
          const newSelection = selection.value.filter((item) => !deleted.includes(item));
          selection.value = newSelection;
          instance.emit("selection-change", newSelection.slice());
        }
      };
      const getSelectionRows = () => {
        return (selection.value || []).slice();
      };
      const toggleRowSelection = (row, selected = void 0, emitChange = true) => {
        const changed = toggleRowStatus(selection.value, row, selected);
        if (changed) {
          const newSelection = (selection.value || []).slice();
          if (emitChange) {
            instance.emit("select", newSelection, row);
          }
          instance.emit("selection-change", newSelection);
        }
      };
      const _toggleAllSelection = () => {
        var _a22, _b;
        const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
        isAllSelected.value = value;
        let selectionChanged = false;
        let childrenCount = 0;
        const rowKey22 = (_b = (_a22 = instance == null ? void 0 : instance.store) == null ? void 0 : _a22.states) == null ? void 0 : _b.rowKey.value;
        data.value.forEach((row, index2) => {
          const rowIndex = index2 + childrenCount;
          if (selectable.value) {
            if (selectable.value.call(null, row, rowIndex) && toggleRowStatus(selection.value, row, value)) {
              selectionChanged = true;
            }
          } else {
            if (toggleRowStatus(selection.value, row, value)) {
              selectionChanged = true;
            }
          }
          childrenCount += getChildrenCount(getRowIdentity(row, rowKey22));
        });
        if (selectionChanged) {
          instance.emit("selection-change", selection.value ? selection.value.slice() : []);
        }
        instance.emit("select-all", selection.value);
      };
      const updateSelectionByRowKey = () => {
        const selectedMap = getKeysMap(selection.value, rowKey2.value);
        data.value.forEach((row) => {
          const rowId = getRowIdentity(row, rowKey2.value);
          const rowInfo = selectedMap[rowId];
          if (rowInfo) {
            selection.value[rowInfo.index] = row;
          }
        });
      };
      const updateAllSelected = () => {
        var _a22, _b, _c;
        if (((_a22 = data.value) == null ? void 0 : _a22.length) === 0) {
          isAllSelected.value = false;
          return;
        }
        let selectedMap;
        if (rowKey2.value) {
          selectedMap = getKeysMap(selection.value, rowKey2.value);
        }
        const isSelected2 = function(row) {
          if (selectedMap) {
            return !!selectedMap[getRowIdentity(row, rowKey2.value)];
          } else {
            return selection.value.includes(row);
          }
        };
        let isAllSelected_ = true;
        let selectedCount = 0;
        let childrenCount = 0;
        for (let i = 0, j = (data.value || []).length; i < j; i++) {
          const keyProp = (_c = (_b = instance == null ? void 0 : instance.store) == null ? void 0 : _b.states) == null ? void 0 : _c.rowKey.value;
          const rowIndex = i + childrenCount;
          const item = data.value[i];
          const isRowSelectable = selectable.value && selectable.value.call(null, item, rowIndex);
          if (!isSelected2(item)) {
            if (!selectable.value || isRowSelectable) {
              isAllSelected_ = false;
              break;
            }
          } else {
            selectedCount++;
          }
          childrenCount += getChildrenCount(getRowIdentity(item, keyProp));
        }
        if (selectedCount === 0)
          isAllSelected_ = false;
        isAllSelected.value = isAllSelected_;
      };
      const getChildrenCount = (rowKey22) => {
        var _a22;
        if (!instance || !instance.store)
          return 0;
        const { treeData } = instance.store.states;
        let count = 0;
        const children = (_a22 = treeData.value[rowKey22]) == null ? void 0 : _a22.children;
        if (children) {
          count += children.length;
          children.forEach((childKey) => {
            count += getChildrenCount(childKey);
          });
        }
        return count;
      };
      const updateFilters = (columns22, values) => {
        if (!Array.isArray(columns22)) {
          columns22 = [columns22];
        }
        const filters_ = {};
        columns22.forEach((col) => {
          filters.value[col.id] = values;
          filters_[col.columnKey || col.id] = values;
        });
        return filters_;
      };
      const updateSort = (column, prop, order) => {
        if (sortingColumn.value && sortingColumn.value !== column) {
          sortingColumn.value.order = null;
        }
        sortingColumn.value = column;
        sortProp.value = prop;
        sortOrder.value = order;
      };
      const execFilter = () => {
        let sourceData = unref(_data);
        Object.keys(filters.value).forEach((columnId) => {
          const values = filters.value[columnId];
          if (!values || values.length === 0)
            return;
          const column = getColumnById({
            columns: columns2.value
          }, columnId);
          if (column && column.filterMethod) {
            sourceData = sourceData.filter((row) => {
              return values.some((value) => column.filterMethod.call(null, value, row, column));
            });
          }
        });
        filteredData.value = sourceData;
      };
      const execSort = () => {
        data.value = sortData(filteredData.value, {
          sortingColumn: sortingColumn.value,
          sortProp: sortProp.value,
          sortOrder: sortOrder.value
        });
      };
      const execQuery = (ignore = void 0) => {
        if (!(ignore && ignore.filter)) {
          execFilter();
        }
        execSort();
      };
      const clearFilter = (columnKeys) => {
        const { tableHeaderRef } = instance.refs;
        if (!tableHeaderRef)
          return;
        const panels = Object.assign({}, tableHeaderRef.filterPanels);
        const keys2 = Object.keys(panels);
        if (!keys2.length)
          return;
        if (typeof columnKeys === "string") {
          columnKeys = [columnKeys];
        }
        if (Array.isArray(columnKeys)) {
          const columns_ = columnKeys.map((key) => getColumnByKey({
            columns: columns2.value
          }, key));
          keys2.forEach((key) => {
            const column = columns_.find((col) => col.id === key);
            if (column) {
              column.filteredValue = [];
            }
          });
          instance.store.commit("filterChange", {
            column: columns_,
            values: [],
            silent: true,
            multi: true
          });
        } else {
          keys2.forEach((key) => {
            const column = columns2.value.find((col) => col.id === key);
            if (column) {
              column.filteredValue = [];
            }
          });
          filters.value = {};
          instance.store.commit("filterChange", {
            column: {},
            values: [],
            silent: true
          });
        }
      };
      const clearSort = () => {
        if (!sortingColumn.value)
          return;
        updateSort(null, null, null);
        instance.store.commit("changeSortCondition", {
          silent: true
        });
      };
      const {
        setExpandRowKeys,
        toggleRowExpansion,
        updateExpandRows,
        states: expandStates,
        isRowExpanded
      } = useExpand({
        data,
        rowKey: rowKey2
      });
      const {
        updateTreeExpandKeys,
        toggleTreeExpansion,
        updateTreeData,
        loadOrToggle,
        states: treeStates
      } = useTree$2({
        data,
        rowKey: rowKey2
      });
      const {
        updateCurrentRowData,
        updateCurrentRow,
        setCurrentRowKey,
        states: currentData
      } = useCurrent({
        data,
        rowKey: rowKey2
      });
      const setExpandRowKeysAdapter = (val) => {
        setExpandRowKeys(val);
        updateTreeExpandKeys(val);
      };
      const toggleRowExpansionAdapter = (row, expanded) => {
        const hasExpandColumn = columns2.value.some(({ type: type2 }) => type2 === "expand");
        if (hasExpandColumn) {
          toggleRowExpansion(row, expanded);
        } else {
          toggleTreeExpansion(row, expanded);
        }
      };
      return {
        assertRowKey,
        updateColumns,
        scheduleLayout,
        isSelected,
        clearSelection,
        cleanSelection,
        getSelectionRows,
        toggleRowSelection,
        _toggleAllSelection,
        toggleAllSelection: null,
        updateSelectionByRowKey,
        updateAllSelected,
        updateFilters,
        updateCurrentRow,
        updateSort,
        execFilter,
        execSort,
        execQuery,
        clearFilter,
        clearSort,
        toggleRowExpansion,
        setExpandRowKeysAdapter,
        setCurrentRowKey,
        toggleRowExpansionAdapter,
        isRowExpanded,
        updateExpandRows,
        updateCurrentRowData,
        loadOrToggle,
        updateTreeData,
        states: {
          tableSize,
          rowKey: rowKey2,
          data,
          _data,
          isComplex,
          _columns,
          originColumns,
          columns: columns2,
          fixedColumns,
          rightFixedColumns,
          leafColumns,
          fixedLeafColumns,
          rightFixedLeafColumns,
          leafColumnsLength,
          fixedLeafColumnsLength,
          rightFixedLeafColumnsLength,
          isAllSelected,
          selection,
          reserveSelection,
          selectOnIndeterminate,
          selectable,
          filters,
          filteredData,
          sortingColumn,
          sortProp,
          sortOrder,
          hoverRow,
          ...expandStates,
          ...treeStates,
          ...currentData
        }
      };
    }
    function replaceColumn(array2, column) {
      return array2.map((item) => {
        var _a2;
        if (item.id === column.id) {
          return column;
        } else if ((_a2 = item.children) == null ? void 0 : _a2.length) {
          item.children = replaceColumn(item.children, column);
        }
        return item;
      });
    }
    function sortColumn(array2) {
      array2.forEach((item) => {
        var _a2, _b;
        item.no = (_a2 = item.getColumnIndex) == null ? void 0 : _a2.call(item);
        if ((_b = item.children) == null ? void 0 : _b.length) {
          sortColumn(item.children);
        }
      });
      array2.sort((cur, pre) => cur.no - pre.no);
    }
    function useStore() {
      const instance = getCurrentInstance();
      const watcher = useWatcher$1();
      const ns2 = useNamespace("table");
      const mutations = {
        setData(states, data) {
          const dataInstanceChanged = unref(states._data) !== data;
          states.data.value = data;
          states._data.value = data;
          instance.store.execQuery();
          instance.store.updateCurrentRowData();
          instance.store.updateExpandRows();
          instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);
          if (unref(states.reserveSelection)) {
            instance.store.assertRowKey();
            instance.store.updateSelectionByRowKey();
          } else {
            if (dataInstanceChanged) {
              instance.store.clearSelection();
            } else {
              instance.store.cleanSelection();
            }
          }
          instance.store.updateAllSelected();
          if (instance.$ready) {
            instance.store.scheduleLayout();
          }
        },
        insertColumn(states, column, parent) {
          const array2 = unref(states._columns);
          let newColumns = [];
          if (!parent) {
            array2.push(column);
            newColumns = array2;
          } else {
            if (parent && !parent.children) {
              parent.children = [];
            }
            parent.children.push(column);
            newColumns = replaceColumn(array2, parent);
          }
          sortColumn(newColumns);
          states._columns.value = newColumns;
          if (column.type === "selection") {
            states.selectable.value = column.selectable;
            states.reserveSelection.value = column.reserveSelection;
          }
          if (instance.$ready) {
            instance.store.updateColumns();
            instance.store.scheduleLayout();
          }
        },
        removeColumn(states, column, parent) {
          const array2 = unref(states._columns) || [];
          if (parent) {
            parent.children.splice(parent.children.findIndex((item) => item.id === column.id), 1);
            if (parent.children.length === 0) {
              delete parent.children;
            }
            states._columns.value = replaceColumn(array2, parent);
          } else {
            const index2 = array2.indexOf(column);
            if (index2 > -1) {
              array2.splice(index2, 1);
              states._columns.value = array2;
            }
          }
          if (instance.$ready) {
            instance.store.updateColumns();
            instance.store.scheduleLayout();
          }
        },
        sort(states, options) {
          const { prop, order, init } = options;
          if (prop) {
            const column = unref(states.columns).find((column2) => column2.property === prop);
            if (column) {
              column.order = order;
              instance.store.updateSort(column, prop, order);
              instance.store.commit("changeSortCondition", { init });
            }
          }
        },
        changeSortCondition(states, options) {
          const { sortingColumn, sortProp, sortOrder } = states;
          const columnValue = unref(sortingColumn), propValue = unref(sortProp), orderValue = unref(sortOrder);
          if (orderValue === null) {
            states.sortingColumn.value = null;
            states.sortProp.value = null;
          }
          const ignore = { filter: true };
          instance.store.execQuery(ignore);
          if (!options || !(options.silent || options.init)) {
            instance.emit("sort-change", {
              column: columnValue,
              prop: propValue,
              order: orderValue
            });
          }
          instance.store.updateTableScrollY();
        },
        filterChange(_states, options) {
          const { column, values, silent } = options;
          const newFilters = instance.store.updateFilters(column, values);
          instance.store.execQuery();
          if (!silent) {
            instance.emit("filter-change", newFilters);
          }
          instance.store.updateTableScrollY();
        },
        toggleAllSelection() {
          instance.store.toggleAllSelection();
        },
        rowSelectedChanged(_states, row) {
          instance.store.toggleRowSelection(row);
          instance.store.updateAllSelected();
        },
        setHoverRow(states, row) {
          states.hoverRow.value = row;
        },
        setCurrentRow(_states, row) {
          instance.store.updateCurrentRow(row);
        }
      };
      const commit = function(name, ...args) {
        const mutations2 = instance.store.mutations;
        if (mutations2[name]) {
          mutations2[name].apply(instance, [instance.store.states].concat(args));
        } else {
          throw new Error(`Action not found: ${name}`);
        }
      };
      const updateTableScrollY = function() {
        nextTick(() => instance.layout.updateScrollY.apply(instance.layout));
      };
      return {
        ns: ns2,
        ...watcher,
        mutations,
        commit,
        updateTableScrollY
      };
    }
    const InitialStateMap = {
      rowKey: "rowKey",
      defaultExpandAll: "defaultExpandAll",
      selectOnIndeterminate: "selectOnIndeterminate",
      indent: "indent",
      lazy: "lazy",
      data: "data",
      ["treeProps.hasChildren"]: {
        key: "lazyColumnIdentifier",
        default: "hasChildren"
      },
      ["treeProps.children"]: {
        key: "childrenColumnName",
        default: "children"
      }
    };
    function createStore(table, props) {
      if (!table) {
        throw new Error("Table is required.");
      }
      const store = useStore();
      store.toggleAllSelection = debounce(store._toggleAllSelection, 10);
      Object.keys(InitialStateMap).forEach((key) => {
        handleValue(getArrKeysValue(props, key), key, store);
      });
      proxyTableProps(store, props);
      return store;
    }
    function proxyTableProps(store, props) {
      Object.keys(InitialStateMap).forEach((key) => {
        watch(() => getArrKeysValue(props, key), (value) => {
          handleValue(value, key, store);
        });
      });
    }
    function handleValue(value, propsKey, store) {
      let newVal = value;
      let storeKey = InitialStateMap[propsKey];
      if (typeof InitialStateMap[propsKey] === "object") {
        storeKey = storeKey.key;
        newVal = newVal || InitialStateMap[propsKey].default;
      }
      store.states[storeKey].value = newVal;
    }
    function getArrKeysValue(props, keys2) {
      if (keys2.includes(".")) {
        const keyList = keys2.split(".");
        let value = props;
        keyList.forEach((key) => {
          value = value[key];
        });
        return value;
      } else {
        return props[keys2];
      }
    }
    class TableLayout {
      constructor(options) {
        this.observers = [];
        this.table = null;
        this.store = null;
        this.columns = [];
        this.fit = true;
        this.showHeader = true;
        this.height = ref(null);
        this.scrollX = ref(false);
        this.scrollY = ref(false);
        this.bodyWidth = ref(null);
        this.fixedWidth = ref(null);
        this.rightFixedWidth = ref(null);
        this.gutterWidth = 0;
        for (const name in options) {
          if (hasOwn$1(options, name)) {
            if (isRef(this[name])) {
              this[name].value = options[name];
            } else {
              this[name] = options[name];
            }
          }
        }
        if (!this.table) {
          throw new Error("Table is required for Table Layout");
        }
        if (!this.store) {
          throw new Error("Store is required for Table Layout");
        }
      }
      updateScrollY() {
        const height = this.height.value;
        if (height === null)
          return false;
        const scrollBarRef = this.table.refs.scrollBarRef;
        if (this.table.vnode.el && scrollBarRef) {
          let scrollY = true;
          const prevScrollY = this.scrollY.value;
          scrollY = scrollBarRef.wrap$.scrollHeight > scrollBarRef.wrap$.clientHeight;
          this.scrollY.value = scrollY;
          return prevScrollY !== scrollY;
        }
        return false;
      }
      setHeight(value, prop = "height") {
        if (!isClient)
          return;
        const el = this.table.vnode.el;
        value = parseHeight(value);
        this.height.value = Number(value);
        if (!el && (value || value === 0))
          return nextTick(() => this.setHeight(value, prop));
        if (typeof value === "number") {
          el.style[prop] = `${value}px`;
          this.updateElsHeight();
        } else if (typeof value === "string") {
          el.style[prop] = value;
          this.updateElsHeight();
        }
      }
      setMaxHeight(value) {
        this.setHeight(value, "max-height");
      }
      getFlattenColumns() {
        const flattenColumns = [];
        const columns2 = this.table.store.states.columns.value;
        columns2.forEach((column) => {
          if (column.isColumnGroup) {
            flattenColumns.push.apply(flattenColumns, column.columns);
          } else {
            flattenColumns.push(column);
          }
        });
        return flattenColumns;
      }
      updateElsHeight() {
        this.updateScrollY();
        this.notifyObservers("scrollable");
      }
      headerDisplayNone(elm) {
        if (!elm)
          return true;
        let headerChild = elm;
        while (headerChild.tagName !== "DIV") {
          if (getComputedStyle(headerChild).display === "none") {
            return true;
          }
          headerChild = headerChild.parentElement;
        }
        return false;
      }
      updateColumnsWidth() {
        if (!isClient)
          return;
        const fit = this.fit;
        const bodyWidth = this.table.vnode.el.clientWidth;
        let bodyMinWidth = 0;
        const flattenColumns = this.getFlattenColumns();
        const flexColumns = flattenColumns.filter((column) => typeof column.width !== "number");
        flattenColumns.forEach((column) => {
          if (typeof column.width === "number" && column.realWidth)
            column.realWidth = null;
        });
        if (flexColumns.length > 0 && fit) {
          flattenColumns.forEach((column) => {
            bodyMinWidth += Number(column.width || column.minWidth || 80);
          });
          if (bodyMinWidth <= bodyWidth) {
            this.scrollX.value = false;
            const totalFlexWidth = bodyWidth - bodyMinWidth;
            if (flexColumns.length === 1) {
              flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
            } else {
              const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);
              const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
              let noneFirstWidth = 0;
              flexColumns.forEach((column, index2) => {
                if (index2 === 0)
                  return;
                const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
                noneFirstWidth += flexWidth;
                column.realWidth = Number(column.minWidth || 80) + flexWidth;
              });
              flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
            }
          } else {
            this.scrollX.value = true;
            flexColumns.forEach((column) => {
              column.realWidth = Number(column.minWidth);
            });
          }
          this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
          this.table.state.resizeState.value.width = this.bodyWidth.value;
        } else {
          flattenColumns.forEach((column) => {
            if (!column.width && !column.minWidth) {
              column.realWidth = 80;
            } else {
              column.realWidth = Number(column.width || column.minWidth);
            }
            bodyMinWidth += column.realWidth;
          });
          this.scrollX.value = bodyMinWidth > bodyWidth;
          this.bodyWidth.value = bodyMinWidth;
        }
        const fixedColumns = this.store.states.fixedColumns.value;
        if (fixedColumns.length > 0) {
          let fixedWidth = 0;
          fixedColumns.forEach((column) => {
            fixedWidth += Number(column.realWidth || column.width);
          });
          this.fixedWidth.value = fixedWidth;
        }
        const rightFixedColumns = this.store.states.rightFixedColumns.value;
        if (rightFixedColumns.length > 0) {
          let rightFixedWidth = 0;
          rightFixedColumns.forEach((column) => {
            rightFixedWidth += Number(column.realWidth || column.width);
          });
          this.rightFixedWidth.value = rightFixedWidth;
        }
        this.notifyObservers("columns");
      }
      addObserver(observer) {
        this.observers.push(observer);
      }
      removeObserver(observer) {
        const index2 = this.observers.indexOf(observer);
        if (index2 !== -1) {
          this.observers.splice(index2, 1);
        }
      }
      notifyObservers(event) {
        const observers = this.observers;
        observers.forEach((observer) => {
          var _a2, _b;
          switch (event) {
            case "columns":
              (_a2 = observer.state) == null ? void 0 : _a2.onColumnsChange(this);
              break;
            case "scrollable":
              (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);
              break;
            default:
              throw new Error(`Table Layout don't have event ${event}.`);
          }
        });
      }
    }
    const { CheckboxGroup: ElCheckboxGroup } = ElCheckbox;
    const _sfc_main$t = defineComponent({
      name: "ElTableFilterPanel",
      components: {
        ElCheckbox,
        ElCheckboxGroup,
        ElScrollbar,
        ElTooltip,
        ElIcon,
        ArrowDown: arrow_down_default,
        ArrowUp: arrow_up_default
      },
      directives: { ClickOutside },
      props: {
        placement: {
          type: String,
          default: "bottom-start"
        },
        store: {
          type: Object
        },
        column: {
          type: Object
        },
        upDataColumn: {
          type: Function
        }
      },
      setup(props) {
        const instance = getCurrentInstance();
        const { t } = useLocale();
        const ns2 = useNamespace("table-filter");
        const parent = instance == null ? void 0 : instance.parent;
        if (!parent.filterPanels.value[props.column.id]) {
          parent.filterPanels.value[props.column.id] = instance;
        }
        const tooltipVisible = ref(false);
        const tooltip = ref(null);
        const filters = computed(() => {
          return props.column && props.column.filters;
        });
        const filterValue = computed({
          get: () => {
            var _a2;
            return (((_a2 = props.column) == null ? void 0 : _a2.filteredValue) || [])[0];
          },
          set: (value) => {
            if (filteredValue.value) {
              if (typeof value !== "undefined" && value !== null) {
                filteredValue.value.splice(0, 1, value);
              } else {
                filteredValue.value.splice(0, 1);
              }
            }
          }
        });
        const filteredValue = computed({
          get() {
            if (props.column) {
              return props.column.filteredValue || [];
            }
            return [];
          },
          set(value) {
            if (props.column) {
              props.upDataColumn("filteredValue", value);
            }
          }
        });
        const multiple = computed(() => {
          if (props.column) {
            return props.column.filterMultiple;
          }
          return true;
        });
        const isActive = (filter) => {
          return filter.value === filterValue.value;
        };
        const hidden = () => {
          tooltipVisible.value = false;
        };
        const showFilterPanel = (e) => {
          e.stopPropagation();
          tooltipVisible.value = !tooltipVisible.value;
        };
        const hideFilterPanel = () => {
          tooltipVisible.value = false;
        };
        const handleConfirm = () => {
          confirmFilter(filteredValue.value);
          hidden();
        };
        const handleReset = () => {
          filteredValue.value = [];
          confirmFilter(filteredValue.value);
          hidden();
        };
        const handleSelect = (_filterValue) => {
          filterValue.value = _filterValue;
          if (typeof _filterValue !== "undefined" && _filterValue !== null) {
            confirmFilter(filteredValue.value);
          } else {
            confirmFilter([]);
          }
          hidden();
        };
        const confirmFilter = (filteredValue2) => {
          props.store.commit("filterChange", {
            column: props.column,
            values: filteredValue2
          });
          props.store.updateAllSelected();
        };
        watch(tooltipVisible, (value) => {
          if (props.column) {
            props.upDataColumn("filterOpened", value);
          }
        }, {
          immediate: true
        });
        const popperPaneRef = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = tooltip.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
        });
        return {
          tooltipVisible,
          multiple,
          filteredValue,
          filterValue,
          filters,
          handleConfirm,
          handleReset,
          handleSelect,
          isActive,
          t,
          ns: ns2,
          showFilterPanel,
          hideFilterPanel,
          popperPaneRef,
          tooltip
        };
      }
    });
    const _hoisted_1$e = { key: 0 };
    const _hoisted_2$a = ["disabled"];
    const _hoisted_3$5 = ["label", "onClick"];
    function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_checkbox = resolveComponent("el-checkbox");
      const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_arrow_up = resolveComponent("arrow-up");
      const _component_arrow_down = resolveComponent("arrow-down");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _directive_click_outside = resolveDirective("click-outside");
      return openBlock(), createBlock(_component_el_tooltip, {
        ref: "tooltip",
        visible: _ctx.tooltipVisible,
        offset: 0,
        placement: _ctx.placement,
        "show-arrow": false,
        "stop-popper-mouse-event": false,
        teleported: "",
        effect: "light",
        pure: "",
        "popper-class": _ctx.ns.b(),
        persistent: ""
      }, {
        content: withCtx(() => [
          _ctx.multiple ? (openBlock(), createElementBlock("div", _hoisted_1$e, [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.ns.e("content"))
            }, [
              createVNode(_component_el_scrollbar, {
                "wrap-class": _ctx.ns.e("wrap")
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_checkbox_group, {
                    modelValue: _ctx.filteredValue,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.filteredValue = $event),
                    class: normalizeClass(_ctx.ns.e("checkbox-group"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
                        return openBlock(), createBlock(_component_el_checkbox, {
                          key: filter.value,
                          label: filter.value
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString$1(filter.text), 1)
                          ]),
                          _: 2
                        }, 1032, ["label"]);
                      }), 128))
                    ]),
                    _: 1
                  }, 8, ["modelValue", "class"])
                ]),
                _: 1
              }, 8, ["wrap-class"])
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass(_ctx.ns.e("bottom"))
            }, [
              createBaseVNode("button", {
                class: normalizeClass({ [_ctx.ns.is("disabled")]: _ctx.filteredValue.length === 0 }),
                disabled: _ctx.filteredValue.length === 0,
                type: "button",
                onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleConfirm && _ctx.handleConfirm(...args))
              }, toDisplayString$1(_ctx.t("el.table.confirmFilter")), 11, _hoisted_2$a),
              createBaseVNode("button", {
                type: "button",
                onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleReset && _ctx.handleReset(...args))
              }, toDisplayString$1(_ctx.t("el.table.resetFilter")), 1)
            ], 2)
          ])) : (openBlock(), createElementBlock("ul", {
            key: 1,
            class: normalizeClass(_ctx.ns.e("list"))
          }, [
            createBaseVNode("li", {
              class: normalizeClass([
                _ctx.ns.e("list-item"),
                {
                  [_ctx.ns.is("active")]: _ctx.filterValue === void 0 || _ctx.filterValue === null
                }
              ]),
              onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleSelect(null))
            }, toDisplayString$1(_ctx.t("el.table.clearFilter")), 3),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
              return openBlock(), createElementBlock("li", {
                key: filter.value,
                class: normalizeClass([_ctx.ns.e("list-item"), _ctx.ns.is("active", _ctx.isActive(filter))]),
                label: filter.value,
                onClick: ($event) => _ctx.handleSelect(filter.value)
              }, toDisplayString$1(filter.text), 11, _hoisted_3$5);
            }), 128))
          ], 2))
        ]),
        default: withCtx(() => [
          withDirectives((openBlock(), createElementBlock("span", {
            class: normalizeClass([
              `${_ctx.ns.namespace.value}-table__column-filter-trigger`,
              `${_ctx.ns.namespace.value}-none-outline`
            ]),
            onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showFilterPanel && _ctx.showFilterPanel(...args))
          }, [
            createVNode(_component_el_icon, null, {
              default: withCtx(() => [
                _ctx.column.filterOpened ? (openBlock(), createBlock(_component_arrow_up, { key: 0 })) : (openBlock(), createBlock(_component_arrow_down, { key: 1 }))
              ]),
              _: 1
            })
          ], 2)), [
            [_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]
          ])
        ]),
        _: 1
      }, 8, ["visible", "placement", "popper-class"]);
    }
    var FilterPanel = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$6], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/filter-panel.vue"]]);
    function useLayoutObserver(root2) {
      const instance = getCurrentInstance();
      onBeforeMount(() => {
        tableLayout.value.addObserver(instance);
      });
      onMounted(() => {
        onColumnsChange(tableLayout.value);
        onScrollableChange(tableLayout.value);
      });
      onUpdated(() => {
        onColumnsChange(tableLayout.value);
        onScrollableChange(tableLayout.value);
      });
      onUnmounted(() => {
        tableLayout.value.removeObserver(instance);
      });
      const tableLayout = computed(() => {
        const layout2 = root2.layout;
        if (!layout2) {
          throw new Error("Can not find table layout.");
        }
        return layout2;
      });
      const onColumnsChange = (layout2) => {
        var _a2;
        const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col")) || [];
        if (!cols.length)
          return;
        const flattenColumns = layout2.getFlattenColumns();
        const columnsMap = {};
        flattenColumns.forEach((column) => {
          columnsMap[column.id] = column;
        });
        for (let i = 0, j = cols.length; i < j; i++) {
          const col = cols[i];
          const name = col.getAttribute("name");
          const column = columnsMap[name];
          if (column) {
            col.setAttribute("width", column.realWidth || column.width);
          }
        }
      };
      const onScrollableChange = (layout2) => {
        var _a2, _b;
        const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col[name=gutter]")) || [];
        for (let i = 0, j = cols.length; i < j; i++) {
          const col = cols[i];
          col.setAttribute("width", layout2.scrollY.value ? layout2.gutterWidth : "0");
        }
        const ths = ((_b = root2.vnode.el) == null ? void 0 : _b.querySelectorAll("th.gutter")) || [];
        for (let i = 0, j = ths.length; i < j; i++) {
          const th = ths[i];
          th.style.width = layout2.scrollY.value ? `${layout2.gutterWidth}px` : "0";
          th.style.display = layout2.scrollY.value ? "" : "none";
        }
      };
      return {
        tableLayout: tableLayout.value,
        onColumnsChange,
        onScrollableChange
      };
    }
    const TABLE_INJECTION_KEY = Symbol("ElTable");
    function useEvent(props, emit) {
      const instance = getCurrentInstance();
      const parent = inject(TABLE_INJECTION_KEY);
      const handleFilterClick = (event) => {
        event.stopPropagation();
        return;
      };
      const handleHeaderClick = (event, column) => {
        if (!column.filters && column.sortable) {
          handleSortClick(event, column, false);
        } else if (column.filterable && !column.sortable) {
          handleFilterClick(event);
        }
        parent == null ? void 0 : parent.emit("header-click", column, event);
      };
      const handleHeaderContextMenu = (event, column) => {
        parent == null ? void 0 : parent.emit("header-contextmenu", column, event);
      };
      const draggingColumn = ref(null);
      const dragging = ref(false);
      const dragState = ref({});
      const handleMouseDown = (event, column) => {
        if (!isClient)
          return;
        if (column.children && column.children.length > 0)
          return;
        if (draggingColumn.value && props.border) {
          dragging.value = true;
          const table = parent;
          emit("set-drag-visible", true);
          const tableEl = table == null ? void 0 : table.vnode.el;
          const tableLeft = tableEl.getBoundingClientRect().left;
          const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
          const columnRect = columnEl.getBoundingClientRect();
          const minLeft = columnRect.left - tableLeft + 30;
          addClass(columnEl, "noclick");
          dragState.value = {
            startMouseLeft: event.clientX,
            startLeft: columnRect.right - tableLeft,
            startColumnLeft: columnRect.left - tableLeft,
            tableLeft
          };
          const resizeProxy = table == null ? void 0 : table.refs.resizeProxy;
          resizeProxy.style.left = `${dragState.value.startLeft}px`;
          document.onselectstart = function() {
            return false;
          };
          document.ondragstart = function() {
            return false;
          };
          const handleMouseMove2 = (event2) => {
            const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
            const proxyLeft = dragState.value.startLeft + deltaLeft;
            resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
          };
          const handleMouseUp = () => {
            if (dragging.value) {
              const { startColumnLeft, startLeft } = dragState.value;
              const finalLeft = Number.parseInt(resizeProxy.style.left, 10);
              const columnWidth = finalLeft - startColumnLeft;
              column.width = column.realWidth = columnWidth;
              table == null ? void 0 : table.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event);
              requestAnimationFrame(() => {
                props.store.scheduleLayout(false, true);
              });
              document.body.style.cursor = "";
              dragging.value = false;
              draggingColumn.value = null;
              dragState.value = {};
              emit("set-drag-visible", false);
            }
            document.removeEventListener("mousemove", handleMouseMove2);
            document.removeEventListener("mouseup", handleMouseUp);
            document.onselectstart = null;
            document.ondragstart = null;
            setTimeout(() => {
              removeClass(columnEl, "noclick");
            }, 0);
          };
          document.addEventListener("mousemove", handleMouseMove2);
          document.addEventListener("mouseup", handleMouseUp);
        }
      };
      const handleMouseMove = (event, column) => {
        var _a2;
        if (column.children && column.children.length > 0)
          return;
        const target = (_a2 = event.target) == null ? void 0 : _a2.closest("th");
        if (!column || !column.resizable)
          return;
        if (!dragging.value && props.border) {
          const rect = target.getBoundingClientRect();
          const bodyStyle = document.body.style;
          if (rect.width > 12 && rect.right - event.pageX < 8) {
            bodyStyle.cursor = "col-resize";
            if (hasClass(target, "is-sortable")) {
              target.style.cursor = "col-resize";
            }
            draggingColumn.value = column;
          } else if (!dragging.value) {
            bodyStyle.cursor = "";
            if (hasClass(target, "is-sortable")) {
              target.style.cursor = "pointer";
            }
            draggingColumn.value = null;
          }
        }
      };
      const handleMouseOut = () => {
        if (!isClient)
          return;
        document.body.style.cursor = "";
      };
      const toggleOrder = ({ order, sortOrders }) => {
        if (order === "")
          return sortOrders[0];
        const index2 = sortOrders.indexOf(order || null);
        return sortOrders[index2 > sortOrders.length - 2 ? 0 : index2 + 1];
      };
      const handleSortClick = (event, column, givenOrder) => {
        var _a2;
        event.stopPropagation();
        const order = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
        const target = (_a2 = event.target) == null ? void 0 : _a2.closest("th");
        if (target) {
          if (hasClass(target, "noclick")) {
            removeClass(target, "noclick");
            return;
          }
        }
        if (!column.sortable)
          return;
        const states = props.store.states;
        let sortProp = states.sortProp.value;
        let sortOrder;
        const sortingColumn = states.sortingColumn.value;
        if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
          if (sortingColumn) {
            sortingColumn.order = null;
          }
          states.sortingColumn.value = column;
          sortProp = column.property;
        }
        if (!order) {
          sortOrder = column.order = null;
        } else {
          sortOrder = column.order = order;
        }
        states.sortProp.value = sortProp;
        states.sortOrder.value = sortOrder;
        parent == null ? void 0 : parent.store.commit("changeSortCondition");
      };
      return {
        handleHeaderClick,
        handleHeaderContextMenu,
        handleMouseDown,
        handleMouseMove,
        handleMouseOut,
        handleSortClick,
        handleFilterClick
      };
    }
    function useStyle$2(props) {
      const parent = inject(TABLE_INJECTION_KEY);
      const ns2 = useNamespace("table");
      const getHeaderRowStyle = (rowIndex) => {
        const headerRowStyle = parent == null ? void 0 : parent.props.headerRowStyle;
        if (typeof headerRowStyle === "function") {
          return headerRowStyle.call(null, { rowIndex });
        }
        return headerRowStyle;
      };
      const getHeaderRowClass = (rowIndex) => {
        const classes = [];
        const headerRowClassName = parent == null ? void 0 : parent.props.headerRowClassName;
        if (typeof headerRowClassName === "string") {
          classes.push(headerRowClassName);
        } else if (typeof headerRowClassName === "function") {
          classes.push(headerRowClassName.call(null, { rowIndex }));
        }
        return classes.join(" ");
      };
      const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
        var _a2;
        let headerCellStyles = (_a2 = parent == null ? void 0 : parent.props.headerCellStyle) != null ? _a2 : {};
        if (typeof headerCellStyles === "function") {
          headerCellStyles = headerCellStyles.call(null, {
            rowIndex,
            columnIndex,
            row,
            column
          });
        }
        const fixedStyle = column.isSubColumn ? null : getFixedColumnOffset(columnIndex, column.fixed, props.store, row);
        ensurePosition(fixedStyle, "left");
        ensurePosition(fixedStyle, "right");
        return Object.assign({}, headerCellStyles, fixedStyle);
      };
      const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
        const fixedClasses = column.isSubColumn ? [] : getFixedColumnsClass(ns2.b(), columnIndex, column.fixed, props.store, row);
        const classes = [
          column.id,
          column.order,
          column.headerAlign,
          column.className,
          column.labelClassName,
          ...fixedClasses
        ];
        if (!column.children) {
          classes.push("is-leaf");
        }
        if (column.sortable) {
          classes.push("is-sortable");
        }
        const headerCellClassName = parent == null ? void 0 : parent.props.headerCellClassName;
        if (typeof headerCellClassName === "string") {
          classes.push(headerCellClassName);
        } else if (typeof headerCellClassName === "function") {
          classes.push(headerCellClassName.call(null, {
            rowIndex,
            columnIndex,
            row,
            column
          }));
        }
        classes.push(ns2.e("cell"));
        return classes.filter((className) => Boolean(className)).join(" ");
      };
      return {
        getHeaderRowStyle,
        getHeaderRowClass,
        getHeaderCellStyle,
        getHeaderCellClass
      };
    }
    const getAllColumns = (columns2) => {
      const result = [];
      columns2.forEach((column) => {
        if (column.children) {
          result.push(column);
          result.push.apply(result, getAllColumns(column.children));
        } else {
          result.push(column);
        }
      });
      return result;
    };
    const convertToRows = (originColumns) => {
      let maxLevel = 1;
      const traverse2 = (column, parent) => {
        if (parent) {
          column.level = parent.level + 1;
          if (maxLevel < column.level) {
            maxLevel = column.level;
          }
        }
        if (column.children) {
          let colSpan = 0;
          column.children.forEach((subColumn) => {
            traverse2(subColumn, column);
            colSpan += subColumn.colSpan;
          });
          column.colSpan = colSpan;
        } else {
          column.colSpan = 1;
        }
      };
      originColumns.forEach((column) => {
        column.level = 1;
        traverse2(column, void 0);
      });
      const rows = [];
      for (let i = 0; i < maxLevel; i++) {
        rows.push([]);
      }
      const allColumns = getAllColumns(originColumns);
      allColumns.forEach((column) => {
        if (!column.children) {
          column.rowSpan = maxLevel - column.level + 1;
        } else {
          column.rowSpan = 1;
          column.children.forEach((col) => col.isSubColumn = true);
        }
        rows[column.level - 1].push(column);
      });
      return rows;
    };
    function useUtils$1(props) {
      const parent = inject(TABLE_INJECTION_KEY);
      const columnRows = computed(() => {
        return convertToRows(props.store.states.originColumns.value);
      });
      const isGroup = computed(() => {
        const result = columnRows.value.length > 1;
        if (result && parent) {
          parent.state.isGroup.value = true;
        }
        return result;
      });
      const toggleAllSelection = (event) => {
        event.stopPropagation();
        parent == null ? void 0 : parent.store.commit("toggleAllSelection");
      };
      return {
        isGroup,
        toggleAllSelection,
        columnRows
      };
    }
    var TableHeader = defineComponent({
      name: "ElTableHeader",
      components: {
        ElCheckbox
      },
      props: {
        fixed: {
          type: String,
          default: ""
        },
        store: {
          required: true,
          type: Object
        },
        border: Boolean,
        defaultSort: {
          type: Object,
          default: () => {
            return {
              prop: "",
              order: ""
            };
          }
        }
      },
      setup(props, { emit }) {
        const instance = getCurrentInstance();
        const parent = inject(TABLE_INJECTION_KEY);
        const ns2 = useNamespace("table");
        const filterPanels = ref({});
        const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
        onMounted(async () => {
          await nextTick();
          await nextTick();
          const { prop, order } = props.defaultSort;
          parent == null ? void 0 : parent.store.commit("sort", { prop, order, init: true });
        });
        const {
          handleHeaderClick,
          handleHeaderContextMenu,
          handleMouseDown,
          handleMouseMove,
          handleMouseOut,
          handleSortClick,
          handleFilterClick
        } = useEvent(props, emit);
        const {
          getHeaderRowStyle,
          getHeaderRowClass,
          getHeaderCellStyle,
          getHeaderCellClass
        } = useStyle$2(props);
        const { isGroup, toggleAllSelection, columnRows } = useUtils$1(props);
        instance.state = {
          onColumnsChange,
          onScrollableChange
        };
        instance.filterPanels = filterPanels;
        return {
          ns: ns2,
          filterPanels,
          onColumnsChange,
          onScrollableChange,
          columnRows,
          getHeaderRowClass,
          getHeaderRowStyle,
          getHeaderCellClass,
          getHeaderCellStyle,
          handleHeaderClick,
          handleHeaderContextMenu,
          handleMouseDown,
          handleMouseMove,
          handleMouseOut,
          handleSortClick,
          handleFilterClick,
          isGroup,
          toggleAllSelection
        };
      },
      render() {
        const {
          ns: ns2,
          isGroup,
          columnRows,
          getHeaderCellStyle,
          getHeaderCellClass,
          getHeaderRowClass,
          getHeaderRowStyle,
          handleHeaderClick,
          handleHeaderContextMenu,
          handleMouseDown,
          handleMouseMove,
          handleSortClick,
          handleMouseOut,
          store,
          $parent
        } = this;
        let rowSpan = 1;
        return h$1("thead", {
          class: { [ns2.is("group")]: isGroup }
        }, columnRows.map((subColumns, rowIndex) => h$1("tr", {
          class: getHeaderRowClass(rowIndex),
          key: rowIndex,
          style: getHeaderRowStyle(rowIndex)
        }, subColumns.map((column, cellIndex) => {
          if (column.rowSpan > rowSpan) {
            rowSpan = column.rowSpan;
          }
          return h$1("th", {
            class: getHeaderCellClass(rowIndex, cellIndex, subColumns, column),
            colspan: column.colSpan,
            key: `${column.id}-thead`,
            rowspan: column.rowSpan,
            style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
            onClick: ($event) => handleHeaderClick($event, column),
            onContextmenu: ($event) => handleHeaderContextMenu($event, column),
            onMousedown: ($event) => handleMouseDown($event, column),
            onMousemove: ($event) => handleMouseMove($event, column),
            onMouseout: handleMouseOut
          }, [
            h$1("div", {
              class: [
                "cell",
                column.filteredValue && column.filteredValue.length > 0 ? "highlight" : ""
              ]
            }, [
              column.renderHeader ? column.renderHeader({
                column,
                $index: cellIndex,
                store,
                _self: $parent
              }) : column.label,
              column.sortable && h$1("span", {
                onClick: ($event) => handleSortClick($event, column),
                class: "caret-wrapper"
              }, [
                h$1("i", {
                  onClick: ($event) => handleSortClick($event, column, "ascending"),
                  class: "sort-caret ascending"
                }),
                h$1("i", {
                  onClick: ($event) => handleSortClick($event, column, "descending"),
                  class: "sort-caret descending"
                })
              ]),
              column.filterable && h$1(FilterPanel, {
                store,
                placement: column.filterPlacement || "bottom-start",
                column,
                upDataColumn: (key, value) => {
                  column[key] = value;
                }
              })
            ])
          ]);
        }))));
      }
    });
    function useEvents(props) {
      const parent = inject(TABLE_INJECTION_KEY);
      const tooltipContent = ref("");
      const tooltipTrigger = ref(h$1("div"));
      const handleEvent = (event, row, name) => {
        var _a2;
        const table = parent;
        const cell = getCell(event);
        let column;
        const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
        if (cell) {
          column = getColumnByCell({
            columns: props.store.states.columns.value
          }, cell, namespace);
          if (column) {
            table == null ? void 0 : table.emit(`cell-${name}`, row, column, cell, event);
          }
        }
        table == null ? void 0 : table.emit(`row-${name}`, row, column, event);
      };
      const handleDoubleClick = (event, row) => {
        handleEvent(event, row, "dblclick");
      };
      const handleClick = (event, row) => {
        props.store.commit("setCurrentRow", row);
        handleEvent(event, row, "click");
      };
      const handleContextMenu = (event, row) => {
        handleEvent(event, row, "contextmenu");
      };
      const handleMouseEnter = debounce((index2) => {
        props.store.commit("setHoverRow", index2);
      }, 30);
      const handleMouseLeave = debounce(() => {
        props.store.commit("setHoverRow", null);
      }, 30);
      const handleCellMouseEnter = (event, row, tooltipEffect) => {
        var _a2;
        const table = parent;
        const cell = getCell(event);
        const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
        if (cell) {
          const column = getColumnByCell({
            columns: props.store.states.columns.value
          }, cell, namespace);
          const hoverState = table.hoverState = { cell, column, row };
          table == null ? void 0 : table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
        }
        const cellChild = event.target.querySelector(".cell");
        if (!(hasClass(cellChild, `${namespace}-tooltip`) && cellChild.childNodes.length)) {
          return;
        }
        const range2 = document.createRange();
        range2.setStart(cellChild, 0);
        range2.setEnd(cellChild, cellChild.childNodes.length);
        const rangeWidth = range2.getBoundingClientRect().width;
        const padding = (Number.parseInt(getStyle(cellChild, "paddingLeft"), 10) || 0) + (Number.parseInt(getStyle(cellChild, "paddingRight"), 10) || 0);
        if (rangeWidth + padding > cellChild.offsetWidth || cellChild.scrollWidth > cellChild.offsetWidth) {
          createTablePopper(parent == null ? void 0 : parent.refs.tableWrapper, cell, cell.innerText || cell.textContent, {
            placement: "top",
            strategy: "fixed"
          }, tooltipEffect);
        }
      };
      const handleCellMouseLeave = (event) => {
        const cell = getCell(event);
        if (!cell)
          return;
        const oldHoverState = parent == null ? void 0 : parent.hoverState;
        parent == null ? void 0 : parent.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
      };
      return {
        handleDoubleClick,
        handleClick,
        handleContextMenu,
        handleMouseEnter,
        handleMouseLeave,
        handleCellMouseEnter,
        handleCellMouseLeave,
        tooltipContent,
        tooltipTrigger
      };
    }
    function useStyles$1(props) {
      const parent = inject(TABLE_INJECTION_KEY);
      const ns2 = useNamespace("table");
      const getRowStyle = (row, rowIndex) => {
        const rowStyle = parent == null ? void 0 : parent.props.rowStyle;
        if (typeof rowStyle === "function") {
          return rowStyle.call(null, {
            row,
            rowIndex
          });
        }
        return rowStyle || null;
      };
      const getRowClass = (row, rowIndex) => {
        const classes = [ns2.e("row")];
        if ((parent == null ? void 0 : parent.props.highlightCurrentRow) && row === props.store.states.currentRow.value) {
          classes.push("current-row");
        }
        if (props.stripe && rowIndex % 2 === 1) {
          classes.push(ns2.em("row", "striped"));
        }
        const rowClassName = parent == null ? void 0 : parent.props.rowClassName;
        if (typeof rowClassName === "string") {
          classes.push(rowClassName);
        } else if (typeof rowClassName === "function") {
          classes.push(rowClassName.call(null, {
            row,
            rowIndex
          }));
        }
        return classes;
      };
      const getCellStyle = (rowIndex, columnIndex, row, column) => {
        const cellStyle = parent == null ? void 0 : parent.props.cellStyle;
        let cellStyles = cellStyle != null ? cellStyle : {};
        if (typeof cellStyle === "function") {
          cellStyles = cellStyle.call(null, {
            rowIndex,
            columnIndex,
            row,
            column
          });
        }
        const fixedStyle = column.isSubColumn ? null : getFixedColumnOffset(columnIndex, props == null ? void 0 : props.fixed, props.store);
        ensurePosition(fixedStyle, "left");
        ensurePosition(fixedStyle, "right");
        return Object.assign({}, cellStyles, fixedStyle);
      };
      const getCellClass = (rowIndex, columnIndex, row, column) => {
        const fixedClasses = column.isSubColumn ? [] : getFixedColumnsClass(ns2.b(), columnIndex, props == null ? void 0 : props.fixed, props.store);
        const classes = [column.id, column.align, column.className, ...fixedClasses];
        const cellClassName = parent == null ? void 0 : parent.props.cellClassName;
        if (typeof cellClassName === "string") {
          classes.push(cellClassName);
        } else if (typeof cellClassName === "function") {
          classes.push(cellClassName.call(null, {
            rowIndex,
            columnIndex,
            row,
            column
          }));
        }
        classes.push(ns2.e("cell"));
        return classes.filter((className) => Boolean(className)).join(" ");
      };
      const getSpan = (row, column, rowIndex, columnIndex) => {
        let rowspan = 1;
        let colspan = 1;
        const fn2 = parent == null ? void 0 : parent.props.spanMethod;
        if (typeof fn2 === "function") {
          const result = fn2({
            row,
            column,
            rowIndex,
            columnIndex
          });
          if (Array.isArray(result)) {
            rowspan = result[0];
            colspan = result[1];
          } else if (typeof result === "object") {
            rowspan = result.rowspan;
            colspan = result.colspan;
          }
        }
        return { rowspan, colspan };
      };
      const getColspanRealWidth = (columns2, colspan, index2) => {
        if (colspan < 1) {
          return columns2[index2].realWidth;
        }
        const widthArr = columns2.map(({ realWidth, width }) => realWidth || width).slice(index2, index2 + colspan);
        return Number(widthArr.reduce((acc, width) => Number(acc) + Number(width), -1));
      };
      return {
        getRowStyle,
        getRowClass,
        getCellStyle,
        getCellClass,
        getSpan,
        getColspanRealWidth
      };
    }
    function useRender$1(props) {
      const parent = inject(TABLE_INJECTION_KEY);
      const ns2 = useNamespace("table");
      const {
        handleDoubleClick,
        handleClick,
        handleContextMenu,
        handleMouseEnter,
        handleMouseLeave,
        handleCellMouseEnter,
        handleCellMouseLeave,
        tooltipContent,
        tooltipTrigger
      } = useEvents(props);
      const {
        getRowStyle,
        getRowClass,
        getCellStyle,
        getCellClass,
        getSpan,
        getColspanRealWidth
      } = useStyles$1(props);
      const firstDefaultColumnIndex = computed(() => {
        return props.store.states.columns.value.findIndex(({ type: type2 }) => type2 === "default");
      });
      const getKeyOfRow = (row, index2) => {
        const rowKey2 = parent.props.rowKey;
        if (rowKey2) {
          return getRowIdentity(row, rowKey2);
        }
        return index2;
      };
      const rowRender = (row, $index, treeRowData, expanded = false) => {
        const { tooltipEffect, store } = props;
        const { indent, columns: columns2 } = store.states;
        const rowClasses = getRowClass(row, $index);
        let display = true;
        if (treeRowData) {
          rowClasses.push(ns2.em("row", `level-${treeRowData.level}`));
          display = treeRowData.display;
        }
        const displayStyle = display ? null : {
          display: "none"
        };
        return h$1("tr", {
          style: [displayStyle, getRowStyle(row, $index)],
          class: rowClasses,
          key: getKeyOfRow(row, $index),
          onDblclick: ($event) => handleDoubleClick($event, row),
          onClick: ($event) => handleClick($event, row),
          onContextmenu: ($event) => handleContextMenu($event, row),
          onMouseenter: () => handleMouseEnter($index),
          onMouseleave: handleMouseLeave
        }, columns2.value.map((column, cellIndex) => {
          const { rowspan, colspan } = getSpan(row, column, $index, cellIndex);
          if (!rowspan || !colspan) {
            return null;
          }
          const columnData = { ...column };
          columnData.realWidth = getColspanRealWidth(columns2.value, colspan, cellIndex);
          const data = {
            store: props.store,
            _self: props.context || parent,
            column: columnData,
            row,
            $index,
            cellIndex,
            expanded
          };
          if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
            data.treeNode = {
              indent: treeRowData.level * indent.value,
              level: treeRowData.level
            };
            if (typeof treeRowData.expanded === "boolean") {
              data.treeNode.expanded = treeRowData.expanded;
              if ("loading" in treeRowData) {
                data.treeNode.loading = treeRowData.loading;
              }
              if ("noLazyChildren" in treeRowData) {
                data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
              }
            }
          }
          const baseKey = `${$index},${cellIndex}`;
          const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
          const tdChildren = cellChildren(cellIndex, column, data);
          return h$1("td", {
            style: getCellStyle($index, cellIndex, row, column),
            class: getCellClass($index, cellIndex, row, column),
            key: `${patchKey}${baseKey}`,
            rowspan,
            colspan,
            onMouseenter: ($event) => handleCellMouseEnter($event, row, tooltipEffect),
            onMouseleave: handleCellMouseLeave
          }, [tdChildren]);
        }));
      };
      const cellChildren = (cellIndex, column, data) => {
        return column.renderCell(data);
      };
      const wrappedRowRender = (row, $index) => {
        const store = props.store;
        const { isRowExpanded, assertRowKey } = store;
        const { treeData, lazyTreeNodeMap, childrenColumnName, rowKey: rowKey2 } = store.states;
        const columns2 = store.states.columns.value;
        const hasExpandColumn = columns2.some(({ type: type2 }) => type2 === "expand");
        if (hasExpandColumn) {
          const expanded = isRowExpanded(row);
          const tr = rowRender(row, $index, void 0, expanded);
          const renderExpanded = parent.renderExpanded;
          if (expanded) {
            if (!renderExpanded) {
              console.error("[Element Error]renderExpanded is required.");
              return tr;
            }
            return [
              [
                tr,
                h$1("tr", {
                  key: `expanded-row__${tr.key}`
                }, [
                  h$1("td", {
                    colspan: columns2.length,
                    class: `${ns2.e("cell")} ${ns2.e("expanded-cell")}`
                  }, [renderExpanded({ row, $index, store, expanded })])
                ])
              ]
            ];
          } else {
            return [[tr]];
          }
        } else if (Object.keys(treeData.value).length) {
          assertRowKey();
          const key = getRowIdentity(row, rowKey2.value);
          let cur = treeData.value[key];
          let treeRowData = null;
          if (cur) {
            treeRowData = {
              expanded: cur.expanded,
              level: cur.level,
              display: true
            };
            if (typeof cur.lazy === "boolean") {
              if (typeof cur.loaded === "boolean" && cur.loaded) {
                treeRowData.noLazyChildren = !(cur.children && cur.children.length);
              }
              treeRowData.loading = cur.loading;
            }
          }
          const tmp = [rowRender(row, $index, treeRowData)];
          if (cur) {
            let i = 0;
            const traverse2 = (children, parent2) => {
              if (!(children && children.length && parent2))
                return;
              children.forEach((node) => {
                const innerTreeRowData = {
                  display: parent2.display && parent2.expanded,
                  level: parent2.level + 1,
                  expanded: false,
                  noLazyChildren: false,
                  loading: false
                };
                const childKey = getRowIdentity(node, rowKey2.value);
                if (childKey === void 0 || childKey === null) {
                  throw new Error("For nested data item, row-key is required.");
                }
                cur = { ...treeData.value[childKey] };
                if (cur) {
                  innerTreeRowData.expanded = cur.expanded;
                  cur.level = cur.level || innerTreeRowData.level;
                  cur.display = !!(cur.expanded && innerTreeRowData.display);
                  if (typeof cur.lazy === "boolean") {
                    if (typeof cur.loaded === "boolean" && cur.loaded) {
                      innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                    }
                    innerTreeRowData.loading = cur.loading;
                  }
                }
                i++;
                tmp.push(rowRender(node, $index + i, innerTreeRowData));
                if (cur) {
                  const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
                  traverse2(nodes2, cur);
                }
              });
            };
            cur.display = true;
            const nodes = lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
            traverse2(nodes, cur);
          }
          return tmp;
        } else {
          return rowRender(row, $index, void 0);
        }
      };
      return {
        wrappedRowRender,
        tooltipContent,
        tooltipTrigger
      };
    }
    const defaultProps$2 = {
      store: {
        required: true,
        type: Object
      },
      stripe: Boolean,
      tooltipEffect: String,
      context: {
        default: () => ({}),
        type: Object
      },
      rowClassName: [String, Function],
      rowStyle: [Object, Function],
      fixed: {
        type: String,
        default: ""
      },
      highlight: Boolean
    };
    var TableBody = defineComponent({
      name: "ElTableBody",
      props: defaultProps$2,
      setup(props) {
        const instance = getCurrentInstance();
        const parent = inject(TABLE_INJECTION_KEY);
        const ns2 = useNamespace("table");
        const { wrappedRowRender, tooltipContent, tooltipTrigger } = useRender$1(props);
        const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
        watch(props.store.states.hoverRow, (newVal, oldVal) => {
          if (!props.store.states.isComplex.value || !isClient)
            return;
          let raf = window.requestAnimationFrame;
          if (!raf) {
            raf = (fn2) => window.setTimeout(fn2, 16);
          }
          raf(() => {
            var _a2;
            const rows = (_a2 = instance == null ? void 0 : instance.vnode.el) == null ? void 0 : _a2.querySelectorAll(`.${ns2.e("row")}`);
            const oldRow = rows[oldVal];
            const newRow = rows[newVal];
            if (oldRow) {
              removeClass(oldRow, "hover-row");
            }
            if (newRow) {
              addClass(newRow, "hover-row");
            }
          });
        });
        onUnmounted(() => {
          var _a2;
          (_a2 = removePopper) == null ? void 0 : _a2();
        });
        return {
          ns: ns2,
          onColumnsChange,
          onScrollableChange,
          wrappedRowRender,
          tooltipContent,
          tooltipTrigger
        };
      },
      render() {
        const { wrappedRowRender, store } = this;
        const data = store.states.data.value || [];
        return h$1("tbody", {}, [
          data.reduce((acc, row) => {
            return acc.concat(wrappedRowRender(row, acc.length));
          }, [])
        ]);
      }
    });
    function hColgroup(props) {
      const isAuto = props.tableLayout === "auto";
      let columns2 = props.columns || [];
      if (isAuto) {
        if (columns2.every((column) => column.width === void 0)) {
          columns2 = [];
        }
      }
      const getPropsData = (column) => {
        const propsData = {
          key: `${props.tableLayout}_${column.id}`,
          style: {},
          name: void 0
        };
        if (isAuto) {
          propsData.style = {
            width: `${column.width}px`
          };
        } else {
          propsData.name = column.id;
        }
        return propsData;
      };
      return h$1("colgroup", {}, columns2.map((column) => h$1("col", getPropsData(column))));
    }
    hColgroup.props = ["columns", "tableLayout"];
    function useMapState() {
      const table = inject(TABLE_INJECTION_KEY);
      const store = table == null ? void 0 : table.store;
      const leftFixedLeafCount = computed(() => {
        return store.states.fixedLeafColumnsLength.value;
      });
      const rightFixedLeafCount = computed(() => {
        return store.states.rightFixedColumns.value.length;
      });
      const columnsCount = computed(() => {
        return store.states.columns.value.length;
      });
      const leftFixedCount = computed(() => {
        return store.states.fixedColumns.value.length;
      });
      const rightFixedCount = computed(() => {
        return store.states.rightFixedColumns.value.length;
      });
      return {
        leftFixedLeafCount,
        rightFixedLeafCount,
        columnsCount,
        leftFixedCount,
        rightFixedCount,
        columns: store.states.columns
      };
    }
    function useStyle$1(props) {
      const { columns: columns2 } = useMapState();
      const ns2 = useNamespace("table");
      const getCellClasses = (columns22, cellIndex) => {
        const column = columns22[cellIndex];
        const classes = [
          ns2.e("cell"),
          column.id,
          column.align,
          column.labelClassName,
          ...getFixedColumnsClass(ns2.b(), cellIndex, column.fixed, props.store)
        ];
        if (column.className) {
          classes.push(column.className);
        }
        if (!column.children) {
          classes.push(ns2.is("leaf"));
        }
        return classes;
      };
      const getCellStyles = (column, cellIndex) => {
        const fixedStyle = getFixedColumnOffset(cellIndex, column.fixed, props.store);
        ensurePosition(fixedStyle, "left");
        ensurePosition(fixedStyle, "right");
        return fixedStyle;
      };
      return {
        getCellClasses,
        getCellStyles,
        columns: columns2
      };
    }
    var TableFooter = defineComponent({
      name: "ElTableFooter",
      props: {
        fixed: {
          type: String,
          default: ""
        },
        store: {
          required: true,
          type: Object
        },
        summaryMethod: Function,
        sumText: String,
        border: Boolean,
        defaultSort: {
          type: Object,
          default: () => {
            return {
              prop: "",
              order: ""
            };
          }
        }
      },
      setup(props) {
        const { getCellClasses, getCellStyles, columns: columns2 } = useStyle$1(props);
        const ns2 = useNamespace("table");
        return {
          ns: ns2,
          getCellClasses,
          getCellStyles,
          columns: columns2
        };
      },
      render() {
        const {
          columns: columns2,
          getCellStyles,
          getCellClasses,
          summaryMethod,
          sumText,
          ns: ns2
        } = this;
        const data = this.store.states.data.value;
        let sums = [];
        if (summaryMethod) {
          sums = summaryMethod({
            columns: columns2,
            data
          });
        } else {
          columns2.forEach((column, index2) => {
            if (index2 === 0) {
              sums[index2] = sumText;
              return;
            }
            const values = data.map((item) => Number(item[column.property]));
            const precisions = [];
            let notNumber = true;
            values.forEach((value) => {
              if (!Number.isNaN(+value)) {
                notNumber = false;
                const decimal = `${value}`.split(".")[1];
                precisions.push(decimal ? decimal.length : 0);
              }
            });
            const precision = Math.max.apply(null, precisions);
            if (!notNumber) {
              sums[index2] = values.reduce((prev, curr) => {
                const value = Number(curr);
                if (!Number.isNaN(+value)) {
                  return Number.parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
                } else {
                  return prev;
                }
              }, 0);
            } else {
              sums[index2] = "";
            }
          });
        }
        return h$1("table", {
          class: ns2.e("footer"),
          cellspacing: "0",
          cellpadding: "0",
          border: "0"
        }, [
          hColgroup({
            columns: columns2
          }),
          h$1("tbody", [
            h$1("tr", {}, [
              ...columns2.map((column, cellIndex) => h$1("td", {
                key: cellIndex,
                colspan: column.colSpan,
                rowspan: column.rowSpan,
                class: getCellClasses(columns2, cellIndex),
                style: getCellStyles(column, cellIndex)
              }, [
                h$1("div", {
                  class: ["cell", column.labelClassName]
                }, [sums[cellIndex]])
              ]))
            ])
          ])
        ]);
      }
    });
    function useUtils(store) {
      const setCurrentRow = (row) => {
        store.commit("setCurrentRow", row);
      };
      const getSelectionRows = () => {
        return store.getSelectionRows();
      };
      const toggleRowSelection = (row, selected) => {
        store.toggleRowSelection(row, selected, false);
        store.updateAllSelected();
      };
      const clearSelection = () => {
        store.clearSelection();
      };
      const clearFilter = (columnKeys) => {
        store.clearFilter(columnKeys);
      };
      const toggleAllSelection = () => {
        store.commit("toggleAllSelection");
      };
      const toggleRowExpansion = (row, expanded) => {
        store.toggleRowExpansionAdapter(row, expanded);
      };
      const clearSort = () => {
        store.clearSort();
      };
      const sort = (prop, order) => {
        store.commit("sort", { prop, order });
      };
      return {
        setCurrentRow,
        getSelectionRows,
        toggleRowSelection,
        clearSelection,
        clearFilter,
        toggleAllSelection,
        toggleRowExpansion,
        clearSort,
        sort
      };
    }
    function useStyle(props, layout2, store, table) {
      const isHidden2 = ref(false);
      const renderExpanded = ref(null);
      const resizeProxyVisible = ref(false);
      const setDragVisible = (visible) => {
        resizeProxyVisible.value = visible;
      };
      const resizeState = ref({
        width: null,
        height: null,
        headerHeight: null
      });
      const isGroup = ref(false);
      const scrollbarViewStyle = {
        display: "inline-block",
        verticalAlign: "middle"
      };
      const tableWidth = ref();
      const tableScrollHeight = ref(0);
      const bodyScrollHeight = ref(0);
      const headerScrollHeight = ref(0);
      const footerScrollHeight = ref(0);
      watchEffect(() => {
        layout2.setHeight(props.height);
      });
      watchEffect(() => {
        layout2.setMaxHeight(props.maxHeight);
      });
      watch(() => [props.currentRowKey, store.states.rowKey], ([currentRowKey, rowKey2]) => {
        if (!unref(rowKey2))
          return;
        store.setCurrentRowKey(`${currentRowKey}`);
      }, {
        immediate: true
      });
      watch(() => props.data, (data) => {
        table.store.commit("setData", data);
      }, {
        immediate: true,
        deep: true
      });
      watchEffect(() => {
        if (props.expandRowKeys) {
          store.setExpandRowKeysAdapter(props.expandRowKeys);
        }
      });
      const handleMouseLeave = () => {
        table.store.commit("setHoverRow", null);
        if (table.hoverState)
          table.hoverState = null;
      };
      const handleHeaderFooterMousewheel = (event, data) => {
        const { pixelX, pixelY } = data;
        if (Math.abs(pixelX) >= Math.abs(pixelY)) {
          table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
        }
      };
      const shouldUpdateHeight = computed(() => {
        return props.height || props.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
      });
      const tableBodyStyles = computed(() => {
        return {
          width: layout2.bodyWidth.value ? `${layout2.bodyWidth.value}px` : ""
        };
      });
      const doLayout = () => {
        if (shouldUpdateHeight.value) {
          layout2.updateElsHeight();
        }
        layout2.updateColumnsWidth();
        requestAnimationFrame(syncPosition);
      };
      onMounted(async () => {
        await nextTick();
        store.updateColumns();
        bindEvents();
        requestAnimationFrame(doLayout);
        const el = table.vnode.el;
        const tableHeader = table.refs.headerWrapper;
        if (props.flexible && el && el.parentElement) {
          el.parentElement.style.minWidth = "0";
        }
        resizeState.value = {
          width: tableWidth.value = el.offsetWidth,
          height: el.offsetHeight,
          headerHeight: props.showHeader && tableHeader ? tableHeader.offsetHeight : null
        };
        store.states.columns.value.forEach((column) => {
          if (column.filteredValue && column.filteredValue.length) {
            table.store.commit("filterChange", {
              column,
              values: column.filteredValue,
              silent: true
            });
          }
        });
        table.$ready = true;
      });
      const setScrollClassByEl = (el, className) => {
        if (!el)
          return;
        const classList = Array.from(el.classList).filter((item) => !item.startsWith("is-scrolling-"));
        classList.push(layout2.scrollX.value ? className : "is-scrolling-none");
        el.className = classList.join(" ");
      };
      const setScrollClass = (className) => {
        const { tableWrapper } = table.refs;
        setScrollClassByEl(tableWrapper, className);
      };
      const hasScrollClass = (className) => {
        const { tableWrapper } = table.refs;
        return !!(tableWrapper && tableWrapper.classList.contains(className));
      };
      const syncPosition = function() {
        if (!table.refs.scrollBarRef)
          return;
        if (!layout2.scrollX.value) {
          const scrollingNoneClass = "is-scrolling-none";
          if (!hasScrollClass(scrollingNoneClass)) {
            setScrollClass(scrollingNoneClass);
          }
          return;
        }
        const scrollContainer = table.refs.scrollBarRef.wrap$;
        if (!scrollContainer)
          return;
        const { scrollLeft, offsetWidth, scrollWidth } = scrollContainer;
        const { headerWrapper, footerWrapper } = table.refs;
        if (headerWrapper)
          headerWrapper.scrollLeft = scrollLeft;
        if (footerWrapper)
          footerWrapper.scrollLeft = scrollLeft;
        const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
        if (scrollLeft >= maxScrollLeftPosition) {
          setScrollClass("is-scrolling-right");
        } else if (scrollLeft === 0) {
          setScrollClass("is-scrolling-left");
        } else {
          setScrollClass("is-scrolling-middle");
        }
      };
      const bindEvents = () => {
        if (!table.refs.scrollBarRef)
          return;
        if (table.refs.scrollBarRef.wrap$) {
          useEventListener(table.refs.scrollBarRef.wrap$, "scroll", syncPosition, {
            passive: true
          });
        }
        if (props.fit) {
          useResizeObserver(table.vnode.el, resizeListener);
        } else {
          useEventListener(window, "resize", resizeListener);
        }
        useResizeObserver(table.refs.bodyWrapper, () => {
          var _a2, _b;
          resizeListener();
          (_b = (_a2 = table.refs) == null ? void 0 : _a2.scrollBarRef) == null ? void 0 : _b.update();
        });
      };
      const resizeListener = () => {
        var _a2, _b, _c;
        const el = table.vnode.el;
        if (!table.$ready || !el)
          return;
        let shouldUpdateLayout = false;
        const {
          width: oldWidth,
          height: oldHeight,
          headerHeight: oldHeaderHeight
        } = resizeState.value;
        const width = tableWidth.value = el.offsetWidth;
        if (oldWidth !== width) {
          shouldUpdateLayout = true;
        }
        const height = el.offsetHeight;
        if ((props.height || shouldUpdateHeight.value) && oldHeight !== height) {
          shouldUpdateLayout = true;
        }
        const tableHeader = props.tableLayout === "fixed" ? table.refs.headerWrapper : (_a2 = table.refs.tableHeaderRef) == null ? void 0 : _a2.$el;
        if (props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) !== oldHeaderHeight) {
          shouldUpdateLayout = true;
        }
        tableScrollHeight.value = ((_b = table.refs.tableWrapper) == null ? void 0 : _b.scrollHeight) || 0;
        headerScrollHeight.value = (tableHeader == null ? void 0 : tableHeader.scrollHeight) || 0;
        footerScrollHeight.value = ((_c = table.refs.footerWrapper) == null ? void 0 : _c.offsetHeight) || 0;
        bodyScrollHeight.value = tableScrollHeight.value - headerScrollHeight.value - footerScrollHeight.value;
        if (shouldUpdateLayout) {
          resizeState.value = {
            width,
            height,
            headerHeight: props.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) || 0
          };
          doLayout();
        }
      };
      const tableSize = useSize();
      const bodyWidth = computed(() => {
        const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout2;
        return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
      });
      const tableLayout = computed(() => {
        if (props.maxHeight)
          return "fixed";
        return props.tableLayout;
      });
      const emptyBlockStyle = computed(() => {
        if (props.data && props.data.length)
          return null;
        let height = "100%";
        if (props.height && bodyScrollHeight.value) {
          height = `${bodyScrollHeight.value}px`;
        }
        const width = tableWidth.value;
        return {
          width: width ? `${width}px` : "",
          height
        };
      });
      const tableInnerStyle = computed(() => {
        if (props.height) {
          return {
            height: !Number.isNaN(Number(props.height)) ? `${props.height}px` : props.height
          };
        }
        if (props.maxHeight) {
          return {
            maxHeight: !Number.isNaN(Number(props.maxHeight)) ? `${props.maxHeight}px` : props.maxHeight
          };
        }
        return {};
      });
      const scrollbarStyle = computed(() => {
        if (props.height) {
          return {
            height: "100%"
          };
        }
        if (props.maxHeight) {
          if (!Number.isNaN(Number(props.maxHeight))) {
            const maxHeight = props.maxHeight;
            const reachMaxHeight = tableScrollHeight.value >= Number(maxHeight);
            if (reachMaxHeight) {
              return {
                maxHeight: `${tableScrollHeight.value - headerScrollHeight.value - footerScrollHeight.value}px`
              };
            }
          } else {
            return {
              maxHeight: `calc(${props.maxHeight} - ${headerScrollHeight.value + footerScrollHeight.value}px)`
            };
          }
        }
        return {};
      });
      const handleFixedMousewheel = (event, data) => {
        const bodyWrapper = table.refs.bodyWrapper;
        if (Math.abs(data.spinY) > 0) {
          const currentScrollTop = bodyWrapper.scrollTop;
          if (data.pixelY < 0 && currentScrollTop !== 0) {
            event.preventDefault();
          }
          if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
            event.preventDefault();
          }
          bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
        } else {
          bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
        }
      };
      return {
        isHidden: isHidden2,
        renderExpanded,
        setDragVisible,
        isGroup,
        handleMouseLeave,
        handleHeaderFooterMousewheel,
        tableSize,
        emptyBlockStyle,
        handleFixedMousewheel,
        resizeProxyVisible,
        bodyWidth,
        resizeState,
        doLayout,
        tableBodyStyles,
        tableLayout,
        scrollbarViewStyle,
        tableInnerStyle,
        scrollbarStyle
      };
    }
    var defaultProps$1 = {
      data: {
        type: Array,
        default: () => []
      },
      size: String,
      width: [String, Number],
      height: [String, Number],
      maxHeight: [String, Number],
      fit: {
        type: Boolean,
        default: true
      },
      stripe: Boolean,
      border: Boolean,
      rowKey: [String, Function],
      showHeader: {
        type: Boolean,
        default: true
      },
      showSummary: Boolean,
      sumText: String,
      summaryMethod: Function,
      rowClassName: [String, Function],
      rowStyle: [Object, Function],
      cellClassName: [String, Function],
      cellStyle: [Object, Function],
      headerRowClassName: [String, Function],
      headerRowStyle: [Object, Function],
      headerCellClassName: [String, Function],
      headerCellStyle: [Object, Function],
      highlightCurrentRow: Boolean,
      currentRowKey: [String, Number],
      emptyText: String,
      expandRowKeys: Array,
      defaultExpandAll: Boolean,
      defaultSort: Object,
      tooltipEffect: String,
      spanMethod: Function,
      selectOnIndeterminate: {
        type: Boolean,
        default: true
      },
      indent: {
        type: Number,
        default: 16
      },
      treeProps: {
        type: Object,
        default: () => {
          return {
            hasChildren: "hasChildren",
            children: "children"
          };
        }
      },
      lazy: Boolean,
      load: Function,
      style: {
        type: Object,
        default: () => ({})
      },
      className: {
        type: String,
        default: ""
      },
      tableLayout: {
        type: String,
        default: "fixed"
      },
      scrollbarAlwaysOn: {
        type: Boolean,
        default: false
      },
      flexible: Boolean
    };
    const useScrollbar$1 = () => {
      const scrollBarRef = ref();
      const scrollTo = (options, yCoord) => {
        const scrollbar = scrollBarRef.value;
        if (scrollbar) {
          scrollbar.scrollTo(options, yCoord);
        }
      };
      const setScrollPosition = (position, offset2) => {
        const scrollbar = scrollBarRef.value;
        if (scrollbar && isNumber$2(offset2) && ["Top", "Left"].includes(position)) {
          scrollbar[`setScroll${position}`](offset2);
        }
      };
      const setScrollTop = (top) => setScrollPosition("Top", top);
      const setScrollLeft = (left2) => setScrollPosition("Left", left2);
      return {
        scrollBarRef,
        scrollTo,
        setScrollTop,
        setScrollLeft
      };
    };
    let tableIdSeed = 1;
    const _sfc_main$s = defineComponent({
      name: "ElTable",
      directives: {
        Mousewheel
      },
      components: {
        TableHeader,
        TableBody,
        TableFooter,
        ElScrollbar,
        hColgroup
      },
      props: defaultProps$1,
      emits: [
        "select",
        "select-all",
        "selection-change",
        "cell-mouse-enter",
        "cell-mouse-leave",
        "cell-contextmenu",
        "cell-click",
        "cell-dblclick",
        "row-click",
        "row-contextmenu",
        "row-dblclick",
        "header-click",
        "header-contextmenu",
        "sort-change",
        "filter-change",
        "current-change",
        "header-dragend",
        "expand-change"
      ],
      setup(props) {
        const { t } = useLocale();
        const ns2 = useNamespace("table");
        const table = getCurrentInstance();
        provide(TABLE_INJECTION_KEY, table);
        const store = createStore(table, props);
        table.store = store;
        const layout2 = new TableLayout({
          store: table.store,
          table,
          fit: props.fit,
          showHeader: props.showHeader
        });
        table.layout = layout2;
        const isEmpty2 = computed(() => (store.states.data.value || []).length === 0);
        const {
          setCurrentRow,
          getSelectionRows,
          toggleRowSelection,
          clearSelection,
          clearFilter,
          toggleAllSelection,
          toggleRowExpansion,
          clearSort,
          sort
        } = useUtils(store);
        const {
          isHidden: isHidden2,
          renderExpanded,
          setDragVisible,
          isGroup,
          handleMouseLeave,
          handleHeaderFooterMousewheel,
          tableSize,
          emptyBlockStyle,
          handleFixedMousewheel,
          resizeProxyVisible,
          bodyWidth,
          resizeState,
          doLayout,
          tableBodyStyles,
          tableLayout,
          scrollbarViewStyle,
          tableInnerStyle,
          scrollbarStyle
        } = useStyle(props, layout2, store, table);
        const { scrollBarRef, scrollTo, setScrollLeft, setScrollTop } = useScrollbar$1();
        const debouncedUpdateLayout = debounce(doLayout, 50);
        const tableId = `el-table_${tableIdSeed++}`;
        table.tableId = tableId;
        table.state = {
          isGroup,
          resizeState,
          doLayout,
          debouncedUpdateLayout
        };
        const computedSumText = computed(() => props.sumText || t("el.table.sumText"));
        const computedEmptyText = computed(() => {
          return props.emptyText || t("el.table.emptyText");
        });
        return {
          ns: ns2,
          layout: layout2,
          store,
          handleHeaderFooterMousewheel,
          handleMouseLeave,
          tableId,
          tableSize,
          isHidden: isHidden2,
          isEmpty: isEmpty2,
          renderExpanded,
          resizeProxyVisible,
          resizeState,
          isGroup,
          bodyWidth,
          tableBodyStyles,
          emptyBlockStyle,
          debouncedUpdateLayout,
          handleFixedMousewheel,
          setCurrentRow,
          getSelectionRows,
          toggleRowSelection,
          clearSelection,
          clearFilter,
          toggleAllSelection,
          toggleRowExpansion,
          clearSort,
          doLayout,
          sort,
          t,
          setDragVisible,
          context: table,
          computedSumText,
          computedEmptyText,
          tableLayout,
          scrollbarViewStyle,
          tableInnerStyle,
          scrollbarStyle,
          scrollBarRef,
          scrollTo,
          setScrollLeft,
          setScrollTop
        };
      }
    });
    const _hoisted_1$d = ["data-prefix"];
    const _hoisted_2$9 = {
      ref: "hiddenColumns",
      class: "hidden-columns"
    };
    function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_hColgroup = resolveComponent("hColgroup");
      const _component_table_header = resolveComponent("table-header");
      const _component_table_body = resolveComponent("table-body");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_table_footer = resolveComponent("table-footer");
      const _directive_mousewheel = resolveDirective("mousewheel");
      return openBlock(), createElementBlock("div", {
        ref: "tableWrapper",
        class: normalizeClass([
          {
            [_ctx.ns.m("fit")]: _ctx.fit,
            [_ctx.ns.m("striped")]: _ctx.stripe,
            [_ctx.ns.m("border")]: _ctx.border || _ctx.isGroup,
            [_ctx.ns.m("hidden")]: _ctx.isHidden,
            [_ctx.ns.m("group")]: _ctx.isGroup,
            [_ctx.ns.m("fluid-height")]: _ctx.maxHeight,
            [_ctx.ns.m("scrollable-x")]: _ctx.layout.scrollX.value,
            [_ctx.ns.m("scrollable-y")]: _ctx.layout.scrollY.value,
            [_ctx.ns.m("enable-row-hover")]: !_ctx.store.states.isComplex.value,
            [_ctx.ns.m("enable-row-transition")]: (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100,
            "has-footer": _ctx.showSummary
          },
          _ctx.ns.m(_ctx.tableSize),
          _ctx.className,
          _ctx.ns.b(),
          _ctx.ns.m(`layout-${_ctx.tableLayout}`)
        ]),
        style: normalizeStyle(_ctx.style),
        "data-prefix": _ctx.ns.namespace.value,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.handleMouseLeave())
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.ns.e("inner-wrapper")),
          style: normalizeStyle(_ctx.tableInnerStyle)
        }, [
          createBaseVNode("div", _hoisted_2$9, [
            renderSlot(_ctx.$slots, "default")
          ], 512),
          _ctx.showHeader && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
            key: 0,
            ref: "headerWrapper",
            class: normalizeClass(_ctx.ns.e("header-wrapper"))
          }, [
            createBaseVNode("table", {
              ref: "tableHeader",
              class: normalizeClass(_ctx.ns.e("header")),
              style: normalizeStyle(_ctx.tableBodyStyles),
              border: "0",
              cellpadding: "0",
              cellspacing: "0"
            }, [
              createVNode(_component_hColgroup, {
                columns: _ctx.store.states.columns.value,
                "table-layout": _ctx.tableLayout
              }, null, 8, ["columns", "table-layout"]),
              createVNode(_component_table_header, {
                ref: "tableHeaderRef",
                border: _ctx.border,
                "default-sort": _ctx.defaultSort,
                store: _ctx.store,
                onSetDragVisible: _ctx.setDragVisible
              }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
            ], 6)
          ], 2)), [
            [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
          ]) : createCommentVNode("v-if", true),
          createBaseVNode("div", {
            ref: "bodyWrapper",
            class: normalizeClass(_ctx.ns.e("body-wrapper"))
          }, [
            createVNode(_component_el_scrollbar, {
              ref: "scrollBarRef",
              "view-style": _ctx.scrollbarViewStyle,
              "wrap-style": _ctx.scrollbarStyle,
              always: _ctx.scrollbarAlwaysOn
            }, {
              default: withCtx(() => [
                createBaseVNode("table", {
                  ref: "tableBody",
                  class: normalizeClass(_ctx.ns.e("body")),
                  cellspacing: "0",
                  cellpadding: "0",
                  border: "0",
                  style: normalizeStyle({
                    width: _ctx.bodyWidth,
                    tableLayout: _ctx.tableLayout
                  })
                }, [
                  createVNode(_component_hColgroup, {
                    columns: _ctx.store.states.columns.value,
                    "table-layout": _ctx.tableLayout
                  }, null, 8, ["columns", "table-layout"]),
                  _ctx.showHeader && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_header, {
                    key: 0,
                    ref: "tableHeaderRef",
                    border: _ctx.border,
                    "default-sort": _ctx.defaultSort,
                    store: _ctx.store,
                    onSetDragVisible: _ctx.setDragVisible
                  }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])) : createCommentVNode("v-if", true),
                  createVNode(_component_table_body, {
                    context: _ctx.context,
                    highlight: _ctx.highlightCurrentRow,
                    "row-class-name": _ctx.rowClassName,
                    "tooltip-effect": _ctx.tooltipEffect,
                    "row-style": _ctx.rowStyle,
                    store: _ctx.store,
                    stripe: _ctx.stripe
                  }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "row-style", "store", "stripe"])
                ], 6),
                _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref: "emptyBlock",
                  style: normalizeStyle(_ctx.emptyBlockStyle),
                  class: normalizeClass(_ctx.ns.e("empty-block"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(_ctx.ns.e("empty-text"))
                  }, [
                    renderSlot(_ctx.$slots, "empty", {}, () => [
                      createTextVNode(toDisplayString$1(_ctx.computedEmptyText), 1)
                    ])
                  ], 2)
                ], 6)) : createCommentVNode("v-if", true),
                _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  ref: "appendWrapper",
                  class: normalizeClass(_ctx.ns.e("append-wrapper"))
                }, [
                  renderSlot(_ctx.$slots, "append")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["view-style", "wrap-style", "always"])
          ], 2),
          _ctx.showSummary ? withDirectives((openBlock(), createElementBlock("div", {
            key: 1,
            ref: "footerWrapper",
            class: normalizeClass(_ctx.ns.e("footer-wrapper"))
          }, [
            createVNode(_component_table_footer, {
              border: _ctx.border,
              "default-sort": _ctx.defaultSort,
              store: _ctx.store,
              style: normalizeStyle(_ctx.tableBodyStyles),
              "sum-text": _ctx.computedSumText,
              "summary-method": _ctx.summaryMethod
            }, null, 8, ["border", "default-sort", "store", "style", "sum-text", "summary-method"])
          ], 2)), [
            [vShow, !_ctx.isEmpty],
            [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
          ]) : createCommentVNode("v-if", true),
          _ctx.border || _ctx.isGroup ? (openBlock(), createElementBlock("div", {
            key: 2,
            class: normalizeClass(_ctx.ns.e("border-left-patch"))
          }, null, 2)) : createCommentVNode("v-if", true)
        ], 6),
        withDirectives(createBaseVNode("div", {
          ref: "resizeProxy",
          class: normalizeClass(_ctx.ns.e("column-resize-proxy"))
        }, null, 2), [
          [vShow, _ctx.resizeProxyVisible]
        ])
      ], 46, _hoisted_1$d);
    }
    var Table = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$5], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/table.vue"]]);
    const defaultClassNames = {
      selection: "table-column--selection",
      expand: "table__expand-column"
    };
    const cellStarts = {
      default: {
        order: ""
      },
      selection: {
        width: 48,
        minWidth: 48,
        realWidth: 48,
        order: ""
      },
      expand: {
        width: 48,
        minWidth: 48,
        realWidth: 48,
        order: ""
      },
      index: {
        width: 48,
        minWidth: 48,
        realWidth: 48,
        order: ""
      }
    };
    const getDefaultClassName = (type2) => {
      return defaultClassNames[type2] || "";
    };
    const cellForced = {
      selection: {
        renderHeader({ store }) {
          function isDisabled() {
            return store.states.data.value && store.states.data.value.length === 0;
          }
          return h$1(ElCheckbox, {
            disabled: isDisabled(),
            size: store.states.tableSize.value,
            indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
            "onUpdate:modelValue": store.toggleAllSelection,
            modelValue: store.states.isAllSelected.value
          });
        },
        renderCell({
          row,
          column,
          store,
          $index
        }) {
          return h$1(ElCheckbox, {
            disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
            size: store.states.tableSize.value,
            onChange: () => {
              store.commit("rowSelectedChanged", row);
            },
            onClick: (event) => event.stopPropagation(),
            modelValue: store.isSelected(row)
          });
        },
        sortable: false,
        resizable: false
      },
      index: {
        renderHeader({ column }) {
          return column.label || "#";
        },
        renderCell({
          column,
          $index
        }) {
          let i = $index + 1;
          const index2 = column.index;
          if (typeof index2 === "number") {
            i = $index + index2;
          } else if (typeof index2 === "function") {
            i = index2($index);
          }
          return h$1("div", {}, [i]);
        },
        sortable: false
      },
      expand: {
        renderHeader({ column }) {
          return column.label || "";
        },
        renderCell({
          row,
          store,
          expanded
        }) {
          const { ns: ns2 } = store;
          const classes = [ns2.e("expand-icon")];
          if (expanded) {
            classes.push(ns2.em("expand-icon", "expanded"));
          }
          const callback = function(e) {
            e.stopPropagation();
            store.toggleRowExpansion(row);
          };
          return h$1("div", {
            class: classes,
            onClick: callback
          }, {
            default: () => {
              return [
                h$1(ElIcon, null, {
                  default: () => {
                    return [h$1(arrow_right_default)];
                  }
                })
              ];
            }
          });
        },
        sortable: false,
        resizable: false
      }
    };
    function defaultRenderCell({
      row,
      column,
      $index
    }) {
      var _a2;
      const property = column.property;
      const value = property && getProp(row, property).value;
      if (column && column.formatter) {
        return column.formatter(row, column, value, $index);
      }
      return ((_a2 = value == null ? void 0 : value.toString) == null ? void 0 : _a2.call(value)) || "";
    }
    function treeCellPrefix({
      row,
      treeNode,
      store
    }, createPlacehoder = false) {
      const { ns: ns2 } = store;
      if (!treeNode) {
        if (createPlacehoder) {
          return [
            h$1("span", {
              class: ns2.e("placeholder")
            })
          ];
        }
        return null;
      }
      const ele = [];
      const callback = function(e) {
        e.stopPropagation();
        if (treeNode.loading) {
          return;
        }
        store.loadOrToggle(row);
      };
      if (treeNode.indent) {
        ele.push(h$1("span", {
          class: ns2.e("indent"),
          style: { "padding-left": `${treeNode.indent}px` }
        }));
      }
      if (typeof treeNode.expanded === "boolean" && !treeNode.noLazyChildren) {
        const expandClasses = [
          ns2.e("expand-icon"),
          treeNode.expanded ? ns2.em("expand-icon", "expanded") : ""
        ];
        let icon = arrow_right_default;
        if (treeNode.loading) {
          icon = loading_default;
        }
        ele.push(h$1("div", {
          class: expandClasses,
          onClick: callback
        }, {
          default: () => {
            return [
              h$1(ElIcon, { class: { [ns2.is("loading")]: treeNode.loading } }, {
                default: () => [h$1(icon)]
              })
            ];
          }
        }));
      } else {
        ele.push(h$1("span", {
          class: ns2.e("placeholder")
        }));
      }
      return ele;
    }
    function getAllAliases(props, aliases) {
      return props.reduce((prev, cur) => {
        prev[cur] = cur;
        return prev;
      }, aliases);
    }
    function useWatcher(owner, props_) {
      const instance = getCurrentInstance();
      const registerComplexWatchers = () => {
        const props = ["fixed"];
        const aliases = {
          realWidth: "width",
          realMinWidth: "minWidth"
        };
        const allAliases = getAllAliases(props, aliases);
        Object.keys(allAliases).forEach((key) => {
          const columnKey = aliases[key];
          if (hasOwn$1(props_, columnKey)) {
            watch(() => props_[columnKey], (newVal) => {
              let value = newVal;
              if (columnKey === "width" && key === "realWidth") {
                value = parseWidth(newVal);
              }
              if (columnKey === "minWidth" && key === "realMinWidth") {
                value = parseMinWidth(newVal);
              }
              instance.columnConfig.value[columnKey] = value;
              instance.columnConfig.value[key] = value;
              const updateColumns = columnKey === "fixed";
              owner.value.store.scheduleLayout(updateColumns);
            });
          }
        });
      };
      const registerNormalWatchers = () => {
        const props = [
          "label",
          "filters",
          "filterMultiple",
          "sortable",
          "index",
          "formatter",
          "className",
          "labelClassName",
          "showOverflowTooltip"
        ];
        const aliases = {
          property: "prop",
          align: "realAlign",
          headerAlign: "realHeaderAlign"
        };
        const allAliases = getAllAliases(props, aliases);
        Object.keys(allAliases).forEach((key) => {
          const columnKey = aliases[key];
          if (hasOwn$1(props_, columnKey)) {
            watch(() => props_[columnKey], (newVal) => {
              instance.columnConfig.value[key] = newVal;
            });
          }
        });
      };
      return {
        registerComplexWatchers,
        registerNormalWatchers
      };
    }
    function useRender(props, slots, owner) {
      const instance = getCurrentInstance();
      const columnId = ref("");
      const isSubColumn = ref(false);
      const realAlign = ref();
      const realHeaderAlign = ref();
      const ns2 = useNamespace("table");
      watchEffect(() => {
        realAlign.value = props.align ? `is-${props.align}` : null;
        realAlign.value;
      });
      watchEffect(() => {
        realHeaderAlign.value = props.headerAlign ? `is-${props.headerAlign}` : realAlign.value;
        realHeaderAlign.value;
      });
      const columnOrTableParent = computed(() => {
        let parent = instance.vnode.vParent || instance.parent;
        while (parent && !parent.tableId && !parent.columnId) {
          parent = parent.vnode.vParent || parent.parent;
        }
        return parent;
      });
      const hasTreeColumn = computed(() => {
        const { store } = instance.parent;
        if (!store)
          return false;
        const { treeData } = store.states;
        const treeDataValue = treeData.value;
        return treeDataValue && Object.keys(treeDataValue).length > 0;
      });
      const realWidth = ref(parseWidth(props.width));
      const realMinWidth = ref(parseMinWidth(props.minWidth));
      const setColumnWidth = (column) => {
        if (realWidth.value)
          column.width = realWidth.value;
        if (realMinWidth.value) {
          column.minWidth = realMinWidth.value;
        }
        if (!column.minWidth) {
          column.minWidth = 80;
        }
        column.realWidth = Number(column.width === void 0 ? column.minWidth : column.width);
        return column;
      };
      const setColumnForcedProps = (column) => {
        const type2 = column.type;
        const source = cellForced[type2] || {};
        Object.keys(source).forEach((prop) => {
          const value = source[prop];
          if (prop !== "className" && value !== void 0) {
            column[prop] = value;
          }
        });
        const className = getDefaultClassName(type2);
        if (className) {
          const forceClass = `${unref(ns2.namespace)}-${className}`;
          column.className = column.className ? `${column.className} ${forceClass}` : forceClass;
        }
        return column;
      };
      const checkSubColumn = (children) => {
        if (Array.isArray(children)) {
          children.forEach((child) => check(child));
        } else {
          check(children);
        }
        function check(item) {
          var _a2;
          if (((_a2 = item == null ? void 0 : item.type) == null ? void 0 : _a2.name) === "ElTableColumn") {
            item.vParent = instance;
          }
        }
      };
      const setColumnRenders = (column) => {
        if (props.renderHeader)
          ;
        else if (column.type !== "selection") {
          column.renderHeader = (scope) => {
            instance.columnConfig.value["label"];
            const renderHeader = slots.header;
            return renderHeader ? renderHeader(scope) : column.label;
          };
        }
        let originRenderCell = column.renderCell;
        if (column.type === "expand") {
          column.renderCell = (data) => h$1("div", {
            class: "cell"
          }, [originRenderCell(data)]);
          owner.value.renderExpanded = (data) => {
            return slots.default ? slots.default(data) : slots.default;
          };
        } else {
          originRenderCell = originRenderCell || defaultRenderCell;
          column.renderCell = (data) => {
            let children = null;
            if (slots.default) {
              const vnodes = slots.default(data);
              children = vnodes.some((v2) => v2.type !== Comment) ? vnodes : originRenderCell(data);
            } else {
              children = originRenderCell(data);
            }
            const shouldCreatePlaceholder = hasTreeColumn.value && data.cellIndex === 0;
            const prefix = treeCellPrefix(data, shouldCreatePlaceholder);
            const props2 = {
              class: "cell",
              style: {}
            };
            if (column.showOverflowTooltip) {
              props2.class = `${props2.class} ${unref(ns2.namespace)}-tooltip`;
              props2.style = {
                width: `${(data.column.realWidth || Number(data.column.width)) - 1}px`
              };
            }
            checkSubColumn(children);
            return h$1("div", props2, [prefix, children]);
          };
        }
        return column;
      };
      const getPropsData = (...propsKey) => {
        return propsKey.reduce((prev, cur) => {
          if (Array.isArray(cur)) {
            cur.forEach((key) => {
              prev[key] = props[key];
            });
          }
          return prev;
        }, {});
      };
      const getColumnElIndex = (children, child) => {
        return Array.prototype.indexOf.call(children, child);
      };
      return {
        columnId,
        realAlign,
        isSubColumn,
        realHeaderAlign,
        columnOrTableParent,
        setColumnWidth,
        setColumnForcedProps,
        setColumnRenders,
        getPropsData,
        getColumnElIndex
      };
    }
    var defaultProps = {
      type: {
        type: String,
        default: "default"
      },
      label: String,
      className: String,
      labelClassName: String,
      property: String,
      prop: String,
      width: {
        type: [String, Number],
        default: ""
      },
      minWidth: {
        type: [String, Number],
        default: ""
      },
      renderHeader: Function,
      sortable: {
        type: [Boolean, String],
        default: false
      },
      sortMethod: Function,
      sortBy: [String, Function, Array],
      resizable: {
        type: Boolean,
        default: true
      },
      columnKey: String,
      align: String,
      headerAlign: String,
      showTooltipWhenOverflow: Boolean,
      showOverflowTooltip: Boolean,
      fixed: [Boolean, String],
      formatter: Function,
      selectable: Function,
      reserveSelection: Boolean,
      filterMethod: Function,
      filteredValue: Array,
      filters: Array,
      filterPlacement: String,
      filterMultiple: {
        type: Boolean,
        default: true
      },
      index: [Number, Function],
      sortOrders: {
        type: Array,
        default: () => {
          return ["ascending", "descending", null];
        },
        validator: (val) => {
          return val.every((order) => ["ascending", "descending", null].includes(order));
        }
      }
    };
    let columnIdSeed = 1;
    var ElTableColumn$1 = defineComponent({
      name: "ElTableColumn",
      components: {
        ElCheckbox
      },
      props: defaultProps,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const columnConfig = ref({});
        const owner = computed(() => {
          let parent2 = instance.parent;
          while (parent2 && !parent2.tableId) {
            parent2 = parent2.parent;
          }
          return parent2;
        });
        const { registerNormalWatchers, registerComplexWatchers } = useWatcher(owner, props);
        const {
          columnId,
          isSubColumn,
          realHeaderAlign,
          columnOrTableParent,
          setColumnWidth,
          setColumnForcedProps,
          setColumnRenders,
          getPropsData,
          getColumnElIndex,
          realAlign
        } = useRender(props, slots, owner);
        const parent = columnOrTableParent.value;
        columnId.value = `${parent.tableId || parent.columnId}_column_${columnIdSeed++}`;
        onBeforeMount(() => {
          isSubColumn.value = owner.value !== parent;
          const type2 = props.type || "default";
          const sortable = props.sortable === "" ? true : props.sortable;
          const defaults2 = {
            ...cellStarts[type2],
            id: columnId.value,
            type: type2,
            property: props.prop || props.property,
            align: realAlign,
            headerAlign: realHeaderAlign,
            showOverflowTooltip: props.showOverflowTooltip || props.showTooltipWhenOverflow,
            filterable: props.filters || props.filterMethod,
            filteredValue: [],
            filterPlacement: "",
            isColumnGroup: false,
            isSubColumn: false,
            filterOpened: false,
            sortable,
            index: props.index,
            rawColumnKey: instance.vnode.key
          };
          const basicProps = [
            "columnKey",
            "label",
            "className",
            "labelClassName",
            "type",
            "renderHeader",
            "formatter",
            "fixed",
            "resizable"
          ];
          const sortProps = ["sortMethod", "sortBy", "sortOrders"];
          const selectProps = ["selectable", "reserveSelection"];
          const filterProps = [
            "filterMethod",
            "filters",
            "filterMultiple",
            "filterOpened",
            "filteredValue",
            "filterPlacement"
          ];
          let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
          column = mergeOptions(defaults2, column);
          const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
          column = chains(column);
          columnConfig.value = column;
          registerNormalWatchers();
          registerComplexWatchers();
        });
        onMounted(() => {
          var _a2;
          const parent2 = columnOrTableParent.value;
          const children = isSubColumn.value ? parent2.vnode.el.children : (_a2 = parent2.refs.hiddenColumns) == null ? void 0 : _a2.children;
          const getColumnIndex = () => getColumnElIndex(children || [], instance.vnode.el);
          columnConfig.value.getColumnIndex = getColumnIndex;
          const columnIndex = getColumnIndex();
          columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null);
        });
        onBeforeUnmount(() => {
          owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent.columnConfig.value : null);
        });
        instance.columnId = columnId.value;
        instance.columnConfig = columnConfig;
        return;
      },
      render() {
        var _a2, _b, _c;
        try {
          const renderDefault = (_b = (_a2 = this.$slots).default) == null ? void 0 : _b.call(_a2, {
            row: {},
            column: {},
            $index: -1
          });
          const children = [];
          if (Array.isArray(renderDefault)) {
            for (const childNode of renderDefault) {
              if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn" || childNode.shapeFlag & 2) {
                children.push(childNode);
              } else if (childNode.type === Fragment && Array.isArray(childNode.children)) {
                childNode.children.forEach((vnode2) => {
                  if ((vnode2 == null ? void 0 : vnode2.patchFlag) !== 1024 && !isString$3(vnode2 == null ? void 0 : vnode2.children)) {
                    children.push(vnode2);
                  }
                });
              }
            }
          }
          const vnode = h$1("div", children);
          return vnode;
        } catch (e) {
          return h$1("div", []);
        }
      }
    });
    const ElTable = withInstall(Table, {
      TableColumn: ElTableColumn$1
    });
    const ElTableColumn = withNoopInstall(ElTableColumn$1);
    var SortOrder = /* @__PURE__ */ ((SortOrder2) => {
      SortOrder2["ASC"] = "asc";
      SortOrder2["DESC"] = "desc";
      return SortOrder2;
    })(SortOrder || {});
    var Alignment = /* @__PURE__ */ ((Alignment2) => {
      Alignment2["CENTER"] = "center";
      Alignment2["RIGHT"] = "right";
      return Alignment2;
    })(Alignment || {});
    var FixedDir = /* @__PURE__ */ ((FixedDir2) => {
      FixedDir2["LEFT"] = "left";
      FixedDir2["RIGHT"] = "right";
      return FixedDir2;
    })(FixedDir || {});
    const oppositeOrderMap = {
      ["asc"]: "desc",
      ["desc"]: "asc"
    };
    const placeholderSign = Symbol("placeholder");
    const calcColumnStyle = (column, fixedColumn, fixed) => {
      var _a2;
      const flex = {
        flexGrow: 0,
        flexShrink: 0,
        ...fixed ? {} : {
          flexGrow: column.flexGrow || 0,
          flexShrink: column.flexShrink || 1
        }
      };
      if (!fixed) {
        flex.flexShrink = 1;
      }
      const style2 = {
        ...(_a2 = column.style) != null ? _a2 : {},
        ...flex,
        flexBasis: "auto",
        width: column.width
      };
      if (!fixedColumn) {
        if (column.maxWidth)
          style2.maxWidth = column.maxWidth;
        if (column.minWidth)
          style2.minWidth = column.minWidth;
      }
      return style2;
    };
    function useColumns(props, columns2, fixed) {
      const visibleColumns = computed(() => {
        return unref(columns2).filter((column) => !column.hidden);
      });
      const fixedColumnsOnLeft = computed(() => unref(visibleColumns).filter((column) => column.fixed === "left" || column.fixed === true));
      const fixedColumnsOnRight = computed(() => unref(visibleColumns).filter((column) => column.fixed === "right"));
      const normalColumns = computed(() => unref(visibleColumns).filter((column) => !column.fixed));
      const mainColumns = computed(() => {
        const ret = [];
        unref(fixedColumnsOnLeft).forEach((column) => {
          ret.push({
            ...column,
            placeholderSign
          });
        });
        unref(normalColumns).forEach((column) => {
          ret.push(column);
        });
        unref(fixedColumnsOnRight).forEach((column) => {
          ret.push({
            ...column,
            placeholderSign
          });
        });
        return ret;
      });
      const hasFixedColumns = computed(() => {
        return unref(fixedColumnsOnLeft).length || unref(fixedColumnsOnRight).length;
      });
      const columnsStyles = computed(() => {
        const _columns = unref(columns2);
        return _columns.reduce((style2, column) => {
          style2[column.key] = calcColumnStyle(column, unref(fixed), props.fixed);
          return style2;
        }, {});
      });
      const columnsTotalWidth = computed(() => {
        return unref(visibleColumns).reduce((width, column) => width + column.width, 0);
      });
      const getColumn = (key) => {
        return unref(columns2).find((column) => column.key === key);
      };
      const getColumnStyle = (key) => {
        return unref(columnsStyles)[key];
      };
      const updateColumnWidth = (column, width) => {
        column.width = width;
      };
      function onColumnSorted(e) {
        var _a2;
        const { key } = e.currentTarget.dataset;
        if (!key)
          return;
        const { sortState, sortBy } = props;
        let order = SortOrder.ASC;
        if (isObject$4(sortState)) {
          order = oppositeOrderMap[sortState[key]];
        } else {
          order = oppositeOrderMap[sortBy.order];
        }
        (_a2 = props.onColumnSort) == null ? void 0 : _a2.call(props, { column: getColumn(key), key, order });
      }
      return {
        columns: columns2,
        columnsStyles,
        columnsTotalWidth,
        fixedColumnsOnLeft,
        fixedColumnsOnRight,
        hasFixedColumns,
        mainColumns,
        normalColumns,
        visibleColumns,
        getColumn,
        getColumnStyle,
        updateColumnWidth,
        onColumnSorted
      };
    }
    const useScrollbar = (props, {
      mainTableRef,
      leftTableRef,
      rightTableRef,
      onMaybeEndReached
    }) => {
      const scrollPos = ref({ scrollLeft: 0, scrollTop: 0 });
      function doScroll(params) {
        var _a2, _b, _c;
        const { scrollTop } = params;
        (_a2 = mainTableRef.value) == null ? void 0 : _a2.scrollTo(params);
        (_b = leftTableRef.value) == null ? void 0 : _b.scrollToTop(scrollTop);
        (_c = rightTableRef.value) == null ? void 0 : _c.scrollToTop(scrollTop);
      }
      function scrollTo(params) {
        scrollPos.value = params;
        doScroll(params);
      }
      function scrollToTop(scrollTop) {
        scrollPos.value.scrollTop = scrollTop;
        doScroll(unref(scrollPos));
      }
      function scrollToLeft(scrollLeft) {
        var _a2, _b;
        scrollPos.value.scrollLeft = scrollLeft;
        (_b = (_a2 = mainTableRef.value) == null ? void 0 : _a2.scrollTo) == null ? void 0 : _b.call(_a2, unref(scrollPos));
      }
      function onScroll(params) {
        var _a2;
        scrollTo(params);
        (_a2 = props.onScroll) == null ? void 0 : _a2.call(props, params);
      }
      function onVerticalScroll({ scrollTop }) {
        const { scrollTop: currentScrollTop } = unref(scrollPos);
        if (scrollTop !== currentScrollTop)
          scrollToTop(scrollTop);
      }
      function scrollToRow(row, strategy = "auto") {
        var _a2;
        (_a2 = mainTableRef.value) == null ? void 0 : _a2.scrollToRow(row, strategy);
      }
      watch(() => unref(scrollPos).scrollTop, (cur, prev) => {
        if (cur > prev)
          onMaybeEndReached();
      });
      return {
        scrollPos,
        scrollTo,
        scrollToLeft,
        scrollToTop,
        scrollToRow,
        onScroll,
        onVerticalScroll
      };
    };
    const useRow = (props, { mainTableRef, leftTableRef, rightTableRef, onMaybeEndReached }) => {
      const vm = getCurrentInstance();
      const { emit } = vm;
      const isResetting = shallowRef(false);
      const hoveringRowKey = shallowRef(null);
      const expandedRowKeys = ref(props.defaultExpandedRowKeys || []);
      const lastRenderedRowIndex = ref(-1);
      const resetIndex = shallowRef(null);
      const rowHeights = ref({});
      const pendingRowHeights = ref({});
      const leftTableHeights = shallowRef({});
      const mainTableHeights = shallowRef({});
      const rightTableHeights = shallowRef({});
      const isDynamic = computed(() => isNumber$2(props.estimatedRowHeight));
      function onRowsRendered(params) {
        var _a2;
        (_a2 = props.onRowsRendered) == null ? void 0 : _a2.call(props, params);
        if (params.rowCacheEnd > unref(lastRenderedRowIndex)) {
          lastRenderedRowIndex.value = params.rowCacheEnd;
        }
      }
      function onRowHovered({ hovered, rowKey: rowKey2 }) {
        hoveringRowKey.value = hovered ? rowKey2 : null;
      }
      function onRowExpanded({
        expanded,
        rowData,
        rowIndex,
        rowKey: rowKey2
      }) {
        var _a2, _b;
        const _expandedRowKeys = [...unref(expandedRowKeys)];
        const currentKeyIndex = _expandedRowKeys.indexOf(rowKey2);
        if (expanded) {
          if (currentKeyIndex === -1)
            _expandedRowKeys.push(rowKey2);
        } else {
          if (currentKeyIndex > -1)
            _expandedRowKeys.splice(currentKeyIndex, 1);
        }
        expandedRowKeys.value = _expandedRowKeys;
        emit("update:expandedRowKeys", _expandedRowKeys);
        (_a2 = props.onRowExpand) == null ? void 0 : _a2.call(props, {
          expanded,
          rowData,
          rowIndex,
          rowKey: rowKey2
        });
        (_b = props.onExpandedRowsChange) == null ? void 0 : _b.call(props, _expandedRowKeys);
      }
      const flushingRowHeights = debounce(() => {
        var _a2, _b, _c, _d;
        isResetting.value = true;
        rowHeights.value = { ...unref(rowHeights), ...unref(pendingRowHeights) };
        resetAfterIndex(unref(resetIndex), false);
        pendingRowHeights.value = {};
        resetIndex.value = null;
        (_a2 = mainTableRef.value) == null ? void 0 : _a2.forceUpdate();
        (_b = leftTableRef.value) == null ? void 0 : _b.forceUpdate();
        (_c = rightTableRef.value) == null ? void 0 : _c.forceUpdate();
        (_d = vm.proxy) == null ? void 0 : _d.$forceUpdate();
        isResetting.value = false;
      }, 0);
      function resetAfterIndex(index2, forceUpdate = false) {
        if (!unref(isDynamic))
          return;
        [mainTableRef, leftTableRef, rightTableRef].forEach((tableRef) => {
          const table = unref(tableRef);
          if (table)
            table.resetAfterRowIndex(index2, forceUpdate);
        });
      }
      function resetHeights(rowKey2, height, rowIdx) {
        const resetIdx = unref(resetIndex);
        if (resetIdx === null) {
          resetIndex.value = rowIdx;
        } else {
          if (resetIdx > rowIdx) {
            resetIndex.value = rowIdx;
          }
        }
        pendingRowHeights.value[rowKey2] = height;
      }
      function onRowHeightChange({ rowKey: rowKey2, height, rowIndex }, fixedDir) {
        if (!fixedDir) {
          mainTableHeights.value[rowKey2] = height;
        } else {
          if (fixedDir === FixedDir.RIGHT) {
            rightTableHeights.value[rowKey2] = height;
          } else {
            leftTableHeights.value[rowKey2] = height;
          }
        }
        const maximumHeight = Math.max(...[leftTableHeights, rightTableHeights, mainTableHeights].map((records) => records.value[rowKey2] || 0));
        if (unref(rowHeights)[rowKey2] !== maximumHeight) {
          resetHeights(rowKey2, maximumHeight, rowIndex);
          flushingRowHeights();
        }
      }
      watch(lastRenderedRowIndex, () => onMaybeEndReached());
      return {
        hoveringRowKey,
        expandedRowKeys,
        lastRenderedRowIndex,
        isDynamic,
        isResetting,
        rowHeights,
        resetAfterIndex,
        onRowExpanded,
        onRowHovered,
        onRowsRendered,
        onRowHeightChange
      };
    };
    const useData = (props, { expandedRowKeys, lastRenderedRowIndex, resetAfterIndex }) => {
      const depthMap = ref({});
      const flattenedData = computed(() => {
        const depths = {};
        const { data: data2, rowKey: rowKey2 } = props;
        const _expandedRowKeys = unref(expandedRowKeys);
        if (!_expandedRowKeys || !_expandedRowKeys.length)
          return data2;
        const array2 = [];
        const keysSet = /* @__PURE__ */ new Set();
        _expandedRowKeys.forEach((x2) => keysSet.add(x2));
        let copy = data2.slice();
        copy.forEach((x2) => depths[x2[rowKey2]] = 0);
        while (copy.length > 0) {
          const item = copy.shift();
          array2.push(item);
          if (keysSet.has(item[rowKey2]) && Array.isArray(item.children) && item.children.length > 0) {
            copy = [...item.children, ...copy];
            item.children.forEach((child) => depths[child[rowKey2]] = depths[item[rowKey2]] + 1);
          }
        }
        depthMap.value = depths;
        return array2;
      });
      const data = computed(() => {
        const { data: data2, expandColumnKey: expandColumnKey2 } = props;
        return expandColumnKey2 ? unref(flattenedData) : data2;
      });
      watch(data, (val, prev) => {
        if (val !== prev) {
          lastRenderedRowIndex.value = -1;
          resetAfterIndex(0, true);
        }
      });
      return {
        data,
        depthMap
      };
    };
    const sumReducer = (sum2, num) => sum2 + num;
    const sum = (listLike) => {
      return isArray$4(listLike) ? listLike.reduce(sumReducer, 0) : listLike;
    };
    const tryCall = (fLike, params, defaultRet = {}) => {
      return isFunction$4(fLike) ? fLike(params) : fLike != null ? fLike : defaultRet;
    };
    const enforceUnit = (style2) => {
      ["width", "maxWidth", "minWidth", "height"].forEach((key) => {
        style2[key] = addUnit(style2[key]);
      });
      return style2;
    };
    const componentToSlot = (ComponentLike) => isVNode$1(ComponentLike) ? (props) => h$1(ComponentLike, props) : ComponentLike;
    const useStyles = (props, {
      columnsTotalWidth,
      data,
      fixedColumnsOnLeft,
      fixedColumnsOnRight
    }) => {
      const bodyWidth = computed(() => {
        const { fixed, width, vScrollbarSize } = props;
        const ret = width - vScrollbarSize;
        return fixed ? Math.max(Math.round(unref(columnsTotalWidth)), ret) : ret;
      });
      const headerWidth = computed(() => unref(bodyWidth) + (props.fixed ? props.vScrollbarSize : 0));
      const mainTableHeight = computed(() => {
        const { height = 0, maxHeight = 0, footerHeight: footerHeight2, hScrollbarSize } = props;
        if (maxHeight > 0) {
          const _fixedRowsHeight = unref(fixedRowsHeight);
          const _rowsHeight = unref(rowsHeight);
          const _headerHeight = unref(headerHeight);
          const total2 = _headerHeight + _fixedRowsHeight + _rowsHeight + hScrollbarSize;
          return Math.min(total2, maxHeight - footerHeight2);
        }
        return height - footerHeight2;
      });
      const rowsHeight = computed(() => {
        const { rowHeight, estimatedRowHeight } = props;
        const _data = unref(data);
        if (isNumber$2(estimatedRowHeight)) {
          return _data.length * estimatedRowHeight;
        }
        return _data.length * rowHeight;
      });
      const fixedTableHeight = computed(() => {
        const { maxHeight } = props;
        const tableHeight = unref(mainTableHeight);
        if (isNumber$2(maxHeight) && maxHeight > 0)
          return tableHeight;
        const totalHeight = unref(rowsHeight) + unref(headerHeight) + unref(fixedRowsHeight);
        return Math.min(tableHeight, totalHeight);
      });
      const mapColumn = (column) => column.width;
      const leftTableWidth = computed(() => sum(unref(fixedColumnsOnLeft).map(mapColumn)));
      const rightTableWidth = computed(() => sum(unref(fixedColumnsOnRight).map(mapColumn)));
      const headerHeight = computed(() => sum(props.headerHeight));
      const fixedRowsHeight = computed(() => {
        var _a2;
        return (((_a2 = props.fixedData) == null ? void 0 : _a2.length) || 0) * props.rowHeight;
      });
      const windowHeight = computed(() => {
        return unref(mainTableHeight) - unref(headerHeight) - unref(fixedRowsHeight);
      });
      const rootStyle = computed(() => {
        const { style: style2 = {}, height, width } = props;
        return enforceUnit({
          ...style2,
          height,
          width
        });
      });
      const footerHeight = computed(() => enforceUnit({ height: props.footerHeight }));
      const emptyStyle = computed(() => ({
        top: addUnit(unref(headerHeight)),
        bottom: addUnit(props.footerHeight),
        width: addUnit(props.width)
      }));
      return {
        bodyWidth,
        fixedTableHeight,
        mainTableHeight,
        leftTableWidth,
        rightTableWidth,
        headerWidth,
        rowsHeight,
        windowHeight,
        footerHeight,
        emptyStyle,
        rootStyle
      };
    };
    const useAutoResize = (props) => {
      const sizer = ref();
      const width$ = ref(0);
      const height$ = ref(0);
      let resizerStopper;
      onMounted(() => {
        resizerStopper = useResizeObserver(sizer, ([entry]) => {
          const { width, height } = entry.contentRect;
          const { paddingLeft, paddingRight, paddingTop, paddingBottom } = getComputedStyle(entry.target);
          const left2 = Number.parseInt(paddingLeft) || 0;
          const right2 = Number.parseInt(paddingRight) || 0;
          const top = Number.parseInt(paddingTop) || 0;
          const bottom = Number.parseInt(paddingBottom) || 0;
          width$.value = width - left2 - right2;
          height$.value = height - top - bottom;
        }).stop;
      });
      onBeforeUnmount(() => {
        resizerStopper == null ? void 0 : resizerStopper();
      });
      watch([width$, height$], ([width, height]) => {
        var _a2;
        (_a2 = props.onResize) == null ? void 0 : _a2.call(props, {
          width,
          height
        });
      });
      return {
        sizer,
        width: width$,
        height: height$
      };
    };
    function useTable(props) {
      const mainTableRef = ref();
      const leftTableRef = ref();
      const rightTableRef = ref();
      const {
        columns: columns2,
        columnsStyles,
        columnsTotalWidth,
        fixedColumnsOnLeft,
        fixedColumnsOnRight,
        hasFixedColumns,
        mainColumns,
        onColumnSorted
      } = useColumns(props, toRef(props, "columns"), toRef(props, "fixed"));
      const {
        scrollTo,
        scrollToLeft,
        scrollToTop,
        scrollToRow,
        onScroll,
        onVerticalScroll,
        scrollPos
      } = useScrollbar(props, {
        mainTableRef,
        leftTableRef,
        rightTableRef,
        onMaybeEndReached
      });
      const {
        expandedRowKeys,
        hoveringRowKey,
        lastRenderedRowIndex,
        isDynamic,
        isResetting,
        rowHeights,
        resetAfterIndex,
        onRowExpanded,
        onRowHeightChange,
        onRowHovered,
        onRowsRendered
      } = useRow(props, {
        mainTableRef,
        leftTableRef,
        rightTableRef,
        onMaybeEndReached
      });
      const { data, depthMap } = useData(props, {
        expandedRowKeys,
        lastRenderedRowIndex,
        resetAfterIndex
      });
      const {
        bodyWidth,
        fixedTableHeight,
        mainTableHeight,
        leftTableWidth,
        rightTableWidth,
        headerWidth,
        rowsHeight,
        windowHeight,
        footerHeight,
        emptyStyle,
        rootStyle
      } = useStyles(props, {
        columnsTotalWidth,
        data,
        fixedColumnsOnLeft,
        fixedColumnsOnRight
      });
      const isScrolling = shallowRef(false);
      const containerRef = ref();
      const showEmpty = computed(() => {
        const noData = unref(data).length === 0;
        return isArray$4(props.fixedData) ? props.fixedData.length === 0 && noData : noData;
      });
      function getRowHeight(rowIndex) {
        const { estimatedRowHeight, rowHeight, rowKey: rowKey2 } = props;
        if (!estimatedRowHeight)
          return rowHeight;
        return unref(rowHeights)[unref(data)[rowIndex][rowKey2]] || estimatedRowHeight;
      }
      function onMaybeEndReached() {
        const { onEndReached } = props;
        if (!onEndReached)
          return;
        const { scrollTop } = unref(scrollPos);
        const _totalHeight = unref(rowsHeight);
        const clientHeight = unref(windowHeight);
        const heightUntilEnd = _totalHeight - (scrollTop + clientHeight) + props.hScrollbarSize;
        if (unref(lastRenderedRowIndex) >= 0 && _totalHeight !== unref(rowsHeight)) {
          onEndReached(heightUntilEnd);
        }
      }
      watch(() => props.expandedRowKeys, (val) => expandedRowKeys.value = val, {
        deep: true
      });
      return {
        columns: columns2,
        containerRef,
        mainTableRef,
        leftTableRef,
        rightTableRef,
        isDynamic,
        isResetting,
        isScrolling,
        hoveringRowKey,
        hasFixedColumns,
        columnsStyles,
        columnsTotalWidth,
        data,
        expandedRowKeys,
        depthMap,
        fixedColumnsOnLeft,
        fixedColumnsOnRight,
        mainColumns,
        bodyWidth,
        emptyStyle,
        rootStyle,
        headerWidth,
        footerHeight,
        mainTableHeight,
        fixedTableHeight,
        leftTableWidth,
        rightTableWidth,
        showEmpty,
        getRowHeight,
        onColumnSorted,
        onRowHovered,
        onRowExpanded,
        onRowsRendered,
        onRowHeightChange,
        scrollTo,
        scrollToLeft,
        scrollToTop,
        scrollToRow,
        onScroll,
        onVerticalScroll
      };
    }
    const TableV2InjectionKey = Symbol("tableV2");
    const classType = String;
    const columns = {
      type: definePropType(Array),
      required: true
    };
    const fixedDataType = {
      type: definePropType(Array)
    };
    const dataType = {
      ...fixedDataType,
      required: true
    };
    const expandColumnKey = String;
    const expandKeys = {
      type: definePropType(Array),
      default: () => mutable([])
    };
    const requiredNumber = {
      type: Number,
      required: true
    };
    const rowKey = {
      type: definePropType([String, Number, Symbol]),
      default: "id"
    };
    const styleType = {
      type: definePropType(Object)
    };
    const tableV2RowProps = buildProps({
      class: String,
      columns,
      columnsStyles: {
        type: definePropType(Object),
        required: true
      },
      depth: Number,
      expandColumnKey,
      estimatedRowHeight: {
        ...virtualizedGridProps.estimatedRowHeight,
        default: void 0
      },
      isScrolling: Boolean,
      onRowExpand: {
        type: definePropType(Function)
      },
      onRowHover: {
        type: definePropType(Function)
      },
      onRowHeightChange: {
        type: definePropType(Function)
      },
      rowData: {
        type: definePropType(Object),
        required: true
      },
      rowEventHandlers: {
        type: definePropType(Object)
      },
      rowIndex: {
        type: Number,
        required: true
      },
      rowKey,
      style: {
        type: definePropType(Object)
      }
    });
    const requiredNumberType = {
      type: Number,
      required: true
    };
    const tableV2HeaderProps = buildProps({
      class: String,
      columns,
      fixedHeaderData: {
        type: definePropType(Array)
      },
      headerData: {
        type: definePropType(Array),
        required: true
      },
      headerHeight: {
        type: definePropType([Number, Array]),
        default: 50
      },
      rowWidth: requiredNumberType,
      rowHeight: {
        type: Number,
        default: 50
      },
      height: requiredNumberType,
      width: requiredNumberType
    });
    const tableV2GridProps = buildProps({
      columns,
      data: dataType,
      fixedData: fixedDataType,
      estimatedRowHeight: tableV2RowProps.estimatedRowHeight,
      width: requiredNumber,
      height: requiredNumber,
      headerWidth: requiredNumber,
      headerHeight: tableV2HeaderProps.headerHeight,
      bodyWidth: requiredNumber,
      rowHeight: requiredNumber,
      cache: virtualizedListProps.cache,
      useIsScrolling: Boolean,
      scrollbarAlwaysOn: virtualizedGridProps.scrollbarAlwaysOn,
      scrollbarStartGap: virtualizedGridProps.scrollbarStartGap,
      scrollbarEndGap: virtualizedGridProps.scrollbarEndGap,
      class: classType,
      style: styleType,
      containerStyle: styleType,
      getRowHeight: {
        type: definePropType(Function),
        required: true
      },
      rowKey: tableV2RowProps.rowKey,
      onRowsRendered: {
        type: definePropType(Function)
      },
      onScroll: {
        type: definePropType(Function)
      }
    });
    const tableV2Props = buildProps({
      cache: tableV2GridProps.cache,
      estimatedRowHeight: tableV2RowProps.estimatedRowHeight,
      rowKey,
      headerClass: {
        type: definePropType([
          String,
          Function
        ])
      },
      headerProps: {
        type: definePropType([
          Object,
          Function
        ])
      },
      headerCellProps: {
        type: definePropType([
          Object,
          Function
        ])
      },
      headerHeight: tableV2HeaderProps.headerHeight,
      footerHeight: {
        type: Number,
        default: 0
      },
      rowClass: {
        type: definePropType([String, Function])
      },
      rowProps: {
        type: definePropType([Object, Function])
      },
      rowHeight: {
        type: Number,
        default: 50
      },
      cellProps: {
        type: definePropType([
          Object,
          Function
        ])
      },
      columns,
      data: dataType,
      dataGetter: {
        type: definePropType(Function)
      },
      fixedData: fixedDataType,
      expandColumnKey: tableV2RowProps.expandColumnKey,
      expandedRowKeys: expandKeys,
      defaultExpandedRowKeys: expandKeys,
      class: classType,
      fixed: Boolean,
      style: {
        type: definePropType(Object)
      },
      width: requiredNumber,
      height: requiredNumber,
      maxHeight: Number,
      useIsScrolling: Boolean,
      indentSize: {
        type: Number,
        default: 12
      },
      iconSize: {
        type: Number,
        default: 12
      },
      hScrollbarSize: virtualizedGridProps.hScrollbarSize,
      vScrollbarSize: virtualizedGridProps.vScrollbarSize,
      scrollbarAlwaysOn: virtualizedScrollbarProps.alwaysOn,
      sortBy: {
        type: definePropType(Object),
        default: () => ({})
      },
      sortState: {
        type: definePropType(Object),
        default: void 0
      },
      onColumnSort: {
        type: definePropType(Function)
      },
      onExpandedRowsChange: {
        type: definePropType(Function)
      },
      onEndReached: {
        type: definePropType(Function)
      },
      onRowExpand: tableV2RowProps.onRowExpand,
      onScroll: tableV2GridProps.onScroll,
      onRowsRendered: tableV2GridProps.onRowsRendered,
      rowEventHandlers: tableV2RowProps.rowEventHandlers
    });
    const TableV2Cell = (props, {
      slots
    }) => {
      var _a2;
      const {
        cellData,
        style: style2
      } = props;
      const displayText = ((_a2 = cellData == null ? void 0 : cellData.toString) == null ? void 0 : _a2.call(cellData)) || "";
      return createVNode("div", {
        "class": props.class,
        "title": displayText,
        "style": style2
      }, [slots.default ? slots.default(props) : displayText]);
    };
    TableV2Cell.displayName = "ElTableV2Cell";
    TableV2Cell.inheritAttrs = false;
    const HeaderCell = (props, {
      slots
    }) => {
      var _a2, _b;
      return slots.default ? slots.default(props) : createVNode("div", {
        "class": props.class,
        "title": (_a2 = props.column) == null ? void 0 : _a2.title
      }, [(_b = props.column) == null ? void 0 : _b.title]);
    };
    HeaderCell.displayName = "ElTableV2HeaderCell";
    HeaderCell.inheritAttrs = false;
    const tableV2HeaderRowProps = buildProps({
      class: String,
      columns,
      columnsStyles: {
        type: definePropType(Object),
        required: true
      },
      headerIndex: Number,
      style: { type: definePropType(Object) }
    });
    const TableV2HeaderRow = defineComponent({
      name: "ElTableV2HeaderRow",
      props: tableV2HeaderRowProps,
      setup(props, {
        slots
      }) {
        return () => {
          const {
            columns: columns2,
            columnsStyles,
            headerIndex,
            style: style2
          } = props;
          let Cells = columns2.map((column, columnIndex) => {
            return slots.cell({
              columns: columns2,
              column,
              columnIndex,
              headerIndex,
              style: columnsStyles[column.key]
            });
          });
          if (slots.header) {
            Cells = slots.header({
              cells: Cells.map((node) => {
                if (isArray$4(node) && node.length === 1) {
                  return node[0];
                }
                return node;
              }),
              columns: columns2,
              headerIndex
            });
          }
          return createVNode("div", {
            "class": props.class,
            "style": style2
          }, [Cells]);
        };
      }
    });
    const COMPONENT_NAME$4 = "ElTableV2Header";
    const TableV2Header = defineComponent({
      name: COMPONENT_NAME$4,
      props: tableV2HeaderProps,
      setup(props, {
        slots,
        expose
      }) {
        const ns2 = useNamespace("table-v2");
        const headerRef = ref();
        const headerStyle = computed(() => enforceUnit({
          width: props.width,
          height: props.height
        }));
        const rowStyle = computed(() => enforceUnit({
          width: props.rowWidth,
          height: props.height
        }));
        const headerHeights = computed(() => castArray$1(unref(props.headerHeight)));
        const scrollToLeft = (left2) => {
          const headerEl = unref(headerRef);
          nextTick(() => {
            (headerEl == null ? void 0 : headerEl.scroll) && headerEl.scroll({
              left: left2
            });
          });
        };
        const renderFixedRows = () => {
          const fixedRowClassName = ns2.e("fixed-header-row");
          const {
            columns: columns2,
            fixedHeaderData,
            rowHeight
          } = props;
          return fixedHeaderData == null ? void 0 : fixedHeaderData.map((fixedRowData, fixedRowIndex) => {
            var _a2;
            const style2 = enforceUnit({
              height: rowHeight,
              width: "100%"
            });
            return (_a2 = slots.fixed) == null ? void 0 : _a2.call(slots, {
              class: fixedRowClassName,
              columns: columns2,
              rowData: fixedRowData,
              rowIndex: -(fixedRowIndex + 1),
              style: style2
            });
          });
        };
        const renderDynamicRows = () => {
          const dynamicRowClassName = ns2.e("dynamic-header-row");
          const {
            columns: columns2
          } = props;
          return unref(headerHeights).map((rowHeight, rowIndex) => {
            var _a2;
            const style2 = enforceUnit({
              width: "100%",
              height: rowHeight
            });
            return (_a2 = slots.dynamic) == null ? void 0 : _a2.call(slots, {
              class: dynamicRowClassName,
              columns: columns2,
              headerIndex: rowIndex,
              style: style2
            });
          });
        };
        expose({
          scrollToLeft
        });
        return () => {
          if (props.height <= 0)
            return;
          return createVNode("div", {
            "ref": headerRef,
            "class": props.class,
            "style": unref(headerStyle)
          }, [createVNode("div", {
            "style": unref(rowStyle),
            "class": ns2.e("header")
          }, [renderDynamicRows(), renderFixedRows()])]);
        };
      }
    });
    const useTableRow = (props) => {
      const {
        isScrolling
      } = inject(TableV2InjectionKey);
      const measured = ref(false);
      const rowRef = ref();
      const measurable = computed(() => {
        return isNumber$2(props.estimatedRowHeight) && props.rowIndex >= 0;
      });
      const doMeasure = (isInit = false) => {
        const $rowRef = unref(rowRef);
        if (!$rowRef)
          return;
        const {
          columns: columns2,
          onRowHeightChange,
          rowKey: rowKey2,
          rowIndex,
          style: style2
        } = props;
        const {
          height
        } = $rowRef.getBoundingClientRect();
        measured.value = true;
        nextTick(() => {
          if (isInit || height !== Number.parseInt(style2.height)) {
            const firstColumn = columns2[0];
            const isPlaceholder = (firstColumn == null ? void 0 : firstColumn.placeholderSign) === placeholderSign;
            onRowHeightChange == null ? void 0 : onRowHeightChange({
              rowKey: rowKey2,
              height,
              rowIndex
            }, firstColumn && !isPlaceholder && firstColumn.fixed);
          }
        });
      };
      const eventHandlers = computed(() => {
        const {
          rowData,
          rowIndex,
          rowKey: rowKey2,
          onRowHover
        } = props;
        const handlers = props.rowEventHandlers || {};
        const eventHandlers2 = {};
        Object.entries(handlers).forEach(([eventName, handler]) => {
          if (isFunction$4(handler)) {
            eventHandlers2[eventName] = (event) => {
              handler({
                event,
                rowData,
                rowIndex,
                rowKey: rowKey2
              });
            };
          }
        });
        if (onRowHover) {
          [{
            name: "onMouseleave",
            hovered: false
          }, {
            name: "onMouseenter",
            hovered: true
          }].forEach(({
            name,
            hovered
          }) => {
            const existedHandler = eventHandlers2[name];
            eventHandlers2[name] = (event) => {
              onRowHover({
                event,
                hovered,
                rowData,
                rowIndex,
                rowKey: rowKey2
              });
              existedHandler == null ? void 0 : existedHandler(event);
            };
          });
        }
        return eventHandlers2;
      });
      const onExpand = (expanded) => {
        const {
          onRowExpand,
          rowData,
          rowIndex,
          rowKey: rowKey2
        } = props;
        onRowExpand == null ? void 0 : onRowExpand({
          expanded,
          rowData,
          rowIndex,
          rowKey: rowKey2
        });
      };
      onMounted(() => {
        if (unref(measurable)) {
          doMeasure(true);
        }
      });
      return {
        isScrolling,
        measurable,
        measured,
        rowRef,
        eventHandlers,
        onExpand
      };
    };
    const COMPONENT_NAME$3 = "ElTableV2TableRow";
    const TableV2Row = defineComponent({
      name: COMPONENT_NAME$3,
      props: tableV2RowProps,
      setup(props, {
        expose,
        slots,
        attrs
      }) {
        const {
          eventHandlers,
          isScrolling,
          measurable,
          measured,
          rowRef,
          onExpand
        } = useTableRow(props);
        expose({
          onExpand
        });
        return () => {
          const {
            columns: columns2,
            columnsStyles,
            expandColumnKey: expandColumnKey2,
            depth,
            rowData,
            rowIndex,
            style: style2
          } = props;
          let ColumnCells = columns2.map((column, columnIndex) => {
            const expandable = isArray$4(rowData.children) && rowData.children.length > 0 && column.key === expandColumnKey2;
            return slots.cell({
              column,
              columns: columns2,
              columnIndex,
              depth,
              style: columnsStyles[column.key],
              rowData,
              rowIndex,
              isScrolling: unref(isScrolling),
              expandIconProps: expandable ? {
                rowData,
                rowIndex,
                onExpand
              } : void 0
            });
          });
          if (slots.row) {
            ColumnCells = slots.row({
              cells: ColumnCells.map((node) => {
                if (isArray$4(node) && node.length === 1) {
                  return node[0];
                }
                return node;
              }),
              style: style2,
              columns: columns2,
              depth,
              rowData,
              rowIndex,
              isScrolling: unref(isScrolling)
            });
          }
          if (unref(measurable)) {
            const {
              height,
              ...exceptHeightStyle
            } = style2 || {};
            const _measured = unref(measured);
            return createVNode("div", mergeProps({
              "ref": rowRef,
              "class": props.class,
              "style": _measured ? style2 : exceptHeightStyle
            }, attrs, unref(eventHandlers)), [ColumnCells]);
          }
          return createVNode("div", mergeProps(attrs, {
            "ref": rowRef,
            "class": props.class,
            "style": style2
          }, unref(eventHandlers)), [ColumnCells]);
        };
      }
    });
    const SortIcon = (props) => {
      const {
        sortOrder
      } = props;
      return createVNode(ElIcon, {
        "size": 14,
        "class": props.class
      }, {
        default: () => [sortOrder === SortOrder.ASC ? createVNode(sort_up_default, null, null) : createVNode(sort_down_default, null, null)]
      });
    };
    const ExpandIcon = (props) => {
      const {
        expanded,
        expandable,
        onExpand,
        style: style2,
        size: size2
      } = props;
      const expandIconProps = {
        onClick: expandable ? () => onExpand(!expanded) : void 0,
        class: props.class
      };
      return createVNode(ElIcon, mergeProps(expandIconProps, {
        "size": size2,
        "style": style2
      }), {
        default: () => [createVNode(arrow_right_default, null, null)]
      });
    };
    const COMPONENT_NAME$2 = "ElTableV2Grid";
    const useTableGrid = (props) => {
      const headerRef = ref();
      const bodyRef = ref();
      const totalHeight = computed(() => {
        const {
          data,
          rowHeight,
          estimatedRowHeight
        } = props;
        if (estimatedRowHeight) {
          return;
        }
        return data.length * rowHeight;
      });
      const fixedRowHeight = computed(() => {
        const {
          fixedData,
          rowHeight
        } = props;
        return ((fixedData == null ? void 0 : fixedData.length) || 0) * rowHeight;
      });
      const headerHeight = computed(() => sum(props.headerHeight));
      const gridHeight = computed(() => {
        const {
          height
        } = props;
        return Math.max(0, height - unref(headerHeight) - unref(fixedRowHeight));
      });
      const hasHeader = computed(() => {
        return unref(headerHeight) + unref(fixedRowHeight) > 0;
      });
      const itemKey = ({
        data,
        rowIndex
      }) => data[rowIndex][props.rowKey];
      function onItemRendered({
        rowCacheStart,
        rowCacheEnd,
        rowVisibleStart,
        rowVisibleEnd
      }) {
        var _a2;
        (_a2 = props.onRowsRendered) == null ? void 0 : _a2.call(props, {
          rowCacheStart,
          rowCacheEnd,
          rowVisibleStart,
          rowVisibleEnd
        });
      }
      function resetAfterRowIndex(index2, forceUpdate2) {
        var _a2;
        (_a2 = bodyRef.value) == null ? void 0 : _a2.resetAfterRowIndex(index2, forceUpdate2);
      }
      function scrollTo(leftOrOptions, top) {
        const header$ = unref(headerRef);
        const body$ = unref(bodyRef);
        if (!header$ || !body$)
          return;
        if (isObject$4(leftOrOptions)) {
          header$.scrollToLeft(leftOrOptions.scrollLeft);
          body$.scrollTo(leftOrOptions);
        } else {
          header$.scrollToLeft(leftOrOptions);
          body$.scrollTo({
            scrollLeft: leftOrOptions,
            scrollTop: top
          });
        }
      }
      function scrollToTop(scrollTop) {
        var _a2;
        (_a2 = unref(bodyRef)) == null ? void 0 : _a2.scrollTo({
          scrollTop
        });
      }
      function scrollToRow(row, strategy) {
        var _a2;
        (_a2 = unref(bodyRef)) == null ? void 0 : _a2.scrollToItem(row, 1, strategy);
      }
      function forceUpdate() {
        var _a2, _b;
        (_a2 = unref(bodyRef)) == null ? void 0 : _a2.$forceUpdate();
        (_b = unref(headerRef)) == null ? void 0 : _b.$forceUpdate();
      }
      return {
        bodyRef,
        forceUpdate,
        fixedRowHeight,
        gridHeight,
        hasHeader,
        headerHeight,
        headerRef,
        totalHeight,
        itemKey,
        onItemRendered,
        resetAfterRowIndex,
        scrollTo,
        scrollToTop,
        scrollToRow
      };
    };
    const TableGrid = defineComponent({
      name: COMPONENT_NAME$2,
      props: tableV2GridProps,
      setup(props, {
        slots,
        expose
      }) {
        const {
          ns: ns2
        } = inject(TableV2InjectionKey);
        const {
          bodyRef,
          fixedRowHeight,
          gridHeight,
          hasHeader,
          headerRef,
          headerHeight,
          totalHeight,
          forceUpdate,
          itemKey,
          onItemRendered,
          resetAfterRowIndex,
          scrollTo,
          scrollToTop,
          scrollToRow
        } = useTableGrid(props);
        expose({
          forceUpdate,
          totalHeight,
          scrollTo,
          scrollToTop,
          scrollToRow,
          resetAfterRowIndex
        });
        const getColumnWidth = () => props.bodyWidth;
        return () => {
          const {
            cache: cache2,
            columns: columns2,
            data,
            fixedData,
            useIsScrolling,
            scrollbarAlwaysOn,
            scrollbarEndGap,
            scrollbarStartGap,
            style: style2,
            rowHeight,
            bodyWidth,
            estimatedRowHeight,
            headerWidth,
            height,
            width,
            getRowHeight,
            onScroll
          } = props;
          const isDynamicRowEnabled = isNumber$2(estimatedRowHeight);
          const Grid = isDynamicRowEnabled ? DynamicSizeGrid : FixedSizeGrid;
          const _headerHeight = unref(headerHeight);
          return createVNode("div", {
            "role": "table",
            "class": [ns2.e("table"), props.class],
            "style": style2
          }, [createVNode(Grid, {
            "ref": bodyRef,
            "data": data,
            "useIsScrolling": useIsScrolling,
            "itemKey": itemKey,
            "columnCache": 0,
            "columnWidth": isDynamicRowEnabled ? getColumnWidth : bodyWidth,
            "totalColumn": 1,
            "totalRow": data.length,
            "rowCache": cache2,
            "rowHeight": isDynamicRowEnabled ? getRowHeight : rowHeight,
            "width": width,
            "height": unref(gridHeight),
            "class": ns2.e("body"),
            "scrollbarStartGap": scrollbarStartGap,
            "scrollbarEndGap": scrollbarEndGap,
            "scrollbarAlwaysOn": scrollbarAlwaysOn,
            "onScroll": onScroll,
            "onItemRendered": onItemRendered,
            "perfMode": false
          }, {
            default: (params) => {
              var _a2;
              const rowData = data[params.rowIndex];
              return (_a2 = slots.row) == null ? void 0 : _a2.call(slots, {
                ...params,
                columns: columns2,
                rowData
              });
            }
          }), unref(hasHeader) && createVNode(TableV2Header, {
            "ref": headerRef,
            "class": ns2.e("header-wrapper"),
            "columns": columns2,
            "headerData": data,
            "headerHeight": props.headerHeight,
            "fixedHeaderData": fixedData,
            "rowWidth": headerWidth,
            "rowHeight": rowHeight,
            "width": width,
            "height": Math.min(_headerHeight + unref(fixedRowHeight), height)
          }, {
            dynamic: slots.header,
            fixed: slots.row
          })]);
        };
      }
    });
    function _isSlot$5(s2) {
      return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode$1(s2);
    }
    const MainTable = (props, {
      slots
    }) => {
      const {
        mainTableRef,
        ...rest
      } = props;
      return createVNode(TableGrid, mergeProps({
        "ref": mainTableRef
      }, rest), _isSlot$5(slots) ? slots : {
        default: () => [slots]
      });
    };
    function _isSlot$4(s2) {
      return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode$1(s2);
    }
    const LeftTable$1 = (props, {
      slots
    }) => {
      if (!props.columns.length)
        return;
      const {
        leftTableRef,
        ...rest
      } = props;
      return createVNode(TableGrid, mergeProps({
        "ref": leftTableRef
      }, rest), _isSlot$4(slots) ? slots : {
        default: () => [slots]
      });
    };
    function _isSlot$3(s2) {
      return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode$1(s2);
    }
    const LeftTable = (props, {
      slots
    }) => {
      if (!props.columns.length)
        return;
      const {
        rightTableRef,
        ...rest
      } = props;
      return createVNode(TableGrid, mergeProps({
        "ref": rightTableRef
      }, rest), _isSlot$3(slots) ? slots : {
        default: () => [slots]
      });
    };
    function _isSlot$2(s2) {
      return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode$1(s2);
    }
    const RowRenderer = (props, {
      slots
    }) => {
      const {
        columns: columns2,
        columnsStyles,
        depthMap,
        expandColumnKey: expandColumnKey2,
        expandedRowKeys,
        estimatedRowHeight,
        hasFixedColumns,
        hoveringRowKey,
        rowData,
        rowIndex,
        style: style2,
        isScrolling,
        rowProps: rowProps2,
        rowClass,
        rowKey: rowKey2,
        rowEventHandlers,
        ns: ns2,
        onRowHovered,
        onRowExpanded
      } = props;
      const rowKls = tryCall(rowClass, {
        columns: columns2,
        rowData,
        rowIndex
      }, "");
      const additionalProps = tryCall(rowProps2, {
        columns: columns2,
        rowData,
        rowIndex
      });
      const _rowKey = rowData[rowKey2];
      const depth = depthMap[_rowKey] || 0;
      const canExpand = Boolean(expandColumnKey2);
      const isFixedRow = rowIndex < 0;
      const kls = [ns2.e("row"), rowKls, {
        [ns2.e(`row-depth-${depth}`)]: canExpand && rowIndex >= 0,
        [ns2.is("expanded")]: canExpand && expandedRowKeys.includes(_rowKey),
        [ns2.is("hovered")]: !isScrolling && _rowKey === hoveringRowKey,
        [ns2.is("fixed")]: !depth && isFixedRow,
        [ns2.is("customized")]: Boolean(slots.row)
      }];
      const onRowHover = hasFixedColumns ? onRowHovered : void 0;
      const _rowProps = {
        ...additionalProps,
        columns: columns2,
        columnsStyles,
        class: kls,
        depth,
        expandColumnKey: expandColumnKey2,
        estimatedRowHeight: isFixedRow ? void 0 : estimatedRowHeight,
        isScrolling,
        rowIndex,
        rowData,
        rowKey: _rowKey,
        rowEventHandlers,
        style: style2
      };
      return createVNode(TableV2Row, mergeProps(_rowProps, {
        "onRowHover": onRowHover,
        "onRowExpand": onRowExpanded
      }), _isSlot$2(slots) ? slots : {
        default: () => [slots]
      });
    };
    const CellRenderer = ({
      columns: columns2,
      column,
      columnIndex,
      depth,
      expandIconProps,
      isScrolling,
      rowData,
      rowIndex,
      style: style2,
      expandedRowKeys,
      ns: ns2,
      cellProps: _cellProps,
      expandColumnKey: expandColumnKey2,
      indentSize,
      iconSize,
      rowKey: rowKey2
    }, {
      slots
    }) => {
      const cellStyle = enforceUnit(style2);
      if (column.placeholderSign === placeholderSign) {
        return createVNode("div", {
          "class": ns2.em("row-cell", "placeholder"),
          "style": cellStyle
        }, null);
      }
      const {
        cellRenderer,
        dataKey,
        dataGetter
      } = column;
      const columnCellRenderer = componentToSlot(cellRenderer);
      const CellComponent = columnCellRenderer || slots.default || ((props) => createVNode(TableV2Cell, props, null));
      const cellData = isFunction$4(dataGetter) ? dataGetter({
        columns: columns2,
        column,
        columnIndex,
        rowData,
        rowIndex
      }) : get(rowData, dataKey != null ? dataKey : "");
      const extraCellProps = tryCall(_cellProps, {
        cellData,
        columns: columns2,
        column,
        columnIndex,
        rowIndex,
        rowData
      });
      const cellProps = {
        class: ns2.e("cell-text"),
        columns: columns2,
        column,
        columnIndex,
        cellData,
        isScrolling,
        rowData,
        rowIndex
      };
      const Cell = CellComponent(cellProps);
      const kls = [ns2.e("row-cell"), column.align === Alignment.CENTER && ns2.is("align-center"), column.align === Alignment.RIGHT && ns2.is("align-right")];
      const expandable = rowIndex >= 0 && column.key === expandColumnKey2;
      const expanded = rowIndex >= 0 && expandedRowKeys.includes(rowData[rowKey2]);
      let IconOrPlaceholder;
      const iconStyle = `margin-inline-start: ${depth * indentSize}px;`;
      if (expandable) {
        if (isObject$4(expandIconProps)) {
          IconOrPlaceholder = createVNode(ExpandIcon, mergeProps(expandIconProps, {
            "class": [ns2.e("expand-icon"), ns2.is("expanded", expanded)],
            "size": iconSize,
            "expanded": expanded,
            "style": iconStyle,
            "expandable": true
          }), null);
        } else {
          IconOrPlaceholder = createVNode("div", {
            "style": [iconStyle, `width: ${iconSize}px; height: ${iconSize}px;`].join(" ")
          }, null);
        }
      }
      return createVNode("div", mergeProps({
        "class": kls,
        "style": cellStyle
      }, extraCellProps), [IconOrPlaceholder, Cell]);
    };
    CellRenderer.inheritAttrs = false;
    function _isSlot$1(s2) {
      return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode$1(s2);
    }
    const HeaderRenderer = ({
      columns: columns2,
      columnsStyles,
      headerIndex,
      style: style2,
      headerClass,
      headerProps,
      ns: ns2
    }, {
      slots
    }) => {
      const param = {
        columns: columns2,
        headerIndex
      };
      const kls = [ns2.e("header-row"), tryCall(headerClass, param, ""), {
        [ns2.is("customized")]: Boolean(slots.header)
      }];
      const extraProps = {
        ...tryCall(headerProps, param),
        columnsStyles,
        class: kls,
        columns: columns2,
        headerIndex,
        style: style2
      };
      return createVNode(TableV2HeaderRow, extraProps, _isSlot$1(slots) ? slots : {
        default: () => [slots]
      });
    };
    const HeaderCellRenderer = (props, {
      slots
    }) => {
      const {
        column,
        ns: ns2,
        style: style2,
        onColumnSorted
      } = props;
      const cellStyle = enforceUnit(style2);
      if (column.placeholderSign === placeholderSign) {
        return createVNode("div", {
          "class": ns2.em("header-row-cell", "placeholder"),
          "style": cellStyle
        }, null);
      }
      const {
        headerCellRenderer,
        headerClass,
        sortable
      } = column;
      const cellProps = {
        ...props,
        class: ns2.e("header-cell-text")
      };
      const cellRenderer = componentToSlot(headerCellRenderer) || slots.default || ((props2) => createVNode(HeaderCell, props2, null));
      const Cell = cellRenderer(cellProps);
      const {
        sortBy,
        sortState,
        headerCellProps
      } = props;
      let sorting, sortOrder;
      if (sortState) {
        const order = sortState[column.key];
        sorting = Boolean(oppositeOrderMap[order]);
        sortOrder = sorting ? order : SortOrder.ASC;
      } else {
        sorting = column.key === sortBy.key;
        sortOrder = sorting ? sortBy.order : SortOrder.ASC;
      }
      const cellKls = [ns2.e("header-cell"), tryCall(headerClass, props, ""), column.align === Alignment.CENTER && ns2.is("align-center"), column.align === Alignment.RIGHT && ns2.is("align-right"), sortable && ns2.is("sortable")];
      const cellWrapperProps = {
        ...tryCall(headerCellProps, props),
        onClick: column.sortable ? onColumnSorted : void 0,
        class: cellKls,
        style: cellStyle,
        ["data-key"]: column.key
      };
      return createVNode("div", cellWrapperProps, [Cell, sortable && createVNode(SortIcon, {
        "class": [ns2.e("sort-icon"), sorting && ns2.is("sorting")],
        "sortOrder": sortOrder
      }, null)]);
    };
    const Footer$1 = (props, {
      slots
    }) => {
      var _a2;
      return createVNode("div", {
        "class": props.class,
        "style": props.style
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
    };
    Footer$1.displayName = "ElTableV2Footer";
    const Footer = (props, {
      slots
    }) => {
      return createVNode("div", {
        "class": props.class,
        "style": props.style
      }, [slots.default ? slots.default() : createVNode(ElEmpty, null, null)]);
    };
    Footer.displayName = "ElTableV2Empty";
    const Overlay = (props, {
      slots
    }) => {
      var _a2;
      return createVNode("div", {
        "class": props.class,
        "style": props.style
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
    };
    Overlay.displayName = "ElTableV2Overlay";
    function _isSlot(s2) {
      return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode$1(s2);
    }
    const COMPONENT_NAME$1 = "ElTableV2";
    const TableV2 = defineComponent({
      name: COMPONENT_NAME$1,
      props: tableV2Props,
      setup(props, {
        slots,
        expose
      }) {
        const ns2 = useNamespace("table-v2");
        const {
          columnsStyles,
          fixedColumnsOnLeft,
          fixedColumnsOnRight,
          mainColumns,
          mainTableHeight,
          fixedTableHeight,
          leftTableWidth,
          rightTableWidth,
          data,
          depthMap,
          expandedRowKeys,
          hasFixedColumns,
          hoveringRowKey,
          mainTableRef,
          leftTableRef,
          rightTableRef,
          isDynamic,
          isResetting,
          isScrolling,
          bodyWidth,
          emptyStyle,
          rootStyle,
          headerWidth,
          footerHeight,
          showEmpty,
          scrollTo,
          scrollToLeft,
          scrollToTop,
          scrollToRow,
          getRowHeight,
          onColumnSorted,
          onRowHeightChange,
          onRowHovered,
          onRowExpanded,
          onRowsRendered,
          onScroll,
          onVerticalScroll
        } = useTable(props);
        expose({
          scrollTo,
          scrollToLeft,
          scrollToTop,
          scrollToRow
        });
        provide(TableV2InjectionKey, {
          ns: ns2,
          isResetting,
          hoveringRowKey,
          isScrolling
        });
        return () => {
          const {
            cache: cache2,
            cellProps,
            estimatedRowHeight,
            expandColumnKey: expandColumnKey2,
            fixedData,
            headerHeight,
            headerClass,
            headerProps,
            headerCellProps,
            sortBy,
            sortState,
            rowHeight,
            rowClass,
            rowEventHandlers,
            rowKey: rowKey2,
            rowProps: rowProps2,
            scrollbarAlwaysOn,
            indentSize,
            iconSize,
            useIsScrolling,
            vScrollbarSize,
            width
          } = props;
          const _data = unref(data);
          const mainTableProps = {
            cache: cache2,
            class: ns2.e("main"),
            columns: unref(mainColumns),
            data: _data,
            fixedData,
            estimatedRowHeight,
            bodyWidth: unref(bodyWidth),
            headerHeight,
            headerWidth: unref(headerWidth),
            height: unref(mainTableHeight),
            mainTableRef,
            rowKey: rowKey2,
            rowHeight,
            scrollbarAlwaysOn,
            scrollbarStartGap: 2,
            scrollbarEndGap: vScrollbarSize,
            useIsScrolling,
            width,
            getRowHeight,
            onRowsRendered,
            onScroll
          };
          const leftColumnsWidth = unref(leftTableWidth);
          const _fixedTableHeight = unref(fixedTableHeight);
          const leftTableProps = {
            cache: cache2,
            class: ns2.e("left"),
            columns: unref(fixedColumnsOnLeft),
            data: _data,
            estimatedRowHeight,
            leftTableRef,
            rowHeight,
            bodyWidth: leftColumnsWidth,
            headerWidth: leftColumnsWidth,
            headerHeight,
            height: _fixedTableHeight,
            rowKey: rowKey2,
            scrollbarAlwaysOn,
            scrollbarStartGap: 2,
            scrollbarEndGap: vScrollbarSize,
            useIsScrolling,
            width: leftColumnsWidth,
            getRowHeight,
            onScroll: onVerticalScroll
          };
          const rightColumnsWidth = unref(rightTableWidth);
          const rightColumnsWidthWithScrollbar = rightColumnsWidth + vScrollbarSize;
          const rightTableProps = {
            cache: cache2,
            class: ns2.e("right"),
            columns: unref(fixedColumnsOnRight),
            data: _data,
            estimatedRowHeight,
            rightTableRef,
            rowHeight,
            bodyWidth: rightColumnsWidthWithScrollbar,
            headerWidth: rightColumnsWidthWithScrollbar,
            headerHeight,
            height: _fixedTableHeight,
            rowKey: rowKey2,
            scrollbarAlwaysOn,
            scrollbarStartGap: 2,
            scrollbarEndGap: vScrollbarSize,
            width: rightColumnsWidthWithScrollbar,
            style: `--${unref(ns2.namespace)}-table-scrollbar-size: ${vScrollbarSize}px`,
            useIsScrolling,
            getRowHeight,
            onScroll: onVerticalScroll
          };
          const _columnsStyles = unref(columnsStyles);
          const tableRowProps = {
            ns: ns2,
            depthMap: unref(depthMap),
            columnsStyles: _columnsStyles,
            expandColumnKey: expandColumnKey2,
            expandedRowKeys: unref(expandedRowKeys),
            estimatedRowHeight,
            hasFixedColumns: unref(hasFixedColumns),
            hoveringRowKey: unref(hoveringRowKey),
            rowProps: rowProps2,
            rowClass,
            rowKey: rowKey2,
            rowEventHandlers,
            onRowHovered,
            onRowExpanded,
            onRowHeightChange
          };
          const tableCellProps = {
            cellProps,
            expandColumnKey: expandColumnKey2,
            indentSize,
            iconSize,
            rowKey: rowKey2,
            expandedRowKeys: unref(expandedRowKeys),
            ns: ns2
          };
          const tableHeaderProps = {
            ns: ns2,
            headerClass,
            headerProps,
            columnsStyles: _columnsStyles
          };
          const tableHeaderCellProps = {
            ns: ns2,
            sortBy,
            sortState,
            headerCellProps,
            onColumnSorted
          };
          const tableSlots = {
            row: (props2) => createVNode(RowRenderer, mergeProps(props2, tableRowProps), {
              row: slots.row,
              cell: (props3) => {
                let _slot;
                return slots.cell ? createVNode(CellRenderer, mergeProps(props3, tableCellProps, {
                  "style": _columnsStyles[props3.column.key]
                }), _isSlot(_slot = slots.cell()) ? _slot : {
                  default: () => [_slot]
                }) : createVNode(CellRenderer, mergeProps(props3, tableCellProps, {
                  "style": _columnsStyles[props3.column.key]
                }), null);
              }
            }),
            header: (props2) => createVNode(HeaderRenderer, mergeProps(props2, tableHeaderProps), {
              header: slots.header,
              cell: (props3) => {
                let _slot2;
                return slots["header-cell"] ? createVNode(HeaderCellRenderer, mergeProps(props3, tableHeaderCellProps, {
                  "style": _columnsStyles[props3.column.key]
                }), _isSlot(_slot2 = slots["header-cell"]()) ? _slot2 : {
                  default: () => [_slot2]
                }) : createVNode(HeaderCellRenderer, mergeProps(props3, tableHeaderCellProps, {
                  "style": _columnsStyles[props3.column.key]
                }), null);
              }
            })
          };
          const rootKls = [props.class, ns2.b(), ns2.e("root"), {
            [ns2.is("dynamic")]: unref(isDynamic)
          }];
          const footerProps = {
            class: ns2.e("footer"),
            style: unref(footerHeight)
          };
          return createVNode("div", {
            "class": rootKls,
            "style": unref(rootStyle)
          }, [createVNode(MainTable, mainTableProps, _isSlot(tableSlots) ? tableSlots : {
            default: () => [tableSlots]
          }), createVNode(LeftTable$1, leftTableProps, _isSlot(tableSlots) ? tableSlots : {
            default: () => [tableSlots]
          }), createVNode(LeftTable, rightTableProps, _isSlot(tableSlots) ? tableSlots : {
            default: () => [tableSlots]
          }), slots.footer && createVNode(Footer$1, footerProps, {
            default: slots.footer
          }), unref(showEmpty) && createVNode(Footer, {
            "class": ns2.e("empty"),
            "style": unref(emptyStyle)
          }, {
            default: slots.empty
          }), slots.overlay && createVNode(Overlay, {
            "class": ns2.e("overlay")
          }, {
            default: slots.overlay
          })]);
        };
      }
    });
    const autoResizerProps = buildProps({
      disableWidth: Boolean,
      disableHeight: Boolean,
      onResize: {
        type: definePropType(Function)
      }
    });
    const AutoResizer = defineComponent({
      name: "ElAutoResizer",
      props: autoResizerProps,
      setup(props, {
        slots
      }) {
        const ns2 = useNamespace("auto-resizer");
        const {
          height,
          width,
          sizer
        } = useAutoResize(props);
        const style2 = {
          width: "100%",
          height: "100%"
        };
        return () => {
          var _a2;
          return createVNode("div", {
            "ref": sizer,
            "class": ns2.b(),
            "style": style2
          }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
            height: height.value,
            width: width.value
          })]);
        };
      }
    });
    const ElTableV2 = withInstall(TableV2);
    const ElAutoResizer = withInstall(AutoResizer);
    const tabBarProps = buildProps({
      tabs: {
        type: definePropType(Array),
        default: () => mutable([])
      }
    });
    const __default__$h = {
      name: "ElTabBar"
    };
    const _sfc_main$r = /* @__PURE__ */ defineComponent({
      ...__default__$h,
      props: tabBarProps,
      setup(__props, { expose }) {
        const props = __props;
        const COMPONENT_NAME2 = "ElTabBar";
        const instance = getCurrentInstance();
        const rootTabs = inject(tabsRootContextKey);
        if (!rootTabs)
          throwError(COMPONENT_NAME2, "<el-tabs><el-tab-bar /></el-tabs>");
        const ns2 = useNamespace("tabs");
        const barRef = ref();
        const barStyle = ref();
        const getBarStyle = () => {
          let offset2 = 0;
          let tabSize = 0;
          const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
          const sizeDir = sizeName === "width" ? "x" : "y";
          props.tabs.every((tab) => {
            var _a2, _b, _c, _d;
            const $el = (_b = (_a2 = instance.parent) == null ? void 0 : _a2.refs) == null ? void 0 : _b[`tab-${tab.uid}`];
            if (!$el)
              return false;
            if (!tab.active) {
              return true;
            }
            tabSize = $el[`client${capitalize$1(sizeName)}`];
            const position = sizeDir === "x" ? "left" : "top";
            offset2 = $el.getBoundingClientRect()[position] - ((_d = (_c = $el.parentElement) == null ? void 0 : _c.getBoundingClientRect()[position]) != null ? _d : 0);
            const tabStyles = window.getComputedStyle($el);
            if (sizeName === "width") {
              if (props.tabs.length > 1) {
                tabSize -= Number.parseFloat(tabStyles.paddingLeft) + Number.parseFloat(tabStyles.paddingRight);
              }
              offset2 += Number.parseFloat(tabStyles.paddingLeft);
            }
            return false;
          });
          return {
            [sizeName]: `${tabSize}px`,
            transform: `translate${capitalize$1(sizeDir)}(${offset2}px)`
          };
        };
        const update = () => barStyle.value = getBarStyle();
        watch(() => props.tabs, async () => {
          await nextTick();
          update();
        }, { immediate: true });
        useResizeObserver(barRef, () => update());
        expose({
          ref: barRef,
          update
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "barRef",
            ref: barRef,
            class: normalizeClass([unref(ns2).e("active-bar"), unref(ns2).is(unref(rootTabs).props.tabPosition)]),
            style: normalizeStyle(barStyle.value)
          }, null, 6);
        };
      }
    });
    var TabBar = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-bar.vue"]]);
    const tabNavProps = buildProps({
      panes: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      currentName: {
        type: [String, Number],
        default: ""
      },
      editable: Boolean,
      onTabClick: {
        type: definePropType(Function),
        default: NOOP
      },
      onTabRemove: {
        type: definePropType(Function),
        default: NOOP
      },
      type: {
        type: String,
        values: ["card", "border-card", ""],
        default: ""
      },
      stretch: Boolean
    });
    const COMPONENT_NAME = "ElTabNav";
    const TabNav = defineComponent({
      name: COMPONENT_NAME,
      props: tabNavProps,
      setup(props, {
        expose
      }) {
        const vm = getCurrentInstance();
        const rootTabs = inject(tabsRootContextKey);
        if (!rootTabs)
          throwError(COMPONENT_NAME, `<el-tabs><tab-nav /></el-tabs>`);
        const ns2 = useNamespace("tabs");
        const visibility = useDocumentVisibility();
        const focused = useWindowFocus();
        const navScroll$ = ref();
        const nav$ = ref();
        const el$ = ref();
        const scrollable = ref(false);
        const navOffset = ref(0);
        const isFocus = ref(false);
        const focusable = ref(true);
        const sizeName = computed(() => ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height");
        const navStyle = computed(() => {
          const dir = sizeName.value === "width" ? "X" : "Y";
          return {
            transform: `translate${dir}(-${navOffset.value}px)`
          };
        });
        const scrollPrev = () => {
          if (!navScroll$.value)
            return;
          const containerSize = navScroll$.value[`offset${capitalize$1(sizeName.value)}`];
          const currentOffset = navOffset.value;
          if (!currentOffset)
            return;
          const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
          navOffset.value = newOffset;
        };
        const scrollNext = () => {
          if (!navScroll$.value || !nav$.value)
            return;
          const navSize = nav$.value[`offset${capitalize$1(sizeName.value)}`];
          const containerSize = navScroll$.value[`offset${capitalize$1(sizeName.value)}`];
          const currentOffset = navOffset.value;
          if (navSize - currentOffset <= containerSize)
            return;
          const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
          navOffset.value = newOffset;
        };
        const scrollToActiveTab = async () => {
          const nav = nav$.value;
          if (!scrollable.value || !el$.value || !navScroll$.value || !nav)
            return;
          await nextTick();
          const activeTab = el$.value.querySelector(".is-active");
          if (!activeTab)
            return;
          const navScroll = navScroll$.value;
          const isHorizontal2 = ["top", "bottom"].includes(rootTabs.props.tabPosition);
          const activeTabBounding = activeTab.getBoundingClientRect();
          const navScrollBounding = navScroll.getBoundingClientRect();
          const maxOffset = isHorizontal2 ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
          const currentOffset = navOffset.value;
          let newOffset = currentOffset;
          if (isHorizontal2) {
            if (activeTabBounding.left < navScrollBounding.left) {
              newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
            }
            if (activeTabBounding.right > navScrollBounding.right) {
              newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
            }
          } else {
            if (activeTabBounding.top < navScrollBounding.top) {
              newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
            }
            if (activeTabBounding.bottom > navScrollBounding.bottom) {
              newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
            }
          }
          newOffset = Math.max(newOffset, 0);
          navOffset.value = Math.min(newOffset, maxOffset);
        };
        const update = () => {
          if (!nav$.value || !navScroll$.value)
            return;
          const navSize = nav$.value[`offset${capitalize$1(sizeName.value)}`];
          const containerSize = navScroll$.value[`offset${capitalize$1(sizeName.value)}`];
          const currentOffset = navOffset.value;
          if (containerSize < navSize) {
            const currentOffset2 = navOffset.value;
            scrollable.value = scrollable.value || {};
            scrollable.value.prev = currentOffset2;
            scrollable.value.next = currentOffset2 + containerSize < navSize;
            if (navSize - currentOffset2 < containerSize) {
              navOffset.value = navSize - containerSize;
            }
          } else {
            scrollable.value = false;
            if (currentOffset > 0) {
              navOffset.value = 0;
            }
          }
        };
        const changeTab = (e) => {
          const code2 = e.code;
          const {
            up: up2,
            down: down2,
            left: left2,
            right: right2
          } = EVENT_CODE;
          if (![up2, down2, left2, right2].includes(code2))
            return;
          const tabList = Array.from(e.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"));
          const currentIndex = tabList.indexOf(e.target);
          let nextIndex;
          if (code2 === left2 || code2 === up2) {
            if (currentIndex === 0) {
              nextIndex = tabList.length - 1;
            } else {
              nextIndex = currentIndex - 1;
            }
          } else {
            if (currentIndex < tabList.length - 1) {
              nextIndex = currentIndex + 1;
            } else {
              nextIndex = 0;
            }
          }
          tabList[nextIndex].focus();
          tabList[nextIndex].click();
          setFocus();
        };
        const setFocus = () => {
          if (focusable.value)
            isFocus.value = true;
        };
        const removeFocus = () => isFocus.value = false;
        watch(visibility, (visibility2) => {
          if (visibility2 === "hidden") {
            focusable.value = false;
          } else if (visibility2 === "visible") {
            setTimeout(() => focusable.value = true, 50);
          }
        });
        watch(focused, (focused2) => {
          if (focused2) {
            setTimeout(() => focusable.value = true, 50);
          } else {
            focusable.value = false;
          }
        });
        useResizeObserver(el$, update);
        onMounted(() => setTimeout(() => scrollToActiveTab(), 0));
        onUpdated(() => update());
        expose({
          scrollToActiveTab,
          removeFocus
        });
        watch(() => props.panes, () => vm.update(), {
          flush: "post"
        });
        return () => {
          const scrollBtn = scrollable.value ? [createVNode("span", {
            "class": [ns2.e("nav-prev"), ns2.is("disabled", !scrollable.value.prev)],
            "onClick": scrollPrev
          }, [createVNode(ElIcon, null, {
            default: () => [createVNode(arrow_left_default, null, null)]
          })]), createVNode("span", {
            "class": [ns2.e("nav-next"), ns2.is("disabled", !scrollable.value.next)],
            "onClick": scrollNext
          }, [createVNode(ElIcon, null, {
            default: () => [createVNode(arrow_right_default, null, null)]
          })])] : null;
          const tabs = props.panes.map((pane, index2) => {
            var _a2, _b, _c, _d;
            const uid2 = pane.uid;
            const disabled = pane.props.disabled;
            const tabName = (_b = (_a2 = pane.props.name) != null ? _a2 : pane.index) != null ? _b : `${index2}`;
            const closable = !disabled && (pane.isClosable || props.editable);
            pane.index = `${index2}`;
            const btnClose = closable ? createVNode(ElIcon, {
              "class": "is-icon-close",
              "onClick": (ev) => props.onTabRemove(pane, ev)
            }, {
              default: () => [createVNode(close_default, null, null)]
            }) : null;
            const tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;
            const tabindex = !disabled && pane.active ? 0 : -1;
            return createVNode("div", {
              "ref": `tab-${uid2}`,
              "class": [ns2.e("item"), ns2.is(rootTabs.props.tabPosition), ns2.is("active", pane.active), ns2.is("disabled", disabled), ns2.is("closable", closable), ns2.is("focus", isFocus.value)],
              "id": `tab-${tabName}`,
              "key": `tab-${uid2}`,
              "aria-controls": `pane-${tabName}`,
              "role": "tab",
              "aria-selected": pane.active,
              "tabindex": tabindex,
              "onFocus": () => setFocus(),
              "onBlur": () => removeFocus(),
              "onClick": (ev) => {
                removeFocus();
                props.onTabClick(pane, tabName, ev);
              },
              "onKeydown": (ev) => {
                if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {
                  props.onTabRemove(pane, ev);
                }
              }
            }, [...[tabLabelContent, btnClose]]);
          });
          return createVNode("div", {
            "ref": el$,
            "class": [ns2.e("nav-wrap"), ns2.is("scrollable", !!scrollable.value), ns2.is(rootTabs.props.tabPosition)]
          }, [scrollBtn, createVNode("div", {
            "class": ns2.e("nav-scroll"),
            "ref": navScroll$
          }, [createVNode("div", {
            "class": [ns2.e("nav"), ns2.is(rootTabs.props.tabPosition), ns2.is("stretch", props.stretch && ["top", "bottom"].includes(rootTabs.props.tabPosition))],
            "ref": nav$,
            "style": navStyle.value,
            "role": "tablist",
            "onKeydown": changeTab
          }, [...[!props.type ? createVNode(TabBar, {
            "tabs": [...props.panes]
          }, null) : null, tabs]])])]);
        };
      }
    });
    const tabsProps = buildProps({
      type: {
        type: String,
        values: ["card", "border-card", ""],
        default: ""
      },
      activeName: {
        type: [String, Number]
      },
      closable: Boolean,
      addable: Boolean,
      modelValue: {
        type: [String, Number]
      },
      editable: Boolean,
      tabPosition: {
        type: String,
        values: ["top", "right", "bottom", "left"],
        default: "top"
      },
      beforeLeave: {
        type: definePropType(Function),
        default: () => true
      },
      stretch: Boolean
    });
    const isPanelName = (value) => isString$3(value) || isNumber$2(value);
    const tabsEmits = {
      [UPDATE_MODEL_EVENT]: (name) => isPanelName(name),
      "tab-click": (pane, ev) => ev instanceof Event,
      "tab-change": (name) => isPanelName(name),
      edit: (paneName, action) => ["remove", "add"].includes(action),
      "tab-remove": (name) => isPanelName(name),
      "tab-add": () => true
    };
    var Tabs = defineComponent({
      name: "ElTabs",
      props: tabsProps,
      emits: tabsEmits,
      setup(props, {
        emit,
        slots,
        expose
      }) {
        var _a2, _b;
        const ns2 = useNamespace("tabs");
        const nav$ = ref();
        const panes = reactive({});
        const currentName = ref((_b = (_a2 = props.modelValue) != null ? _a2 : props.activeName) != null ? _b : "0");
        const changeCurrentName = (value) => {
          currentName.value = value;
          emit(UPDATE_MODEL_EVENT, value);
          emit("tab-change", value);
        };
        const setCurrentName = async (value) => {
          var _a22, _b2, _c;
          if (currentName.value === value || isUndefined$1(value))
            return;
          try {
            const canLeave = await ((_a22 = props.beforeLeave) == null ? void 0 : _a22.call(props, value, currentName.value));
            if (canLeave !== false) {
              changeCurrentName(value);
              (_c = (_b2 = nav$.value) == null ? void 0 : _b2.removeFocus) == null ? void 0 : _c.call(_b2);
            }
          } catch (e) {
          }
        };
        const handleTabClick = (tab, tabName, event) => {
          if (tab.props.disabled)
            return;
          setCurrentName(tabName);
          emit("tab-click", tab, event);
        };
        const handleTabRemove = (pane, ev) => {
          if (pane.props.disabled || isUndefined$1(pane.props.name))
            return;
          ev.stopPropagation();
          emit("edit", pane.props.name, "remove");
          emit("tab-remove", pane.props.name);
        };
        const handleTabAdd = () => {
          emit("edit", void 0, "add");
          emit("tab-add");
        };
        useDeprecated({
          from: '"activeName"',
          replacement: '"model-value" or "v-model"',
          scope: "ElTabs",
          version: "2.3.0",
          ref: "https://element-plus.org/en-US/component/tabs.html#attributes",
          type: "Attribute"
        }, computed(() => !!props.activeName));
        watch(() => props.activeName, (modelValue) => setCurrentName(modelValue));
        watch(() => props.modelValue, (modelValue) => setCurrentName(modelValue));
        watch(currentName, async () => {
          var _a22;
          await nextTick();
          (_a22 = nav$.value) == null ? void 0 : _a22.scrollToActiveTab();
        });
        {
          const registerPane = (pane) => panes[pane.uid] = pane;
          const unregisterPane = (uid2) => delete panes[uid2];
          provide(tabsRootContextKey, {
            props,
            currentName,
            registerPane,
            unregisterPane
          });
        }
        expose({
          currentName
        });
        return () => {
          const newButton = props.editable || props.addable ? createVNode("span", {
            "class": ns2.e("new-tab"),
            "tabindex": "0",
            "onClick": handleTabAdd,
            "onKeydown": (ev) => {
              if (ev.code === EVENT_CODE.enter)
                handleTabAdd();
            }
          }, [createVNode(ElIcon, {
            "class": ns2.is("icon-plus")
          }, {
            default: () => [createVNode(plus_default, null, null)]
          })]) : null;
          const header = createVNode("div", {
            "class": [ns2.e("header"), ns2.is(props.tabPosition)]
          }, [newButton, createVNode(TabNav, {
            "ref": nav$,
            "currentName": currentName.value,
            "editable": props.editable,
            "type": props.type,
            "panes": Object.values(panes),
            "stretch": props.stretch,
            "onTabClick": handleTabClick,
            "onTabRemove": handleTabRemove
          }, null)]);
          const panels = createVNode("div", {
            "class": ns2.e("content")
          }, [renderSlot(slots, "default")]);
          return createVNode("div", {
            "class": [ns2.b(), ns2.m(props.tabPosition), {
              [ns2.m("card")]: props.type === "card",
              [ns2.m("border-card")]: props.type === "border-card"
            }]
          }, [...props.tabPosition !== "bottom" ? [header, panels] : [panels, header]]);
        };
      }
    });
    const tabPaneProps = buildProps({
      label: {
        type: String,
        default: ""
      },
      name: {
        type: [String, Number]
      },
      closable: Boolean,
      disabled: Boolean,
      lazy: Boolean
    });
    const _hoisted_1$c = ["id", "aria-hidden", "aria-labelledby"];
    const __default__$g = {
      name: "ElTabPane"
    };
    const _sfc_main$q = /* @__PURE__ */ defineComponent({
      ...__default__$g,
      props: tabPaneProps,
      setup(__props) {
        const props = __props;
        const COMPONENT_NAME2 = "ElTabPane";
        const instance = getCurrentInstance();
        const slots = useSlots();
        const tabsRoot = inject(tabsRootContextKey);
        if (!tabsRoot)
          throwError(COMPONENT_NAME2, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
        const ns2 = useNamespace("tab-pane");
        const index2 = ref();
        const isClosable = computed(() => props.closable || tabsRoot.props.closable);
        const active = computedEager(() => {
          var _a2;
          return tabsRoot.currentName.value === ((_a2 = props.name) != null ? _a2 : index2.value);
        });
        const loaded = ref(active.value);
        const paneName = computed(() => {
          var _a2;
          return (_a2 = props.name) != null ? _a2 : index2.value;
        });
        const shouldBeRender = computedEager(() => !props.lazy || loaded.value || active.value);
        watch(active, (val) => {
          if (val)
            loaded.value = true;
        });
        const pane = reactive({
          uid: instance.uid,
          slots,
          props,
          paneName,
          active,
          index: index2,
          isClosable
        });
        onMounted(() => {
          tabsRoot.registerPane(pane);
        });
        onUnmounted(() => {
          tabsRoot.unregisterPane(pane.uid);
        });
        return (_ctx, _cache) => {
          return unref(shouldBeRender) ? withDirectives((openBlock(), createElementBlock("div", {
            key: 0,
            id: `pane-${unref(paneName)}`,
            class: normalizeClass(unref(ns2).b()),
            role: "tabpanel",
            "aria-hidden": !unref(active),
            "aria-labelledby": `tab-${unref(paneName)}`
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 10, _hoisted_1$c)), [
            [vShow, unref(active)]
          ]) : createCommentVNode("v-if", true);
        };
      }
    });
    var TabPane = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-pane.vue"]]);
    const ElTabs = withInstall(Tabs, {
      TabPane
    });
    const ElTabPane = withNoopInstall(TabPane);
    const timeSelectProps = buildProps({
      format: {
        type: String,
        default: "HH:mm"
      },
      modelValue: String,
      disabled: Boolean,
      editable: {
        type: Boolean,
        default: true
      },
      effect: {
        type: String,
        default: "light"
      },
      clearable: {
        type: Boolean,
        default: true
      },
      size: useSizeProp,
      placeholder: String,
      start: {
        type: String,
        default: "09:00"
      },
      end: {
        type: String,
        default: "18:00"
      },
      step: {
        type: String,
        default: "00:30"
      },
      minTime: String,
      maxTime: String,
      name: String,
      prefixIcon: {
        type: definePropType([String, Object]),
        default: () => clock_default
      },
      clearIcon: {
        type: definePropType([String, Object]),
        default: () => circle_close_default
      }
    });
    const parseTime = (time) => {
      const values = (time || "").split(":");
      if (values.length >= 2) {
        let hours = Number.parseInt(values[0], 10);
        const minutes = Number.parseInt(values[1], 10);
        const timeUpper = time.toUpperCase();
        if (timeUpper.includes("AM") && hours === 12) {
          hours = 0;
        } else if (timeUpper.includes("PM") && hours !== 12) {
          hours += 12;
        }
        return {
          hours,
          minutes
        };
      }
      return null;
    };
    const compareTime = (time1, time2) => {
      const value1 = parseTime(time1);
      if (!value1)
        return -1;
      const value2 = parseTime(time2);
      if (!value2)
        return -1;
      const minutes1 = value1.minutes + value1.hours * 60;
      const minutes2 = value2.minutes + value2.hours * 60;
      if (minutes1 === minutes2) {
        return 0;
      }
      return minutes1 > minutes2 ? 1 : -1;
    };
    const padTime = (time) => {
      return `${time}`.padStart(2, "0");
    };
    const formatTime = (time) => {
      return `${padTime(time.hours)}:${padTime(time.minutes)}`;
    };
    const nextTime = (time, step) => {
      const timeValue = parseTime(time);
      if (!timeValue)
        return "";
      const stepValue = parseTime(step);
      if (!stepValue)
        return "";
      const next = {
        hours: timeValue.hours,
        minutes: timeValue.minutes
      };
      next.minutes += stepValue.minutes;
      next.hours += stepValue.hours;
      next.hours += Math.floor(next.minutes / 60);
      next.minutes = next.minutes % 60;
      return formatTime(next);
    };
    const __default__$f = {
      name: "ElTimeSelect"
    };
    const _sfc_main$p = /* @__PURE__ */ defineComponent({
      ...__default__$f,
      props: timeSelectProps,
      emits: ["change", "blur", "focus", "update:modelValue"],
      setup(__props, { expose }) {
        const props = __props;
        dayjs.extend(customParseFormat);
        const { Option: ElOption2 } = ElSelect;
        const nsInput = useNamespace("input");
        const select = ref();
        const _disabled = useDisabled$1();
        const value = computed(() => props.modelValue);
        const start = computed(() => {
          const time = parseTime(props.start);
          return time ? formatTime(time) : null;
        });
        const end2 = computed(() => {
          const time = parseTime(props.end);
          return time ? formatTime(time) : null;
        });
        const step = computed(() => {
          const time = parseTime(props.step);
          return time ? formatTime(time) : null;
        });
        const minTime = computed(() => {
          const time = parseTime(props.minTime || "");
          return time ? formatTime(time) : null;
        });
        const maxTime = computed(() => {
          const time = parseTime(props.maxTime || "");
          return time ? formatTime(time) : null;
        });
        const items = computed(() => {
          const result = [];
          if (props.start && props.end && props.step) {
            let current = start.value;
            let currentTime;
            while (current && end2.value && compareTime(current, end2.value) <= 0) {
              currentTime = dayjs(current, "HH:mm").format(props.format);
              result.push({
                value: currentTime,
                disabled: compareTime(current, minTime.value || "-1:-1") <= 0 || compareTime(current, maxTime.value || "100:100") >= 0
              });
              current = nextTime(current, step.value);
            }
          }
          return result;
        });
        const blur = () => {
          var _a2, _b;
          (_b = (_a2 = select.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
        };
        const focus = () => {
          var _a2, _b;
          (_b = (_a2 = select.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
        };
        expose({
          blur,
          focus
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElSelect), {
            ref_key: "select",
            ref: select,
            "model-value": unref(value),
            disabled: unref(_disabled),
            clearable: _ctx.clearable,
            "clear-icon": _ctx.clearIcon,
            size: _ctx.size,
            effect: _ctx.effect,
            placeholder: _ctx.placeholder,
            "default-first-option": "",
            filterable: _ctx.editable,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = (event) => _ctx.$emit("update:modelValue", event)),
            onChange: _cache[1] || (_cache[1] = (event) => _ctx.$emit("change", event)),
            onBlur: _cache[2] || (_cache[2] = (event) => _ctx.$emit("blur", event)),
            onFocus: _cache[3] || (_cache[3] = (event) => _ctx.$emit("focus", event))
          }, {
            prefix: withCtx(() => [
              _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(nsInput).e("prefix-icon"))
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : createCommentVNode("v-if", true)
            ]),
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(items), (item) => {
                return openBlock(), createBlock(unref(ElOption2), {
                  key: item.value,
                  label: item.value,
                  value: item.value,
                  disabled: item.disabled
                }, null, 8, ["label", "value", "disabled"]);
              }), 128))
            ]),
            _: 1
          }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "effect", "placeholder", "filterable"]);
        };
      }
    });
    var TimeSelect = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-select/src/time-select.vue"]]);
    TimeSelect.install = (app2) => {
      app2.component(TimeSelect.name, TimeSelect);
    };
    const _TimeSelect = TimeSelect;
    const ElTimeSelect = _TimeSelect;
    const Timeline = defineComponent({
      name: "ElTimeline",
      setup(_2, { slots }) {
        const ns2 = useNamespace("timeline");
        provide("timeline", slots);
        return () => {
          return h$1("ul", { class: [ns2.b()] }, [renderSlot(slots, "default")]);
        };
      }
    });
    const timelineItemProps = buildProps({
      timestamp: {
        type: String,
        default: ""
      },
      hideTimestamp: {
        type: Boolean,
        default: false
      },
      center: {
        type: Boolean,
        default: false
      },
      placement: {
        type: String,
        values: ["top", "bottom"],
        default: "bottom"
      },
      type: {
        type: String,
        values: ["primary", "success", "warning", "danger", "info"],
        default: ""
      },
      color: {
        type: String,
        default: ""
      },
      size: {
        type: String,
        values: ["normal", "large"],
        default: "normal"
      },
      icon: {
        type: iconPropType
      },
      hollow: {
        type: Boolean,
        default: false
      }
    });
    const __default__$e = {
      name: "ElTimelineItem"
    };
    const _sfc_main$o = /* @__PURE__ */ defineComponent({
      ...__default__$e,
      props: timelineItemProps,
      setup(__props) {
        const ns2 = useNamespace("timeline-item");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("li", {
            class: normalizeClass([unref(ns2).b(), { [unref(ns2).e("center")]: _ctx.center }])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("tail"))
            }, null, 2),
            !_ctx.$slots.dot ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass([
                unref(ns2).e("node"),
                unref(ns2).em("node", _ctx.size || ""),
                unref(ns2).em("node", _ctx.type || ""),
                unref(ns2).is("hollow", _ctx.hollow)
              ]),
              style: normalizeStyle({
                backgroundColor: _ctx.color
              })
            }, [
              _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(ns2).e("icon"))
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                ]),
                _: 1
              }, 8, ["class"])) : createCommentVNode("v-if", true)
            ], 6)) : createCommentVNode("v-if", true),
            _ctx.$slots.dot ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(unref(ns2).e("dot"))
            }, [
              renderSlot(_ctx.$slots, "dot")
            ], 2)) : createCommentVNode("v-if", true),
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("wrapper"))
            }, [
              !_ctx.hideTimestamp && _ctx.placement === "top" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass([unref(ns2).e("timestamp"), unref(ns2).is("top")])
              }, toDisplayString$1(_ctx.timestamp), 3)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns2).e("content"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2),
              !_ctx.hideTimestamp && _ctx.placement === "bottom" ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass([unref(ns2).e("timestamp"), unref(ns2).is("bottom")])
              }, toDisplayString$1(_ctx.timestamp), 3)) : createCommentVNode("v-if", true)
            ], 2)
          ], 2);
        };
      }
    });
    var TimelineItem = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/timeline/src/timeline-item.vue"]]);
    const ElTimeline = withInstall(Timeline, {
      TimelineItem
    });
    const ElTimelineItem = withNoopInstall(TimelineItem);
    const tooltipV2CommonProps = buildProps({
      nowrap: Boolean
    });
    var TooltipV2Sides = /* @__PURE__ */ ((TooltipV2Sides2) => {
      TooltipV2Sides2["top"] = "top";
      TooltipV2Sides2["bottom"] = "bottom";
      TooltipV2Sides2["left"] = "left";
      TooltipV2Sides2["right"] = "right";
      return TooltipV2Sides2;
    })(TooltipV2Sides || {});
    const tooltipV2Sides = Object.values(TooltipV2Sides);
    const tooltipV2ArrowProps = buildProps({
      width: {
        type: Number,
        default: 10
      },
      height: {
        type: Number,
        default: 10
      },
      style: {
        type: definePropType(Object),
        default: null
      }
    });
    const tooltipV2ArrowSpecialProps = buildProps({
      side: {
        type: definePropType(String),
        values: tooltipV2Sides,
        required: true
      }
    });
    const tooltipV2Strategies = ["absolute", "fixed"];
    const tooltipV2Placements = [
      "top-start",
      "top-end",
      "top",
      "bottom-start",
      "bottom-end",
      "bottom",
      "left-start",
      "left-end",
      "left",
      "right-start",
      "right-end",
      "right"
    ];
    const tooltipV2ContentProps = buildProps({
      ariaLabel: String,
      arrowPadding: {
        type: definePropType(Number),
        default: 5
      },
      effect: {
        type: String,
        default: ""
      },
      contentClass: String,
      placement: {
        type: definePropType(String),
        values: tooltipV2Placements,
        default: "bottom"
      },
      reference: {
        type: definePropType(Object),
        default: null
      },
      offset: {
        type: Number,
        default: 8
      },
      strategy: {
        type: definePropType(String),
        values: tooltipV2Strategies,
        default: "absolute"
      },
      showArrow: {
        type: Boolean,
        default: false
      }
    });
    const tooltipV2RootProps = buildProps({
      delayDuration: {
        type: Number,
        default: 300
      },
      defaultOpen: Boolean,
      open: {
        type: Boolean,
        default: void 0
      },
      onOpenChange: {
        type: definePropType(Function)
      },
      "onUpdate:open": {
        type: definePropType(Function)
      }
    });
    const EventHandler = {
      type: definePropType(Function)
    };
    const tooltipV2TriggerProps = buildProps({
      onBlur: EventHandler,
      onClick: EventHandler,
      onFocus: EventHandler,
      onMouseDown: EventHandler,
      onMouseEnter: EventHandler,
      onMouseLeave: EventHandler
    });
    const tooltipV2Props = buildProps({
      ...tooltipV2RootProps,
      ...tooltipV2ArrowProps,
      ...tooltipV2TriggerProps,
      ...tooltipV2ContentProps,
      alwaysOn: Boolean,
      fullTransition: Boolean,
      transitionProps: {
        type: definePropType(Object),
        default: null
      },
      teleported: Boolean,
      to: {
        type: definePropType(String),
        default: "body"
      }
    });
    const __default__$d = {
      name: "ElTooltipV2Root"
    };
    const _sfc_main$n = /* @__PURE__ */ defineComponent({
      ...__default__$d,
      props: tooltipV2RootProps,
      setup(__props, { expose }) {
        const props = __props;
        const _open = ref(props.defaultOpen);
        const triggerRef2 = ref(null);
        const open = computed({
          get: () => isPropAbsent(props.open) ? _open.value : props.open,
          set: (open2) => {
            var _a2;
            _open.value = open2;
            (_a2 = props["onUpdate:open"]) == null ? void 0 : _a2.call(props, open2);
          }
        });
        const isOpenDelayed = computed(() => isNumber$2(props.delayDuration) && props.delayDuration > 0);
        const { start: onDelayedOpen, stop: clearTimer } = useTimeoutFn(() => {
          open.value = true;
        }, computed(() => props.delayDuration), {
          immediate: false
        });
        const ns2 = useNamespace("tooltip-v2");
        const contentId = useId();
        const onNormalOpen = () => {
          clearTimer();
          open.value = true;
        };
        const onDelayOpen = () => {
          unref(isOpenDelayed) ? onDelayedOpen() : onNormalOpen();
        };
        const onOpen = onNormalOpen;
        const onClose = () => {
          clearTimer();
          open.value = false;
        };
        const onChange = (open2) => {
          var _a2;
          if (open2) {
            document.dispatchEvent(new CustomEvent(TOOLTIP_V2_OPEN));
            onOpen();
          }
          (_a2 = props.onOpenChange) == null ? void 0 : _a2.call(props, open2);
        };
        watch(open, onChange);
        onMounted(() => {
          document.addEventListener(TOOLTIP_V2_OPEN, onClose);
        });
        onBeforeUnmount(() => {
          clearTimer();
          document.removeEventListener(TOOLTIP_V2_OPEN, onClose);
        });
        provide(tooltipV2RootKey, {
          contentId,
          triggerRef: triggerRef2,
          ns: ns2,
          onClose,
          onDelayOpen,
          onOpen
        });
        expose({
          onOpen,
          onClose
        });
        return (_ctx, _cache) => {
          return renderSlot(_ctx.$slots, "default", { open: unref(open) });
        };
      }
    });
    var TooltipV2Root = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/root.vue"]]);
    const __default__$c = {
      name: "ElTooltipV2Arrow"
    };
    const _sfc_main$m = /* @__PURE__ */ defineComponent({
      ...__default__$c,
      props: {
        ...tooltipV2ArrowProps,
        ...tooltipV2ArrowSpecialProps
      },
      setup(__props) {
        const props = __props;
        const { ns: ns2 } = inject(tooltipV2RootKey);
        const { arrowRef } = inject(tooltipV2ContentKey);
        const arrowStyle = computed(() => {
          const { style: style2, width, height } = props;
          const namespace = ns2.namespace.value;
          return {
            [`--${namespace}-tooltip-v2-arrow-width`]: `${width}px`,
            [`--${namespace}-tooltip-v2-arrow-height`]: `${height}px`,
            [`--${namespace}-tooltip-v2-arrow-border-width`]: `${width / 2}px`,
            [`--${namespace}-tooltip-v2-arrow-cover-width`]: width / 2 - 1,
            ...style2 || {}
          };
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            ref_key: "arrowRef",
            ref: arrowRef,
            style: normalizeStyle(unref(arrowStyle)),
            class: normalizeClass(unref(ns2).e("arrow"))
          }, null, 6);
        };
      }
    });
    var TooltipV2Arrow = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/arrow.vue"]]);
    const visualHiddenProps = buildProps({
      style: {
        type: definePropType([String, Object, Array]),
        default: () => ({})
      }
    });
    const __default__$b = {
      name: "ElVisuallyHidden"
    };
    const _sfc_main$l = /* @__PURE__ */ defineComponent({
      ...__default__$b,
      props: visualHiddenProps,
      setup(__props) {
        const props = __props;
        const computedStyle = computed(() => {
          return [
            props.style,
            {
              position: "absolute",
              border: 0,
              width: 1,
              height: 1,
              padding: 0,
              margin: -1,
              overflow: "hidden",
              clip: "rect(0, 0, 0, 0)",
              whiteSpace: "nowrap",
              wordWrap: "normal"
            }
          ];
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, { style: unref(computedStyle) }), [
            renderSlot(_ctx.$slots, "default")
          ], 16);
        };
      }
    });
    var ElVisuallyHidden = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/visual-hidden/src/visual-hidden.vue"]]);
    const _hoisted_1$b = ["data-side"];
    const __default__$a = {
      name: "ElTooltipV2Content"
    };
    const _sfc_main$k = /* @__PURE__ */ defineComponent({
      ...__default__$a,
      props: { ...tooltipV2ContentProps, ...tooltipV2CommonProps },
      setup(__props) {
        const props = __props;
        const { triggerRef: triggerRef2, contentId } = inject(tooltipV2RootKey);
        const placement = ref(props.placement);
        const strategy = ref(props.strategy);
        const arrowRef = ref(null);
        const { referenceRef, contentRef, middlewareData, x: x2, y, update } = useFloating({
          placement,
          strategy,
          middleware: computed(() => {
            const middleware = [offset(props.offset)];
            if (props.showArrow) {
              middleware.push(arrowMiddleware({
                arrowRef
              }));
            }
            return middleware;
          })
        });
        const zIndex2 = useZIndex().nextZIndex();
        const ns2 = useNamespace("tooltip-v2");
        const side = computed(() => {
          return placement.value.split("-")[0];
        });
        const contentStyle = computed(() => {
          return {
            position: unref(strategy),
            top: `${unref(y) || 0}px`,
            left: `${unref(x2) || 0}px`,
            zIndex: zIndex2
          };
        });
        const arrowStyle = computed(() => {
          if (!props.showArrow)
            return {};
          const { arrow: arrow2 } = unref(middlewareData);
          return {
            [`--${ns2.namespace.value}-tooltip-v2-arrow-x`]: `${arrow2 == null ? void 0 : arrow2.x}px` || "",
            [`--${ns2.namespace.value}-tooltip-v2-arrow-y`]: `${arrow2 == null ? void 0 : arrow2.y}px` || ""
          };
        });
        const contentClass = computed(() => [
          ns2.e("content"),
          ns2.is("dark", props.effect === "dark"),
          ns2.is(unref(strategy)),
          props.contentClass
        ]);
        watch(arrowRef, () => update());
        watch(() => props.placement, (val) => placement.value = val);
        onMounted(() => {
          watch(() => props.reference || triggerRef2.value, (el) => {
            referenceRef.value = el || void 0;
          }, {
            immediate: true
          });
        });
        provide(tooltipV2ContentKey, { arrowRef });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "contentRef",
            ref: contentRef,
            style: normalizeStyle(unref(contentStyle)),
            "data-tooltip-v2-root": ""
          }, [
            !_ctx.nowrap ? (openBlock(), createElementBlock("div", {
              key: 0,
              "data-side": unref(side),
              class: normalizeClass(unref(contentClass))
            }, [
              renderSlot(_ctx.$slots, "default", {
                contentStyle: unref(contentStyle),
                contentClass: unref(contentClass)
              }),
              createVNode(unref(ElVisuallyHidden), {
                id: unref(contentId),
                role: "tooltip"
              }, {
                default: withCtx(() => [
                  _ctx.ariaLabel ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createTextVNode(toDisplayString$1(_ctx.ariaLabel), 1)
                  ], 64)) : renderSlot(_ctx.$slots, "default", { key: 1 })
                ]),
                _: 3
              }, 8, ["id"]),
              renderSlot(_ctx.$slots, "arrow", {
                style: normalizeStyle(unref(arrowStyle)),
                side: unref(side)
              })
            ], 10, _hoisted_1$b)) : createCommentVNode("v-if", true)
          ], 4);
        };
      }
    });
    var TooltipV2Content = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/content.vue"]]);
    const forwardRefProps = buildProps({
      setRef: {
        type: definePropType(Function),
        required: true
      },
      onlyChild: Boolean
    });
    var ForwardRef = defineComponent({
      props: forwardRefProps,
      setup(props, {
        slots
      }) {
        const fragmentRef = ref();
        const setRef2 = composeRefs(fragmentRef, (el) => {
          if (el) {
            props.setRef(el.nextElementSibling);
          } else {
            props.setRef(null);
          }
        });
        return () => {
          var _a2;
          const [firstChild] = ((_a2 = slots.default) == null ? void 0 : _a2.call(slots)) || [];
          const child = props.onlyChild ? ensureOnlyChild(firstChild.children) : firstChild.children;
          return createVNode(Fragment, {
            "ref": setRef2
          }, [child]);
        };
      }
    });
    const __default__$9 = {
      name: "ElTooltipV2Trigger"
    };
    const _sfc_main$j = /* @__PURE__ */ defineComponent({
      ...__default__$9,
      props: {
        ...tooltipV2CommonProps,
        ...tooltipV2TriggerProps
      },
      setup(__props) {
        const props = __props;
        const { onClose, onOpen, onDelayOpen, triggerRef: triggerRef2, contentId } = inject(tooltipV2RootKey);
        let isMousedown = false;
        const setTriggerRef = (el) => {
          triggerRef2.value = el;
        };
        const onMouseup = () => {
          isMousedown = false;
        };
        const onMouseenter = composeEventHandlers(props.onMouseEnter, onDelayOpen);
        const onMouseleave = composeEventHandlers(props.onMouseLeave, onClose);
        const onMousedown = composeEventHandlers(props.onMouseDown, () => {
          onClose();
          isMousedown = true;
          document.addEventListener("mouseup", onMouseup, { once: true });
        });
        const onFocus = composeEventHandlers(props.onFocus, () => {
          if (!isMousedown)
            onOpen();
        });
        const onBlur = composeEventHandlers(props.onBlur, onClose);
        const onClick = composeEventHandlers(props.onClick, (e) => {
          if (e.detail === 0)
            onClose();
        });
        const events = {
          blur: onBlur,
          click: onClick,
          focus: onFocus,
          mousedown: onMousedown,
          mouseenter: onMouseenter,
          mouseleave: onMouseleave
        };
        const setEvents = (el, events2, type2) => {
          if (el) {
            Object.entries(events2).forEach(([name, handler]) => {
              el[type2](name, handler);
            });
          }
        };
        watch(triggerRef2, (triggerEl, previousTriggerEl) => {
          setEvents(triggerEl, events, "addEventListener");
          setEvents(previousTriggerEl, events, "removeEventListener");
          if (triggerEl) {
            triggerEl.setAttribute("aria-describedby", contentId.value);
          }
        });
        onBeforeUnmount(() => {
          setEvents(triggerRef2.value, events, "removeEventListener");
          document.removeEventListener("mouseup", onMouseup);
        });
        return (_ctx, _cache) => {
          return _ctx.nowrap ? (openBlock(), createBlock(unref(ForwardRef), {
            key: 0,
            "set-ref": setTriggerRef,
            "only-child": ""
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          })) : (openBlock(), createElementBlock("button", mergeProps({
            key: 1,
            ref_key: "triggerRef",
            ref: triggerRef2
          }, _ctx.$attrs), [
            renderSlot(_ctx.$slots, "default")
          ], 16));
        };
      }
    });
    var TooltipV2Trigger = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/trigger.vue"]]);
    const __default__$8 = {
      name: "ElTooltipV2"
    };
    const _sfc_main$i = /* @__PURE__ */ defineComponent({
      ...__default__$8,
      props: tooltipV2Props,
      setup(__props) {
        const props = __props;
        const refedProps = toRefs(props);
        const arrowProps = reactive(pick$1(refedProps, Object.keys(tooltipV2ArrowProps)));
        const contentProps = reactive(pick$1(refedProps, Object.keys(tooltipV2ContentProps)));
        const rootProps = reactive(pick$1(refedProps, Object.keys(tooltipV2RootProps)));
        const triggerProps = reactive(pick$1(refedProps, Object.keys(tooltipV2TriggerProps)));
        return (_ctx, _cache) => {
          return openBlock(), createBlock(TooltipV2Root, normalizeProps(guardReactiveProps(rootProps)), {
            default: withCtx(({ open }) => [
              createVNode(TooltipV2Trigger, mergeProps(triggerProps, { nowrap: "" }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "trigger")
                ]),
                _: 3
              }, 16),
              (openBlock(), createBlock(Teleport, {
                to: _ctx.to,
                disabled: !_ctx.teleported
              }, [
                _ctx.fullTransition ? (openBlock(), createBlock(Transition, normalizeProps(mergeProps({ key: 0 }, _ctx.transitionProps)), {
                  default: withCtx(() => [
                    _ctx.alwaysOn || open ? (openBlock(), createBlock(TooltipV2Content, normalizeProps(mergeProps({ key: 0 }, contentProps)), {
                      arrow: withCtx(({ style: style2, side }) => [
                        _ctx.showArrow ? (openBlock(), createBlock(TooltipV2Arrow, mergeProps({ key: 0 }, arrowProps, {
                          style: style2,
                          side
                        }), null, 16, ["style", "side"])) : createCommentVNode("v-if", true)
                      ]),
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "default")
                      ]),
                      _: 3
                    }, 16)) : createCommentVNode("v-if", true)
                  ]),
                  _: 2
                }, 1040)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  _ctx.alwaysOn || open ? (openBlock(), createBlock(TooltipV2Content, normalizeProps(mergeProps({ key: 0 }, contentProps)), {
                    arrow: withCtx(({ style: style2, side }) => [
                      _ctx.showArrow ? (openBlock(), createBlock(TooltipV2Arrow, mergeProps({ key: 0 }, arrowProps, {
                        style: style2,
                        side
                      }), null, 16, ["style", "side"])) : createCommentVNode("v-if", true)
                    ]),
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "default")
                    ]),
                    _: 3
                  }, 16)) : createCommentVNode("v-if", true)
                ], 64))
              ], 8, ["to", "disabled"]))
            ]),
            _: 3
          }, 16);
        };
      }
    });
    var TooltipV2 = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip-v2/src/tooltip.vue"]]);
    const ElTooltipV2 = withInstall(TooltipV2);
    const LEFT_CHECK_CHANGE_EVENT = "left-check-change";
    const RIGHT_CHECK_CHANGE_EVENT = "right-check-change";
    const transferProps = buildProps({
      data: {
        type: definePropType(Array),
        default: () => []
      },
      titles: {
        type: definePropType(Array),
        default: () => []
      },
      buttonTexts: {
        type: definePropType(Array),
        default: () => []
      },
      filterPlaceholder: String,
      filterMethod: {
        type: definePropType(Function)
      },
      leftDefaultChecked: {
        type: definePropType(Array),
        default: () => []
      },
      rightDefaultChecked: {
        type: definePropType(Array),
        default: () => []
      },
      renderContent: {
        type: definePropType(Function)
      },
      modelValue: {
        type: definePropType(Array),
        default: () => []
      },
      format: {
        type: definePropType(Object),
        default: () => ({})
      },
      filterable: Boolean,
      props: {
        type: definePropType(Object),
        default: () => mutable({
          label: "label",
          key: "key",
          disabled: "disabled"
        })
      },
      targetOrder: {
        type: String,
        values: ["original", "push", "unshift"],
        default: "original"
      },
      validateEvent: {
        type: Boolean,
        default: true
      }
    });
    const transferCheckedChangeFn = (value, movedKeys) => [value, movedKeys].every(isArray$4) || isArray$4(value) && isNil(movedKeys);
    const transferEmits = {
      [CHANGE_EVENT]: (value, direction2, movedKeys) => [value, movedKeys].every(isArray$4) && ["left", "right"].includes(direction2),
      [UPDATE_MODEL_EVENT]: (value) => isArray$4(value),
      [LEFT_CHECK_CHANGE_EVENT]: transferCheckedChangeFn,
      [RIGHT_CHECK_CHANGE_EVENT]: transferCheckedChangeFn
    };
    const CHECKED_CHANGE_EVENT = "checked-change";
    const transferPanelProps = buildProps({
      data: transferProps.data,
      optionRender: {
        type: definePropType(Function)
      },
      placeholder: String,
      title: String,
      filterable: Boolean,
      format: transferProps.format,
      filterMethod: transferProps.filterMethod,
      defaultChecked: transferProps.leftDefaultChecked,
      props: transferProps.props
    });
    const transferPanelEmits = {
      [CHECKED_CHANGE_EVENT]: transferCheckedChangeFn
    };
    const usePropsAlias = (props) => {
      const initProps2 = {
        label: "label",
        key: "key",
        disabled: "disabled"
      };
      return computed(() => ({
        ...initProps2,
        ...props.props
      }));
    };
    const useCheck$1 = (props, panelState, emit) => {
      const propsAlias = usePropsAlias(props);
      const filteredData = computed(() => {
        return props.data.filter((item) => {
          if (isFunction$4(props.filterMethod)) {
            return props.filterMethod(panelState.query, item);
          } else {
            const label = String(item[propsAlias.value.label] || item[propsAlias.value.key]);
            return label.toLowerCase().includes(panelState.query.toLowerCase());
          }
        });
      });
      const checkableData = computed(() => filteredData.value.filter((item) => !item[propsAlias.value.disabled]));
      const checkedSummary = computed(() => {
        const checkedLength = panelState.checked.length;
        const dataLength = props.data.length;
        const { noChecked, hasChecked } = props.format;
        if (noChecked && hasChecked) {
          return checkedLength > 0 ? hasChecked.replace(/\${checked}/g, checkedLength.toString()).replace(/\${total}/g, dataLength.toString()) : noChecked.replace(/\${total}/g, dataLength.toString());
        } else {
          return `${checkedLength}/${dataLength}`;
        }
      });
      const isIndeterminate = computed(() => {
        const checkedLength = panelState.checked.length;
        return checkedLength > 0 && checkedLength < checkableData.value.length;
      });
      const updateAllChecked = () => {
        const checkableDataKeys = checkableData.value.map((item) => item[propsAlias.value.key]);
        panelState.allChecked = checkableDataKeys.length > 0 && checkableDataKeys.every((item) => panelState.checked.includes(item));
      };
      const handleAllCheckedChange = (value) => {
        panelState.checked = value ? checkableData.value.map((item) => item[propsAlias.value.key]) : [];
      };
      watch(() => panelState.checked, (val, oldVal) => {
        updateAllChecked();
        if (panelState.checkChangeByUser) {
          const movedKeys = val.concat(oldVal).filter((v2) => !val.includes(v2) || !oldVal.includes(v2));
          emit(CHECKED_CHANGE_EVENT, val, movedKeys);
        } else {
          emit(CHECKED_CHANGE_EVENT, val);
          panelState.checkChangeByUser = true;
        }
      });
      watch(checkableData, () => {
        updateAllChecked();
      });
      watch(() => props.data, () => {
        const checked = [];
        const filteredDataKeys = filteredData.value.map((item) => item[propsAlias.value.key]);
        panelState.checked.forEach((item) => {
          if (filteredDataKeys.includes(item)) {
            checked.push(item);
          }
        });
        panelState.checkChangeByUser = false;
        panelState.checked = checked;
      });
      watch(() => props.defaultChecked, (val, oldVal) => {
        if (oldVal && val.length === oldVal.length && val.every((item) => oldVal.includes(item)))
          return;
        const checked = [];
        const checkableDataKeys = checkableData.value.map((item) => item[propsAlias.value.key]);
        val.forEach((item) => {
          if (checkableDataKeys.includes(item)) {
            checked.push(item);
          }
        });
        panelState.checkChangeByUser = false;
        panelState.checked = checked;
      }, {
        immediate: true
      });
      return {
        filteredData,
        checkableData,
        checkedSummary,
        isIndeterminate,
        updateAllChecked,
        handleAllCheckedChange
      };
    };
    const useCheckedChange = (checkedState, emit) => {
      const onSourceCheckedChange = (val, movedKeys) => {
        checkedState.leftChecked = val;
        if (!movedKeys)
          return;
        emit(LEFT_CHECK_CHANGE_EVENT, val, movedKeys);
      };
      const onTargetCheckedChange = (val, movedKeys) => {
        checkedState.rightChecked = val;
        if (!movedKeys)
          return;
        emit(RIGHT_CHECK_CHANGE_EVENT, val, movedKeys);
      };
      return {
        onSourceCheckedChange,
        onTargetCheckedChange
      };
    };
    const useComputedData = (props) => {
      const propsAlias = usePropsAlias(props);
      const dataObj = computed(() => props.data.reduce((o2, cur) => (o2[cur[propsAlias.value.key]] = cur) && o2, {}));
      const sourceData = computed(() => props.data.filter((item) => !props.modelValue.includes(item[propsAlias.value.key])));
      const targetData = computed(() => {
        if (props.targetOrder === "original") {
          return props.data.filter((item) => props.modelValue.includes(item[propsAlias.value.key]));
        } else {
          return props.modelValue.reduce((arr, cur) => {
            const val = dataObj.value[cur];
            if (val) {
              arr.push(val);
            }
            return arr;
          }, []);
        }
      });
      return {
        sourceData,
        targetData
      };
    };
    const useMove = (props, checkedState, emit) => {
      const propsAlias = usePropsAlias(props);
      const _emit = (value, direction2, movedKeys) => {
        emit(UPDATE_MODEL_EVENT, value);
        emit(CHANGE_EVENT, value, direction2, movedKeys);
      };
      const addToLeft = () => {
        const currentValue = props.modelValue.slice();
        checkedState.rightChecked.forEach((item) => {
          const index2 = currentValue.indexOf(item);
          if (index2 > -1) {
            currentValue.splice(index2, 1);
          }
        });
        _emit(currentValue, "left", checkedState.rightChecked);
      };
      const addToRight = () => {
        let currentValue = props.modelValue.slice();
        const itemsToBeMoved = props.data.filter((item) => {
          const itemKey = item[propsAlias.value.key];
          return checkedState.leftChecked.includes(itemKey) && !props.modelValue.includes(itemKey);
        }).map((item) => item[propsAlias.value.key]);
        currentValue = props.targetOrder === "unshift" ? itemsToBeMoved.concat(currentValue) : currentValue.concat(itemsToBeMoved);
        if (props.targetOrder === "original") {
          currentValue = props.data.filter((item) => currentValue.includes(item[propsAlias.value.key])).map((item) => item[propsAlias.value.key]);
        }
        _emit(currentValue, "right", checkedState.leftChecked);
      };
      return {
        addToLeft,
        addToRight
      };
    };
    const __default__$7 = {
      name: "ElTransferPanel"
    };
    const _sfc_main$h = /* @__PURE__ */ defineComponent({
      ...__default__$7,
      props: transferPanelProps,
      emits: transferPanelEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const slots = useSlots();
        const OptionContent = ({ option }) => option;
        const { t } = useLocale();
        const ns2 = useNamespace("transfer");
        const panelState = reactive({
          checked: [],
          allChecked: false,
          query: "",
          inputHover: false,
          checkChangeByUser: true
        });
        const propsAlias = usePropsAlias(props);
        const {
          filteredData,
          checkedSummary,
          isIndeterminate,
          handleAllCheckedChange
        } = useCheck$1(props, panelState, emit);
        const hasNoMatch = computed(() => !isEmpty(panelState.query) && isEmpty(filteredData.value));
        const hasFooter = computed(() => !isEmpty(slots.default()[0].children));
        const { checked, allChecked, query, inputHover } = toRefs(panelState);
        expose({
          query
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(ns2).b("panel"))
          }, [
            createBaseVNode("p", {
              class: normalizeClass(unref(ns2).be("panel", "header"))
            }, [
              createVNode(unref(ElCheckbox), {
                modelValue: unref(allChecked),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(allChecked) ? allChecked.value = $event : null),
                indeterminate: unref(isIndeterminate),
                "validate-event": false,
                onChange: unref(handleAllCheckedChange)
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(_ctx.title) + " ", 1),
                  createBaseVNode("span", null, toDisplayString$1(unref(checkedSummary)), 1)
                ]),
                _: 1
              }, 8, ["modelValue", "indeterminate", "onChange"])
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass([unref(ns2).be("panel", "body"), unref(ns2).is("with-footer", unref(hasFooter))])
            }, [
              _ctx.filterable ? (openBlock(), createBlock(unref(ElInput), {
                key: 0,
                modelValue: unref(query),
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(query) ? query.value = $event : null),
                class: normalizeClass(unref(ns2).be("panel", "filter")),
                size: "default",
                placeholder: _ctx.placeholder,
                "prefix-icon": unref(search_default),
                clearable: "",
                "validate-event": false,
                onMouseenter: _cache[2] || (_cache[2] = ($event) => inputHover.value = true),
                onMouseleave: _cache[3] || (_cache[3] = ($event) => inputHover.value = false)
              }, null, 8, ["modelValue", "class", "placeholder", "prefix-icon"])) : createCommentVNode("v-if", true),
              withDirectives(createVNode(unref(ElCheckboxGroup$1), {
                modelValue: unref(checked),
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(checked) ? checked.value = $event : null),
                "validate-event": false,
                class: normalizeClass([unref(ns2).is("filterable", _ctx.filterable), unref(ns2).be("panel", "list")])
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(filteredData), (item) => {
                    return openBlock(), createBlock(unref(ElCheckbox), {
                      key: item[unref(propsAlias).key],
                      class: normalizeClass(unref(ns2).be("panel", "item")),
                      label: item[unref(propsAlias).key],
                      disabled: item[unref(propsAlias).disabled],
                      "validate-event": false
                    }, {
                      default: withCtx(() => {
                        var _a2;
                        return [
                          createVNode(OptionContent, {
                            option: (_a2 = _ctx.optionRender) == null ? void 0 : _a2.call(_ctx, item)
                          }, null, 8, ["option"])
                        ];
                      }),
                      _: 2
                    }, 1032, ["class", "label", "disabled"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "class"]), [
                [vShow, !unref(hasNoMatch) && !unref(isEmpty)(_ctx.data)]
              ]),
              withDirectives(createBaseVNode("p", {
                class: normalizeClass(unref(ns2).be("panel", "empty"))
              }, toDisplayString$1(unref(hasNoMatch) ? unref(t)("el.transfer.noMatch") : unref(t)("el.transfer.noData")), 3), [
                [vShow, unref(hasNoMatch) || unref(isEmpty)(_ctx.data)]
              ])
            ], 2),
            unref(hasFooter) ? (openBlock(), createElementBlock("p", {
              key: 0,
              class: normalizeClass(unref(ns2).be("panel", "footer"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    });
    var TransferPanel = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer-panel.vue"]]);
    const _hoisted_1$a = { key: 0 };
    const _hoisted_2$8 = { key: 0 };
    const __default__$6 = {
      name: "ElTransfer"
    };
    const _sfc_main$g = /* @__PURE__ */ defineComponent({
      ...__default__$6,
      props: transferProps,
      emits: transferEmits,
      setup(__props, { expose, emit }) {
        const props = __props;
        const slots = useSlots();
        const { t } = useLocale();
        const ns2 = useNamespace("transfer");
        const { formItem } = useFormItem();
        const checkedState = reactive({
          leftChecked: [],
          rightChecked: []
        });
        const propsAlias = usePropsAlias(props);
        const { sourceData, targetData } = useComputedData(props);
        const { onSourceCheckedChange, onTargetCheckedChange } = useCheckedChange(checkedState, emit);
        const { addToLeft, addToRight } = useMove(props, checkedState, emit);
        const leftPanel = ref();
        const rightPanel = ref();
        const clearQuery = (which) => {
          switch (which) {
            case "left":
              leftPanel.value.query = "";
              break;
            case "right":
              rightPanel.value.query = "";
              break;
          }
        };
        const hasButtonTexts = computed(() => props.buttonTexts.length === 2);
        const leftPanelTitle = computed(() => props.titles[0] || t("el.transfer.titles.0"));
        const rightPanelTitle = computed(() => props.titles[1] || t("el.transfer.titles.1"));
        const panelFilterPlaceholder = computed(() => props.filterPlaceholder || t("el.transfer.filterPlaceholder"));
        watch(() => props.modelValue, () => {
          var _a2;
          if (props.validateEvent) {
            (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
          }
        });
        const optionRender = computed(() => (option) => {
          if (props.renderContent)
            return props.renderContent(h$1, option);
          if (slots.default)
            return slots.default({ option });
          return h$1("span", option[propsAlias.value.label] || option[propsAlias.value.key]);
        });
        expose({
          clearQuery,
          leftPanel,
          rightPanel
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(ns2).b())
          }, [
            createVNode(TransferPanel, {
              ref_key: "leftPanel",
              ref: leftPanel,
              data: unref(sourceData),
              "option-render": unref(optionRender),
              placeholder: unref(panelFilterPlaceholder),
              title: unref(leftPanelTitle),
              filterable: _ctx.filterable,
              format: _ctx.format,
              "filter-method": _ctx.filterMethod,
              "default-checked": _ctx.leftDefaultChecked,
              props: props.props,
              onCheckedChange: unref(onSourceCheckedChange)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "left-footer")
              ]),
              _: 3
            }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]),
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).e("buttons"))
            }, [
              createVNode(unref(ElButton), {
                type: "primary",
                class: normalizeClass([unref(ns2).e("button"), unref(ns2).is("with-texts", unref(hasButtonTexts))]),
                disabled: unref(isEmpty)(checkedState.rightChecked),
                onClick: unref(addToLeft)
              }, {
                default: withCtx(() => [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_left_default))
                    ]),
                    _: 1
                  }),
                  !unref(isUndefined$1)(_ctx.buttonTexts[0]) ? (openBlock(), createElementBlock("span", _hoisted_1$a, toDisplayString$1(_ctx.buttonTexts[0]), 1)) : createCommentVNode("v-if", true)
                ]),
                _: 1
              }, 8, ["class", "disabled", "onClick"]),
              createVNode(unref(ElButton), {
                type: "primary",
                class: normalizeClass([unref(ns2).e("button"), unref(ns2).is("with-texts", unref(hasButtonTexts))]),
                disabled: unref(isEmpty)(checkedState.leftChecked),
                onClick: unref(addToRight)
              }, {
                default: withCtx(() => [
                  !unref(isUndefined$1)(_ctx.buttonTexts[1]) ? (openBlock(), createElementBlock("span", _hoisted_2$8, toDisplayString$1(_ctx.buttonTexts[1]), 1)) : createCommentVNode("v-if", true),
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_right_default))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["class", "disabled", "onClick"])
            ], 2),
            createVNode(TransferPanel, {
              ref_key: "rightPanel",
              ref: rightPanel,
              data: unref(targetData),
              "option-render": unref(optionRender),
              placeholder: unref(panelFilterPlaceholder),
              filterable: _ctx.filterable,
              format: _ctx.format,
              "filter-method": _ctx.filterMethod,
              title: unref(rightPanelTitle),
              "default-checked": _ctx.rightDefaultChecked,
              props: props.props,
              onCheckedChange: unref(onTargetCheckedChange)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "right-footer")
              ]),
              _: 3
            }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])
          ], 2);
        };
      }
    });
    var Transfer = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer.vue"]]);
    const ElTransfer = withInstall(Transfer);
    const NODE_KEY = "$treeNodeId";
    const markNodeData = function(node, data) {
      if (!data || data[NODE_KEY])
        return;
      Object.defineProperty(data, NODE_KEY, {
        value: node.id,
        enumerable: false,
        configurable: false,
        writable: false
      });
    };
    const getNodeKey = function(key, data) {
      if (!key)
        return data[NODE_KEY];
      return data[key];
    };
    const getChildState = (node) => {
      let all = true;
      let none = true;
      let allWithoutDisable = true;
      for (let i = 0, j = node.length; i < j; i++) {
        const n = node[i];
        if (n.checked !== true || n.indeterminate) {
          all = false;
          if (!n.disabled) {
            allWithoutDisable = false;
          }
        }
        if (n.checked !== false || n.indeterminate) {
          none = false;
        }
      }
      return { all, none, allWithoutDisable, half: !all && !none };
    };
    const reInitChecked = function(node) {
      if (node.childNodes.length === 0 || node.loading)
        return;
      const { all, none, half } = getChildState(node.childNodes);
      if (all) {
        node.checked = true;
        node.indeterminate = false;
      } else if (half) {
        node.checked = false;
        node.indeterminate = true;
      } else if (none) {
        node.checked = false;
        node.indeterminate = false;
      }
      const parent = node.parent;
      if (!parent || parent.level === 0)
        return;
      if (!node.store.checkStrictly) {
        reInitChecked(parent);
      }
    };
    const getPropertyFromData = function(node, prop) {
      const props = node.store.props;
      const data = node.data || {};
      const config = props[prop];
      if (typeof config === "function") {
        return config(data, node);
      } else if (typeof config === "string") {
        return data[config];
      } else if (typeof config === "undefined") {
        const dataProp = data[prop];
        return dataProp === void 0 ? "" : dataProp;
      }
    };
    let nodeIdSeed = 0;
    class Node {
      constructor(options) {
        this.id = nodeIdSeed++;
        this.text = null;
        this.checked = false;
        this.indeterminate = false;
        this.data = null;
        this.expanded = false;
        this.parent = null;
        this.visible = true;
        this.isCurrent = false;
        this.canFocus = false;
        for (const name in options) {
          if (hasOwn$1(options, name)) {
            this[name] = options[name];
          }
        }
        this.level = 0;
        this.loaded = false;
        this.childNodes = [];
        this.loading = false;
        if (this.parent) {
          this.level = this.parent.level + 1;
        }
      }
      initialize() {
        const store = this.store;
        if (!store) {
          throw new Error("[Node]store is required!");
        }
        store.registerNode(this);
        const props = store.props;
        if (props && typeof props.isLeaf !== "undefined") {
          const isLeaf2 = getPropertyFromData(this, "isLeaf");
          if (typeof isLeaf2 === "boolean") {
            this.isLeafByUser = isLeaf2;
          }
        }
        if (store.lazy !== true && this.data) {
          this.setData(this.data);
          if (store.defaultExpandAll) {
            this.expanded = true;
            this.canFocus = true;
          }
        } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {
          this.expand();
        }
        if (!Array.isArray(this.data)) {
          markNodeData(this, this.data);
        }
        if (!this.data)
          return;
        const defaultExpandedKeys = store.defaultExpandedKeys;
        const key = store.key;
        if (key && defaultExpandedKeys && defaultExpandedKeys.includes(this.key)) {
          this.expand(null, store.autoExpandParent);
        }
        if (key && store.currentNodeKey !== void 0 && this.key === store.currentNodeKey) {
          store.currentNode = this;
          store.currentNode.isCurrent = true;
        }
        if (store.lazy) {
          store._initDefaultCheckedNode(this);
        }
        this.updateLeafState();
        if (this.parent && (this.level === 1 || this.parent.expanded === true))
          this.canFocus = true;
      }
      setData(data) {
        if (!Array.isArray(data)) {
          markNodeData(this, data);
        }
        this.data = data;
        this.childNodes = [];
        let children;
        if (this.level === 0 && Array.isArray(this.data)) {
          children = this.data;
        } else {
          children = getPropertyFromData(this, "children") || [];
        }
        for (let i = 0, j = children.length; i < j; i++) {
          this.insertChild({ data: children[i] });
        }
      }
      get label() {
        return getPropertyFromData(this, "label");
      }
      get key() {
        const nodeKey = this.store.key;
        if (this.data)
          return this.data[nodeKey];
        return null;
      }
      get disabled() {
        return getPropertyFromData(this, "disabled");
      }
      get nextSibling() {
        const parent = this.parent;
        if (parent) {
          const index2 = parent.childNodes.indexOf(this);
          if (index2 > -1) {
            return parent.childNodes[index2 + 1];
          }
        }
        return null;
      }
      get previousSibling() {
        const parent = this.parent;
        if (parent) {
          const index2 = parent.childNodes.indexOf(this);
          if (index2 > -1) {
            return index2 > 0 ? parent.childNodes[index2 - 1] : null;
          }
        }
        return null;
      }
      contains(target, deep = true) {
        return (this.childNodes || []).some((child) => child === target || deep && child.contains(target));
      }
      remove() {
        const parent = this.parent;
        if (parent) {
          parent.removeChild(this);
        }
      }
      insertChild(child, index2, batch) {
        if (!child)
          throw new Error("InsertChild error: child is required.");
        if (!(child instanceof Node)) {
          if (!batch) {
            const children = this.getChildren(true);
            if (!children.includes(child.data)) {
              if (typeof index2 === "undefined" || index2 < 0) {
                children.push(child.data);
              } else {
                children.splice(index2, 0, child.data);
              }
            }
          }
          Object.assign(child, {
            parent: this,
            store: this.store
          });
          child = reactive(new Node(child));
          if (child instanceof Node) {
            child.initialize();
          }
        }
        child.level = this.level + 1;
        if (typeof index2 === "undefined" || index2 < 0) {
          this.childNodes.push(child);
        } else {
          this.childNodes.splice(index2, 0, child);
        }
        this.updateLeafState();
      }
      insertBefore(child, ref2) {
        let index2;
        if (ref2) {
          index2 = this.childNodes.indexOf(ref2);
        }
        this.insertChild(child, index2);
      }
      insertAfter(child, ref2) {
        let index2;
        if (ref2) {
          index2 = this.childNodes.indexOf(ref2);
          if (index2 !== -1)
            index2 += 1;
        }
        this.insertChild(child, index2);
      }
      removeChild(child) {
        const children = this.getChildren() || [];
        const dataIndex = children.indexOf(child.data);
        if (dataIndex > -1) {
          children.splice(dataIndex, 1);
        }
        const index2 = this.childNodes.indexOf(child);
        if (index2 > -1) {
          this.store && this.store.deregisterNode(child);
          child.parent = null;
          this.childNodes.splice(index2, 1);
        }
        this.updateLeafState();
      }
      removeChildByData(data) {
        let targetNode = null;
        for (let i = 0; i < this.childNodes.length; i++) {
          if (this.childNodes[i].data === data) {
            targetNode = this.childNodes[i];
            break;
          }
        }
        if (targetNode) {
          this.removeChild(targetNode);
        }
      }
      expand(callback, expandParent) {
        const done = () => {
          if (expandParent) {
            let parent = this.parent;
            while (parent.level > 0) {
              parent.expanded = true;
              parent = parent.parent;
            }
          }
          this.expanded = true;
          if (callback)
            callback();
          this.childNodes.forEach((item) => {
            item.canFocus = true;
          });
        };
        if (this.shouldLoadData()) {
          this.loadData((data) => {
            if (Array.isArray(data)) {
              if (this.checked) {
                this.setChecked(true, true);
              } else if (!this.store.checkStrictly) {
                reInitChecked(this);
              }
              done();
            }
          });
        } else {
          done();
        }
      }
      doCreateChildren(array2, defaultProps2 = {}) {
        array2.forEach((item) => {
          this.insertChild(Object.assign({ data: item }, defaultProps2), void 0, true);
        });
      }
      collapse() {
        this.expanded = false;
        this.childNodes.forEach((item) => {
          item.canFocus = false;
        });
      }
      shouldLoadData() {
        return this.store.lazy === true && this.store.load && !this.loaded;
      }
      updateLeafState() {
        if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== "undefined") {
          this.isLeaf = this.isLeafByUser;
          return;
        }
        const childNodes = this.childNodes;
        if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
          this.isLeaf = !childNodes || childNodes.length === 0;
          return;
        }
        this.isLeaf = false;
      }
      setChecked(value, deep, recursion, passValue) {
        this.indeterminate = value === "half";
        this.checked = value === true;
        if (this.store.checkStrictly)
          return;
        if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
          const { all, allWithoutDisable } = getChildState(this.childNodes);
          if (!this.isLeaf && !all && allWithoutDisable) {
            this.checked = false;
            value = false;
          }
          const handleDescendants = () => {
            if (deep) {
              const childNodes = this.childNodes;
              for (let i = 0, j = childNodes.length; i < j; i++) {
                const child = childNodes[i];
                passValue = passValue || value !== false;
                const isCheck = child.disabled ? child.checked : passValue;
                child.setChecked(isCheck, deep, true, passValue);
              }
              const { half, all: all2 } = getChildState(childNodes);
              if (!all2) {
                this.checked = all2;
                this.indeterminate = half;
              }
            }
          };
          if (this.shouldLoadData()) {
            this.loadData(() => {
              handleDescendants();
              reInitChecked(this);
            }, {
              checked: value !== false
            });
            return;
          } else {
            handleDescendants();
          }
        }
        const parent = this.parent;
        if (!parent || parent.level === 0)
          return;
        if (!recursion) {
          reInitChecked(parent);
        }
      }
      getChildren(forceInit = false) {
        if (this.level === 0)
          return this.data;
        const data = this.data;
        if (!data)
          return null;
        const props = this.store.props;
        let children = "children";
        if (props) {
          children = props.children || "children";
        }
        if (data[children] === void 0) {
          data[children] = null;
        }
        if (forceInit && !data[children]) {
          data[children] = [];
        }
        return data[children];
      }
      updateChildren() {
        const newData = this.getChildren() || [];
        const oldData = this.childNodes.map((node) => node.data);
        const newDataMap = {};
        const newNodes = [];
        newData.forEach((item, index2) => {
          const key = item[NODE_KEY];
          const isNodeExists = !!key && oldData.findIndex((data) => data[NODE_KEY] === key) >= 0;
          if (isNodeExists) {
            newDataMap[key] = { index: index2, data: item };
          } else {
            newNodes.push({ index: index2, data: item });
          }
        });
        if (!this.store.lazy) {
          oldData.forEach((item) => {
            if (!newDataMap[item[NODE_KEY]])
              this.removeChildByData(item);
          });
        }
        newNodes.forEach(({ index: index2, data }) => {
          this.insertChild({ data }, index2);
        });
        this.updateLeafState();
      }
      loadData(callback, defaultProps2 = {}) {
        if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps2).length)) {
          this.loading = true;
          const resolve2 = (children) => {
            this.childNodes = [];
            this.doCreateChildren(children, defaultProps2);
            this.loaded = true;
            this.loading = false;
            this.updateLeafState();
            if (callback) {
              callback.call(this, children);
            }
          };
          this.store.load(this, resolve2);
        } else {
          if (callback) {
            callback.call(this);
          }
        }
      }
    }
    class TreeStore {
      constructor(options) {
        this.currentNode = null;
        this.currentNodeKey = null;
        for (const option in options) {
          if (hasOwn$1(options, option)) {
            this[option] = options[option];
          }
        }
        this.nodesMap = {};
      }
      initialize() {
        this.root = new Node({
          data: this.data,
          store: this
        });
        this.root.initialize();
        if (this.lazy && this.load) {
          const loadFn = this.load;
          loadFn(this.root, (data) => {
            this.root.doCreateChildren(data);
            this._initDefaultCheckedNodes();
          });
        } else {
          this._initDefaultCheckedNodes();
        }
      }
      filter(value) {
        const filterNodeMethod = this.filterNodeMethod;
        const lazy = this.lazy;
        const traverse2 = function(node) {
          const childNodes = node.root ? node.root.childNodes : node.childNodes;
          childNodes.forEach((child) => {
            child.visible = filterNodeMethod.call(child, value, child.data, child);
            traverse2(child);
          });
          if (!node.visible && childNodes.length) {
            let allHidden = true;
            allHidden = !childNodes.some((child) => child.visible);
            if (node.root) {
              node.root.visible = allHidden === false;
            } else {
              node.visible = allHidden === false;
            }
          }
          if (!value)
            return;
          if (node.visible && !node.isLeaf && !lazy)
            node.expand();
        };
        traverse2(this);
      }
      setData(newVal) {
        const instanceChanged = newVal !== this.root.data;
        if (instanceChanged) {
          this.root.setData(newVal);
          this._initDefaultCheckedNodes();
        } else {
          this.root.updateChildren();
        }
      }
      getNode(data) {
        if (data instanceof Node)
          return data;
        const key = isObject$4(data) ? getNodeKey(this.key, data) : data;
        return this.nodesMap[key] || null;
      }
      insertBefore(data, refData) {
        const refNode = this.getNode(refData);
        refNode.parent.insertBefore({ data }, refNode);
      }
      insertAfter(data, refData) {
        const refNode = this.getNode(refData);
        refNode.parent.insertAfter({ data }, refNode);
      }
      remove(data) {
        const node = this.getNode(data);
        if (node && node.parent) {
          if (node === this.currentNode) {
            this.currentNode = null;
          }
          node.parent.removeChild(node);
        }
      }
      append(data, parentData) {
        const parentNode = parentData ? this.getNode(parentData) : this.root;
        if (parentNode) {
          parentNode.insertChild({ data });
        }
      }
      _initDefaultCheckedNodes() {
        const defaultCheckedKeys = this.defaultCheckedKeys || [];
        const nodesMap = this.nodesMap;
        defaultCheckedKeys.forEach((checkedKey) => {
          const node = nodesMap[checkedKey];
          if (node) {
            node.setChecked(true, !this.checkStrictly);
          }
        });
      }
      _initDefaultCheckedNode(node) {
        const defaultCheckedKeys = this.defaultCheckedKeys || [];
        if (defaultCheckedKeys.includes(node.key)) {
          node.setChecked(true, !this.checkStrictly);
        }
      }
      setDefaultCheckedKey(newVal) {
        if (newVal !== this.defaultCheckedKeys) {
          this.defaultCheckedKeys = newVal;
          this._initDefaultCheckedNodes();
        }
      }
      registerNode(node) {
        const key = this.key;
        if (!node || !node.data)
          return;
        if (!key) {
          this.nodesMap[node.id] = node;
        } else {
          const nodeKey = node.key;
          if (nodeKey !== void 0)
            this.nodesMap[node.key] = node;
        }
      }
      deregisterNode(node) {
        const key = this.key;
        if (!key || !node || !node.data)
          return;
        node.childNodes.forEach((child) => {
          this.deregisterNode(child);
        });
        delete this.nodesMap[node.key];
      }
      getCheckedNodes(leafOnly = false, includeHalfChecked = false) {
        const checkedNodes = [];
        const traverse2 = function(node) {
          const childNodes = node.root ? node.root.childNodes : node.childNodes;
          childNodes.forEach((child) => {
            if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
              checkedNodes.push(child.data);
            }
            traverse2(child);
          });
        };
        traverse2(this);
        return checkedNodes;
      }
      getCheckedKeys(leafOnly = false) {
        return this.getCheckedNodes(leafOnly).map((data) => (data || {})[this.key]);
      }
      getHalfCheckedNodes() {
        const nodes = [];
        const traverse2 = function(node) {
          const childNodes = node.root ? node.root.childNodes : node.childNodes;
          childNodes.forEach((child) => {
            if (child.indeterminate) {
              nodes.push(child.data);
            }
            traverse2(child);
          });
        };
        traverse2(this);
        return nodes;
      }
      getHalfCheckedKeys() {
        return this.getHalfCheckedNodes().map((data) => (data || {})[this.key]);
      }
      _getAllNodes() {
        const allNodes = [];
        const nodesMap = this.nodesMap;
        for (const nodeKey in nodesMap) {
          if (hasOwn$1(nodesMap, nodeKey)) {
            allNodes.push(nodesMap[nodeKey]);
          }
        }
        return allNodes;
      }
      updateChildren(key, data) {
        const node = this.nodesMap[key];
        if (!node)
          return;
        const childNodes = node.childNodes;
        for (let i = childNodes.length - 1; i >= 0; i--) {
          const child = childNodes[i];
          this.remove(child.data);
        }
        for (let i = 0, j = data.length; i < j; i++) {
          const child = data[i];
          this.append(child, node.data);
        }
      }
      _setCheckedKeys(key, leafOnly = false, checkedKeys) {
        const allNodes = this._getAllNodes().sort((a2, b2) => b2.level - a2.level);
        const cache2 = /* @__PURE__ */ Object.create(null);
        const keys2 = Object.keys(checkedKeys);
        allNodes.forEach((node) => node.setChecked(false, false));
        for (let i = 0, j = allNodes.length; i < j; i++) {
          const node = allNodes[i];
          const nodeKey = node.data[key].toString();
          const checked = keys2.includes(nodeKey);
          if (!checked) {
            if (node.checked && !cache2[nodeKey]) {
              node.setChecked(false, false);
            }
            continue;
          }
          let parent = node.parent;
          while (parent && parent.level > 0) {
            cache2[parent.data[key]] = true;
            parent = parent.parent;
          }
          if (node.isLeaf || this.checkStrictly) {
            node.setChecked(true, false);
            continue;
          }
          node.setChecked(true, true);
          if (leafOnly) {
            node.setChecked(false, false);
            const traverse2 = function(node2) {
              const childNodes = node2.childNodes;
              childNodes.forEach((child) => {
                if (!child.isLeaf) {
                  child.setChecked(false, false);
                }
                traverse2(child);
              });
            };
            traverse2(node);
          }
        }
      }
      setCheckedNodes(array2, leafOnly = false) {
        const key = this.key;
        const checkedKeys = {};
        array2.forEach((item) => {
          checkedKeys[(item || {})[key]] = true;
        });
        this._setCheckedKeys(key, leafOnly, checkedKeys);
      }
      setCheckedKeys(keys2, leafOnly = false) {
        this.defaultCheckedKeys = keys2;
        const key = this.key;
        const checkedKeys = {};
        keys2.forEach((key2) => {
          checkedKeys[key2] = true;
        });
        this._setCheckedKeys(key, leafOnly, checkedKeys);
      }
      setDefaultExpandedKeys(keys2) {
        keys2 = keys2 || [];
        this.defaultExpandedKeys = keys2;
        keys2.forEach((key) => {
          const node = this.getNode(key);
          if (node)
            node.expand(null, this.autoExpandParent);
        });
      }
      setChecked(data, checked, deep) {
        const node = this.getNode(data);
        if (node) {
          node.setChecked(!!checked, deep);
        }
      }
      getCurrentNode() {
        return this.currentNode;
      }
      setCurrentNode(currentNode) {
        const prevCurrentNode = this.currentNode;
        if (prevCurrentNode) {
          prevCurrentNode.isCurrent = false;
        }
        this.currentNode = currentNode;
        this.currentNode.isCurrent = true;
      }
      setUserCurrentNode(node, shouldAutoExpandParent = true) {
        const key = node[this.key];
        const currNode = this.nodesMap[key];
        this.setCurrentNode(currNode);
        if (shouldAutoExpandParent && this.currentNode.level > 1) {
          this.currentNode.parent.expand(null, true);
        }
      }
      setCurrentNodeKey(key, shouldAutoExpandParent = true) {
        if (key === null || key === void 0) {
          this.currentNode && (this.currentNode.isCurrent = false);
          this.currentNode = null;
          return;
        }
        const node = this.getNode(key);
        if (node) {
          this.setCurrentNode(node);
          if (shouldAutoExpandParent && this.currentNode.level > 1) {
            this.currentNode.parent.expand(null, true);
          }
        }
      }
    }
    const _sfc_main$f = defineComponent({
      name: "ElTreeNodeContent",
      props: {
        node: {
          type: Object,
          required: true
        },
        renderContent: Function
      },
      setup(props) {
        const ns2 = useNamespace("tree");
        const nodeInstance = inject("NodeInstance");
        const tree = inject("RootTree");
        return () => {
          const node = props.node;
          const { data, store } = node;
          return props.renderContent ? props.renderContent(h$1, { _self: nodeInstance, node, data, store }) : tree.ctx.slots.default ? tree.ctx.slots.default({ node, data }) : h$1("span", { class: ns2.be("node", "label") }, [node.label]);
        };
      }
    });
    var NodeContent = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node-content.vue"]]);
    function useNodeExpandEventBroadcast(props) {
      const parentNodeMap = inject("TreeNodeMap", null);
      const currentNodeMap = {
        treeNodeExpand: (node) => {
          if (props.node !== node) {
            props.node.collapse();
          }
        },
        children: []
      };
      if (parentNodeMap) {
        parentNodeMap.children.push(currentNodeMap);
      }
      provide("TreeNodeMap", currentNodeMap);
      return {
        broadcastExpanded: (node) => {
          if (!props.accordion)
            return;
          for (const childNode of currentNodeMap.children) {
            childNode.treeNodeExpand(node);
          }
        }
      };
    }
    const dragEventsKey = Symbol("dragEvents");
    function useDragNodeHandler({ props, ctx, el$, dropIndicator$, store }) {
      const ns2 = useNamespace("tree");
      const dragState = ref({
        showDropIndicator: false,
        draggingNode: null,
        dropNode: null,
        allowDrop: true,
        dropType: null
      });
      const treeNodeDragStart = ({ event, treeNode }) => {
        if (typeof props.allowDrag === "function" && !props.allowDrag(treeNode.node)) {
          event.preventDefault();
          return false;
        }
        event.dataTransfer.effectAllowed = "move";
        try {
          event.dataTransfer.setData("text/plain", "");
        } catch (e) {
        }
        dragState.value.draggingNode = treeNode;
        ctx.emit("node-drag-start", treeNode.node, event);
      };
      const treeNodeDragOver = ({ event, treeNode }) => {
        const dropNode = treeNode;
        const oldDropNode = dragState.value.dropNode;
        if (oldDropNode && oldDropNode !== dropNode) {
          removeClass(oldDropNode.$el, ns2.is("drop-inner"));
        }
        const draggingNode = dragState.value.draggingNode;
        if (!draggingNode || !dropNode)
          return;
        let dropPrev = true;
        let dropInner = true;
        let dropNext = true;
        let userAllowDropInner = true;
        if (typeof props.allowDrop === "function") {
          dropPrev = props.allowDrop(draggingNode.node, dropNode.node, "prev");
          userAllowDropInner = dropInner = props.allowDrop(draggingNode.node, dropNode.node, "inner");
          dropNext = props.allowDrop(draggingNode.node, dropNode.node, "next");
        }
        event.dataTransfer.dropEffect = dropInner || dropPrev || dropNext ? "move" : "none";
        if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {
          if (oldDropNode) {
            ctx.emit("node-drag-leave", draggingNode.node, oldDropNode.node, event);
          }
          ctx.emit("node-drag-enter", draggingNode.node, dropNode.node, event);
        }
        if (dropPrev || dropInner || dropNext) {
          dragState.value.dropNode = dropNode;
        }
        if (dropNode.node.nextSibling === draggingNode.node) {
          dropNext = false;
        }
        if (dropNode.node.previousSibling === draggingNode.node) {
          dropPrev = false;
        }
        if (dropNode.node.contains(draggingNode.node, false)) {
          dropInner = false;
        }
        if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {
          dropPrev = false;
          dropInner = false;
          dropNext = false;
        }
        const targetPosition = dropNode.$el.getBoundingClientRect();
        const treePosition = el$.value.getBoundingClientRect();
        let dropType;
        const prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : -1;
        const nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : 1;
        let indicatorTop = -9999;
        const distance = event.clientY - targetPosition.top;
        if (distance < targetPosition.height * prevPercent) {
          dropType = "before";
        } else if (distance > targetPosition.height * nextPercent) {
          dropType = "after";
        } else if (dropInner) {
          dropType = "inner";
        } else {
          dropType = "none";
        }
        const iconPosition = dropNode.$el.querySelector(`.${ns2.be("node", "expand-icon")}`).getBoundingClientRect();
        const dropIndicator = dropIndicator$.value;
        if (dropType === "before") {
          indicatorTop = iconPosition.top - treePosition.top;
        } else if (dropType === "after") {
          indicatorTop = iconPosition.bottom - treePosition.top;
        }
        dropIndicator.style.top = `${indicatorTop}px`;
        dropIndicator.style.left = `${iconPosition.right - treePosition.left}px`;
        if (dropType === "inner") {
          addClass(dropNode.$el, ns2.is("drop-inner"));
        } else {
          removeClass(dropNode.$el, ns2.is("drop-inner"));
        }
        dragState.value.showDropIndicator = dropType === "before" || dropType === "after";
        dragState.value.allowDrop = dragState.value.showDropIndicator || userAllowDropInner;
        dragState.value.dropType = dropType;
        ctx.emit("node-drag-over", draggingNode.node, dropNode.node, event);
      };
      const treeNodeDragEnd = (event) => {
        const { draggingNode, dropType, dropNode } = dragState.value;
        event.preventDefault();
        event.dataTransfer.dropEffect = "move";
        if (draggingNode && dropNode) {
          const draggingNodeCopy = { data: draggingNode.node.data };
          if (dropType !== "none") {
            draggingNode.node.remove();
          }
          if (dropType === "before") {
            dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);
          } else if (dropType === "after") {
            dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);
          } else if (dropType === "inner") {
            dropNode.node.insertChild(draggingNodeCopy);
          }
          if (dropType !== "none") {
            store.value.registerNode(draggingNodeCopy);
          }
          removeClass(dropNode.$el, ns2.is("drop-inner"));
          ctx.emit("node-drag-end", draggingNode.node, dropNode.node, dropType, event);
          if (dropType !== "none") {
            ctx.emit("node-drop", draggingNode.node, dropNode.node, dropType, event);
          }
        }
        if (draggingNode && !dropNode) {
          ctx.emit("node-drag-end", draggingNode.node, null, dropType, event);
        }
        dragState.value.showDropIndicator = false;
        dragState.value.draggingNode = null;
        dragState.value.dropNode = null;
        dragState.value.allowDrop = true;
      };
      provide(dragEventsKey, {
        treeNodeDragStart,
        treeNodeDragOver,
        treeNodeDragEnd
      });
      return {
        dragState
      };
    }
    const _sfc_main$e = defineComponent({
      name: "ElTreeNode",
      components: {
        ElCollapseTransition: _CollapseTransition,
        ElCheckbox,
        NodeContent,
        ElIcon,
        Loading: loading_default
      },
      props: {
        node: {
          type: Node,
          default: () => ({})
        },
        props: {
          type: Object,
          default: () => ({})
        },
        accordion: Boolean,
        renderContent: Function,
        renderAfterExpand: Boolean,
        showCheckbox: {
          type: Boolean,
          default: false
        }
      },
      emits: ["node-expand"],
      setup(props, ctx) {
        const ns2 = useNamespace("tree");
        const { broadcastExpanded } = useNodeExpandEventBroadcast(props);
        const tree = inject("RootTree");
        const expanded = ref(false);
        const childNodeRendered = ref(false);
        const oldChecked = ref(null);
        const oldIndeterminate = ref(null);
        const node$ = ref(null);
        const dragEvents = inject(dragEventsKey);
        const instance = getCurrentInstance();
        provide("NodeInstance", instance);
        if (props.node.expanded) {
          expanded.value = true;
          childNodeRendered.value = true;
        }
        const childrenKey = tree.props["children"] || "children";
        watch(() => {
          const children = props.node.data[childrenKey];
          return children && [...children];
        }, () => {
          props.node.updateChildren();
        });
        watch(() => props.node.indeterminate, (val) => {
          handleSelectChange(props.node.checked, val);
        });
        watch(() => props.node.checked, (val) => {
          handleSelectChange(val, props.node.indeterminate);
        });
        watch(() => props.node.expanded, (val) => {
          nextTick(() => expanded.value = val);
          if (val) {
            childNodeRendered.value = true;
          }
        });
        const getNodeKey$1 = (node) => {
          return getNodeKey(tree.props.nodeKey, node.data);
        };
        const getNodeClass = (node) => {
          const nodeClassFunc = props.props.class;
          if (!nodeClassFunc) {
            return {};
          }
          let className;
          if (isFunction$4(nodeClassFunc)) {
            const { data } = node;
            className = nodeClassFunc(data, node);
          } else {
            className = nodeClassFunc;
          }
          if (isString$3(className)) {
            return { [className]: true };
          } else {
            return className;
          }
        };
        const handleSelectChange = (checked, indeterminate) => {
          if (oldChecked.value !== checked || oldIndeterminate.value !== indeterminate) {
            tree.ctx.emit("check-change", props.node.data, checked, indeterminate);
          }
          oldChecked.value = checked;
          oldIndeterminate.value = indeterminate;
        };
        const handleClick = (e) => {
          const store = tree.store.value;
          store.setCurrentNode(props.node);
          tree.ctx.emit("current-change", store.currentNode ? store.currentNode.data : null, store.currentNode);
          tree.currentNode.value = props.node;
          if (tree.props.expandOnClickNode) {
            handleExpandIconClick();
          }
          if (tree.props.checkOnClickNode && !props.node.disabled) {
            handleCheckChange(null, {
              target: { checked: !props.node.checked }
            });
          }
          tree.ctx.emit("node-click", props.node.data, props.node, instance, e);
        };
        const handleContextMenu = (event) => {
          if (tree.instance.vnode.props["onNodeContextmenu"]) {
            event.stopPropagation();
            event.preventDefault();
          }
          tree.ctx.emit("node-contextmenu", event, props.node.data, props.node, instance);
        };
        const handleExpandIconClick = () => {
          if (props.node.isLeaf)
            return;
          if (expanded.value) {
            tree.ctx.emit("node-collapse", props.node.data, props.node, instance);
            props.node.collapse();
          } else {
            props.node.expand();
            ctx.emit("node-expand", props.node.data, props.node, instance);
          }
        };
        const handleCheckChange = (value, ev) => {
          props.node.setChecked(ev.target.checked, !tree.props.checkStrictly);
          nextTick(() => {
            const store = tree.store.value;
            tree.ctx.emit("check", props.node.data, {
              checkedNodes: store.getCheckedNodes(),
              checkedKeys: store.getCheckedKeys(),
              halfCheckedNodes: store.getHalfCheckedNodes(),
              halfCheckedKeys: store.getHalfCheckedKeys()
            });
          });
        };
        const handleChildNodeExpand = (nodeData, node, instance2) => {
          broadcastExpanded(node);
          tree.ctx.emit("node-expand", nodeData, node, instance2);
        };
        const handleDragStart = (event) => {
          if (!tree.props.draggable)
            return;
          dragEvents.treeNodeDragStart({ event, treeNode: props });
        };
        const handleDragOver = (event) => {
          event.preventDefault();
          if (!tree.props.draggable)
            return;
          dragEvents.treeNodeDragOver({
            event,
            treeNode: { $el: node$.value, node: props.node }
          });
        };
        const handleDrop = (event) => {
          event.preventDefault();
        };
        const handleDragEnd = (event) => {
          if (!tree.props.draggable)
            return;
          dragEvents.treeNodeDragEnd(event);
        };
        return {
          ns: ns2,
          node$,
          tree,
          expanded,
          childNodeRendered,
          oldChecked,
          oldIndeterminate,
          getNodeKey: getNodeKey$1,
          getNodeClass,
          handleSelectChange,
          handleClick,
          handleContextMenu,
          handleExpandIconClick,
          handleCheckChange,
          handleChildNodeExpand,
          handleDragStart,
          handleDragOver,
          handleDrop,
          handleDragEnd,
          CaretRight: caret_right_default
        };
      }
    });
    const _hoisted_1$9 = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"];
    const _hoisted_2$7 = ["aria-expanded"];
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_checkbox = resolveComponent("el-checkbox");
      const _component_loading = resolveComponent("loading");
      const _component_node_content = resolveComponent("node-content");
      const _component_el_tree_node = resolveComponent("el-tree-node");
      const _component_el_collapse_transition = resolveComponent("el-collapse-transition");
      return withDirectives((openBlock(), createElementBlock("div", {
        ref: "node$",
        class: normalizeClass([
          _ctx.ns.b("node"),
          _ctx.ns.is("expanded", _ctx.expanded),
          _ctx.ns.is("current", _ctx.node.isCurrent),
          _ctx.ns.is("hidden", !_ctx.node.visible),
          _ctx.ns.is("focusable", !_ctx.node.disabled),
          _ctx.ns.is("checked", !_ctx.node.disabled && _ctx.node.checked),
          _ctx.getNodeClass(_ctx.node)
        ]),
        role: "treeitem",
        tabindex: "-1",
        "aria-expanded": _ctx.expanded,
        "aria-disabled": _ctx.node.disabled,
        "aria-checked": _ctx.node.checked,
        draggable: _ctx.tree.props.draggable,
        "data-key": _ctx.getNodeKey(_ctx.node),
        onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"])),
        onContextmenu: _cache[2] || (_cache[2] = (...args) => _ctx.handleContextMenu && _ctx.handleContextMenu(...args)),
        onDragstart: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.handleDragStart && _ctx.handleDragStart(...args), ["stop"])),
        onDragover: _cache[4] || (_cache[4] = withModifiers((...args) => _ctx.handleDragOver && _ctx.handleDragOver(...args), ["stop"])),
        onDragend: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.handleDragEnd && _ctx.handleDragEnd(...args), ["stop"])),
        onDrop: _cache[6] || (_cache[6] = withModifiers((...args) => _ctx.handleDrop && _ctx.handleDrop(...args), ["stop"]))
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.ns.be("node", "content")),
          style: normalizeStyle({ paddingLeft: (_ctx.node.level - 1) * _ctx.tree.props.indent + "px" })
        }, [
          _ctx.tree.props.icon || _ctx.CaretRight ? (openBlock(), createBlock(_component_el_icon, {
            key: 0,
            class: normalizeClass([
              _ctx.ns.be("node", "expand-icon"),
              _ctx.ns.is("leaf", _ctx.node.isLeaf),
              {
                expanded: !_ctx.node.isLeaf && _ctx.expanded
              }
            ]),
            onClick: withModifiers(_ctx.handleExpandIconClick, ["stop"])
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.tree.props.icon || _ctx.CaretRight)))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
          _ctx.showCheckbox ? (openBlock(), createBlock(_component_el_checkbox, {
            key: 1,
            "model-value": _ctx.node.checked,
            indeterminate: _ctx.node.indeterminate,
            disabled: !!_ctx.node.disabled,
            onClick: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["stop"])),
            onChange: _ctx.handleCheckChange
          }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : createCommentVNode("v-if", true),
          _ctx.node.loading ? (openBlock(), createBlock(_component_el_icon, {
            key: 2,
            class: normalizeClass([_ctx.ns.be("node", "loading-icon"), _ctx.ns.is("loading")])
          }, {
            default: withCtx(() => [
              createVNode(_component_loading)
            ]),
            _: 1
          }, 8, ["class"])) : createCommentVNode("v-if", true),
          createVNode(_component_node_content, {
            node: _ctx.node,
            "render-content": _ctx.renderContent
          }, null, 8, ["node", "render-content"])
        ], 6),
        createVNode(_component_el_collapse_transition, null, {
          default: withCtx(() => [
            !_ctx.renderAfterExpand || _ctx.childNodeRendered ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.ns.be("node", "children")),
              role: "group",
              "aria-expanded": _ctx.expanded
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.node.childNodes, (child) => {
                return openBlock(), createBlock(_component_el_tree_node, {
                  key: _ctx.getNodeKey(child),
                  "render-content": _ctx.renderContent,
                  "render-after-expand": _ctx.renderAfterExpand,
                  "show-checkbox": _ctx.showCheckbox,
                  node: child,
                  accordion: _ctx.accordion,
                  props: _ctx.props,
                  onNodeExpand: _ctx.handleChildNodeExpand
                }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]);
              }), 128))
            ], 10, _hoisted_2$7)), [
              [vShow, _ctx.expanded]
            ]) : createCommentVNode("v-if", true)
          ]),
          _: 1
        })
      ], 42, _hoisted_1$9)), [
        [vShow, _ctx.node.visible]
      ]);
    }
    var ElTreeNode$1 = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]]);
    function useKeydown({ el$ }, store) {
      const ns2 = useNamespace("tree");
      const treeItems = shallowRef([]);
      const checkboxItems = shallowRef([]);
      onMounted(() => {
        initTabIndex();
      });
      onUpdated(() => {
        treeItems.value = Array.from(el$.value.querySelectorAll("[role=treeitem]"));
        checkboxItems.value = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
      });
      watch(checkboxItems, (val) => {
        val.forEach((checkbox) => {
          checkbox.setAttribute("tabindex", "-1");
        });
      });
      const handleKeydown = (ev) => {
        const currentItem = ev.target;
        if (!currentItem.className.includes(ns2.b("node")))
          return;
        const code2 = ev.code;
        treeItems.value = Array.from(el$.value.querySelectorAll(`.${ns2.is("focusable")}[role=treeitem]`));
        const currentIndex = treeItems.value.indexOf(currentItem);
        let nextIndex;
        if ([EVENT_CODE.up, EVENT_CODE.down].includes(code2)) {
          ev.preventDefault();
          if (code2 === EVENT_CODE.up) {
            nextIndex = currentIndex === -1 ? 0 : currentIndex !== 0 ? currentIndex - 1 : treeItems.value.length - 1;
            const startIndex = nextIndex;
            while (true) {
              if (store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus)
                break;
              nextIndex--;
              if (nextIndex === startIndex) {
                nextIndex = -1;
                break;
              }
              if (nextIndex < 0) {
                nextIndex = treeItems.value.length - 1;
              }
            }
          } else {
            nextIndex = currentIndex === -1 ? 0 : currentIndex < treeItems.value.length - 1 ? currentIndex + 1 : 0;
            const startIndex = nextIndex;
            while (true) {
              if (store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus)
                break;
              nextIndex++;
              if (nextIndex === startIndex) {
                nextIndex = -1;
                break;
              }
              if (nextIndex >= treeItems.value.length) {
                nextIndex = 0;
              }
            }
          }
          nextIndex !== -1 && treeItems.value[nextIndex].focus();
        }
        if ([EVENT_CODE.left, EVENT_CODE.right].includes(code2)) {
          ev.preventDefault();
          currentItem.click();
        }
        const hasInput = currentItem.querySelector('[type="checkbox"]');
        if ([EVENT_CODE.enter, EVENT_CODE.space].includes(code2) && hasInput) {
          ev.preventDefault();
          hasInput.click();
        }
      };
      useEventListener(el$, "keydown", handleKeydown);
      const initTabIndex = () => {
        var _a2;
        treeItems.value = Array.from(el$.value.querySelectorAll(`.${ns2.is("focusable")}[role=treeitem]`));
        checkboxItems.value = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
        const checkedItem = el$.value.querySelectorAll(`.${ns2.is("checked")}[role=treeitem]`);
        if (checkedItem.length) {
          checkedItem[0].setAttribute("tabindex", "0");
          return;
        }
        (_a2 = treeItems.value[0]) == null ? void 0 : _a2.setAttribute("tabindex", "0");
      };
    }
    const _sfc_main$d = defineComponent({
      name: "ElTree",
      components: { ElTreeNode: ElTreeNode$1 },
      props: {
        data: {
          type: Array,
          default: () => []
        },
        emptyText: {
          type: String
        },
        renderAfterExpand: {
          type: Boolean,
          default: true
        },
        nodeKey: String,
        checkStrictly: Boolean,
        defaultExpandAll: Boolean,
        expandOnClickNode: {
          type: Boolean,
          default: true
        },
        checkOnClickNode: Boolean,
        checkDescendants: {
          type: Boolean,
          default: false
        },
        autoExpandParent: {
          type: Boolean,
          default: true
        },
        defaultCheckedKeys: Array,
        defaultExpandedKeys: Array,
        currentNodeKey: [String, Number],
        renderContent: Function,
        showCheckbox: {
          type: Boolean,
          default: false
        },
        draggable: {
          type: Boolean,
          default: false
        },
        allowDrag: Function,
        allowDrop: Function,
        props: {
          type: Object,
          default: () => ({
            children: "children",
            label: "label",
            disabled: "disabled"
          })
        },
        lazy: {
          type: Boolean,
          default: false
        },
        highlightCurrent: Boolean,
        load: Function,
        filterNodeMethod: Function,
        accordion: Boolean,
        indent: {
          type: Number,
          default: 18
        },
        icon: {
          type: iconPropType
        }
      },
      emits: [
        "check-change",
        "current-change",
        "node-click",
        "node-contextmenu",
        "node-collapse",
        "node-expand",
        "check",
        "node-drag-start",
        "node-drag-end",
        "node-drop",
        "node-drag-leave",
        "node-drag-enter",
        "node-drag-over"
      ],
      setup(props, ctx) {
        const { t } = useLocale();
        const ns2 = useNamespace("tree");
        const store = ref(new TreeStore({
          key: props.nodeKey,
          data: props.data,
          lazy: props.lazy,
          props: props.props,
          load: props.load,
          currentNodeKey: props.currentNodeKey,
          checkStrictly: props.checkStrictly,
          checkDescendants: props.checkDescendants,
          defaultCheckedKeys: props.defaultCheckedKeys,
          defaultExpandedKeys: props.defaultExpandedKeys,
          autoExpandParent: props.autoExpandParent,
          defaultExpandAll: props.defaultExpandAll,
          filterNodeMethod: props.filterNodeMethod
        }));
        store.value.initialize();
        const root2 = ref(store.value.root);
        const currentNode = ref(null);
        const el$ = ref(null);
        const dropIndicator$ = ref(null);
        const { broadcastExpanded } = useNodeExpandEventBroadcast(props);
        const { dragState } = useDragNodeHandler({
          props,
          ctx,
          el$,
          dropIndicator$,
          store
        });
        useKeydown({ el$ }, store);
        const isEmpty2 = computed(() => {
          const { childNodes } = root2.value;
          return !childNodes || childNodes.length === 0 || childNodes.every(({ visible }) => !visible);
        });
        watch(() => props.currentNodeKey, (newVal) => {
          store.value.setCurrentNodeKey(newVal);
        });
        watch(() => props.defaultCheckedKeys, (newVal) => {
          store.value.setDefaultCheckedKey(newVal);
        });
        watch(() => props.defaultExpandedKeys, (newVal) => {
          store.value.setDefaultExpandedKeys(newVal);
        });
        watch(() => props.data, (newVal) => {
          store.value.setData(newVal);
        }, { deep: true });
        watch(() => props.checkStrictly, (newVal) => {
          store.value.checkStrictly = newVal;
        });
        const filter = (value) => {
          if (!props.filterNodeMethod)
            throw new Error("[Tree] filterNodeMethod is required when filter");
          store.value.filter(value);
        };
        const getNodeKey$1 = (node) => {
          return getNodeKey(props.nodeKey, node.data);
        };
        const getNodePath = (data) => {
          if (!props.nodeKey)
            throw new Error("[Tree] nodeKey is required in getNodePath");
          const node = store.value.getNode(data);
          if (!node)
            return [];
          const path = [node.data];
          let parent = node.parent;
          while (parent && parent !== root2.value) {
            path.push(parent.data);
            parent = parent.parent;
          }
          return path.reverse();
        };
        const getCheckedNodes = (leafOnly, includeHalfChecked) => {
          return store.value.getCheckedNodes(leafOnly, includeHalfChecked);
        };
        const getCheckedKeys = (leafOnly) => {
          return store.value.getCheckedKeys(leafOnly);
        };
        const getCurrentNode = () => {
          const currentNode2 = store.value.getCurrentNode();
          return currentNode2 ? currentNode2.data : null;
        };
        const getCurrentKey = () => {
          if (!props.nodeKey)
            throw new Error("[Tree] nodeKey is required in getCurrentKey");
          const currentNode2 = getCurrentNode();
          return currentNode2 ? currentNode2[props.nodeKey] : null;
        };
        const setCheckedNodes = (nodes, leafOnly) => {
          if (!props.nodeKey)
            throw new Error("[Tree] nodeKey is required in setCheckedNodes");
          store.value.setCheckedNodes(nodes, leafOnly);
        };
        const setCheckedKeys = (keys2, leafOnly) => {
          if (!props.nodeKey)
            throw new Error("[Tree] nodeKey is required in setCheckedKeys");
          store.value.setCheckedKeys(keys2, leafOnly);
        };
        const setChecked2 = (data, checked, deep) => {
          store.value.setChecked(data, checked, deep);
        };
        const getHalfCheckedNodes = () => {
          return store.value.getHalfCheckedNodes();
        };
        const getHalfCheckedKeys = () => {
          return store.value.getHalfCheckedKeys();
        };
        const setCurrentNode = (node, shouldAutoExpandParent = true) => {
          if (!props.nodeKey)
            throw new Error("[Tree] nodeKey is required in setCurrentNode");
          const preNode = store.value.currentNode;
          store.value.setUserCurrentNode(node, shouldAutoExpandParent);
          const currNode = store.value.currentNode;
          if (preNode !== currNode) {
            ctx.emit("current-change", currNode ? currNode.data : null, currNode);
          }
        };
        const setCurrentKey = (key, shouldAutoExpandParent = true) => {
          if (!props.nodeKey)
            throw new Error("[Tree] nodeKey is required in setCurrentKey");
          const preNode = store.value.currentNode;
          store.value.setCurrentNodeKey(key, shouldAutoExpandParent);
          const currNode = store.value.currentNode;
          if (preNode !== currNode) {
            ctx.emit("current-change", currNode ? currNode.data : null, currNode);
          }
        };
        const getNode = (data) => {
          return store.value.getNode(data);
        };
        const remove2 = (data) => {
          store.value.remove(data);
        };
        const append = (data, parentNode) => {
          store.value.append(data, parentNode);
        };
        const insertBefore = (data, refNode) => {
          store.value.insertBefore(data, refNode);
        };
        const insertAfter = (data, refNode) => {
          store.value.insertAfter(data, refNode);
        };
        const handleNodeExpand = (nodeData, node, instance) => {
          broadcastExpanded(node);
          ctx.emit("node-expand", nodeData, node, instance);
        };
        const updateKeyChildren = (key, data) => {
          if (!props.nodeKey)
            throw new Error("[Tree] nodeKey is required in updateKeyChild");
          store.value.updateChildren(key, data);
        };
        provide("RootTree", {
          ctx,
          props,
          store,
          root: root2,
          currentNode,
          instance: getCurrentInstance()
        });
        provide(formItemContextKey, void 0);
        return {
          ns: ns2,
          store,
          root: root2,
          currentNode,
          dragState,
          el$,
          dropIndicator$,
          isEmpty: isEmpty2,
          filter,
          getNodeKey: getNodeKey$1,
          getNodePath,
          getCheckedNodes,
          getCheckedKeys,
          getCurrentNode,
          getCurrentKey,
          setCheckedNodes,
          setCheckedKeys,
          setChecked: setChecked2,
          getHalfCheckedNodes,
          getHalfCheckedKeys,
          setCurrentNode,
          setCurrentKey,
          t,
          getNode,
          remove: remove2,
          append,
          insertBefore,
          insertAfter,
          handleNodeExpand,
          updateKeyChildren
        };
      }
    });
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      var _a2;
      const _component_el_tree_node = resolveComponent("el-tree-node");
      return openBlock(), createElementBlock("div", {
        ref: "el$",
        class: normalizeClass([
          _ctx.ns.b(),
          _ctx.ns.is("dragging", !!_ctx.dragState.draggingNode),
          _ctx.ns.is("drop-not-allow", !_ctx.dragState.allowDrop),
          _ctx.ns.is("drop-inner", _ctx.dragState.dropType === "inner"),
          { [_ctx.ns.m("highlight-current")]: _ctx.highlightCurrent }
        ]),
        role: "tree"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.root.childNodes, (child) => {
          return openBlock(), createBlock(_component_el_tree_node, {
            key: _ctx.getNodeKey(child),
            node: child,
            props: _ctx.props,
            accordion: _ctx.accordion,
            "render-after-expand": _ctx.renderAfterExpand,
            "show-checkbox": _ctx.showCheckbox,
            "render-content": _ctx.renderContent,
            onNodeExpand: _ctx.handleNodeExpand
          }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]);
        }), 128)),
        _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.ns.e("empty-block"))
        }, [
          createBaseVNode("span", {
            class: normalizeClass(_ctx.ns.e("empty-text"))
          }, toDisplayString$1((_a2 = _ctx.emptyText) != null ? _a2 : _ctx.t("el.tree.emptyText")), 3)
        ], 2)) : createCommentVNode("v-if", true),
        withDirectives(createBaseVNode("div", {
          ref: "dropIndicator$",
          class: normalizeClass(_ctx.ns.e("drop-indicator"))
        }, null, 2), [
          [vShow, _ctx.dragState.showDropIndicator]
        ])
      ], 2);
    }
    var Tree = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]]);
    Tree.install = (app2) => {
      app2.component(Tree.name, Tree);
    };
    const _Tree = Tree;
    const ElTree = _Tree;
    const useSelect = (props, { attrs }, {
      tree,
      key
    }) => {
      const ns2 = useNamespace("tree-select");
      const result = {
        ...pick$1(toRefs(props), Object.keys(ElSelect.props)),
        ...attrs,
        valueKey: key,
        popperClass: computed(() => {
          const classes = [ns2.e("popper")];
          if (props.popperClass)
            classes.push(props.popperClass);
          return classes.join(" ");
        }),
        filterMethod: (keyword = "") => {
          if (props.filterMethod)
            props.filterMethod(keyword);
          nextTick(() => {
            var _a2;
            (_a2 = tree.value) == null ? void 0 : _a2.filter(keyword);
          });
        },
        onVisibleChange: (visible) => {
          var _a2;
          (_a2 = attrs.onVisibleChange) == null ? void 0 : _a2.call(attrs, visible);
          if (props.filterable && visible) {
            result.filterMethod();
          }
        }
      };
      return result;
    };
    const component = defineComponent({
      extends: ElOption,
      setup(props, ctx) {
        const result = ElOption.setup(props, ctx);
        delete result.selectOptionClick;
        const vm = getCurrentInstance().proxy;
        nextTick(() => {
          if (!result.select.cachedOptions.get(vm.value)) {
            result.select.onOptionCreate(vm);
          }
        });
        return result;
      },
      methods: {
        selectOptionClick() {
          this.$el.parentElement.click();
        }
      }
    });
    function isValidValue(val) {
      return val || val === 0;
    }
    function isValidArray(val) {
      return Array.isArray(val) && val.length;
    }
    function toValidArray(val) {
      return Array.isArray(val) ? val : isValidValue(val) ? [val] : [];
    }
    function treeFind(treeData, findCallback, getChildren, resultCallback, parent) {
      for (let i = 0; i < treeData.length; i++) {
        const data = treeData[i];
        if (findCallback(data, i, treeData, parent)) {
          return resultCallback ? resultCallback(data, i, treeData, parent) : data;
        } else {
          const children = getChildren(data);
          if (isValidArray(children)) {
            const find = treeFind(children, findCallback, getChildren, resultCallback, data);
            if (find)
              return find;
          }
        }
      }
    }
    const useTree$1 = (props, { attrs, slots, emit }, {
      select,
      tree,
      key
    }) => {
      watch(() => props.modelValue, () => {
        if (props.showCheckbox) {
          nextTick(() => {
            const treeInstance = tree.value;
            if (treeInstance && !isEqual$1(treeInstance.getCheckedKeys(), toValidArray(props.modelValue))) {
              treeInstance.setCheckedKeys(toValidArray(props.modelValue));
            }
          });
        }
      }, {
        immediate: true,
        deep: true
      });
      const propsMap = computed(() => ({
        value: key.value,
        ...props.props
      }));
      const getNodeValByProp = (prop, data) => {
        var _a2;
        const propVal = propsMap.value[prop];
        if (isFunction$4(propVal)) {
          return propVal(data, (_a2 = tree.value) == null ? void 0 : _a2.getNode(getNodeValByProp("value", data)));
        } else {
          return data[propVal];
        }
      };
      const defaultExpandedParentKeys = toValidArray(props.modelValue).map((value) => {
        return treeFind(props.data || [], (data) => getNodeValByProp("value", data) === value, (data) => getNodeValByProp("children", data), (data, index2, array2, parent) => parent && getNodeValByProp("value", parent));
      }).filter((item) => isValidValue(item));
      return {
        ...pick$1(toRefs(props), Object.keys(_Tree.props)),
        ...attrs,
        nodeKey: key,
        expandOnClickNode: computed(() => {
          return !props.checkStrictly && props.expandOnClickNode;
        }),
        defaultExpandedKeys: computed(() => {
          return props.defaultExpandedKeys ? props.defaultExpandedKeys.concat(defaultExpandedParentKeys) : defaultExpandedParentKeys;
        }),
        renderContent: (h2, { node, data, store }) => {
          return h2(component, {
            value: getNodeValByProp("value", data),
            label: getNodeValByProp("label", data),
            disabled: getNodeValByProp("disabled", data)
          }, props.renderContent ? () => props.renderContent(h2, { node, data, store }) : slots.default ? () => slots.default({ node, data, store }) : void 0);
        },
        filterNodeMethod: (value, data, node) => {
          var _a2;
          if (props.filterNodeMethod)
            return props.filterNodeMethod(value, data, node);
          if (!value)
            return true;
          return (_a2 = getNodeValByProp("label", data)) == null ? void 0 : _a2.includes(value);
        },
        onNodeClick: (data, node, e) => {
          var _a2, _b, _c;
          (_a2 = attrs.onNodeClick) == null ? void 0 : _a2.call(attrs, data, node, e);
          if (props.showCheckbox && props.checkOnClickNode)
            return;
          if (!props.showCheckbox && (props.checkStrictly || node.isLeaf)) {
            if (!getNodeValByProp("disabled", data)) {
              const option = (_b = select.value) == null ? void 0 : _b.options.get(getNodeValByProp("value", data));
              (_c = select.value) == null ? void 0 : _c.handleOptionSelect(option, true);
            }
          } else if (props.expandOnClickNode) {
            e.proxy.handleExpandIconClick();
          }
        },
        onCheck: (data, params) => {
          var _a2;
          (_a2 = attrs.onCheck) == null ? void 0 : _a2.call(attrs, data, params);
          const dataValue = getNodeValByProp("value", data);
          if (props.checkStrictly) {
            emit(UPDATE_MODEL_EVENT, props.multiple ? params.checkedKeys : params.checkedKeys.includes(dataValue) ? dataValue : void 0);
          } else {
            if (props.multiple) {
              emit(UPDATE_MODEL_EVENT, tree.value.getCheckedKeys(true));
            } else {
              const firstLeaf = treeFind([data], (data2) => !isValidArray(getNodeValByProp("children", data2)) && !getNodeValByProp("disabled", data2), (data2) => getNodeValByProp("children", data2));
              const firstLeafKey = firstLeaf ? getNodeValByProp("value", firstLeaf) : void 0;
              const hasCheckedChild = isValidValue(props.modelValue) && !!treeFind([data], (data2) => getNodeValByProp("value", data2) === props.modelValue, (data2) => getNodeValByProp("children", data2));
              emit(UPDATE_MODEL_EVENT, firstLeafKey === props.modelValue || hasCheckedChild ? void 0 : firstLeafKey);
            }
          }
        }
      };
    };
    const _sfc_main$c = defineComponent({
      name: "ElTreeSelect",
      inheritAttrs: false,
      props: {
        ...ElSelect.props,
        ..._Tree.props
      },
      setup(props, context) {
        const { slots, expose } = context;
        const select = ref();
        const tree = ref();
        const key = computed(() => props.nodeKey || props.valueKey || "value");
        const selectProps = useSelect(props, context, { select, tree, key });
        const treeProps2 = useTree$1(props, context, { select, tree, key });
        const methods = reactive({});
        expose(methods);
        onMounted(() => {
          Object.assign(methods, {
            ...pick$1(tree.value, [
              "filter",
              "updateKeyChildren",
              "getCheckedNodes",
              "setCheckedNodes",
              "getCheckedKeys",
              "setCheckedKeys",
              "setChecked",
              "getHalfCheckedNodes",
              "getHalfCheckedKeys",
              "getCurrentKey",
              "getCurrentNode",
              "setCurrentKey",
              "setCurrentNode",
              "getNode",
              "remove",
              "append",
              "insertBefore",
              "insertAfter"
            ]),
            ...pick$1(select.value, ["focus", "blur"])
          });
        });
        return () => h$1(ElSelect, reactive({
          ...selectProps,
          ref: (ref2) => select.value = ref2
        }), {
          ...slots,
          default: () => h$1(_Tree, reactive({
            ...treeProps2,
            ref: (ref2) => tree.value = ref2
          }))
        });
      }
    });
    var TreeSelect = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-select/src/tree-select.vue"]]);
    TreeSelect.install = (app2) => {
      app2.component(TreeSelect.name, TreeSelect);
    };
    const _TreeSelect = TreeSelect;
    const ElTreeSelect = _TreeSelect;
    const ROOT_TREE_INJECTION_KEY = Symbol();
    const EMPTY_NODE = {
      key: -1,
      level: -1,
      data: {}
    };
    var TreeOptionsEnum = /* @__PURE__ */ ((TreeOptionsEnum2) => {
      TreeOptionsEnum2["KEY"] = "id";
      TreeOptionsEnum2["LABEL"] = "label";
      TreeOptionsEnum2["CHILDREN"] = "children";
      TreeOptionsEnum2["DISABLED"] = "disabled";
      return TreeOptionsEnum2;
    })(TreeOptionsEnum || {});
    var SetOperationEnum = /* @__PURE__ */ ((SetOperationEnum2) => {
      SetOperationEnum2["ADD"] = "add";
      SetOperationEnum2["DELETE"] = "delete";
      return SetOperationEnum2;
    })(SetOperationEnum || {});
    const treeProps = buildProps({
      data: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      emptyText: {
        type: String
      },
      height: {
        type: Number,
        default: 200
      },
      props: {
        type: definePropType(Object),
        default: () => mutable({
          children: "children",
          label: "label",
          disabled: "disabled",
          value: "id"
        })
      },
      highlightCurrent: {
        type: Boolean,
        default: false
      },
      showCheckbox: {
        type: Boolean,
        default: false
      },
      defaultCheckedKeys: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      checkStrictly: {
        type: Boolean,
        default: false
      },
      defaultExpandedKeys: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      indent: {
        type: Number,
        default: 16
      },
      icon: {
        type: iconPropType
      },
      expandOnClickNode: {
        type: Boolean,
        default: true
      },
      checkOnClickNode: {
        type: Boolean,
        default: false
      },
      currentNodeKey: {
        type: definePropType([String, Number])
      },
      accordion: {
        type: Boolean,
        default: false
      },
      filterMethod: {
        type: definePropType(Function)
      },
      perfMode: {
        type: Boolean,
        default: true
      }
    });
    const treeNodeProps = buildProps({
      node: {
        type: definePropType(Object),
        default: () => mutable(EMPTY_NODE)
      },
      expanded: {
        type: Boolean,
        default: false
      },
      checked: {
        type: Boolean,
        default: false
      },
      indeterminate: {
        type: Boolean,
        default: false
      },
      showCheckbox: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      current: {
        type: Boolean,
        default: false
      },
      hiddenExpandIcon: {
        type: Boolean,
        default: false
      }
    });
    const treeNodeContentProps = buildProps({
      node: {
        type: definePropType(Object),
        required: true
      }
    });
    const NODE_CLICK = "node-click";
    const NODE_EXPAND = "node-expand";
    const NODE_COLLAPSE = "node-collapse";
    const CURRENT_CHANGE = "current-change";
    const NODE_CHECK = "check";
    const NODE_CHECK_CHANGE = "check-change";
    const NODE_CONTEXTMENU = "node-contextmenu";
    const treeEmits = {
      [NODE_CLICK]: (data, node, e) => data && node && e,
      [NODE_EXPAND]: (data, node) => data && node,
      [NODE_COLLAPSE]: (data, node) => data && node,
      [CURRENT_CHANGE]: (data, node) => data && node,
      [NODE_CHECK]: (data, checkedInfo) => data && checkedInfo,
      [NODE_CHECK_CHANGE]: (data, checked) => data && typeof checked === "boolean",
      [NODE_CONTEXTMENU]: (event, data, node) => event && data && node
    };
    const treeNodeEmits = {
      click: (node, e) => !!(node && e),
      toggle: (node) => !!node,
      check: (node, checked) => node && typeof checked === "boolean"
    };
    function useCheck(props, tree) {
      const checkedKeys = ref(/* @__PURE__ */ new Set());
      const indeterminateKeys = ref(/* @__PURE__ */ new Set());
      const { emit } = getCurrentInstance();
      watch([() => tree.value, () => props.defaultCheckedKeys], () => {
        return nextTick(() => {
          _setCheckedKeys(props.defaultCheckedKeys);
        });
      }, {
        immediate: true
      });
      const updateCheckedKeys = () => {
        if (!tree.value || !props.showCheckbox || props.checkStrictly) {
          return;
        }
        const { levelTreeNodeMap, maxLevel } = tree.value;
        const checkedKeySet = checkedKeys.value;
        const indeterminateKeySet = /* @__PURE__ */ new Set();
        for (let level = maxLevel - 1; level >= 1; --level) {
          const nodes = levelTreeNodeMap.get(level);
          if (!nodes)
            continue;
          nodes.forEach((node) => {
            const children = node.children;
            if (children) {
              let allChecked = true;
              let hasChecked = false;
              for (const childNode of children) {
                const key = childNode.key;
                if (checkedKeySet.has(key)) {
                  hasChecked = true;
                } else if (indeterminateKeySet.has(key)) {
                  allChecked = false;
                  hasChecked = true;
                  break;
                } else {
                  allChecked = false;
                }
              }
              if (allChecked) {
                checkedKeySet.add(node.key);
              } else if (hasChecked) {
                indeterminateKeySet.add(node.key);
                checkedKeySet.delete(node.key);
              } else {
                checkedKeySet.delete(node.key);
                indeterminateKeySet.delete(node.key);
              }
            }
          });
        }
        indeterminateKeys.value = indeterminateKeySet;
      };
      const isChecked = (node) => checkedKeys.value.has(node.key);
      const isIndeterminate = (node) => indeterminateKeys.value.has(node.key);
      const toggleCheckbox = (node, isChecked2, nodeClick = true) => {
        const checkedKeySet = checkedKeys.value;
        const toggle = (node2, checked) => {
          checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](node2.key);
          const children = node2.children;
          if (!props.checkStrictly && children) {
            children.forEach((childNode) => {
              if (!childNode.disabled) {
                toggle(childNode, checked);
              }
            });
          }
        };
        toggle(node, isChecked2);
        updateCheckedKeys();
        if (nodeClick) {
          afterNodeCheck(node, isChecked2);
        }
      };
      const afterNodeCheck = (node, checked) => {
        const { checkedNodes, checkedKeys: checkedKeys2 } = getChecked();
        const { halfCheckedNodes, halfCheckedKeys } = getHalfChecked();
        emit(NODE_CHECK, node.data, {
          checkedKeys: checkedKeys2,
          checkedNodes,
          halfCheckedKeys,
          halfCheckedNodes
        });
        emit(NODE_CHECK_CHANGE, node.data, checked);
      };
      function getCheckedKeys(leafOnly = false) {
        return getChecked(leafOnly).checkedKeys;
      }
      function getCheckedNodes(leafOnly = false) {
        return getChecked(leafOnly).checkedNodes;
      }
      function getHalfCheckedKeys() {
        return getHalfChecked().halfCheckedKeys;
      }
      function getHalfCheckedNodes() {
        return getHalfChecked().halfCheckedNodes;
      }
      function getChecked(leafOnly = false) {
        const checkedNodes = [];
        const keys2 = [];
        if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
          const { treeNodeMap } = tree.value;
          checkedKeys.value.forEach((key) => {
            const node = treeNodeMap.get(key);
            if (node && (!leafOnly || leafOnly && node.isLeaf)) {
              keys2.push(key);
              checkedNodes.push(node.data);
            }
          });
        }
        return {
          checkedKeys: keys2,
          checkedNodes
        };
      }
      function getHalfChecked() {
        const halfCheckedNodes = [];
        const halfCheckedKeys = [];
        if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
          const { treeNodeMap } = tree.value;
          indeterminateKeys.value.forEach((key) => {
            const node = treeNodeMap.get(key);
            if (node) {
              halfCheckedKeys.push(key);
              halfCheckedNodes.push(node.data);
            }
          });
        }
        return {
          halfCheckedNodes,
          halfCheckedKeys
        };
      }
      function setCheckedKeys(keys2) {
        checkedKeys.value.clear();
        indeterminateKeys.value.clear();
        _setCheckedKeys(keys2);
      }
      function setChecked2(key, isChecked2) {
        if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {
          const node = tree.value.treeNodeMap.get(key);
          if (node) {
            toggleCheckbox(node, isChecked2, false);
          }
        }
      }
      function _setCheckedKeys(keys2) {
        if (tree == null ? void 0 : tree.value) {
          const { treeNodeMap } = tree.value;
          if (props.showCheckbox && treeNodeMap && keys2) {
            for (const key of keys2) {
              const node = treeNodeMap.get(key);
              if (node && !isChecked(node)) {
                toggleCheckbox(node, true, false);
              }
            }
          }
        }
      }
      return {
        updateCheckedKeys,
        toggleCheckbox,
        isChecked,
        isIndeterminate,
        getCheckedKeys,
        getCheckedNodes,
        getHalfCheckedKeys,
        getHalfCheckedNodes,
        setChecked: setChecked2,
        setCheckedKeys
      };
    }
    function useFilter(props, tree) {
      const hiddenNodeKeySet = ref(/* @__PURE__ */ new Set([]));
      const hiddenExpandIconKeySet = ref(/* @__PURE__ */ new Set([]));
      const filterable = computed(() => {
        return isFunction$4(props.filterMethod);
      });
      function doFilter(query) {
        var _a2;
        if (!filterable.value) {
          return;
        }
        const expandKeySet = /* @__PURE__ */ new Set();
        const hiddenExpandIconKeys = hiddenExpandIconKeySet.value;
        const hiddenKeys = hiddenNodeKeySet.value;
        const family = [];
        const nodes = ((_a2 = tree.value) == null ? void 0 : _a2.treeNodes) || [];
        const filter = props.filterMethod;
        hiddenKeys.clear();
        function traverse2(nodes2) {
          nodes2.forEach((node) => {
            family.push(node);
            if (filter == null ? void 0 : filter(query, node.data)) {
              family.forEach((member) => {
                expandKeySet.add(member.key);
              });
            } else if (node.isLeaf) {
              hiddenKeys.add(node.key);
            }
            const children = node.children;
            if (children) {
              traverse2(children);
            }
            if (!node.isLeaf) {
              if (!expandKeySet.has(node.key)) {
                hiddenKeys.add(node.key);
              } else if (children) {
                let allHidden = true;
                for (const childNode of children) {
                  if (!hiddenKeys.has(childNode.key)) {
                    allHidden = false;
                    break;
                  }
                }
                if (allHidden) {
                  hiddenExpandIconKeys.add(node.key);
                } else {
                  hiddenExpandIconKeys.delete(node.key);
                }
              }
            }
            family.pop();
          });
        }
        traverse2(nodes);
        return expandKeySet;
      }
      function isForceHiddenExpandIcon(node) {
        return hiddenExpandIconKeySet.value.has(node.key);
      }
      return {
        hiddenExpandIconKeySet,
        hiddenNodeKeySet,
        doFilter,
        isForceHiddenExpandIcon
      };
    }
    function useTree(props, emit) {
      const expandedKeySet = ref(new Set(props.defaultExpandedKeys));
      const currentKey = ref();
      const tree = shallowRef();
      watch(() => props.currentNodeKey, (key) => {
        currentKey.value = key;
      }, {
        immediate: true
      });
      watch(() => props.data, (data) => {
        setData(data);
      }, {
        immediate: true
      });
      const {
        isIndeterminate,
        isChecked,
        toggleCheckbox,
        getCheckedKeys,
        getCheckedNodes,
        getHalfCheckedKeys,
        getHalfCheckedNodes,
        setChecked: setChecked2,
        setCheckedKeys
      } = useCheck(props, tree);
      const { doFilter, hiddenNodeKeySet, isForceHiddenExpandIcon } = useFilter(props, tree);
      const valueKey = computed(() => {
        var _a2;
        return ((_a2 = props.props) == null ? void 0 : _a2.value) || TreeOptionsEnum.KEY;
      });
      const childrenKey = computed(() => {
        var _a2;
        return ((_a2 = props.props) == null ? void 0 : _a2.children) || TreeOptionsEnum.CHILDREN;
      });
      const disabledKey = computed(() => {
        var _a2;
        return ((_a2 = props.props) == null ? void 0 : _a2.disabled) || TreeOptionsEnum.DISABLED;
      });
      const labelKey = computed(() => {
        var _a2;
        return ((_a2 = props.props) == null ? void 0 : _a2.label) || TreeOptionsEnum.LABEL;
      });
      const flattenTree = computed(() => {
        const expandedKeys = expandedKeySet.value;
        const hiddenKeys = hiddenNodeKeySet.value;
        const flattenNodes = [];
        const nodes = tree.value && tree.value.treeNodes || [];
        function traverse2() {
          const stack2 = [];
          for (let i = nodes.length - 1; i >= 0; --i) {
            stack2.push(nodes[i]);
          }
          while (stack2.length) {
            const node = stack2.pop();
            if (!node)
              continue;
            if (!hiddenKeys.has(node.key)) {
              flattenNodes.push(node);
            }
            if (expandedKeys.has(node.key)) {
              const children = node.children;
              if (children) {
                const length = children.length;
                for (let i = length - 1; i >= 0; --i) {
                  stack2.push(children[i]);
                }
              }
            }
          }
        }
        traverse2();
        return flattenNodes;
      });
      const isNotEmpty = computed(() => {
        return flattenTree.value.length > 0;
      });
      function createTree(data) {
        const treeNodeMap = /* @__PURE__ */ new Map();
        const levelTreeNodeMap = /* @__PURE__ */ new Map();
        let maxLevel = 1;
        function traverse2(nodes, level = 1, parent = void 0) {
          var _a2;
          const siblings = [];
          for (const rawNode of nodes) {
            const value = getKey(rawNode);
            const node = {
              level,
              key: value,
              data: rawNode
            };
            node.label = getLabel(rawNode);
            node.parent = parent;
            const children = getChildren(rawNode);
            node.disabled = getDisabled(rawNode);
            node.isLeaf = !children || children.length === 0;
            if (children && children.length) {
              node.children = traverse2(children, level + 1, node);
            }
            siblings.push(node);
            treeNodeMap.set(value, node);
            if (!levelTreeNodeMap.has(level)) {
              levelTreeNodeMap.set(level, []);
            }
            (_a2 = levelTreeNodeMap.get(level)) == null ? void 0 : _a2.push(node);
          }
          if (level > maxLevel) {
            maxLevel = level;
          }
          return siblings;
        }
        const treeNodes = traverse2(data);
        return {
          treeNodeMap,
          levelTreeNodeMap,
          maxLevel,
          treeNodes
        };
      }
      function filter(query) {
        const keys2 = doFilter(query);
        if (keys2) {
          expandedKeySet.value = keys2;
        }
      }
      function getChildren(node) {
        return node[childrenKey.value];
      }
      function getKey(node) {
        if (!node) {
          return "";
        }
        return node[valueKey.value];
      }
      function getDisabled(node) {
        return node[disabledKey.value];
      }
      function getLabel(node) {
        return node[labelKey.value];
      }
      function toggleExpand(node) {
        const expandedKeys = expandedKeySet.value;
        if (expandedKeys.has(node.key)) {
          collapseNode(node);
        } else {
          expandNode(node);
        }
      }
      function setExpandedKeys(keys2) {
        expandedKeySet.value = new Set(keys2);
      }
      function handleNodeClick(node, e) {
        emit(NODE_CLICK, node.data, node, e);
        handleCurrentChange(node);
        if (props.expandOnClickNode) {
          toggleExpand(node);
        }
        if (props.showCheckbox && props.checkOnClickNode && !node.disabled) {
          toggleCheckbox(node, !isChecked(node), true);
        }
      }
      function handleCurrentChange(node) {
        if (!isCurrent(node)) {
          currentKey.value = node.key;
          emit(CURRENT_CHANGE, node.data, node);
        }
      }
      function handleNodeCheck(node, checked) {
        toggleCheckbox(node, checked);
      }
      function expandNode(node) {
        const keySet = expandedKeySet.value;
        if (tree.value && props.accordion) {
          const { treeNodeMap } = tree.value;
          keySet.forEach((key) => {
            const treeNode = treeNodeMap.get(key);
            if (node && node.level === treeNode.level) {
              keySet.delete(key);
            }
          });
        }
        keySet.add(node.key);
        emit(NODE_EXPAND, node.data, node);
      }
      function collapseNode(node) {
        expandedKeySet.value.delete(node.key);
        emit(NODE_COLLAPSE, node.data, node);
      }
      function isExpanded(node) {
        return expandedKeySet.value.has(node.key);
      }
      function isDisabled(node) {
        return !!node.disabled;
      }
      function isCurrent(node) {
        const current = currentKey.value;
        return !!current && current === node.key;
      }
      function getCurrentNode() {
        var _a2, _b;
        if (!currentKey.value)
          return void 0;
        return (_b = (_a2 = tree.value) == null ? void 0 : _a2.treeNodeMap.get(currentKey.value)) == null ? void 0 : _b.data;
      }
      function getCurrentKey() {
        return currentKey.value;
      }
      function setCurrentKey(key) {
        currentKey.value = key;
      }
      function setData(data) {
        nextTick(() => tree.value = createTree(data));
      }
      function getNode(data) {
        var _a2;
        const key = isObject$4(data) ? getKey(data) : data;
        return (_a2 = tree.value) == null ? void 0 : _a2.treeNodeMap.get(key);
      }
      return {
        tree,
        flattenTree,
        isNotEmpty,
        getKey,
        getChildren,
        toggleExpand,
        toggleCheckbox,
        isExpanded,
        isChecked,
        isIndeterminate,
        isDisabled,
        isCurrent,
        isForceHiddenExpandIcon,
        handleNodeClick,
        handleNodeCheck,
        getCurrentNode,
        getCurrentKey,
        setCurrentKey,
        getCheckedKeys,
        getCheckedNodes,
        getHalfCheckedKeys,
        getHalfCheckedNodes,
        setChecked: setChecked2,
        setCheckedKeys,
        filter,
        setData,
        getNode,
        expandNode,
        collapseNode,
        setExpandedKeys
      };
    }
    var ElNodeContent = defineComponent({
      name: "ElTreeNodeContent",
      props: treeNodeContentProps,
      setup(props) {
        const tree = inject(ROOT_TREE_INJECTION_KEY);
        const ns2 = useNamespace("tree");
        return () => {
          const node = props.node;
          const { data } = node;
          return (tree == null ? void 0 : tree.ctx.slots.default) ? tree.ctx.slots.default({ node, data }) : h$1("span", { class: ns2.be("node", "label") }, [node == null ? void 0 : node.label]);
        };
      }
    });
    const DEFAULT_ICON = "caret-right";
    const _sfc_main$b = defineComponent({
      name: "ElTreeNode",
      components: {
        ElIcon,
        CaretRight: caret_right_default,
        ElCheckbox,
        ElNodeContent
      },
      props: treeNodeProps,
      emits: treeNodeEmits,
      setup(props, { emit }) {
        const tree = inject(ROOT_TREE_INJECTION_KEY);
        const ns2 = useNamespace("tree");
        const indent = computed(() => {
          var _a2;
          return (_a2 = tree == null ? void 0 : tree.props.indent) != null ? _a2 : 16;
        });
        const icon = computed(() => {
          var _a2;
          return (_a2 = tree == null ? void 0 : tree.props.icon) != null ? _a2 : DEFAULT_ICON;
        });
        const handleClick = (e) => {
          emit("click", props.node, e);
        };
        const handleExpandIconClick = () => {
          emit("toggle", props.node);
        };
        const handleCheckChange = (value) => {
          emit("check", props.node, value);
        };
        const handleContextMenu = (event) => {
          var _a2, _b, _c, _d;
          if ((_c = (_b = (_a2 = tree == null ? void 0 : tree.instance) == null ? void 0 : _a2.vnode) == null ? void 0 : _b.props) == null ? void 0 : _c["onNodeContextmenu"]) {
            event.stopPropagation();
            event.preventDefault();
          }
          tree == null ? void 0 : tree.ctx.emit(NODE_CONTEXTMENU, event, (_d = props.node) == null ? void 0 : _d.data, props.node);
        };
        return {
          ns: ns2,
          indent,
          icon,
          handleClick,
          handleExpandIconClick,
          handleCheckChange,
          handleContextMenu
        };
      }
    });
    const _hoisted_1$8 = ["aria-expanded", "aria-disabled", "aria-checked", "data-key"];
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      var _a2, _b, _c;
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_checkbox = resolveComponent("el-checkbox");
      const _component_el_node_content = resolveComponent("el-node-content");
      return openBlock(), createElementBlock("div", {
        ref: "node$",
        class: normalizeClass([
          _ctx.ns.b("node"),
          _ctx.ns.is("expanded", _ctx.expanded),
          _ctx.ns.is("current", _ctx.current),
          _ctx.ns.is("focusable", !_ctx.disabled),
          _ctx.ns.is("checked", !_ctx.disabled && _ctx.checked)
        ]),
        role: "treeitem",
        tabindex: "-1",
        "aria-expanded": _ctx.expanded,
        "aria-disabled": _ctx.disabled,
        "aria-checked": _ctx.checked,
        "data-key": (_a2 = _ctx.node) == null ? void 0 : _a2.key,
        onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"])),
        onContextmenu: _cache[2] || (_cache[2] = (...args) => _ctx.handleContextMenu && _ctx.handleContextMenu(...args))
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.ns.be("node", "content")),
          style: normalizeStyle({ paddingLeft: `${(_ctx.node.level - 1) * _ctx.indent}px` })
        }, [
          _ctx.icon ? (openBlock(), createBlock(_component_el_icon, {
            key: 0,
            class: normalizeClass([
              _ctx.ns.is("leaf", !!((_b = _ctx.node) == null ? void 0 : _b.isLeaf)),
              _ctx.ns.is("hidden", _ctx.hiddenExpandIcon),
              {
                expanded: !((_c = _ctx.node) == null ? void 0 : _c.isLeaf) && _ctx.expanded
              },
              _ctx.ns.be("node", "expand-icon")
            ]),
            onClick: withModifiers(_ctx.handleExpandIconClick, ["stop"])
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
          _ctx.showCheckbox ? (openBlock(), createBlock(_component_el_checkbox, {
            key: 1,
            "model-value": _ctx.checked,
            indeterminate: _ctx.indeterminate,
            disabled: _ctx.disabled,
            onChange: _ctx.handleCheckChange,
            onClick: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["stop"]))
          }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : createCommentVNode("v-if", true),
          createVNode(_component_el_node_content, { node: _ctx.node }, null, 8, ["node"])
        ], 6)
      ], 42, _hoisted_1$8);
    }
    var ElTreeNode = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$2], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree-node.vue"]]);
    const _sfc_main$a = defineComponent({
      name: "ElTreeV2",
      components: {
        ElTreeNode,
        FixedSizeList
      },
      props: treeProps,
      emits: treeEmits,
      setup(props, ctx) {
        provide(ROOT_TREE_INJECTION_KEY, {
          ctx,
          props,
          instance: getCurrentInstance()
        });
        provide(formItemContextKey, void 0);
        const { t } = useLocale();
        const ns2 = useNamespace("tree");
        const {
          flattenTree,
          isNotEmpty,
          toggleExpand,
          isExpanded,
          isIndeterminate,
          isChecked,
          isDisabled,
          isCurrent,
          isForceHiddenExpandIcon,
          toggleCheckbox,
          handleNodeClick,
          handleNodeCheck,
          getCurrentNode,
          getCurrentKey,
          setCurrentKey,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked: setChecked2,
          setCheckedKeys,
          filter,
          setData,
          getNode,
          expandNode,
          collapseNode,
          setExpandedKeys
        } = useTree(props, ctx.emit);
        ctx.expose({
          getCurrentNode,
          getCurrentKey,
          setCurrentKey,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked: setChecked2,
          setCheckedKeys,
          filter,
          setData,
          getNode,
          expandNode,
          collapseNode,
          setExpandedKeys
        });
        return {
          t,
          ns: ns2,
          flattenTree,
          itemSize: 26,
          isNotEmpty,
          toggleExpand,
          toggleCheckbox,
          isExpanded,
          isIndeterminate,
          isChecked,
          isDisabled,
          isCurrent,
          isForceHiddenExpandIcon,
          handleNodeClick,
          handleNodeCheck
        };
      }
    });
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      var _a2;
      const _component_el_tree_node = resolveComponent("el-tree-node");
      const _component_fixed_size_list = resolveComponent("fixed-size-list");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.ns.b(), { [_ctx.ns.m("highlight-current")]: _ctx.highlightCurrent }]),
        role: "tree"
      }, [
        _ctx.isNotEmpty ? (openBlock(), createBlock(_component_fixed_size_list, {
          key: 0,
          "class-name": _ctx.ns.b("virtual-list"),
          data: _ctx.flattenTree,
          total: _ctx.flattenTree.length,
          height: _ctx.height,
          "item-size": _ctx.itemSize,
          "perf-mode": _ctx.perfMode
        }, {
          default: withCtx(({ data, index: index2, style: style2 }) => [
            (openBlock(), createBlock(_component_el_tree_node, {
              key: data[index2].key,
              style: normalizeStyle(style2),
              node: data[index2],
              expanded: _ctx.isExpanded(data[index2]),
              "show-checkbox": _ctx.showCheckbox,
              checked: _ctx.isChecked(data[index2]),
              indeterminate: _ctx.isIndeterminate(data[index2]),
              disabled: _ctx.isDisabled(data[index2]),
              current: _ctx.isCurrent(data[index2]),
              "hidden-expand-icon": _ctx.isForceHiddenExpandIcon(data[index2]),
              onClick: _ctx.handleNodeClick,
              onToggle: _ctx.toggleExpand,
              onCheck: _ctx.handleNodeCheck
            }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck"]))
          ]),
          _: 1
        }, 8, ["class-name", "data", "total", "height", "item-size", "perf-mode"])) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.ns.e("empty-block"))
        }, [
          createBaseVNode("span", {
            class: normalizeClass(_ctx.ns.e("empty-text"))
          }, toDisplayString$1((_a2 = _ctx.emptyText) != null ? _a2 : _ctx.t("el.tree.emptyText")), 3)
        ], 2))
      ], 2);
    }
    var TreeV2 = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$1], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree.vue"]]);
    const ElTreeV2 = withInstall(TreeV2);
    const SCOPE$2 = "ElUpload";
    class UploadAjaxError extends Error {
      constructor(message2, status, method2, url) {
        super(message2);
        this.name = "UploadAjaxError";
        this.status = status;
        this.method = method2;
        this.url = url;
      }
    }
    function getError(action, option, xhr) {
      let msg;
      if (xhr.response) {
        msg = `${xhr.response.error || xhr.response}`;
      } else if (xhr.responseText) {
        msg = `${xhr.responseText}`;
      } else {
        msg = `fail to ${option.method} ${action} ${xhr.status}`;
      }
      return new UploadAjaxError(msg, xhr.status, option.method, action);
    }
    function getBody(xhr) {
      const text = xhr.responseText || xhr.response;
      if (!text) {
        return text;
      }
      try {
        return JSON.parse(text);
      } catch (e) {
        return text;
      }
    }
    const ajaxUpload = (option) => {
      if (typeof XMLHttpRequest === "undefined")
        throwError(SCOPE$2, "XMLHttpRequest is undefined");
      const xhr = new XMLHttpRequest();
      const action = option.action;
      if (xhr.upload) {
        xhr.upload.addEventListener("progress", (evt) => {
          const progressEvt = evt;
          progressEvt.percent = evt.total > 0 ? evt.loaded / evt.total * 100 : 0;
          option.onProgress(progressEvt);
        });
      }
      const formData = new FormData();
      if (option.data) {
        for (const [key, value] of Object.entries(option.data)) {
          if (Array.isArray(value))
            formData.append(key, ...value);
          else
            formData.append(key, value);
        }
      }
      formData.append(option.filename, option.file, option.file.name);
      xhr.addEventListener("error", () => {
        option.onError(getError(action, option, xhr));
      });
      xhr.addEventListener("load", () => {
        if (xhr.status < 200 || xhr.status >= 300) {
          return option.onError(getError(action, option, xhr));
        }
        option.onSuccess(getBody(xhr));
      });
      xhr.open(option.method, action, true);
      if (option.withCredentials && "withCredentials" in xhr) {
        xhr.withCredentials = true;
      }
      const headers = option.headers || {};
      if (headers instanceof Headers) {
        headers.forEach((value, key) => xhr.setRequestHeader(key, value));
      } else {
        for (const [key, value] of Object.entries(headers)) {
          if (isNil(value))
            continue;
          xhr.setRequestHeader(key, String(value));
        }
      }
      xhr.send(formData);
      return xhr;
    };
    const uploadListTypes = ["text", "picture", "picture-card"];
    let fileId = 1;
    const genFileId = () => Date.now() + fileId++;
    const uploadBaseProps = buildProps({
      action: {
        type: String,
        default: "#"
      },
      headers: {
        type: definePropType(Object)
      },
      method: {
        type: String,
        default: "post"
      },
      data: {
        type: Object,
        default: () => mutable({})
      },
      multiple: {
        type: Boolean,
        default: false
      },
      name: {
        type: String,
        default: "file"
      },
      drag: {
        type: Boolean,
        default: false
      },
      withCredentials: Boolean,
      showFileList: {
        type: Boolean,
        default: true
      },
      accept: {
        type: String,
        default: ""
      },
      type: {
        type: String,
        default: "select"
      },
      fileList: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      autoUpload: {
        type: Boolean,
        default: true
      },
      listType: {
        type: String,
        values: uploadListTypes,
        default: "text"
      },
      httpRequest: {
        type: definePropType(Function),
        default: ajaxUpload
      },
      disabled: Boolean,
      limit: Number
    });
    const uploadProps = buildProps({
      ...uploadBaseProps,
      beforeUpload: {
        type: definePropType(Function),
        default: NOOP
      },
      beforeRemove: {
        type: definePropType(Function)
      },
      onRemove: {
        type: definePropType(Function),
        default: NOOP
      },
      onChange: {
        type: definePropType(Function),
        default: NOOP
      },
      onPreview: {
        type: definePropType(Function),
        default: NOOP
      },
      onSuccess: {
        type: definePropType(Function),
        default: NOOP
      },
      onProgress: {
        type: definePropType(Function),
        default: NOOP
      },
      onError: {
        type: definePropType(Function),
        default: NOOP
      },
      onExceed: {
        type: definePropType(Function),
        default: NOOP
      }
    });
    const uploadListProps = buildProps({
      files: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      disabled: {
        type: Boolean,
        default: false
      },
      handlePreview: {
        type: definePropType(Function),
        default: NOOP
      },
      listType: {
        type: String,
        values: uploadListTypes,
        default: "text"
      }
    });
    const uploadListEmits = {
      remove: (file) => !!file
    };
    const _hoisted_1$7 = ["onKeydown"];
    const _hoisted_2$6 = ["src"];
    const _hoisted_3$4 = ["onClick"];
    const _hoisted_4$3 = ["onClick"];
    const _hoisted_5$2 = ["onClick"];
    const __default__$5 = {
      name: "ElUploadList"
    };
    const _sfc_main$9 = /* @__PURE__ */ defineComponent({
      ...__default__$5,
      props: uploadListProps,
      emits: uploadListEmits,
      setup(__props, { emit }) {
        const { t } = useLocale();
        const nsUpload = useNamespace("upload");
        const nsIcon = useNamespace("icon");
        const nsList = useNamespace("list");
        const focusing = ref(false);
        const handleRemove = (file) => {
          emit("remove", file);
        };
        return (_ctx, _cache) => {
          return openBlock(), createBlock(TransitionGroup, {
            tag: "ul",
            class: normalizeClass([
              unref(nsUpload).b("list"),
              unref(nsUpload).bm("list", _ctx.listType),
              unref(nsUpload).is("disabled", _ctx.disabled)
            ]),
            name: unref(nsList).b()
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.files, (file) => {
                return openBlock(), createElementBlock("li", {
                  key: file.uid || file.name,
                  class: normalizeClass([
                    unref(nsUpload).be("list", "item"),
                    unref(nsUpload).is(file.status),
                    { focusing: focusing.value }
                  ]),
                  tabindex: "0",
                  onKeydown: withKeys(($event) => !_ctx.disabled && handleRemove(file), ["delete"]),
                  onFocus: _cache[0] || (_cache[0] = ($event) => focusing.value = true),
                  onBlur: _cache[1] || (_cache[1] = ($event) => focusing.value = false),
                  onClick: _cache[2] || (_cache[2] = ($event) => focusing.value = false)
                }, [
                  renderSlot(_ctx.$slots, "default", { file }, () => [
                    _ctx.listType === "picture" || file.status !== "uploading" && _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("img", {
                      key: 0,
                      class: normalizeClass(unref(nsUpload).be("list", "item-thumbnail")),
                      src: file.url,
                      alt: ""
                    }, null, 10, _hoisted_2$6)) : createCommentVNode("v-if", true),
                    file.status === "uploading" || _ctx.listType !== "picture-card" ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: normalizeClass(unref(nsUpload).be("list", "item-info"))
                    }, [
                      createBaseVNode("a", {
                        class: normalizeClass(unref(nsUpload).be("list", "item-name")),
                        onClick: withModifiers(($event) => _ctx.handlePreview(file), ["prevent"])
                      }, [
                        createVNode(unref(ElIcon), {
                          class: normalizeClass(unref(nsIcon).m("document"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(document_default))
                          ]),
                          _: 1
                        }, 8, ["class"]),
                        createBaseVNode("span", {
                          class: normalizeClass(unref(nsUpload).be("list", "item-file-name"))
                        }, toDisplayString$1(file.name), 3)
                      ], 10, _hoisted_3$4),
                      file.status === "uploading" ? (openBlock(), createBlock(unref(ElProgress), {
                        key: 0,
                        type: _ctx.listType === "picture-card" ? "circle" : "line",
                        "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
                        percentage: Number(file.percentage),
                        style: normalizeStyle(_ctx.listType === "picture-card" ? "" : "margin-top: 0.5rem")
                      }, null, 8, ["type", "stroke-width", "percentage", "style"])) : createCommentVNode("v-if", true)
                    ], 2)) : createCommentVNode("v-if", true),
                    createBaseVNode("label", {
                      class: normalizeClass(unref(nsUpload).be("list", "item-status-label"))
                    }, [
                      _ctx.listType === "text" ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("circle-check")])
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_check_default))
                        ]),
                        _: 1
                      }, 8, ["class"])) : ["picture-card", "picture"].includes(_ctx.listType) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("check")])
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(check_default))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2),
                    !_ctx.disabled ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 2,
                      class: normalizeClass(unref(nsIcon).m("close")),
                      onClick: ($event) => handleRemove(file)
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(close_default))
                      ]),
                      _: 2
                    }, 1032, ["class", "onClick"])) : createCommentVNode("v-if", true),
                    createCommentVNode(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
                    createCommentVNode(" This is a bug which needs to be fixed "),
                    createCommentVNode(" TODO: Fix the incorrect navigation interaction "),
                    !_ctx.disabled ? (openBlock(), createElementBlock("i", {
                      key: 3,
                      class: normalizeClass(unref(nsIcon).m("close-tip"))
                    }, toDisplayString$1(unref(t)("el.upload.deleteTip")), 3)) : createCommentVNode("v-if", true),
                    _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("span", {
                      key: 4,
                      class: normalizeClass(unref(nsUpload).be("list", "item-actions"))
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(unref(nsUpload).be("list", "item-preview")),
                        onClick: ($event) => _ctx.handlePreview(file)
                      }, [
                        createVNode(unref(ElIcon), {
                          class: normalizeClass(unref(nsIcon).m("zoom-in"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(zoom_in_default))
                          ]),
                          _: 1
                        }, 8, ["class"])
                      ], 10, _hoisted_4$3),
                      !_ctx.disabled ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        class: normalizeClass(unref(nsUpload).be("list", "item-delete")),
                        onClick: ($event) => handleRemove(file)
                      }, [
                        createVNode(unref(ElIcon), {
                          class: normalizeClass(unref(nsIcon).m("delete"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(delete_default))
                          ]),
                          _: 1
                        }, 8, ["class"])
                      ], 10, _hoisted_5$2)) : createCommentVNode("v-if", true)
                    ], 2)) : createCommentVNode("v-if", true)
                  ])
                ], 42, _hoisted_1$7);
              }), 128)),
              renderSlot(_ctx.$slots, "append")
            ]),
            _: 3
          }, 8, ["class", "name"]);
        };
      }
    });
    var UploadList = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]);
    const uploadDraggerProps = buildProps({
      disabled: {
        type: Boolean,
        default: false
      }
    });
    const uploadDraggerEmits = {
      file: (file) => isArray$4(file)
    };
    const _hoisted_1$6 = ["onDrop", "onDragover"];
    const __default__$4 = {
      name: "ElUploadDrag"
    };
    const _sfc_main$8 = /* @__PURE__ */ defineComponent({
      ...__default__$4,
      props: uploadDraggerProps,
      emits: uploadDraggerEmits,
      setup(__props, { emit }) {
        const props = __props;
        const COMPONENT_NAME2 = "ElUploadDrag";
        const uploaderContext = inject(uploadContextKey);
        if (!uploaderContext) {
          throwError(COMPONENT_NAME2, "usage: <el-upload><el-upload-dragger /></el-upload>");
        }
        const ns2 = useNamespace("upload");
        const dragover = ref(false);
        const onDrop = (e) => {
          if (props.disabled)
            return;
          dragover.value = false;
          const files = Array.from(e.dataTransfer.files);
          const accept = uploaderContext.accept.value;
          if (!accept) {
            emit("file", files);
            return;
          }
          const filesFiltered = files.filter((file) => {
            const { type: type2, name } = file;
            const extension = name.includes(".") ? `.${name.split(".").pop()}` : "";
            const baseType = type2.replace(/\/.*$/, "");
            return accept.split(",").map((type22) => type22.trim()).filter((type22) => type22).some((acceptedType) => {
              if (acceptedType.startsWith(".")) {
                return extension === acceptedType;
              }
              if (/\/\*$/.test(acceptedType)) {
                return baseType === acceptedType.replace(/\/\*$/, "");
              }
              if (/^[^/]+\/[^/]+$/.test(acceptedType)) {
                return type2 === acceptedType;
              }
              return false;
            });
          });
          emit("file", filesFiltered);
        };
        const onDragover = () => {
          if (!props.disabled)
            dragover.value = true;
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([unref(ns2).b("dragger"), unref(ns2).is("dragover", dragover.value)]),
            onDrop: withModifiers(onDrop, ["prevent"]),
            onDragover: withModifiers(onDragover, ["prevent"]),
            onDragleave: _cache[0] || (_cache[0] = withModifiers(($event) => dragover.value = false, ["prevent"]))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 42, _hoisted_1$6);
        };
      }
    });
    var UploadDragger = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]);
    const uploadContentProps = buildProps({
      ...uploadBaseProps,
      beforeUpload: {
        type: definePropType(Function),
        default: NOOP
      },
      onRemove: {
        type: definePropType(Function),
        default: NOOP
      },
      onStart: {
        type: definePropType(Function),
        default: NOOP
      },
      onSuccess: {
        type: definePropType(Function),
        default: NOOP
      },
      onProgress: {
        type: definePropType(Function),
        default: NOOP
      },
      onError: {
        type: definePropType(Function),
        default: NOOP
      },
      onExceed: {
        type: definePropType(Function),
        default: NOOP
      }
    });
    const _hoisted_1$5 = ["onKeydown"];
    const _hoisted_2$5 = ["name", "multiple", "accept"];
    const __default__$3 = {
      name: "ElUploadContent",
      inheritAttrs: false
    };
    const _sfc_main$7 = /* @__PURE__ */ defineComponent({
      ...__default__$3,
      props: uploadContentProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns2 = useNamespace("upload");
        const requests = shallowRef({});
        const inputRef = shallowRef();
        const uploadFiles = (files) => {
          if (files.length === 0)
            return;
          const { autoUpload, limit, fileList, multiple, onStart, onExceed } = props;
          if (limit && fileList.length + files.length > limit) {
            onExceed(files, fileList);
            return;
          }
          if (!multiple) {
            files = files.slice(0, 1);
          }
          for (const file of files) {
            const rawFile = file;
            rawFile.uid = genFileId();
            onStart(rawFile);
            if (autoUpload)
              upload(rawFile);
          }
        };
        const upload = async (rawFile) => {
          inputRef.value.value = "";
          if (!props.beforeUpload) {
            return doUpload(rawFile);
          }
          let hookResult;
          try {
            hookResult = await props.beforeUpload(rawFile);
          } catch (e) {
            hookResult = false;
          }
          if (hookResult === false) {
            props.onRemove(rawFile);
            return;
          }
          let file = rawFile;
          if (hookResult instanceof Blob) {
            if (hookResult instanceof File) {
              file = hookResult;
            } else {
              file = new File([hookResult], rawFile.name, {
                type: rawFile.type
              });
            }
          }
          doUpload(Object.assign(file, {
            uid: rawFile.uid
          }));
        };
        const doUpload = (rawFile) => {
          const {
            headers,
            data,
            method: method2,
            withCredentials,
            name: filename,
            action,
            onProgress,
            onSuccess,
            onError,
            httpRequest
          } = props;
          const { uid: uid2 } = rawFile;
          const options = {
            headers: headers || {},
            withCredentials,
            file: rawFile,
            data,
            method: method2,
            filename,
            action,
            onProgress: (evt) => {
              onProgress(evt, rawFile);
            },
            onSuccess: (res) => {
              onSuccess(res, rawFile);
              delete requests.value[uid2];
            },
            onError: (err) => {
              onError(err, rawFile);
              delete requests.value[uid2];
            }
          };
          const request2 = httpRequest(options);
          requests.value[uid2] = request2;
          if (request2 instanceof Promise) {
            request2.then(options.onSuccess, options.onError);
          }
        };
        const handleChange = (e) => {
          const files = e.target.files;
          if (!files)
            return;
          uploadFiles(Array.from(files));
        };
        const handleClick = () => {
          if (!props.disabled) {
            inputRef.value.value = "";
            inputRef.value.click();
          }
        };
        const handleKeydown = () => {
          handleClick();
        };
        const abort = (file) => {
          const _reqs = entriesOf(requests.value).filter(file ? ([uid2]) => String(file.uid) === uid2 : () => true);
          _reqs.forEach(([uid2, req]) => {
            if (req instanceof XMLHttpRequest)
              req.abort();
            delete requests.value[uid2];
          });
        };
        expose({
          abort,
          upload
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([unref(ns2).b(), unref(ns2).m(_ctx.listType), unref(ns2).is("drag", _ctx.drag)]),
            tabindex: "0",
            onClick: handleClick,
            onKeydown: withKeys(withModifiers(handleKeydown, ["self"]), ["enter", "space"])
          }, [
            _ctx.drag ? (openBlock(), createBlock(UploadDragger, {
              key: 0,
              disabled: _ctx.disabled,
              onFile: uploadFiles
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["disabled"])) : renderSlot(_ctx.$slots, "default", { key: 1 }),
            createBaseVNode("input", {
              ref_key: "inputRef",
              ref: inputRef,
              class: normalizeClass(unref(ns2).e("input")),
              name: _ctx.name,
              multiple: _ctx.multiple,
              accept: _ctx.accept,
              type: "file",
              onChange: handleChange,
              onClick: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["stop"]))
            }, null, 42, _hoisted_2$5)
          ], 42, _hoisted_1$5);
        };
      }
    });
    var UploadContent = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]);
    const SCOPE$1 = "ElUpload";
    const revokeObjectURL = (file) => {
      var _a2;
      if ((_a2 = file.url) == null ? void 0 : _a2.startsWith("blob:")) {
        URL.revokeObjectURL(file.url);
      }
    };
    const useHandlers = (props, uploadRef) => {
      const uploadFiles = useVModel(props, "fileList", void 0, { passive: true });
      const getFile = (rawFile) => uploadFiles.value.find((file) => file.uid === rawFile.uid);
      function abort(file) {
        var _a2;
        (_a2 = uploadRef.value) == null ? void 0 : _a2.abort(file);
      }
      function clearFiles(states = ["ready", "uploading", "success", "fail"]) {
        uploadFiles.value = uploadFiles.value.filter((row) => !states.includes(row.status));
      }
      const handleError2 = (err, rawFile) => {
        const file = getFile(rawFile);
        if (!file)
          return;
        console.error(err);
        file.status = "fail";
        uploadFiles.value.splice(uploadFiles.value.indexOf(file), 1);
        props.onError(err, file, uploadFiles.value);
        props.onChange(file, uploadFiles.value);
      };
      const handleProgress = (evt, rawFile) => {
        const file = getFile(rawFile);
        if (!file)
          return;
        props.onProgress(evt, file, uploadFiles.value);
        file.status = "uploading";
        file.percentage = Math.round(evt.percent);
      };
      const handleSuccess = (response, rawFile) => {
        const file = getFile(rawFile);
        if (!file)
          return;
        file.status = "success";
        file.response = response;
        props.onSuccess(response, file, uploadFiles.value);
        props.onChange(file, uploadFiles.value);
      };
      const handleStart = (file) => {
        const uploadFile = {
          name: file.name,
          percentage: 0,
          status: "ready",
          size: file.size,
          raw: file,
          uid: file.uid
        };
        if (props.listType === "picture-card" || props.listType === "picture") {
          try {
            uploadFile.url = URL.createObjectURL(file);
          } catch (err) {
            debugWarn(SCOPE$1, err.message);
            props.onError(err, uploadFile, uploadFiles.value);
          }
        }
        uploadFiles.value = [...uploadFiles.value, uploadFile];
        props.onChange(uploadFile, uploadFiles.value);
      };
      const handleRemove = async (file) => {
        const uploadFile = file instanceof File ? getFile(file) : file;
        if (!uploadFile)
          throwError(SCOPE$1, "file to be removed not found");
        const doRemove = (file2) => {
          abort(file2);
          const fileList = uploadFiles.value;
          fileList.splice(fileList.indexOf(file2), 1);
          props.onRemove(file2, fileList);
          revokeObjectURL(file2);
        };
        if (props.beforeRemove) {
          const before = await props.beforeRemove(uploadFile, uploadFiles.value);
          if (before !== false)
            doRemove(uploadFile);
        } else {
          doRemove(uploadFile);
        }
      };
      function submit() {
        uploadFiles.value.filter(({ status }) => status === "ready").forEach(({ raw }) => {
          var _a2;
          return raw && ((_a2 = uploadRef.value) == null ? void 0 : _a2.upload(raw));
        });
      }
      watch(() => props.listType, (val) => {
        if (val !== "picture-card" && val !== "picture") {
          return;
        }
        uploadFiles.value = uploadFiles.value.map((file) => {
          const { raw, url } = file;
          if (!url && raw) {
            try {
              file.url = URL.createObjectURL(raw);
            } catch (err) {
              props.onError(err, file, uploadFiles.value);
            }
          }
          return file;
        });
      });
      watch(uploadFiles, (files) => {
        for (const file of files) {
          file.uid || (file.uid = genFileId());
          file.status || (file.status = "success");
        }
      }, { immediate: true, deep: true });
      return {
        uploadFiles,
        abort,
        clearFiles,
        handleError: handleError2,
        handleProgress,
        handleStart,
        handleSuccess,
        handleRemove,
        submit
      };
    };
    const __default__$2 = {
      name: "ElUpload"
    };
    const _sfc_main$6 = /* @__PURE__ */ defineComponent({
      ...__default__$2,
      props: uploadProps,
      setup(__props, { expose }) {
        const props = __props;
        const slots = useSlots();
        const disabled = useDisabled$1();
        const uploadRef = shallowRef();
        const {
          abort,
          submit,
          clearFiles,
          uploadFiles,
          handleStart,
          handleError: handleError2,
          handleRemove,
          handleSuccess,
          handleProgress
        } = useHandlers(props, uploadRef);
        const isPictureCard = computed(() => props.listType === "picture-card");
        const uploadContentProps2 = computed(() => ({
          ...props,
          fileList: uploadFiles.value,
          onStart: handleStart,
          onProgress: handleProgress,
          onSuccess: handleSuccess,
          onError: handleError2,
          onRemove: handleRemove
        }));
        onBeforeUnmount(() => {
          uploadFiles.value.forEach(({ url }) => {
            if (url == null ? void 0 : url.startsWith("blob:"))
              URL.revokeObjectURL(url);
          });
        });
        provide(uploadContextKey, {
          accept: toRef(props, "accept")
        });
        expose({
          abort,
          submit,
          clearFiles,
          handleStart,
          handleRemove
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", null, [
            unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
              key: 0,
              disabled: unref(disabled),
              "list-type": _ctx.listType,
              files: unref(uploadFiles),
              "handle-preview": _ctx.onPreview,
              onRemove: unref(handleRemove)
            }, createSlots({
              append: withCtx(() => [
                _ctx.listType === "picture-card" ? (openBlock(), createBlock(UploadContent, mergeProps({
                  key: 0,
                  ref_key: "uploadRef",
                  ref: uploadRef
                }, unref(uploadContentProps2)), {
                  default: withCtx(() => [
                    unref(slots).trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                    !unref(slots).trigger && unref(slots).default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 16)) : createCommentVNode("v-if", true)
              ]),
              _: 2
            }, [
              _ctx.$slots.file ? {
                name: "default",
                fn: withCtx(({ file }) => [
                  renderSlot(_ctx.$slots, "file", { file })
                ])
              } : void 0
            ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true),
            _ctx.listType !== "picture-card" ? (openBlock(), createBlock(UploadContent, mergeProps({
              key: 1,
              ref_key: "uploadRef",
              ref: uploadRef
            }, unref(uploadContentProps2)), {
              default: withCtx(() => [
                unref(slots).trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                !unref(slots).trigger && unref(slots).default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16)) : createCommentVNode("v-if", true),
            _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "default", { key: 2 }) : createCommentVNode("v-if", true),
            renderSlot(_ctx.$slots, "tip"),
            !unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
              key: 3,
              disabled: unref(disabled),
              "list-type": _ctx.listType,
              files: unref(uploadFiles),
              "handle-preview": _ctx.onPreview,
              onRemove: unref(handleRemove)
            }, createSlots({ _: 2 }, [
              _ctx.$slots.file ? {
                name: "default",
                fn: withCtx(({ file }) => [
                  renderSlot(_ctx.$slots, "file", { file })
                ])
              } : void 0
            ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true)
          ]);
        };
      }
    });
    var Upload = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]);
    const ElUpload = withInstall(Upload);
    var Components = [
      ElAffix,
      ElAlert,
      ElAutocomplete,
      ElAutoResizer,
      ElAvatar,
      ElBacktop,
      ElBadge,
      ElBreadcrumb,
      ElBreadcrumbItem,
      ElButton,
      ElButtonGroup$1,
      ElCalendar,
      ElCard,
      ElCarousel,
      ElCarouselItem,
      ElCascader,
      ElCascaderPanel,
      ElCheckTag,
      ElCheckbox,
      ElCheckboxButton,
      ElCheckboxGroup$1,
      ElCol,
      ElCollapse,
      ElCollapseItem,
      ElCollapseTransition,
      ElColorPicker,
      ElConfigProvider,
      ElContainer,
      ElAside,
      ElFooter,
      ElHeader,
      ElMain,
      ElDatePicker,
      ElDescriptions,
      ElDescriptionsItem,
      ElDialog,
      ElDivider,
      ElDrawer,
      ElDropdown,
      ElDropdownItem,
      ElDropdownMenu,
      ElEmpty,
      ElForm,
      ElFormItem,
      ElIcon,
      ElImage,
      ElImageViewer,
      ElInput,
      ElInputNumber,
      ElLink,
      ElMenu,
      ElMenuItem,
      ElMenuItemGroup,
      ElPageHeader,
      ElPagination,
      ElPopconfirm,
      ElPopover,
      ElPopper,
      ElProgress,
      ElRadio,
      ElRadioButton,
      ElRadioGroup,
      ElRate,
      ElResult,
      ElRow,
      ElScrollbar,
      ElSelect,
      ElOption,
      ElOptionGroup,
      ElSelectV2,
      ElSkeleton,
      ElSkeletonItem,
      ElSlider,
      ElSpace,
      ElSteps,
      ElStep,
      ElSwitch,
      ElTable,
      ElTableColumn,
      ElTableV2,
      ElTabs,
      ElTabPane,
      ElTag,
      ElTimePicker,
      ElTimeSelect,
      ElTimeline,
      ElTimelineItem,
      ElTooltip,
      ElTooltipV2,
      ElTransfer,
      ElTree,
      ElTreeSelect,
      ElTreeV2,
      ElUpload
    ];
    const SCOPE = "ElInfiniteScroll";
    const CHECK_INTERVAL = 50;
    const DEFAULT_DELAY = 200;
    const DEFAULT_DISTANCE = 0;
    const attributes = {
      delay: {
        type: Number,
        default: DEFAULT_DELAY
      },
      distance: {
        type: Number,
        default: DEFAULT_DISTANCE
      },
      disabled: {
        type: Boolean,
        default: false
      },
      immediate: {
        type: Boolean,
        default: true
      }
    };
    const getScrollOptions = (el, instance) => {
      return Object.entries(attributes).reduce((acm, [name, option]) => {
        var _a2, _b;
        const { type: type2, default: defaultValue } = option;
        const attrVal = el.getAttribute(`infinite-scroll-${name}`);
        let value = (_b = (_a2 = instance[attrVal]) != null ? _a2 : attrVal) != null ? _b : defaultValue;
        value = value === "false" ? false : value;
        value = type2(value);
        acm[name] = Number.isNaN(value) ? defaultValue : value;
        return acm;
      }, {});
    };
    const destroyObserver = (el) => {
      const { observer } = el[SCOPE];
      if (observer) {
        observer.disconnect();
        delete el[SCOPE].observer;
      }
    };
    const handleScroll = (el, cb) => {
      const { container, containerEl, instance, observer, lastScrollTop } = el[SCOPE];
      const { disabled, distance } = getScrollOptions(el, instance);
      const { clientHeight, scrollHeight, scrollTop } = containerEl;
      const delta = scrollTop - lastScrollTop;
      el[SCOPE].lastScrollTop = scrollTop;
      if (observer || disabled || delta < 0)
        return;
      let shouldTrigger = false;
      if (container === el) {
        shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;
      } else {
        const { clientTop, scrollHeight: height } = el;
        const offsetTop = getOffsetTopDistance(el, containerEl);
        shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;
      }
      if (shouldTrigger) {
        cb.call(instance);
      }
    };
    function checkFull(el, cb) {
      const { containerEl, instance } = el[SCOPE];
      const { disabled } = getScrollOptions(el, instance);
      if (disabled || containerEl.clientHeight === 0)
        return;
      if (containerEl.scrollHeight <= containerEl.clientHeight) {
        cb.call(instance);
      } else {
        destroyObserver(el);
      }
    }
    const InfiniteScroll = {
      async mounted(el, binding) {
        const { instance, value: cb } = binding;
        if (!isFunction$4(cb)) {
          throwError(SCOPE, "'v-infinite-scroll' binding value must be a function");
        }
        await nextTick();
        const { delay, immediate } = getScrollOptions(el, instance);
        const container = getScrollContainer(el, true);
        const containerEl = container === window ? document.documentElement : container;
        const onScroll = throttle(handleScroll.bind(null, el, cb), delay);
        if (!container)
          return;
        el[SCOPE] = {
          instance,
          container,
          containerEl,
          delay,
          cb,
          onScroll,
          lastScrollTop: containerEl.scrollTop
        };
        if (immediate) {
          const observer = new MutationObserver(throttle(checkFull.bind(null, el, cb), CHECK_INTERVAL));
          el[SCOPE].observer = observer;
          observer.observe(el, { childList: true, subtree: true });
          checkFull(el, cb);
        }
        container.addEventListener("scroll", onScroll);
      },
      unmounted(el) {
        const { container, onScroll } = el[SCOPE];
        container == null ? void 0 : container.removeEventListener("scroll", onScroll);
        destroyObserver(el);
      },
      async updated(el) {
        if (!el[SCOPE]) {
          await nextTick();
        }
        const { containerEl, cb, observer } = el[SCOPE];
        if (containerEl.clientHeight && observer) {
          checkFull(el, cb);
        }
      }
    };
    const _InfiniteScroll = InfiniteScroll;
    _InfiniteScroll.install = (app2) => {
      app2.directive("InfiniteScroll", _InfiniteScroll);
    };
    const ElInfiniteScroll = _InfiniteScroll;
    function createLoadingComponent(options) {
      let afterLeaveTimer;
      const ns2 = useNamespace("loading");
      const afterLeaveFlag = ref(false);
      const data = reactive({
        ...options,
        originalPosition: "",
        originalOverflow: "",
        visible: false
      });
      function setText(text) {
        data.text = text;
      }
      function destroySelf() {
        const target = data.parent;
        if (!target.vLoadingAddClassList) {
          let loadingNumber = target.getAttribute("loading-number");
          loadingNumber = Number.parseInt(loadingNumber) - 1;
          if (!loadingNumber) {
            removeClass(target, ns2.bm("parent", "relative"));
            target.removeAttribute("loading-number");
          } else {
            target.setAttribute("loading-number", loadingNumber.toString());
          }
          removeClass(target, ns2.bm("parent", "hidden"));
        }
        removeElLoadingChild();
        loadingInstance.unmount();
      }
      function removeElLoadingChild() {
        var _a2, _b;
        (_b = (_a2 = vm.$el) == null ? void 0 : _a2.parentNode) == null ? void 0 : _b.removeChild(vm.$el);
      }
      function close2() {
        var _a2;
        if (options.beforeClose && !options.beforeClose())
          return;
        const target = data.parent;
        target.vLoadingAddClassList = void 0;
        afterLeaveFlag.value = true;
        clearTimeout(afterLeaveTimer);
        afterLeaveTimer = window.setTimeout(() => {
          if (afterLeaveFlag.value) {
            afterLeaveFlag.value = false;
            destroySelf();
          }
        }, 400);
        data.visible = false;
        (_a2 = options.closed) == null ? void 0 : _a2.call(options);
      }
      function handleAfterLeave() {
        if (!afterLeaveFlag.value)
          return;
        afterLeaveFlag.value = false;
        destroySelf();
      }
      const elLoadingComponent = {
        name: "ElLoading",
        setup() {
          return () => {
            const svg = data.spinner || data.svg;
            const spinner = h$1("svg", {
              class: "circular",
              viewBox: data.svgViewBox ? data.svgViewBox : "25 25 50 50",
              ...svg ? { innerHTML: svg } : {}
            }, [
              h$1("circle", {
                class: "path",
                cx: "50",
                cy: "50",
                r: "20",
                fill: "none"
              })
            ]);
            const spinnerText = data.text ? h$1("p", { class: ns2.b("text") }, [data.text]) : void 0;
            return h$1(Transition, {
              name: ns2.b("fade"),
              onAfterLeave: handleAfterLeave
            }, {
              default: withCtx(() => [
                withDirectives(createVNode("div", {
                  style: {
                    backgroundColor: data.background || ""
                  },
                  class: [
                    ns2.b("mask"),
                    data.customClass,
                    data.fullscreen ? "is-fullscreen" : ""
                  ]
                }, [
                  h$1("div", {
                    class: ns2.b("spinner")
                  }, [spinner, spinnerText])
                ]), [[vShow, data.visible]])
              ])
            });
          };
        }
      };
      const loadingInstance = createApp(elLoadingComponent);
      const vm = loadingInstance.mount(document.createElement("div"));
      return {
        ...toRefs(data),
        setText,
        removeElLoadingChild,
        close: close2,
        handleAfterLeave,
        vm,
        get $el() {
          return vm.$el;
        }
      };
    }
    let fullscreenInstance = void 0;
    const Loading = function(options = {}) {
      if (!isClient)
        return void 0;
      const resolved = resolveOptions(options);
      if (resolved.fullscreen && fullscreenInstance) {
        return fullscreenInstance;
      }
      const instance = createLoadingComponent({
        ...resolved,
        closed: () => {
          var _a2;
          (_a2 = resolved.closed) == null ? void 0 : _a2.call(resolved);
          if (resolved.fullscreen)
            fullscreenInstance = void 0;
        }
      });
      addStyle(resolved, resolved.parent, instance);
      addClassList(resolved, resolved.parent, instance);
      resolved.parent.vLoadingAddClassList = () => addClassList(resolved, resolved.parent, instance);
      let loadingNumber = resolved.parent.getAttribute("loading-number");
      if (!loadingNumber) {
        loadingNumber = "1";
      } else {
        loadingNumber = `${Number.parseInt(loadingNumber) + 1}`;
      }
      resolved.parent.setAttribute("loading-number", loadingNumber);
      resolved.parent.appendChild(instance.$el);
      nextTick(() => instance.visible.value = resolved.visible);
      if (resolved.fullscreen) {
        fullscreenInstance = instance;
      }
      return instance;
    };
    const resolveOptions = (options) => {
      var _a2, _b, _c, _d;
      let target;
      if (isString$3(options.target)) {
        target = (_a2 = document.querySelector(options.target)) != null ? _a2 : document.body;
      } else {
        target = options.target || document.body;
      }
      return {
        parent: target === document.body || options.body ? document.body : target,
        background: options.background || "",
        svg: options.svg || "",
        svgViewBox: options.svgViewBox || "",
        spinner: options.spinner || false,
        text: options.text || "",
        fullscreen: target === document.body && ((_b = options.fullscreen) != null ? _b : true),
        lock: (_c = options.lock) != null ? _c : false,
        customClass: options.customClass || "",
        visible: (_d = options.visible) != null ? _d : true,
        target
      };
    };
    const addStyle = async (options, parent, instance) => {
      const { nextZIndex } = useZIndex();
      const maskStyle = {};
      if (options.fullscreen) {
        instance.originalPosition.value = getStyle(document.body, "position");
        instance.originalOverflow.value = getStyle(document.body, "overflow");
        maskStyle.zIndex = nextZIndex();
      } else if (options.parent === document.body) {
        instance.originalPosition.value = getStyle(document.body, "position");
        await nextTick();
        for (const property of ["top", "left"]) {
          const scroll = property === "top" ? "scrollTop" : "scrollLeft";
          maskStyle[property] = `${options.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] - Number.parseInt(getStyle(document.body, `margin-${property}`), 10)}px`;
        }
        for (const property of ["height", "width"]) {
          maskStyle[property] = `${options.target.getBoundingClientRect()[property]}px`;
        }
      } else {
        instance.originalPosition.value = getStyle(parent, "position");
      }
      for (const [key, value] of Object.entries(maskStyle)) {
        instance.$el.style[key] = value;
      }
    };
    const addClassList = (options, parent, instance) => {
      const ns2 = useNamespace("loading");
      if (instance.originalPosition.value !== "absolute" && instance.originalPosition.value !== "fixed") {
        addClass(parent, ns2.bm("parent", "relative"));
      } else {
        removeClass(parent, ns2.bm("parent", "relative"));
      }
      if (options.fullscreen && options.lock) {
        addClass(parent, ns2.bm("parent", "hidden"));
      } else {
        removeClass(parent, ns2.bm("parent", "hidden"));
      }
    };
    const INSTANCE_KEY = Symbol("ElLoading");
    const createInstance$1 = (el, binding) => {
      var _a2, _b, _c, _d;
      const vm = binding.instance;
      const getBindingProp = (key) => isObject$4(binding.value) ? binding.value[key] : void 0;
      const resolveExpression = (key) => {
        const data = isString$3(key) && (vm == null ? void 0 : vm[key]) || key;
        if (data)
          return ref(data);
        else
          return data;
      };
      const getProp2 = (name) => resolveExpression(getBindingProp(name) || el.getAttribute(`element-loading-${hyphenate(name)}`));
      const fullscreen = (_a2 = getBindingProp("fullscreen")) != null ? _a2 : binding.modifiers.fullscreen;
      const options = {
        text: getProp2("text"),
        svg: getProp2("svg"),
        svgViewBox: getProp2("svgViewBox"),
        spinner: getProp2("spinner"),
        background: getProp2("background"),
        customClass: getProp2("customClass"),
        fullscreen,
        target: (_b = getBindingProp("target")) != null ? _b : fullscreen ? void 0 : el,
        body: (_c = getBindingProp("body")) != null ? _c : binding.modifiers.body,
        lock: (_d = getBindingProp("lock")) != null ? _d : binding.modifiers.lock
      };
      el[INSTANCE_KEY] = {
        options,
        instance: Loading(options)
      };
    };
    const updateOptions = (newOptions, originalOptions) => {
      for (const key of Object.keys(originalOptions)) {
        if (isRef(originalOptions[key]))
          originalOptions[key].value = newOptions[key];
      }
    };
    const vLoading = {
      mounted(el, binding) {
        if (binding.value) {
          createInstance$1(el, binding);
        }
      },
      updated(el, binding) {
        const instance = el[INSTANCE_KEY];
        if (binding.oldValue !== binding.value) {
          if (binding.value && !binding.oldValue) {
            createInstance$1(el, binding);
          } else if (binding.value && binding.oldValue) {
            if (isObject$4(binding.value))
              updateOptions(binding.value, instance.options);
          } else {
            instance == null ? void 0 : instance.instance.close();
          }
        }
      },
      unmounted(el) {
        var _a2;
        (_a2 = el[INSTANCE_KEY]) == null ? void 0 : _a2.instance.close();
      }
    };
    const ElLoading = {
      install(app2) {
        app2.directive("loading", vLoading);
        app2.config.globalProperties.$loading = Loading;
      },
      directive: vLoading,
      service: Loading
    };
    const messageTypes = ["success", "info", "warning", "error"];
    const messageDefaults = mutable({
      customClass: "",
      center: false,
      dangerouslyUseHTMLString: false,
      duration: 3e3,
      icon: void 0,
      id: "",
      message: "",
      onClose: void 0,
      showClose: false,
      type: "info",
      offset: 16,
      zIndex: 0,
      grouping: false,
      repeatNum: 1,
      appendTo: isClient ? document.body : void 0
    });
    const messageProps = buildProps({
      customClass: {
        type: String,
        default: messageDefaults.customClass
      },
      center: {
        type: Boolean,
        default: messageDefaults.center
      },
      dangerouslyUseHTMLString: {
        type: Boolean,
        default: messageDefaults.dangerouslyUseHTMLString
      },
      duration: {
        type: Number,
        default: messageDefaults.duration
      },
      icon: {
        type: iconPropType,
        default: messageDefaults.icon
      },
      id: {
        type: String,
        default: messageDefaults.id
      },
      message: {
        type: definePropType([
          String,
          Object,
          Function
        ]),
        default: messageDefaults.message
      },
      onClose: {
        type: definePropType(Function),
        required: false
      },
      showClose: {
        type: Boolean,
        default: messageDefaults.showClose
      },
      type: {
        type: String,
        values: messageTypes,
        default: messageDefaults.type
      },
      offset: {
        type: Number,
        default: messageDefaults.offset
      },
      zIndex: {
        type: Number,
        default: messageDefaults.zIndex
      },
      grouping: {
        type: Boolean,
        default: messageDefaults.grouping
      },
      repeatNum: {
        type: Number,
        default: messageDefaults.repeatNum
      }
    });
    const messageEmits = {
      destroy: () => true
    };
    const instances = shallowReactive([]);
    const getInstance = (id2) => {
      const idx = instances.findIndex((instance) => instance.id === id2);
      const current = instances[idx];
      let prev;
      if (idx > 0) {
        prev = instances[idx - 1];
      }
      return { current, prev };
    };
    const getLastOffset = (id2) => {
      const { prev } = getInstance(id2);
      if (!prev)
        return 0;
      return prev.vm.exposed.bottom.value;
    };
    const _hoisted_1$4 = ["id"];
    const _hoisted_2$4 = ["innerHTML"];
    const __default__$1 = {
      name: "ElMessage"
    };
    const _sfc_main$5 = /* @__PURE__ */ defineComponent({
      ...__default__$1,
      props: messageProps,
      emits: messageEmits,
      setup(__props, { expose }) {
        const props = __props;
        const { Close } = TypeComponents;
        const ns2 = useNamespace("message");
        const messageRef = ref();
        const visible = ref(false);
        const height = ref(0);
        let stopTimer = void 0;
        const badgeType = computed(() => props.type ? props.type === "error" ? "danger" : props.type : "info");
        const typeClass = computed(() => {
          const type2 = props.type;
          return { [ns2.bm("icon", type2)]: type2 && TypeComponentsMap[type2] };
        });
        const iconComponent = computed(() => props.icon || TypeComponentsMap[props.type] || "");
        const lastOffset = computed(() => getLastOffset(props.id));
        const offset2 = computed(() => props.offset + lastOffset.value);
        const bottom = computed(() => height.value + offset2.value);
        const customStyle = computed(() => ({
          top: `${offset2.value}px`,
          zIndex: props.zIndex
        }));
        function startTimer() {
          if (props.duration === 0)
            return;
          ({ stop: stopTimer } = useTimeoutFn(() => {
            close2();
          }, props.duration));
        }
        function clearTimer() {
          stopTimer == null ? void 0 : stopTimer();
        }
        function close2() {
          visible.value = false;
        }
        function keydown({ code: code2 }) {
          if (code2 === EVENT_CODE.esc) {
            close2();
          }
        }
        onMounted(() => {
          startTimer();
          visible.value = true;
        });
        watch(() => props.repeatNum, () => {
          clearTimer();
          startTimer();
        });
        useEventListener(document, "keydown", keydown);
        useResizeObserver(messageRef, () => {
          height.value = messageRef.value.getBoundingClientRect().height;
        });
        expose({
          visible,
          bottom,
          close: close2
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition, {
            name: unref(ns2).b("fade"),
            onBeforeLeave: _ctx.onClose,
            onAfterLeave: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("destroy")),
            persisted: ""
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                id: _ctx.id,
                ref_key: "messageRef",
                ref: messageRef,
                class: normalizeClass([
                  unref(ns2).b(),
                  { [unref(ns2).m(_ctx.type)]: _ctx.type && !_ctx.icon },
                  unref(ns2).is("center", _ctx.center),
                  unref(ns2).is("closable", _ctx.showClose),
                  _ctx.customClass
                ]),
                style: normalizeStyle(unref(customStyle)),
                role: "alert",
                onMouseenter: clearTimer,
                onMouseleave: startTimer
              }, [
                _ctx.repeatNum > 1 ? (openBlock(), createBlock(unref(ElBadge), {
                  key: 0,
                  value: _ctx.repeatNum,
                  type: unref(badgeType),
                  class: normalizeClass(unref(ns2).e("badge"))
                }, null, 8, ["value", "type", "class"])) : createCommentVNode("v-if", true),
                unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 1,
                  class: normalizeClass([unref(ns2).e("icon"), unref(typeClass)])
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true),
                renderSlot(_ctx.$slots, "default", {}, () => [
                  !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", {
                    key: 0,
                    class: normalizeClass(unref(ns2).e("content"))
                  }, toDisplayString$1(_ctx.message), 3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                    createBaseVNode("p", {
                      class: normalizeClass(unref(ns2).e("content")),
                      innerHTML: _ctx.message
                    }, null, 10, _hoisted_2$4)
                  ], 2112))
                ]),
                _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 2,
                  class: normalizeClass(unref(ns2).e("closeBtn")),
                  onClick: withModifiers(close2, ["stop"])
                }, {
                  default: withCtx(() => [
                    createVNode(unref(Close))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
              ], 46, _hoisted_1$4), [
                [vShow, visible.value]
              ])
            ]),
            _: 3
          }, 8, ["name", "onBeforeLeave"]);
        };
      }
    });
    var MessageConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);
    let seed$1 = 1;
    const normalizeOptions = (params) => {
      const options = !params || isString$3(params) || isVNode$1(params) || isFunction$4(params) ? { message: params } : params;
      const normalized = {
        ...messageDefaults,
        ...options
      };
      if (!normalized.appendTo) {
        normalized.appendTo = document.body;
      } else if (isString$3(normalized.appendTo)) {
        let appendTo = document.querySelector(normalized.appendTo);
        if (!isElement$1(appendTo)) {
          appendTo = document.body;
        }
        normalized.appendTo = appendTo;
      }
      return normalized;
    };
    const closeMessage = (instance) => {
      const idx = instances.indexOf(instance);
      if (idx === -1)
        return;
      instances.splice(idx, 1);
      const { handler } = instance;
      handler.close();
    };
    const createMessage = ({ appendTo, ...options }, context) => {
      const { nextZIndex } = useZIndex();
      const id2 = `message_${seed$1++}`;
      const userOnClose = options.onClose;
      const container = document.createElement("div");
      const props = {
        ...options,
        zIndex: nextZIndex() + options.zIndex,
        id: id2,
        onClose: () => {
          userOnClose == null ? void 0 : userOnClose();
          closeMessage(instance);
        },
        onDestroy: () => {
          render(null, container);
        }
      };
      const vnode = createVNode(MessageConstructor, props, isFunction$4(props.message) || isVNode$1(props.message) ? { default: props.message } : null);
      vnode.appContext = context || message._context;
      render(vnode, container);
      appendTo.appendChild(container.firstElementChild);
      const vm = vnode.component;
      const handler = {
        close: () => {
          vm.exposed.visible.value = false;
        }
      };
      const instance = {
        id: id2,
        vnode,
        vm,
        handler,
        props: vnode.component.props
      };
      return instance;
    };
    const message = (options = {}, context) => {
      if (!isClient)
        return { close: () => void 0 };
      if (isNumber$2(messageConfig.max) && instances.length >= messageConfig.max) {
        return { close: () => void 0 };
      }
      const normalized = normalizeOptions(options);
      if (normalized.grouping && instances.length) {
        const instance2 = instances.find(({ vnode: vm }) => {
          var _a2;
          return ((_a2 = vm.props) == null ? void 0 : _a2.message) === normalized.message;
        });
        if (instance2) {
          instance2.props.repeatNum += 1;
          instance2.props.type = normalized.type;
          return instance2.handler;
        }
      }
      const instance = createMessage(normalized, context);
      instances.push(instance);
      return instance.handler;
    };
    messageTypes.forEach((type2) => {
      message[type2] = (options = {}, appContext) => {
        const normalized = normalizeOptions(options);
        return message({ ...normalized, type: type2 }, appContext);
      };
    });
    function closeAll$1(type2) {
      for (const instance of instances) {
        if (!type2 || type2 === instance.props.type) {
          instance.handler.close();
        }
      }
    }
    message.closeAll = closeAll$1;
    message._context = null;
    const ElMessage = withInstallFunction(message, "$message");
    const _sfc_main$4 = defineComponent({
      name: "ElMessageBox",
      directives: {
        TrapFocus
      },
      components: {
        ElButton,
        ElFocusTrap,
        ElInput,
        ElOverlay,
        ElIcon,
        ...TypeComponents
      },
      inheritAttrs: false,
      props: {
        buttonSize: {
          type: String,
          validator: isValidComponentSize
        },
        modal: {
          type: Boolean,
          default: true
        },
        lockScroll: {
          type: Boolean,
          default: true
        },
        showClose: {
          type: Boolean,
          default: true
        },
        closeOnClickModal: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        closeOnHashChange: {
          type: Boolean,
          default: true
        },
        center: Boolean,
        draggable: Boolean,
        roundButton: {
          default: false,
          type: Boolean
        },
        container: {
          type: String,
          default: "body"
        },
        boxType: {
          type: String,
          default: ""
        }
      },
      emits: ["vanish", "action"],
      setup(props, { emit }) {
        const { t } = useLocale();
        const ns2 = useNamespace("message-box");
        const visible = ref(false);
        const { nextZIndex } = useZIndex();
        const state = reactive({
          autofocus: true,
          beforeClose: null,
          callback: null,
          cancelButtonText: "",
          cancelButtonClass: "",
          confirmButtonText: "",
          confirmButtonClass: "",
          customClass: "",
          customStyle: {},
          dangerouslyUseHTMLString: false,
          distinguishCancelAndClose: false,
          icon: "",
          inputPattern: null,
          inputPlaceholder: "",
          inputType: "text",
          inputValue: null,
          inputValidator: null,
          inputErrorMessage: "",
          message: null,
          modalFade: true,
          modalClass: "",
          showCancelButton: false,
          showConfirmButton: true,
          type: "",
          title: void 0,
          showInput: false,
          action: "",
          confirmButtonLoading: false,
          cancelButtonLoading: false,
          confirmButtonDisabled: false,
          editorErrorMessage: "",
          validateError: false,
          zIndex: nextZIndex()
        });
        const typeClass = computed(() => {
          const type2 = state.type;
          return { [ns2.bm("icon", type2)]: type2 && TypeComponentsMap[type2] };
        });
        const contentId = useId();
        const inputId = useId();
        const btnSize = useSize(computed(() => props.buttonSize), { prop: true, form: true, formItem: true });
        const iconComponent = computed(() => state.icon || TypeComponentsMap[state.type] || "");
        const hasMessage = computed(() => !!state.message);
        const rootRef = ref();
        const headerRef = ref();
        const focusStartRef = ref();
        const inputRef = ref();
        const confirmRef = ref();
        const confirmButtonClasses = computed(() => state.confirmButtonClass);
        watch(() => state.inputValue, async (val) => {
          await nextTick();
          if (props.boxType === "prompt" && val !== null) {
            validate();
          }
        }, { immediate: true });
        watch(() => visible.value, (val) => {
          var _a2, _b;
          if (val) {
            if (props.boxType !== "prompt") {
              if (state.autofocus) {
                focusStartRef.value = (_b = (_a2 = confirmRef.value) == null ? void 0 : _a2.$el) != null ? _b : rootRef.value;
              } else {
                focusStartRef.value = rootRef.value;
              }
            }
            state.zIndex = nextZIndex();
          }
          if (props.boxType !== "prompt")
            return;
          if (val) {
            nextTick().then(() => {
              var _a22;
              if (inputRef.value && inputRef.value.$el) {
                if (state.autofocus) {
                  focusStartRef.value = (_a22 = getInputElement()) != null ? _a22 : rootRef.value;
                } else {
                  focusStartRef.value = rootRef.value;
                }
              }
            });
          } else {
            state.editorErrorMessage = "";
            state.validateError = false;
          }
        });
        const draggable2 = computed(() => props.draggable);
        useDraggable(rootRef, headerRef, draggable2);
        onMounted(async () => {
          await nextTick();
          if (props.closeOnHashChange) {
            window.addEventListener("hashchange", doClose);
          }
        });
        onBeforeUnmount(() => {
          if (props.closeOnHashChange) {
            window.removeEventListener("hashchange", doClose);
          }
        });
        function doClose() {
          if (!visible.value)
            return;
          visible.value = false;
          nextTick(() => {
            if (state.action)
              emit("action", state.action);
          });
        }
        const handleWrapperClick = () => {
          if (props.closeOnClickModal) {
            handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
          }
        };
        const overlayEvent = useSameTarget(handleWrapperClick);
        const handleInputEnter = (e) => {
          if (state.inputType !== "textarea") {
            e.preventDefault();
            return handleAction("confirm");
          }
        };
        const handleAction = (action) => {
          var _a2;
          if (props.boxType === "prompt" && action === "confirm" && !validate()) {
            return;
          }
          state.action = action;
          if (state.beforeClose) {
            (_a2 = state.beforeClose) == null ? void 0 : _a2.call(state, action, state, doClose);
          } else {
            doClose();
          }
        };
        const validate = () => {
          if (props.boxType === "prompt") {
            const inputPattern = state.inputPattern;
            if (inputPattern && !inputPattern.test(state.inputValue || "")) {
              state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
              state.validateError = true;
              return false;
            }
            const inputValidator = state.inputValidator;
            if (typeof inputValidator === "function") {
              const validateResult = inputValidator(state.inputValue);
              if (validateResult === false) {
                state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
                state.validateError = true;
                return false;
              }
              if (typeof validateResult === "string") {
                state.editorErrorMessage = validateResult;
                state.validateError = true;
                return false;
              }
            }
          }
          state.editorErrorMessage = "";
          state.validateError = false;
          return true;
        };
        const getInputElement = () => {
          const inputRefs = inputRef.value.$refs;
          return inputRefs.input || inputRefs.textarea;
        };
        const handleClose = () => {
          handleAction("close");
        };
        const onCloseRequested = () => {
          if (props.closeOnPressEscape) {
            handleClose();
          }
        };
        if (props.lockScroll) {
          useLockscreen(visible);
        }
        useRestoreActive(visible);
        return {
          ...toRefs(state),
          ns: ns2,
          overlayEvent,
          visible,
          hasMessage,
          typeClass,
          contentId,
          inputId,
          btnSize,
          iconComponent,
          confirmButtonClasses,
          rootRef,
          focusStartRef,
          headerRef,
          inputRef,
          confirmRef,
          doClose,
          handleClose,
          onCloseRequested,
          handleWrapperClick,
          handleInputEnter,
          handleAction,
          t
        };
      }
    });
    const _hoisted_1$3 = ["aria-label", "aria-describedby"];
    const _hoisted_2$3 = ["aria-label"];
    const _hoisted_3$3 = ["id"];
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_icon = resolveComponent("el-icon");
      const _component_close = resolveComponent("close");
      const _component_el_input = resolveComponent("el-input");
      const _component_el_button = resolveComponent("el-button");
      const _component_el_focus_trap = resolveComponent("el-focus-trap");
      const _component_el_overlay = resolveComponent("el-overlay");
      return openBlock(), createBlock(Transition, {
        name: "fade-in-linear",
        onAfterLeave: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("vanish")),
        persisted: ""
      }, {
        default: withCtx(() => [
          withDirectives(createVNode(_component_el_overlay, {
            "z-index": _ctx.zIndex,
            "overlay-class": [_ctx.ns.is("message-box"), _ctx.modalClass],
            mask: _ctx.modal
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                role: "dialog",
                "aria-label": _ctx.title,
                "aria-modal": "true",
                "aria-describedby": !_ctx.showInput ? _ctx.contentId : void 0,
                class: normalizeClass(`${_ctx.ns.namespace.value}-overlay-message-box`),
                onClick: _cache[8] || (_cache[8] = (...args) => _ctx.overlayEvent.onClick && _ctx.overlayEvent.onClick(...args)),
                onMousedown: _cache[9] || (_cache[9] = (...args) => _ctx.overlayEvent.onMousedown && _ctx.overlayEvent.onMousedown(...args)),
                onMouseup: _cache[10] || (_cache[10] = (...args) => _ctx.overlayEvent.onMouseup && _ctx.overlayEvent.onMouseup(...args))
              }, [
                createVNode(_component_el_focus_trap, {
                  loop: "",
                  trapped: _ctx.visible,
                  "focus-trap-el": _ctx.rootRef,
                  "focus-start-el": _ctx.focusStartRef,
                  onReleaseRequested: _ctx.onCloseRequested
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      ref: "rootRef",
                      class: normalizeClass([
                        _ctx.ns.b(),
                        _ctx.customClass,
                        _ctx.ns.is("draggable", _ctx.draggable),
                        { [_ctx.ns.m("center")]: _ctx.center }
                      ]),
                      style: normalizeStyle(_ctx.customStyle),
                      tabindex: "-1",
                      onClick: _cache[7] || (_cache[7] = withModifiers(() => {
                      }, ["stop"]))
                    }, [
                      _ctx.title !== null && _ctx.title !== void 0 ? (openBlock(), createElementBlock("div", {
                        key: 0,
                        ref: "headerRef",
                        class: normalizeClass(_ctx.ns.e("header"))
                      }, [
                        createBaseVNode("div", {
                          class: normalizeClass(_ctx.ns.e("title"))
                        }, [
                          _ctx.iconComponent && _ctx.center ? (openBlock(), createBlock(_component_el_icon, {
                            key: 0,
                            class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                          }, {
                            default: withCtx(() => [
                              (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                            ]),
                            _: 1
                          }, 8, ["class"])) : createCommentVNode("v-if", true),
                          createBaseVNode("span", null, toDisplayString$1(_ctx.title), 1)
                        ], 2),
                        _ctx.showClose ? (openBlock(), createElementBlock("button", {
                          key: 0,
                          type: "button",
                          class: normalizeClass(_ctx.ns.e("headerbtn")),
                          "aria-label": _ctx.t("el.messagebox.close"),
                          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel")),
                          onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                        }, [
                          createVNode(_component_el_icon, {
                            class: normalizeClass(_ctx.ns.e("close"))
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_close)
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ], 42, _hoisted_2$3)) : createCommentVNode("v-if", true)
                      ], 2)) : createCommentVNode("v-if", true),
                      createBaseVNode("div", {
                        id: _ctx.contentId,
                        class: normalizeClass(_ctx.ns.e("content"))
                      }, [
                        createBaseVNode("div", {
                          class: normalizeClass(_ctx.ns.e("container"))
                        }, [
                          _ctx.iconComponent && !_ctx.center && _ctx.hasMessage ? (openBlock(), createBlock(_component_el_icon, {
                            key: 0,
                            class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                          }, {
                            default: withCtx(() => [
                              (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                            ]),
                            _: 1
                          }, 8, ["class"])) : createCommentVNode("v-if", true),
                          _ctx.hasMessage ? (openBlock(), createElementBlock("div", {
                            key: 1,
                            class: normalizeClass(_ctx.ns.e("message"))
                          }, [
                            renderSlot(_ctx.$slots, "default", {}, () => [
                              !_ctx.dangerouslyUseHTMLString ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                key: 0,
                                for: _ctx.showInput ? _ctx.inputId : void 0
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString$1(!_ctx.dangerouslyUseHTMLString ? _ctx.message : ""), 1)
                                ]),
                                _: 1
                              }, 8, ["for"])) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                key: 1,
                                for: _ctx.showInput ? _ctx.inputId : void 0,
                                innerHTML: _ctx.message
                              }, null, 8, ["for", "innerHTML"]))
                            ])
                          ], 2)) : createCommentVNode("v-if", true)
                        ], 2),
                        withDirectives(createBaseVNode("div", {
                          class: normalizeClass(_ctx.ns.e("input"))
                        }, [
                          createVNode(_component_el_input, {
                            id: _ctx.inputId,
                            ref: "inputRef",
                            modelValue: _ctx.inputValue,
                            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
                            type: _ctx.inputType,
                            placeholder: _ctx.inputPlaceholder,
                            "aria-invalid": _ctx.validateError,
                            class: normalizeClass({ invalid: _ctx.validateError }),
                            onKeydown: withKeys(_ctx.handleInputEnter, ["enter"])
                          }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("errormsg")),
                            style: normalizeStyle({
                              visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                            })
                          }, toDisplayString$1(_ctx.editorErrorMessage), 7)
                        ], 2), [
                          [vShow, _ctx.showInput]
                        ])
                      ], 10, _hoisted_3$3),
                      createBaseVNode("div", {
                        class: normalizeClass(_ctx.ns.e("btns"))
                      }, [
                        _ctx.showCancelButton ? (openBlock(), createBlock(_component_el_button, {
                          key: 0,
                          loading: _ctx.cancelButtonLoading,
                          class: normalizeClass([_ctx.cancelButtonClass]),
                          round: _ctx.roundButton,
                          size: _ctx.btnSize,
                          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleAction("cancel")),
                          onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.handleAction("cancel"), ["prevent"]), ["enter"]))
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString$1(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                          ]),
                          _: 1
                        }, 8, ["loading", "class", "round", "size"])) : createCommentVNode("v-if", true),
                        withDirectives(createVNode(_component_el_button, {
                          ref: "confirmRef",
                          type: "primary",
                          loading: _ctx.confirmButtonLoading,
                          class: normalizeClass([_ctx.confirmButtonClasses]),
                          round: _ctx.roundButton,
                          disabled: _ctx.confirmButtonDisabled,
                          size: _ctx.btnSize,
                          onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleAction("confirm")),
                          onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.handleAction("confirm"), ["prevent"]), ["enter"]))
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString$1(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                          ]),
                          _: 1
                        }, 8, ["loading", "class", "round", "disabled", "size"]), [
                          [vShow, _ctx.showConfirmButton]
                        ])
                      ], 2)
                    ], 6)
                  ]),
                  _: 3
                }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
              ], 42, _hoisted_1$3)
            ]),
            _: 3
          }, 8, ["z-index", "overlay-class", "mask"]), [
            [vShow, _ctx.visible]
          ])
        ]),
        _: 3
      });
    }
    var MessageBoxConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/message-box/src/index.vue"]]);
    const messageInstance = /* @__PURE__ */ new Map();
    const initInstance = (props, container, appContext = null) => {
      const vnode = h$1(MessageBoxConstructor, props);
      vnode.appContext = appContext;
      render(vnode, container);
      document.body.appendChild(container.firstElementChild);
      return vnode.component;
    };
    const genContainer = () => {
      return document.createElement("div");
    };
    const showMessage = (options, appContext) => {
      const container = genContainer();
      options.onVanish = () => {
        render(null, container);
        messageInstance.delete(vm);
      };
      options.onAction = (action) => {
        const currentMsg = messageInstance.get(vm);
        let resolve2;
        if (options.showInput) {
          resolve2 = { value: vm.inputValue, action };
        } else {
          resolve2 = action;
        }
        if (options.callback) {
          options.callback(resolve2, instance.proxy);
        } else {
          if (action === "cancel" || action === "close") {
            if (options.distinguishCancelAndClose && action !== "cancel") {
              currentMsg.reject("close");
            } else {
              currentMsg.reject("cancel");
            }
          } else {
            currentMsg.resolve(resolve2);
          }
        }
      };
      const instance = initInstance(options, container, appContext);
      const vm = instance.proxy;
      for (const prop in options) {
        if (hasOwn$1(options, prop) && !hasOwn$1(vm.$props, prop)) {
          vm[prop] = options[prop];
        }
      }
      watch(() => vm.message, (newVal, oldVal) => {
        if (isVNode$1(newVal)) {
          instance.slots.default = () => [newVal];
        } else if (isVNode$1(oldVal) && !isVNode$1(newVal)) {
          delete instance.slots.default;
        }
      }, {
        immediate: true
      });
      vm.visible = true;
      return vm;
    };
    function MessageBox(options, appContext = null) {
      if (!isClient)
        return Promise.reject();
      let callback;
      if (isString$3(options) || isVNode$1(options)) {
        options = {
          message: options
        };
      } else {
        callback = options.callback;
      }
      return new Promise((resolve2, reject) => {
        const vm = showMessage(options, appContext != null ? appContext : MessageBox._context);
        messageInstance.set(vm, {
          options,
          callback,
          resolve: resolve2,
          reject
        });
      });
    }
    const MESSAGE_BOX_VARIANTS = ["alert", "confirm", "prompt"];
    const MESSAGE_BOX_DEFAULT_OPTS = {
      alert: { closeOnPressEscape: false, closeOnClickModal: false },
      confirm: { showCancelButton: true },
      prompt: { showCancelButton: true, showInput: true }
    };
    MESSAGE_BOX_VARIANTS.forEach((boxType) => {
      MessageBox[boxType] = messageBoxFactory(boxType);
    });
    function messageBoxFactory(boxType) {
      return (message2, title, options, appContext) => {
        let titleOrOpts = "";
        if (isObject$4(title)) {
          options = title;
          titleOrOpts = "";
        } else if (isUndefined$1(title)) {
          titleOrOpts = "";
        } else {
          titleOrOpts = title;
        }
        return MessageBox(Object.assign({
          title: titleOrOpts,
          message: message2,
          type: "",
          ...MESSAGE_BOX_DEFAULT_OPTS[boxType]
        }, options, {
          boxType
        }), appContext);
      };
    }
    MessageBox.close = () => {
      messageInstance.forEach((_2, vm) => {
        vm.doClose();
      });
      messageInstance.clear();
    };
    MessageBox._context = null;
    const _MessageBox = MessageBox;
    _MessageBox.install = (app2) => {
      _MessageBox._context = app2._context;
      app2.config.globalProperties.$msgbox = _MessageBox;
      app2.config.globalProperties.$messageBox = _MessageBox;
      app2.config.globalProperties.$alert = _MessageBox.alert;
      app2.config.globalProperties.$confirm = _MessageBox.confirm;
      app2.config.globalProperties.$prompt = _MessageBox.prompt;
    };
    const ElMessageBox = _MessageBox;
    const notificationTypes = [
      "success",
      "info",
      "warning",
      "error"
    ];
    const notificationProps = buildProps({
      customClass: {
        type: String,
        default: ""
      },
      dangerouslyUseHTMLString: {
        type: Boolean,
        default: false
      },
      duration: {
        type: Number,
        default: 4500
      },
      icon: {
        type: iconPropType
      },
      id: {
        type: String,
        default: ""
      },
      message: {
        type: definePropType([String, Object]),
        default: ""
      },
      offset: {
        type: Number,
        default: 0
      },
      onClick: {
        type: definePropType(Function),
        default: () => void 0
      },
      onClose: {
        type: definePropType(Function),
        required: true
      },
      position: {
        type: String,
        values: ["top-right", "top-left", "bottom-right", "bottom-left"],
        default: "top-right"
      },
      showClose: {
        type: Boolean,
        default: true
      },
      title: {
        type: String,
        default: ""
      },
      type: {
        type: String,
        values: [...notificationTypes, ""],
        default: ""
      },
      zIndex: {
        type: Number,
        default: 0
      }
    });
    const notificationEmits = {
      destroy: () => true
    };
    const _hoisted_1$2 = ["id"];
    const _hoisted_2$2 = ["textContent"];
    const _hoisted_3$2 = { key: 0 };
    const _hoisted_4$2 = ["innerHTML"];
    const __default__ = {
      name: "ElNotification"
    };
    const _sfc_main$3 = /* @__PURE__ */ defineComponent({
      ...__default__,
      props: notificationProps,
      emits: notificationEmits,
      setup(__props, { expose }) {
        const props = __props;
        const ns2 = useNamespace("notification");
        const { Close } = CloseComponents;
        const visible = ref(false);
        let timer = void 0;
        const typeClass = computed(() => {
          const type2 = props.type;
          return type2 && TypeComponentsMap[props.type] ? ns2.m(type2) : "";
        });
        const iconComponent = computed(() => {
          if (!props.type)
            return props.icon;
          return TypeComponentsMap[props.type] || props.icon;
        });
        const horizontalClass = computed(() => props.position.endsWith("right") ? "right" : "left");
        const verticalProperty = computed(() => props.position.startsWith("top") ? "top" : "bottom");
        const positionStyle = computed(() => {
          return {
            [verticalProperty.value]: `${props.offset}px`,
            zIndex: props.zIndex
          };
        });
        function startTimer() {
          if (props.duration > 0) {
            ({ stop: timer } = useTimeoutFn(() => {
              if (visible.value)
                close2();
            }, props.duration));
          }
        }
        function clearTimer() {
          timer == null ? void 0 : timer();
        }
        function close2() {
          visible.value = false;
        }
        function onKeydown({ code: code2 }) {
          if (code2 === EVENT_CODE.delete || code2 === EVENT_CODE.backspace) {
            clearTimer();
          } else if (code2 === EVENT_CODE.esc) {
            if (visible.value) {
              close2();
            }
          } else {
            startTimer();
          }
        }
        onMounted(() => {
          startTimer();
          visible.value = true;
        });
        useEventListener(document, "keydown", onKeydown);
        expose({
          visible,
          close: close2
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition, {
            name: unref(ns2).b("fade"),
            onBeforeLeave: _ctx.onClose,
            onAfterLeave: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("destroy")),
            persisted: ""
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                id: _ctx.id,
                class: normalizeClass([unref(ns2).b(), _ctx.customClass, unref(horizontalClass)]),
                style: normalizeStyle(unref(positionStyle)),
                role: "alert",
                onMouseenter: clearTimer,
                onMouseleave: startTimer,
                onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
              }, [
                unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass([unref(ns2).e("icon"), unref(typeClass)])
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns2).e("group"))
                }, [
                  createBaseVNode("h2", {
                    class: normalizeClass(unref(ns2).e("title")),
                    textContent: toDisplayString$1(_ctx.title)
                  }, null, 10, _hoisted_2$2),
                  withDirectives(createBaseVNode("div", {
                    class: normalizeClass(unref(ns2).e("content")),
                    style: normalizeStyle(!!_ctx.title ? void 0 : { margin: 0 })
                  }, [
                    renderSlot(_ctx.$slots, "default", {}, () => [
                      !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", _hoisted_3$2, toDisplayString$1(_ctx.message), 1)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                        createBaseVNode("p", { innerHTML: _ctx.message }, null, 8, _hoisted_4$2)
                      ], 2112))
                    ])
                  ], 6), [
                    [vShow, _ctx.message]
                  ]),
                  _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns2).e("closeBtn")),
                    onClick: withModifiers(close2, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(Close))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 2)
              ], 46, _hoisted_1$2), [
                [vShow, visible.value]
              ])
            ]),
            _: 3
          }, 8, ["name", "onBeforeLeave"]);
        };
      }
    });
    var NotificationConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/notification/src/notification.vue"]]);
    const notifications = {
      "top-left": [],
      "top-right": [],
      "bottom-left": [],
      "bottom-right": []
    };
    const GAP_SIZE = 16;
    let seed = 1;
    const notify = function(options = {}, context = null) {
      if (!isClient)
        return { close: () => void 0 };
      if (typeof options === "string" || isVNode$1(options)) {
        options = { message: options };
      }
      const position = options.position || "top-right";
      let verticalOffset = options.offset || 0;
      notifications[position].forEach(({ vm: vm2 }) => {
        var _a2;
        verticalOffset += (((_a2 = vm2.el) == null ? void 0 : _a2.offsetHeight) || 0) + GAP_SIZE;
      });
      verticalOffset += GAP_SIZE;
      const { nextZIndex } = useZIndex();
      const id2 = `notification_${seed++}`;
      const userOnClose = options.onClose;
      const props = {
        ...options,
        zIndex: nextZIndex(),
        offset: verticalOffset,
        id: id2,
        onClose: () => {
          close(id2, position, userOnClose);
        }
      };
      let appendTo = document.body;
      if (isElement$1(options.appendTo)) {
        appendTo = options.appendTo;
      } else if (isString$3(options.appendTo)) {
        appendTo = document.querySelector(options.appendTo);
      }
      if (!isElement$1(appendTo)) {
        appendTo = document.body;
      }
      const container = document.createElement("div");
      const vm = createVNode(NotificationConstructor, props, isVNode$1(props.message) ? {
        default: () => props.message
      } : null);
      vm.appContext = context != null ? context : notify._context;
      vm.props.onDestroy = () => {
        render(null, container);
      };
      render(vm, container);
      notifications[position].push({ vm });
      appendTo.appendChild(container.firstElementChild);
      return {
        close: () => {
          vm.component.exposed.visible.value = false;
        }
      };
    };
    notificationTypes.forEach((type2) => {
      notify[type2] = (options = {}) => {
        if (typeof options === "string" || isVNode$1(options)) {
          options = {
            message: options
          };
        }
        return notify({
          ...options,
          type: type2
        });
      };
    });
    function close(id2, position, userOnClose) {
      const orientedNotifications = notifications[position];
      const idx = orientedNotifications.findIndex(({ vm: vm2 }) => {
        var _a2;
        return ((_a2 = vm2.component) == null ? void 0 : _a2.props.id) === id2;
      });
      if (idx === -1)
        return;
      const { vm } = orientedNotifications[idx];
      if (!vm)
        return;
      userOnClose == null ? void 0 : userOnClose(vm);
      const removedHeight = vm.el.offsetHeight;
      const verticalPos = position.split("-")[0];
      orientedNotifications.splice(idx, 1);
      const len = orientedNotifications.length;
      if (len < 1)
        return;
      for (let i = idx; i < len; i++) {
        const { el, component: component2 } = orientedNotifications[i].vm;
        const pos = Number.parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;
        component2.props.offset = pos;
      }
    }
    function closeAll() {
      for (const orientedNotifications of Object.values(notifications)) {
        orientedNotifications.forEach(({ vm }) => {
          vm.component.exposed.visible.value = false;
        });
      }
    }
    notify.closeAll = closeAll;
    notify._context = null;
    const ElNotification = withInstallFunction(notify, "$notify");
    var Plugins = [
      ElInfiniteScroll,
      ElLoading,
      ElMessage,
      ElMessageBox,
      ElNotification,
      ElPopoverDirective
    ];
    var installer = makeInstaller([...Components, ...Plugins]);
    const index = "";
    const base = "";
    const elConfigProvider = "";
    const elRadioGroup = "";
    const elRadio = "";
    const elDivider = "";
    const elInput = "";
    const elDialog = "";
    const elOverlay = "";
    const elContainer = "";
    const elAside = "";
    const elFooter = "";
    const elHeader = "";
    const elMain = "";
    const elTable = "";
    const elCheckbox = "";
    const elTag = "";
    const elTooltip = "";
    const elPopper = "";
    const elScrollbar = "";
    const elTableColumn = "";
    const elButton = "";
    const elIcon = "";
    const elLink = "";
    const elAvatar = "";
    function bind(fn2, thisArg) {
      return function wrap() {
        return fn2.apply(thisArg, arguments);
      };
    }
    const { toString } = Object.prototype;
    const { getPrototypeOf } = Object;
    const kindOf = ((cache2) => (thing) => {
      const str = toString.call(thing);
      return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    const kindOfTest = (type2) => {
      type2 = type2.toLowerCase();
      return (thing) => kindOf(thing) === type2;
    };
    const typeOfTest = (type2) => (thing) => typeof thing === type2;
    const { isArray: isArray$1 } = Array;
    const isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    const isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    const isString$1 = typeOfTest("string");
    const isFunction$1 = typeOfTest("function");
    const isNumber$1 = typeOfTest("number");
    const isObject$1 = (thing) => thing !== null && typeof thing === "object";
    const isBoolean$1 = (thing) => thing === true || thing === false;
    const isPlainObject$1 = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    const isDate$1 = kindOfTest("Date");
    const isFile = kindOfTest("File");
    const isBlob = kindOfTest("Blob");
    const isFileList = kindOfTest("FileList");
    const isStream = (val) => isObject$1(val) && isFunction$1(val.pipe);
    const isFormData = (thing) => {
      const pattern2 = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern2 || isFunction$1(thing.toString) && thing.toString() === pattern2);
    };
    const isURLSearchParams = kindOfTest("URLSearchParams");
    const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn2, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l2;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray$1(obj)) {
        for (i = 0, l2 = obj.length; i < l2; i++) {
          fn2.call(null, obj[i], i, obj);
        }
      } else {
        const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys2.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys2[i];
          fn2.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys2 = Object.keys(obj);
      let i = keys2.length;
      let _key;
      while (i-- > 0) {
        _key = keys2[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    const _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    const isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue2 = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject$1(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray$1(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l2 = arguments.length; i < l2; i++) {
        arguments[i] && forEach(arguments[i], assignValue2);
      }
      return result;
    }
    const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
      forEach(b2, (val, key) => {
        if (thisArg && isFunction$1(val)) {
          a2[key] = bind(val, thisArg);
        } else {
          a2[key] = val;
        }
      }, { allOwnKeys });
      return a2;
    };
    const stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    const inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    const endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    const toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray$1(thing))
        return thing;
      let i = thing.length;
      if (!isNumber$1(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    const isTypedArray = ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    const forEachEntry = (obj, fn2) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn2.call(obj, pair[0], pair[1]);
      }
    };
    const matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    const isHTMLForm = kindOfTest("HTMLFormElement");
    const toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer2(m2, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    const hasOwnProperty$1 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    const isRegExp$1 = kindOfTest("RegExp");
    const reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        if (reducer(descriptor, name, obj) !== false) {
          reducedDescriptors[name] = descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    const freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction$1(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    const toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray$1(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    const noop = () => {
    };
    const toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    const ALPHA = "abcdefghijklmnopqrstuvwxyz";
    const DIGIT = "0123456789";
    const ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size2--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$1(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    const toJSONObject = (obj) => {
      const stack2 = new Array(10);
      const visit = (source, i) => {
        if (isObject$1(source)) {
          if (stack2.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack2[i] = source;
            const target = isArray$1(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack2[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    const utils = {
      isArray: isArray$1,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString$1,
      isNumber: isNumber$1,
      isBoolean: isBoolean$1,
      isObject: isObject$1,
      isPlainObject: isPlainObject$1,
      isUndefined,
      isDate: isDate$1,
      isFile,
      isBlob,
      isRegExp: isRegExp$1,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty: hasOwnProperty$1,
      hasOwnProp: hasOwnProperty$1,
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject
    };
    function AxiosError(message2, code2, config, request2, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message2;
      this.name = "AxiosError";
      code2 && (this.code = code2);
      config && (this.config = config);
      request2 && (this.request = request2);
      response && (this.response = response);
    }
    utils.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: utils.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    const prototype$1 = AxiosError.prototype;
    const descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
    ].forEach((code2) => {
      descriptors[code2] = { value: code2 };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code2, config, request2, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code2, config, request2, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    const httpAdapter = null;
    function isVisitable(thing) {
      return utils.isPlainObject(thing) || utils.isArray(thing);
    }
    function removeBrackets(key) {
      return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils.isArray(arr) && !arr.some(isVisitable);
    }
    const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils.isSpecCompliantForm(formData);
      if (!utils.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index2) {
              !(utils.isUndefined(el) || el === null) && formData.append(
                indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack2 = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils.isUndefined(value))
          return;
        if (stack2.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack2.push(value);
        utils.forEach(value, function each(el, key) {
          const result = !(utils.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack2.pop();
      }
      if (!utils.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    const prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    class InterceptorManager {
      constructor() {
        this.handlers = [];
      }
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      eject(id2) {
        if (this.handlers[id2]) {
          this.handlers[id2] = null;
        }
      }
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      forEach(fn2) {
        utils.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn2(h2);
          }
        });
      }
    }
    const InterceptorManager$1 = InterceptorManager;
    const transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    const FormData$1 = FormData;
    const isStandardBrowserEnv = (() => {
      let product;
      if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    })();
    const isStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    const platform = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob
      },
      isStandardBrowserEnv,
      isStandardBrowserWebWorkerEnv,
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys2 = Object.keys(arr);
      let i;
      const len = keys2.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys2[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index2) {
        let name = path[index2++];
        const isNumericKey = Number.isFinite(+name);
        const isLast = index2 >= path.length;
        name = !name && utils.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index2);
        if (result && utils.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
        const obj = {};
        utils.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    const DEFAULT_CONTENT_TYPE = {
      "Content-Type": void 0
    };
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    const defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils.isObject(data);
        if (isObjectPayload && utils.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils.isFormData(data);
        if (isFormData2) {
          if (!hasJSONContentType) {
            return data;
          }
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method2) {
      defaults.headers[method2] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
      defaults.headers[method2] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    const defaults$1 = defaults;
    const ignoreDuplicateOf = utils.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    const parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    const $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    function isValidHeaderName(str) {
      return /^[-_a-zA-Z]+$/.test(str.trim());
    }
    function matchHeaderValue(context, value, header, filter) {
      if (utils.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (!utils.isString(value))
        return;
      if (utils.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys2 = Object.keys(this);
        let i = keys2.length;
        let deleted = false;
        while (i--) {
          const key = keys2[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format2) {
        const self2 = this;
        const headers = {};
        utils.forEach(this, (value, header) => {
          const key = utils.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format2 ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed2 = new this(first);
        targets.forEach((target) => computed2.set(target));
        return computed2;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    }
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils.freezeMethods(AxiosHeaders.prototype);
    utils.freezeMethods(AxiosHeaders);
    const AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils.forEach(fns, function transform2(fn2) {
        data = fn2.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message2, config, request2) {
      AxiosError.call(this, message2 == null ? "canceled" : message2, AxiosError.ERR_CANCELED, config, request2);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve2, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    const cookies = platform.isStandardBrowserEnv ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          const cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove2(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove2() {
        }
      };
    }();
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    const isURLSameOrigin = platform.isStandardBrowserEnv ? function standardBrowserEnv() {
      const msie = /(msie|trident)/i.test(navigator.userAgent);
      const urlParsingNode = document.createElement("a");
      let originURL;
      function resolveURL(url) {
        let href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }();
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min2) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min2 = min2 !== void 0 ? min2 : 1e3;
      return function push(chunkLength) {
        const now2 = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now2;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now2;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now2 - firstSampleTS < min2) {
          return;
        }
        const passed = startedAt && now2 - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e) => {
        const loaded = e.loaded;
        const total2 = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total2;
        bytesNotified = loaded;
        const data = {
          loaded,
          total: total2,
          progress: total2 ? loaded / total2 : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total2 && inRange ? (total2 - loaded) / rate : void 0,
          event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    const xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        const responseType = config.responseType;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
          requestHeaders.setContentType(false);
        }
        let request2 = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request2.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request2.timeout = config.timeout;
        function onloadend() {
          if (!request2) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
          const response = {
            data: responseData,
            status: request2.status,
            statusText: request2.statusText,
            headers: responseHeaders,
            config,
            request: request2
          };
          settle(function _resolve(value) {
            resolve2(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request2 = null;
        }
        if ("onloadend" in request2) {
          request2.onloadend = onloadend;
        } else {
          request2.onreadystatechange = function handleLoad() {
            if (!request2 || request2.readyState !== 4) {
              return;
            }
            if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request2.onabort = function handleAbort() {
          if (!request2) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request2));
          request2 = null;
        };
        request2.onerror = function handleError2() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request2));
          request2 = null;
        };
        request2.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request2
          ));
          request2 = null;
        };
        if (platform.isStandardBrowserEnv) {
          const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
          if (xsrfValue) {
            requestHeaders.set(config.xsrfHeaderName, xsrfValue);
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request2) {
          utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request2.setRequestHeader(key, val);
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request2.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request2.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request2.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request2.upload) {
          request2.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request2) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request2) : cancel);
            request2.abort();
            request2 = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request2.send(requestData || null);
      });
    };
    const knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils.forEach(knownAdapters, (fn2, value) => {
      if (fn2) {
        try {
          Object.defineProperty(fn2, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn2, "adapterName", { value });
      }
    });
    const adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
            break;
          }
        }
        if (!adapter) {
          if (adapter === false) {
            throw new AxiosError(
              `Adapter ${nameOrAdapter} is not supported by the environment`,
              "ERR_NOT_SUPPORT"
            );
          }
          throw new Error(
            utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
          );
        }
        if (!utils.isFunction(adapter)) {
          throw new TypeError("adapter is not a function");
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge.call({ caseless }, target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a2, b2, caseless) {
        if (!utils.isUndefined(b2)) {
          return getMergedValue(a2, b2, caseless);
        } else if (!utils.isUndefined(a2)) {
          return getMergedValue(void 0, a2, caseless);
        }
      }
      function valueFromConfig2(a2, b2) {
        if (!utils.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        }
      }
      function defaultToConfig2(a2, b2) {
        if (!utils.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        } else if (!utils.isUndefined(a2)) {
          return getMergedValue(void 0, a2);
        }
      }
      function mergeDirectKeys(a2, b2, prop) {
        if (prop in config2) {
          return getMergedValue(a2, b2);
        } else if (prop in config1) {
          return getMergedValue(void 0, a2);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    const VERSION$2 = "1.3.2";
    const validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
      validators$1[type2] = function validator2(thing) {
        return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
      };
    });
    const deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version2, message2) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION$2 + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys2 = Object.keys(options);
      let i = keys2.length;
      while (i-- > 0) {
        const opt = keys2[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    const validator = {
      assertOptions,
      validators: validators$1
    };
    const validators = validator.validators;
    class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer !== void 0) {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders;
        contextHeaders = headers && utils.merge(
          headers.common,
          headers[config.method]
        );
        contextHeaders && utils.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method2) => {
            delete headers[method2];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    }
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method2) {
      Axios.prototype[method2] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method: method2,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method: method2,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method2] = generateHTTPMethod();
      Axios.prototype[method2 + "Form"] = generateHTTPMethod(true);
    });
    const Axios$1 = Axios;
    class CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve2) {
          resolvePromise = resolve2;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve2) => {
            token.subscribe(resolve2);
            _resolve = resolve2;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message2, config, request2) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message2, config, request2);
          resolvePromise(token.reason);
        });
      }
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      }
      static source() {
        let cancel;
        const token = new CancelToken(function executor(c2) {
          cancel = c2;
        });
        return {
          token,
          cancel
        };
      }
    }
    const CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    }
    const HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    const HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    const axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION$2;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    const axios$1 = axios;
    const request = axios$1.create({
      timeout: 1e4,
      headers: {
        "Content-Type": "application/json; charset=utf-8"
      }
    });
    request.defaults.baseURL = location.href;
    request.interceptors.request.use(
      (req) => {
        return req;
      }
    );
    request.interceptors.response.use(
      (resp) => {
        let result = resp.data;
        if (result.code === 200) {
          return resp;
        }
        if (result.code === 401) {
          return Promise.reject(401);
        }
        if (!result.code || result.code === 500) {
          ElMessage({
            type: "error",
            message: result.message ? result.message : "\u7CFB\u7EDF\u5F02\u5E38"
          });
        }
        return Promise.reject(result.message);
      },
      (error) => {
        console.error("\u53D1\u751F\u5F02\u5E38\uFF1A", error);
        if (error.code === "ECONNABORTED") {
          ElMessage({
            message: "\u7F51\u7EDC\u8D85\u65F6",
            type: "error",
            duration: 2e3
          });
          return Promise.reject("time out");
        }
        if (error.code === "ERR_NETWORK") {
          ElMessage({
            message: "\u7CFB\u7EDF\u5F02\u5E38,\u8BF7\u7A0D\u540E\u91CD\u8BD5",
            type: "error",
            duration: 2e3
          });
          return Promise.reject(() => {
          });
        }
        if (error.response.data) {
          error.message = error.response.data.message;
        }
        if (error.response.status === 404) {
          error.message = "\u8D44\u6E90\u672A\u627E\u5230";
        }
        ElMessage({
          message: error.message,
          type: "error",
          duration: 3e3
        });
        return Promise.reject(error);
      }
    );
    /*!
      * shared v9.2.2
      * (c) 2022 kazuya kawaguchi
      * Released under the MIT License.
      */
    const inBrowser = typeof window !== "undefined";
    const hasSymbol = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
    const makeSymbol = (name) => hasSymbol ? Symbol(name) : name;
    const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
    const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
    const isNumber = (val) => typeof val === "number" && isFinite(val);
    const isDate = (val) => toTypeString(val) === "[object Date]";
    const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
    const isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
    function warn(msg, err) {
      if (typeof console !== "undefined") {
        console.warn(`[intlify] ` + msg);
        if (err) {
          console.warn(err.stack);
        }
      }
    }
    const assign = Object.assign;
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function escapeHtml(rawText) {
      return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
    }
    const hasOwnProperty = Object.prototype.hasOwnProperty;
    function hasOwn(obj, key) {
      return hasOwnProperty.call(obj, key);
    }
    const isArray = Array.isArray;
    const isFunction = (val) => typeof val === "function";
    const isString = (val) => typeof val === "string";
    const isBoolean = (val) => typeof val === "boolean";
    const isObject = (val) => val !== null && typeof val === "object";
    const objectToString = Object.prototype.toString;
    const toTypeString = (value) => objectToString.call(value);
    const isPlainObject = (val) => toTypeString(val) === "[object Object]";
    const toDisplayString = (val) => {
      return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
    };
    /*!
      * message-compiler v9.2.2
      * (c) 2022 kazuya kawaguchi
      * Released under the MIT License.
      */
    const CompileErrorCodes = {
      EXPECTED_TOKEN: 1,
      INVALID_TOKEN_IN_PLACEHOLDER: 2,
      UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
      UNKNOWN_ESCAPE_SEQUENCE: 4,
      INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
      UNBALANCED_CLOSING_BRACE: 6,
      UNTERMINATED_CLOSING_BRACE: 7,
      EMPTY_PLACEHOLDER: 8,
      NOT_ALLOW_NEST_PLACEHOLDER: 9,
      INVALID_LINKED_FORMAT: 10,
      MUST_HAVE_MESSAGES_IN_PLURAL: 11,
      UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
      UNEXPECTED_EMPTY_LINKED_KEY: 13,
      UNEXPECTED_LEXICAL_ANALYSIS: 14,
      __EXTEND_POINT__: 15
    };
    function createCompileError(code2, loc, options = {}) {
      const { domain, messages: messages2, args } = options;
      const msg = code2;
      const error = new SyntaxError(String(msg));
      error.code = code2;
      if (loc) {
        error.location = loc;
      }
      error.domain = domain;
      return error;
    }
    function defaultOnError(error) {
      throw error;
    }
    function createPosition(line, column, offset2) {
      return { line, column, offset: offset2 };
    }
    function createLocation(start, end2, source) {
      const loc = { start, end: end2 };
      if (source != null) {
        loc.source = source;
      }
      return loc;
    }
    const CHAR_SP = " ";
    const CHAR_CR = "\r";
    const CHAR_LF = "\n";
    const CHAR_LS = String.fromCharCode(8232);
    const CHAR_PS = String.fromCharCode(8233);
    function createScanner(str) {
      const _buf = str;
      let _index = 0;
      let _line = 1;
      let _column = 1;
      let _peekOffset = 0;
      const isCRLF = (index3) => _buf[index3] === CHAR_CR && _buf[index3 + 1] === CHAR_LF;
      const isLF = (index3) => _buf[index3] === CHAR_LF;
      const isPS = (index3) => _buf[index3] === CHAR_PS;
      const isLS = (index3) => _buf[index3] === CHAR_LS;
      const isLineEnd = (index3) => isCRLF(index3) || isLF(index3) || isPS(index3) || isLS(index3);
      const index2 = () => _index;
      const line = () => _line;
      const column = () => _column;
      const peekOffset = () => _peekOffset;
      const charAt = (offset2) => isCRLF(offset2) || isPS(offset2) || isLS(offset2) ? CHAR_LF : _buf[offset2];
      const currentChar = () => charAt(_index);
      const currentPeek = () => charAt(_index + _peekOffset);
      function next() {
        _peekOffset = 0;
        if (isLineEnd(_index)) {
          _line++;
          _column = 0;
        }
        if (isCRLF(_index)) {
          _index++;
        }
        _index++;
        _column++;
        return _buf[_index];
      }
      function peek() {
        if (isCRLF(_index + _peekOffset)) {
          _peekOffset++;
        }
        _peekOffset++;
        return _buf[_index + _peekOffset];
      }
      function reset2() {
        _index = 0;
        _line = 1;
        _column = 1;
        _peekOffset = 0;
      }
      function resetPeek(offset2 = 0) {
        _peekOffset = offset2;
      }
      function skipToPeek() {
        const target = _index + _peekOffset;
        while (target !== _index) {
          next();
        }
        _peekOffset = 0;
      }
      return {
        index: index2,
        line,
        column,
        peekOffset,
        charAt,
        currentChar,
        currentPeek,
        next,
        peek,
        reset: reset2,
        resetPeek,
        skipToPeek
      };
    }
    const EOF = void 0;
    const LITERAL_DELIMITER = "'";
    const ERROR_DOMAIN$1 = "tokenizer";
    function createTokenizer(source, options = {}) {
      const location2 = options.location !== false;
      const _scnr = createScanner(source);
      const currentOffset = () => _scnr.index();
      const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
      const _initLoc = currentPosition();
      const _initOffset = currentOffset();
      const _context = {
        currentType: 14,
        offset: _initOffset,
        startLoc: _initLoc,
        endLoc: _initLoc,
        lastType: 14,
        lastOffset: _initOffset,
        lastStartLoc: _initLoc,
        lastEndLoc: _initLoc,
        braceNest: 0,
        inLinked: false,
        text: ""
      };
      const context = () => _context;
      const { onError } = options;
      function emitError(code2, pos, offset2, ...args) {
        const ctx = context();
        pos.column += offset2;
        pos.offset += offset2;
        if (onError) {
          const loc = createLocation(ctx.startLoc, pos);
          const err = createCompileError(code2, loc, {
            domain: ERROR_DOMAIN$1,
            args
          });
          onError(err);
        }
      }
      function getToken(context2, type2, value) {
        context2.endLoc = currentPosition();
        context2.currentType = type2;
        const token = { type: type2 };
        if (location2) {
          token.loc = createLocation(context2.startLoc, context2.endLoc);
        }
        if (value != null) {
          token.value = value;
        }
        return token;
      }
      const getEndToken = (context2) => getToken(context2, 14);
      function eat(scnr, ch) {
        if (scnr.currentChar() === ch) {
          scnr.next();
          return ch;
        } else {
          emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
          return "";
        }
      }
      function peekSpaces(scnr) {
        let buf = "";
        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
          buf += scnr.currentPeek();
          scnr.peek();
        }
        return buf;
      }
      function skipSpaces(scnr) {
        const buf = peekSpaces(scnr);
        scnr.skipToPeek();
        return buf;
      }
      function isIdentifierStart(ch) {
        if (ch === EOF) {
          return false;
        }
        const cc = ch.charCodeAt(0);
        return cc >= 97 && cc <= 122 || cc >= 65 && cc <= 90 || cc === 95;
      }
      function isNumberStart(ch) {
        if (ch === EOF) {
          return false;
        }
        const cc = ch.charCodeAt(0);
        return cc >= 48 && cc <= 57;
      }
      function isNamedIdentifierStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 2) {
          return false;
        }
        peekSpaces(scnr);
        const ret = isIdentifierStart(scnr.currentPeek());
        scnr.resetPeek();
        return ret;
      }
      function isListIdentifierStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 2) {
          return false;
        }
        peekSpaces(scnr);
        const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
        const ret = isNumberStart(ch);
        scnr.resetPeek();
        return ret;
      }
      function isLiteralStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 2) {
          return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === LITERAL_DELIMITER;
        scnr.resetPeek();
        return ret;
      }
      function isLinkedDotStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 8) {
          return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === ".";
        scnr.resetPeek();
        return ret;
      }
      function isLinkedModifierStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 9) {
          return false;
        }
        peekSpaces(scnr);
        const ret = isIdentifierStart(scnr.currentPeek());
        scnr.resetPeek();
        return ret;
      }
      function isLinkedDelimiterStart(scnr, context2) {
        const { currentType } = context2;
        if (!(currentType === 8 || currentType === 12)) {
          return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === ":";
        scnr.resetPeek();
        return ret;
      }
      function isLinkedReferStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 10) {
          return false;
        }
        const fn2 = () => {
          const ch = scnr.currentPeek();
          if (ch === "{") {
            return isIdentifierStart(scnr.peek());
          } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
            return false;
          } else if (ch === CHAR_LF) {
            scnr.peek();
            return fn2();
          } else {
            return isIdentifierStart(ch);
          }
        };
        const ret = fn2();
        scnr.resetPeek();
        return ret;
      }
      function isPluralStart(scnr) {
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === "|";
        scnr.resetPeek();
        return ret;
      }
      function detectModuloStart(scnr) {
        const spaces = peekSpaces(scnr);
        const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
        scnr.resetPeek();
        return {
          isModulo: ret,
          hasSpace: spaces.length > 0
        };
      }
      function isTextStart(scnr, reset2 = true) {
        const fn2 = (hasSpace = false, prev = "", detectModulo = false) => {
          const ch = scnr.currentPeek();
          if (ch === "{") {
            return prev === "%" ? false : hasSpace;
          } else if (ch === "@" || !ch) {
            return prev === "%" ? true : hasSpace;
          } else if (ch === "%") {
            scnr.peek();
            return fn2(hasSpace, "%", true);
          } else if (ch === "|") {
            return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
          } else if (ch === CHAR_SP) {
            scnr.peek();
            return fn2(true, CHAR_SP, detectModulo);
          } else if (ch === CHAR_LF) {
            scnr.peek();
            return fn2(true, CHAR_LF, detectModulo);
          } else {
            return true;
          }
        };
        const ret = fn2();
        reset2 && scnr.resetPeek();
        return ret;
      }
      function takeChar(scnr, fn2) {
        const ch = scnr.currentChar();
        if (ch === EOF) {
          return EOF;
        }
        if (fn2(ch)) {
          scnr.next();
          return ch;
        }
        return null;
      }
      function takeIdentifierChar(scnr) {
        const closure = (ch) => {
          const cc = ch.charCodeAt(0);
          return cc >= 97 && cc <= 122 || cc >= 65 && cc <= 90 || cc >= 48 && cc <= 57 || cc === 95 || cc === 36;
        };
        return takeChar(scnr, closure);
      }
      function takeDigit(scnr) {
        const closure = (ch) => {
          const cc = ch.charCodeAt(0);
          return cc >= 48 && cc <= 57;
        };
        return takeChar(scnr, closure);
      }
      function takeHexDigit(scnr) {
        const closure = (ch) => {
          const cc = ch.charCodeAt(0);
          return cc >= 48 && cc <= 57 || cc >= 65 && cc <= 70 || cc >= 97 && cc <= 102;
        };
        return takeChar(scnr, closure);
      }
      function getDigits(scnr) {
        let ch = "";
        let num = "";
        while (ch = takeDigit(scnr)) {
          num += ch;
        }
        return num;
      }
      function readModulo(scnr) {
        skipSpaces(scnr);
        const ch = scnr.currentChar();
        if (ch !== "%") {
          emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
        }
        scnr.next();
        return "%";
      }
      function readText(scnr) {
        let buf = "";
        while (true) {
          const ch = scnr.currentChar();
          if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
            break;
          } else if (ch === "%") {
            if (isTextStart(scnr)) {
              buf += ch;
              scnr.next();
            } else {
              break;
            }
          } else if (ch === CHAR_SP || ch === CHAR_LF) {
            if (isTextStart(scnr)) {
              buf += ch;
              scnr.next();
            } else if (isPluralStart(scnr)) {
              break;
            } else {
              buf += ch;
              scnr.next();
            }
          } else {
            buf += ch;
            scnr.next();
          }
        }
        return buf;
      }
      function readNamedIdentifier(scnr) {
        skipSpaces(scnr);
        let ch = "";
        let name = "";
        while (ch = takeIdentifierChar(scnr)) {
          name += ch;
        }
        if (scnr.currentChar() === EOF) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        return name;
      }
      function readListIdentifier(scnr) {
        skipSpaces(scnr);
        let value = "";
        if (scnr.currentChar() === "-") {
          scnr.next();
          value += `-${getDigits(scnr)}`;
        } else {
          value += getDigits(scnr);
        }
        if (scnr.currentChar() === EOF) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        return value;
      }
      function readLiteral(scnr) {
        skipSpaces(scnr);
        eat(scnr, `'`);
        let ch = "";
        let literal = "";
        const fn2 = (x2) => x2 !== LITERAL_DELIMITER && x2 !== CHAR_LF;
        while (ch = takeChar(scnr, fn2)) {
          if (ch === "\\") {
            literal += readEscapeSequence(scnr);
          } else {
            literal += ch;
          }
        }
        const current = scnr.currentChar();
        if (current === CHAR_LF || current === EOF) {
          emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
          if (current === CHAR_LF) {
            scnr.next();
            eat(scnr, `'`);
          }
          return literal;
        }
        eat(scnr, `'`);
        return literal;
      }
      function readEscapeSequence(scnr) {
        const ch = scnr.currentChar();
        switch (ch) {
          case "\\":
          case `'`:
            scnr.next();
            return `\\${ch}`;
          case "u":
            return readUnicodeEscapeSequence(scnr, ch, 4);
          case "U":
            return readUnicodeEscapeSequence(scnr, ch, 6);
          default:
            emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
            return "";
        }
      }
      function readUnicodeEscapeSequence(scnr, unicode, digits) {
        eat(scnr, unicode);
        let sequence = "";
        for (let i = 0; i < digits; i++) {
          const ch = takeHexDigit(scnr);
          if (!ch) {
            emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
            break;
          }
          sequence += ch;
        }
        return `\\${unicode}${sequence}`;
      }
      function readInvalidIdentifier(scnr) {
        skipSpaces(scnr);
        let ch = "";
        let identifiers = "";
        const closure = (ch2) => ch2 !== "{" && ch2 !== "}" && ch2 !== CHAR_SP && ch2 !== CHAR_LF;
        while (ch = takeChar(scnr, closure)) {
          identifiers += ch;
        }
        return identifiers;
      }
      function readLinkedModifier(scnr) {
        let ch = "";
        let name = "";
        while (ch = takeIdentifierChar(scnr)) {
          name += ch;
        }
        return name;
      }
      function readLinkedRefer(scnr) {
        const fn2 = (detect = false, buf) => {
          const ch = scnr.currentChar();
          if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || !ch) {
            return buf;
          } else if (ch === CHAR_SP) {
            return buf;
          } else if (ch === CHAR_LF) {
            buf += ch;
            scnr.next();
            return fn2(detect, buf);
          } else {
            buf += ch;
            scnr.next();
            return fn2(true, buf);
          }
        };
        return fn2(false, "");
      }
      function readPlural(scnr) {
        skipSpaces(scnr);
        const plural = eat(scnr, "|");
        skipSpaces(scnr);
        return plural;
      }
      function readTokenInPlaceholder(scnr, context2) {
        let token = null;
        const ch = scnr.currentChar();
        switch (ch) {
          case "{":
            if (context2.braceNest >= 1) {
              emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
            }
            scnr.next();
            token = getToken(context2, 2, "{");
            skipSpaces(scnr);
            context2.braceNest++;
            return token;
          case "}":
            if (context2.braceNest > 0 && context2.currentType === 2) {
              emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
            }
            scnr.next();
            token = getToken(context2, 3, "}");
            context2.braceNest--;
            context2.braceNest > 0 && skipSpaces(scnr);
            if (context2.inLinked && context2.braceNest === 0) {
              context2.inLinked = false;
            }
            return token;
          case "@":
            if (context2.braceNest > 0) {
              emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
            }
            token = readTokenInLinked(scnr, context2) || getEndToken(context2);
            context2.braceNest = 0;
            return token;
          default:
            let validNamedIdentifier = true;
            let validListIdentifier = true;
            let validLiteral = true;
            if (isPluralStart(scnr)) {
              if (context2.braceNest > 0) {
                emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
              }
              token = getToken(context2, 1, readPlural(scnr));
              context2.braceNest = 0;
              context2.inLinked = false;
              return token;
            }
            if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
              emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
              context2.braceNest = 0;
              return readToken(scnr, context2);
            }
            if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
              token = getToken(context2, 5, readNamedIdentifier(scnr));
              skipSpaces(scnr);
              return token;
            }
            if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
              token = getToken(context2, 6, readListIdentifier(scnr));
              skipSpaces(scnr);
              return token;
            }
            if (validLiteral = isLiteralStart(scnr, context2)) {
              token = getToken(context2, 7, readLiteral(scnr));
              skipSpaces(scnr);
              return token;
            }
            if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
              token = getToken(context2, 13, readInvalidIdentifier(scnr));
              emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
              skipSpaces(scnr);
              return token;
            }
            break;
        }
        return token;
      }
      function readTokenInLinked(scnr, context2) {
        const { currentType } = context2;
        let token = null;
        const ch = scnr.currentChar();
        if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        switch (ch) {
          case "@":
            scnr.next();
            token = getToken(context2, 8, "@");
            context2.inLinked = true;
            return token;
          case ".":
            skipSpaces(scnr);
            scnr.next();
            return getToken(context2, 9, ".");
          case ":":
            skipSpaces(scnr);
            scnr.next();
            return getToken(context2, 10, ":");
          default:
            if (isPluralStart(scnr)) {
              token = getToken(context2, 1, readPlural(scnr));
              context2.braceNest = 0;
              context2.inLinked = false;
              return token;
            }
            if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
              skipSpaces(scnr);
              return readTokenInLinked(scnr, context2);
            }
            if (isLinkedModifierStart(scnr, context2)) {
              skipSpaces(scnr);
              return getToken(context2, 12, readLinkedModifier(scnr));
            }
            if (isLinkedReferStart(scnr, context2)) {
              skipSpaces(scnr);
              if (ch === "{") {
                return readTokenInPlaceholder(scnr, context2) || token;
              } else {
                return getToken(context2, 11, readLinkedRefer(scnr));
              }
            }
            if (currentType === 8) {
              emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
            }
            context2.braceNest = 0;
            context2.inLinked = false;
            return readToken(scnr, context2);
        }
      }
      function readToken(scnr, context2) {
        let token = { type: 14 };
        if (context2.braceNest > 0) {
          return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
        }
        if (context2.inLinked) {
          return readTokenInLinked(scnr, context2) || getEndToken(context2);
        }
        const ch = scnr.currentChar();
        switch (ch) {
          case "{":
            return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
          case "}":
            emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
            scnr.next();
            return getToken(context2, 3, "}");
          case "@":
            return readTokenInLinked(scnr, context2) || getEndToken(context2);
          default:
            if (isPluralStart(scnr)) {
              token = getToken(context2, 1, readPlural(scnr));
              context2.braceNest = 0;
              context2.inLinked = false;
              return token;
            }
            const { isModulo, hasSpace } = detectModuloStart(scnr);
            if (isModulo) {
              return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
            }
            if (isTextStart(scnr)) {
              return getToken(context2, 0, readText(scnr));
            }
            break;
        }
        return token;
      }
      function nextToken() {
        const { currentType, offset: offset2, startLoc, endLoc } = _context;
        _context.lastType = currentType;
        _context.lastOffset = offset2;
        _context.lastStartLoc = startLoc;
        _context.lastEndLoc = endLoc;
        _context.offset = currentOffset();
        _context.startLoc = currentPosition();
        if (_scnr.currentChar() === EOF) {
          return getToken(_context, 14);
        }
        return readToken(_scnr, _context);
      }
      return {
        nextToken,
        currentOffset,
        currentPosition,
        context
      };
    }
    const ERROR_DOMAIN = "parser";
    const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
    function fromEscapeSequence(match, codePoint4, codePoint6) {
      switch (match) {
        case `\\\\`:
          return `\\`;
        case `\\'`:
          return `'`;
        default: {
          const codePoint = parseInt(codePoint4 || codePoint6, 16);
          if (codePoint <= 55295 || codePoint >= 57344) {
            return String.fromCodePoint(codePoint);
          }
          return "\uFFFD";
        }
      }
    }
    function createParser(options = {}) {
      const location2 = options.location !== false;
      const { onError } = options;
      function emitError(tokenzer, code2, start, offset2, ...args) {
        const end2 = tokenzer.currentPosition();
        end2.offset += offset2;
        end2.column += offset2;
        if (onError) {
          const loc = createLocation(start, end2);
          const err = createCompileError(code2, loc, {
            domain: ERROR_DOMAIN,
            args
          });
          onError(err);
        }
      }
      function startNode(type2, offset2, loc) {
        const node = {
          type: type2,
          start: offset2,
          end: offset2
        };
        if (location2) {
          node.loc = { start: loc, end: loc };
        }
        return node;
      }
      function endNode(node, offset2, pos, type2) {
        node.end = offset2;
        if (type2) {
          node.type = type2;
        }
        if (location2 && node.loc) {
          node.loc.end = pos;
        }
      }
      function parseText(tokenizer, value) {
        const context = tokenizer.context();
        const node = startNode(3, context.offset, context.startLoc);
        node.value = value;
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      function parseList(tokenizer, index2) {
        const context = tokenizer.context();
        const { lastOffset: offset2, lastStartLoc: loc } = context;
        const node = startNode(5, offset2, loc);
        node.index = parseInt(index2, 10);
        tokenizer.nextToken();
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      function parseNamed(tokenizer, key) {
        const context = tokenizer.context();
        const { lastOffset: offset2, lastStartLoc: loc } = context;
        const node = startNode(4, offset2, loc);
        node.key = key;
        tokenizer.nextToken();
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      function parseLiteral(tokenizer, value) {
        const context = tokenizer.context();
        const { lastOffset: offset2, lastStartLoc: loc } = context;
        const node = startNode(9, offset2, loc);
        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
        tokenizer.nextToken();
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      function parseLinkedModifier(tokenizer) {
        const token = tokenizer.nextToken();
        const context = tokenizer.context();
        const { lastOffset: offset2, lastStartLoc: loc } = context;
        const node = startNode(8, offset2, loc);
        if (token.type !== 12) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
          node.value = "";
          endNode(node, offset2, loc);
          return {
            nextConsumeToken: token,
            node
          };
        }
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        node.value = token.value || "";
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return {
          node
        };
      }
      function parseLinkedKey(tokenizer, value) {
        const context = tokenizer.context();
        const node = startNode(7, context.offset, context.startLoc);
        node.value = value;
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      function parseLinked(tokenizer) {
        const context = tokenizer.context();
        const linkedNode = startNode(6, context.offset, context.startLoc);
        let token = tokenizer.nextToken();
        if (token.type === 9) {
          const parsed = parseLinkedModifier(tokenizer);
          linkedNode.modifier = parsed.node;
          token = parsed.nextConsumeToken || tokenizer.nextToken();
        }
        if (token.type !== 10) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        token = tokenizer.nextToken();
        if (token.type === 2) {
          token = tokenizer.nextToken();
        }
        switch (token.type) {
          case 11:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
            break;
          case 5:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            linkedNode.key = parseNamed(tokenizer, token.value || "");
            break;
          case 6:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            linkedNode.key = parseList(tokenizer, token.value || "");
            break;
          case 7:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            linkedNode.key = parseLiteral(tokenizer, token.value || "");
            break;
          default:
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
            const nextContext = tokenizer.context();
            const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
            emptyLinkedKeyNode.value = "";
            endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
            linkedNode.key = emptyLinkedKeyNode;
            endNode(linkedNode, nextContext.offset, nextContext.startLoc);
            return {
              nextConsumeToken: token,
              node: linkedNode
            };
        }
        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
        return {
          node: linkedNode
        };
      }
      function parseMessage(tokenizer) {
        const context = tokenizer.context();
        const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
        const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
        const node = startNode(2, startOffset, startLoc);
        node.items = [];
        let nextToken = null;
        do {
          const token = nextToken || tokenizer.nextToken();
          nextToken = null;
          switch (token.type) {
            case 0:
              if (token.value == null) {
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
              }
              node.items.push(parseText(tokenizer, token.value || ""));
              break;
            case 6:
              if (token.value == null) {
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
              }
              node.items.push(parseList(tokenizer, token.value || ""));
              break;
            case 5:
              if (token.value == null) {
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
              }
              node.items.push(parseNamed(tokenizer, token.value || ""));
              break;
            case 7:
              if (token.value == null) {
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
              }
              node.items.push(parseLiteral(tokenizer, token.value || ""));
              break;
            case 8:
              const parsed = parseLinked(tokenizer);
              node.items.push(parsed.node);
              nextToken = parsed.nextConsumeToken || null;
              break;
          }
        } while (context.currentType !== 14 && context.currentType !== 1);
        const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
        const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
        endNode(node, endOffset, endLoc);
        return node;
      }
      function parsePlural(tokenizer, offset2, loc, msgNode) {
        const context = tokenizer.context();
        let hasEmptyMessage = msgNode.items.length === 0;
        const node = startNode(1, offset2, loc);
        node.cases = [];
        node.cases.push(msgNode);
        do {
          const msg = parseMessage(tokenizer);
          if (!hasEmptyMessage) {
            hasEmptyMessage = msg.items.length === 0;
          }
          node.cases.push(msg);
        } while (context.currentType !== 14);
        if (hasEmptyMessage) {
          emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
        }
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      function parseResource(tokenizer) {
        const context = tokenizer.context();
        const { offset: offset2, startLoc } = context;
        const msgNode = parseMessage(tokenizer);
        if (context.currentType === 14) {
          return msgNode;
        } else {
          return parsePlural(tokenizer, offset2, startLoc, msgNode);
        }
      }
      function parse2(source) {
        const tokenizer = createTokenizer(source, assign({}, options));
        const context = tokenizer.context();
        const node = startNode(0, context.offset, context.startLoc);
        if (location2 && node.loc) {
          node.loc.source = source;
        }
        node.body = parseResource(tokenizer);
        if (context.currentType !== 14) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
        }
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      return { parse: parse2 };
    }
    function getTokenCaption(token) {
      if (token.type === 14) {
        return "EOF";
      }
      const name = (token.value || "").replace(/\r?\n/gu, "\\n");
      return name.length > 10 ? name.slice(0, 9) + "\u2026" : name;
    }
    function createTransformer(ast, options = {}) {
      const _context = {
        ast,
        helpers: /* @__PURE__ */ new Set()
      };
      const context = () => _context;
      const helper = (name) => {
        _context.helpers.add(name);
        return name;
      };
      return { context, helper };
    }
    function traverseNodes(nodes, transformer) {
      for (let i = 0; i < nodes.length; i++) {
        traverseNode(nodes[i], transformer);
      }
    }
    function traverseNode(node, transformer) {
      switch (node.type) {
        case 1:
          traverseNodes(node.cases, transformer);
          transformer.helper("plural");
          break;
        case 2:
          traverseNodes(node.items, transformer);
          break;
        case 6:
          const linked = node;
          traverseNode(linked.key, transformer);
          transformer.helper("linked");
          transformer.helper("type");
          break;
        case 5:
          transformer.helper("interpolate");
          transformer.helper("list");
          break;
        case 4:
          transformer.helper("interpolate");
          transformer.helper("named");
          break;
      }
    }
    function transform(ast, options = {}) {
      const transformer = createTransformer(ast);
      transformer.helper("normalize");
      ast.body && traverseNode(ast.body, transformer);
      const context = transformer.context();
      ast.helpers = Array.from(context.helpers);
    }
    function createCodeGenerator(ast, options) {
      const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
      const _context = {
        source: ast.loc.source,
        filename,
        code: "",
        column: 1,
        line: 1,
        offset: 0,
        map: void 0,
        breakLineCode,
        needIndent: _needIndent,
        indentLevel: 0
      };
      const context = () => _context;
      function push(code2, node) {
        _context.code += code2;
      }
      function _newline(n, withBreakLine = true) {
        const _breakLineCode = withBreakLine ? breakLineCode : "";
        push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
      }
      function indent(withNewLine = true) {
        const level = ++_context.indentLevel;
        withNewLine && _newline(level);
      }
      function deindent(withNewLine = true) {
        const level = --_context.indentLevel;
        withNewLine && _newline(level);
      }
      function newline() {
        _newline(_context.indentLevel);
      }
      const helper = (key) => `_${key}`;
      const needIndent = () => _context.needIndent;
      return {
        context,
        push,
        indent,
        deindent,
        newline,
        helper,
        needIndent
      };
    }
    function generateLinkedNode(generator, node) {
      const { helper } = generator;
      generator.push(`${helper("linked")}(`);
      generateNode(generator, node.key);
      if (node.modifier) {
        generator.push(`, `);
        generateNode(generator, node.modifier);
        generator.push(`, _type`);
      } else {
        generator.push(`, undefined, _type`);
      }
      generator.push(`)`);
    }
    function generateMessageNode(generator, node) {
      const { helper, needIndent } = generator;
      generator.push(`${helper("normalize")}([`);
      generator.indent(needIndent());
      const length = node.items.length;
      for (let i = 0; i < length; i++) {
        generateNode(generator, node.items[i]);
        if (i === length - 1) {
          break;
        }
        generator.push(", ");
      }
      generator.deindent(needIndent());
      generator.push("])");
    }
    function generatePluralNode(generator, node) {
      const { helper, needIndent } = generator;
      if (node.cases.length > 1) {
        generator.push(`${helper("plural")}([`);
        generator.indent(needIndent());
        const length = node.cases.length;
        for (let i = 0; i < length; i++) {
          generateNode(generator, node.cases[i]);
          if (i === length - 1) {
            break;
          }
          generator.push(", ");
        }
        generator.deindent(needIndent());
        generator.push(`])`);
      }
    }
    function generateResource(generator, node) {
      if (node.body) {
        generateNode(generator, node.body);
      } else {
        generator.push("null");
      }
    }
    function generateNode(generator, node) {
      const { helper } = generator;
      switch (node.type) {
        case 0:
          generateResource(generator, node);
          break;
        case 1:
          generatePluralNode(generator, node);
          break;
        case 2:
          generateMessageNode(generator, node);
          break;
        case 6:
          generateLinkedNode(generator, node);
          break;
        case 8:
          generator.push(JSON.stringify(node.value), node);
          break;
        case 7:
          generator.push(JSON.stringify(node.value), node);
          break;
        case 5:
          generator.push(`${helper("interpolate")}(${helper("list")}(${node.index}))`, node);
          break;
        case 4:
          generator.push(`${helper("interpolate")}(${helper("named")}(${JSON.stringify(node.key)}))`, node);
          break;
        case 9:
          generator.push(JSON.stringify(node.value), node);
          break;
        case 3:
          generator.push(JSON.stringify(node.value), node);
          break;
      }
    }
    const generate = (ast, options = {}) => {
      const mode = isString(options.mode) ? options.mode : "normal";
      const filename = isString(options.filename) ? options.filename : "message.intl";
      const sourceMap = !!options.sourceMap;
      const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
      const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
      const helpers = ast.helpers || [];
      const generator = createCodeGenerator(ast, {
        mode,
        filename,
        sourceMap,
        breakLineCode,
        needIndent
      });
      generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
      generator.indent(needIndent);
      if (helpers.length > 0) {
        generator.push(`const { ${helpers.map((s2) => `${s2}: _${s2}`).join(", ")} } = ctx`);
        generator.newline();
      }
      generator.push(`return `);
      generateNode(generator, ast);
      generator.deindent(needIndent);
      generator.push(`}`);
      const { code: code2, map } = generator.context();
      return {
        ast,
        code: code2,
        map: map ? map.toJSON() : void 0
      };
    };
    function baseCompile(source, options = {}) {
      const assignedOptions = assign({}, options);
      const parser = createParser(assignedOptions);
      const ast = parser.parse(source);
      transform(ast, assignedOptions);
      return generate(ast, assignedOptions);
    }
    /*!
      * devtools-if v9.2.2
      * (c) 2022 kazuya kawaguchi
      * Released under the MIT License.
      */
    const IntlifyDevToolsHooks = {
      I18nInit: "i18n:init",
      FunctionTranslate: "function:translate"
    };
    /*!
      * core-base v9.2.2
      * (c) 2022 kazuya kawaguchi
      * Released under the MIT License.
      */
    const pathStateMachine = [];
    pathStateMachine[0] = {
      ["w"]: [0],
      ["i"]: [3, 0],
      ["["]: [4],
      ["o"]: [7]
    };
    pathStateMachine[1] = {
      ["w"]: [1],
      ["."]: [2],
      ["["]: [4],
      ["o"]: [7]
    };
    pathStateMachine[2] = {
      ["w"]: [2],
      ["i"]: [3, 0],
      ["0"]: [3, 0]
    };
    pathStateMachine[3] = {
      ["i"]: [3, 0],
      ["0"]: [3, 0],
      ["w"]: [1, 1],
      ["."]: [2, 1],
      ["["]: [4, 1],
      ["o"]: [7, 1]
    };
    pathStateMachine[4] = {
      ["'"]: [5, 0],
      ['"']: [6, 0],
      ["["]: [
        4,
        2
      ],
      ["]"]: [1, 3],
      ["o"]: 8,
      ["l"]: [4, 0]
    };
    pathStateMachine[5] = {
      ["'"]: [4, 0],
      ["o"]: 8,
      ["l"]: [5, 0]
    };
    pathStateMachine[6] = {
      ['"']: [4, 0],
      ["o"]: 8,
      ["l"]: [6, 0]
    };
    const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
    function isLiteral(exp) {
      return literalValueRE.test(exp);
    }
    function stripQuotes(str) {
      const a2 = str.charCodeAt(0);
      const b2 = str.charCodeAt(str.length - 1);
      return a2 === b2 && (a2 === 34 || a2 === 39) ? str.slice(1, -1) : str;
    }
    function getPathCharType(ch) {
      if (ch === void 0 || ch === null) {
        return "o";
      }
      const code2 = ch.charCodeAt(0);
      switch (code2) {
        case 91:
        case 93:
        case 46:
        case 34:
        case 39:
          return ch;
        case 95:
        case 36:
        case 45:
          return "i";
        case 9:
        case 10:
        case 13:
        case 160:
        case 65279:
        case 8232:
        case 8233:
          return "w";
      }
      return "i";
    }
    function formatSubPath(path) {
      const trimmed = path.trim();
      if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
        return false;
      }
      return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
    }
    function parse(path) {
      const keys2 = [];
      let index2 = -1;
      let mode = 0;
      let subPathDepth = 0;
      let c2;
      let key;
      let newChar;
      let type2;
      let transition;
      let action;
      let typeMap;
      const actions = [];
      actions[0] = () => {
        if (key === void 0) {
          key = newChar;
        } else {
          key += newChar;
        }
      };
      actions[1] = () => {
        if (key !== void 0) {
          keys2.push(key);
          key = void 0;
        }
      };
      actions[2] = () => {
        actions[0]();
        subPathDepth++;
      };
      actions[3] = () => {
        if (subPathDepth > 0) {
          subPathDepth--;
          mode = 4;
          actions[0]();
        } else {
          subPathDepth = 0;
          if (key === void 0) {
            return false;
          }
          key = formatSubPath(key);
          if (key === false) {
            return false;
          } else {
            actions[1]();
          }
        }
      };
      function maybeUnescapeQuote() {
        const nextChar = path[index2 + 1];
        if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
          index2++;
          newChar = "\\" + nextChar;
          actions[0]();
          return true;
        }
      }
      while (mode !== null) {
        index2++;
        c2 = path[index2];
        if (c2 === "\\" && maybeUnescapeQuote()) {
          continue;
        }
        type2 = getPathCharType(c2);
        typeMap = pathStateMachine[mode];
        transition = typeMap[type2] || typeMap["l"] || 8;
        if (transition === 8) {
          return;
        }
        mode = transition[0];
        if (transition[1] !== void 0) {
          action = actions[transition[1]];
          if (action) {
            newChar = c2;
            if (action() === false) {
              return;
            }
          }
        }
        if (mode === 7) {
          return keys2;
        }
      }
    }
    const cache = /* @__PURE__ */ new Map();
    function resolveWithKeyValue(obj, path) {
      return isObject(obj) ? obj[path] : null;
    }
    function resolveValue(obj, path) {
      if (!isObject(obj)) {
        return null;
      }
      let hit = cache.get(path);
      if (!hit) {
        hit = parse(path);
        if (hit) {
          cache.set(path, hit);
        }
      }
      if (!hit) {
        return null;
      }
      const len = hit.length;
      let last = obj;
      let i = 0;
      while (i < len) {
        const val = last[hit[i]];
        if (val === void 0) {
          return null;
        }
        last = val;
        i++;
      }
      return last;
    }
    const DEFAULT_MODIFIER = (str) => str;
    const DEFAULT_MESSAGE = (ctx) => "";
    const DEFAULT_MESSAGE_DATA_TYPE = "text";
    const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : values.join("");
    const DEFAULT_INTERPOLATE = toDisplayString;
    function pluralDefault(choice, choicesLength) {
      choice = Math.abs(choice);
      if (choicesLength === 2) {
        return choice ? choice > 1 ? 1 : 0 : 1;
      }
      return choice ? Math.min(choice, 2) : 0;
    }
    function getPluralIndex(options) {
      const index2 = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
      return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index2 : index2;
    }
    function normalizeNamed(pluralIndex, props) {
      if (!props.count) {
        props.count = pluralIndex;
      }
      if (!props.n) {
        props.n = pluralIndex;
      }
    }
    function createMessageContext(options = {}) {
      const locale = options.locale;
      const pluralIndex = getPluralIndex(options);
      const pluralRule = isObject(options.pluralRules) && isString(locale) && isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
      const orgPluralRule = isObject(options.pluralRules) && isString(locale) && isFunction(options.pluralRules[locale]) ? pluralDefault : void 0;
      const plural = (messages2) => {
        return messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
      };
      const _list = options.list || [];
      const list = (index2) => _list[index2];
      const _named = options.named || {};
      isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
      const named = (key) => _named[key];
      function message2(key) {
        const msg = isFunction(options.messages) ? options.messages(key) : isObject(options.messages) ? options.messages[key] : false;
        return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
      }
      const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
      const normalize = isPlainObject(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
      const interpolate = isPlainObject(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
      const type2 = isPlainObject(options.processor) && isString(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
      const linked = (key, ...args) => {
        const [arg1, arg2] = args;
        let type3 = "text";
        let modifier = "";
        if (args.length === 1) {
          if (isObject(arg1)) {
            modifier = arg1.modifier || modifier;
            type3 = arg1.type || type3;
          } else if (isString(arg1)) {
            modifier = arg1 || modifier;
          }
        } else if (args.length === 2) {
          if (isString(arg1)) {
            modifier = arg1 || modifier;
          }
          if (isString(arg2)) {
            type3 = arg2 || type3;
          }
        }
        let msg = message2(key)(ctx);
        if (type3 === "vnode" && isArray(msg) && modifier) {
          msg = msg[0];
        }
        return modifier ? _modifier(modifier)(msg, type3) : msg;
      };
      const ctx = {
        ["list"]: list,
        ["named"]: named,
        ["plural"]: plural,
        ["linked"]: linked,
        ["message"]: message2,
        ["type"]: type2,
        ["interpolate"]: interpolate,
        ["normalize"]: normalize
      };
      return ctx;
    }
    let devtools = null;
    function setDevToolsHook(hook) {
      devtools = hook;
    }
    function initI18nDevTools(i18n2, version2, meta) {
      devtools && devtools.emit(IntlifyDevToolsHooks.I18nInit, {
        timestamp: Date.now(),
        i18n: i18n2,
        version: version2,
        meta
      });
    }
    const translateDevTools = /* @__PURE__ */ createDevToolsHook(IntlifyDevToolsHooks.FunctionTranslate);
    function createDevToolsHook(hook) {
      return (payloads) => devtools && devtools.emit(hook, payloads);
    }
    const CoreWarnCodes = {
      NOT_FOUND_KEY: 1,
      FALLBACK_TO_TRANSLATE: 2,
      CANNOT_FORMAT_NUMBER: 3,
      FALLBACK_TO_NUMBER_FORMAT: 4,
      CANNOT_FORMAT_DATE: 5,
      FALLBACK_TO_DATE_FORMAT: 6,
      __EXTEND_POINT__: 7
    };
    function fallbackWithSimple(ctx, fallback, start) {
      return [.../* @__PURE__ */ new Set([
        start,
        ...isArray(fallback) ? fallback : isObject(fallback) ? Object.keys(fallback) : isString(fallback) ? [fallback] : [start]
      ])];
    }
    function fallbackWithLocaleChain(ctx, fallback, start) {
      const startLocale = isString(start) ? start : DEFAULT_LOCALE;
      const context = ctx;
      if (!context.__localeChainCache) {
        context.__localeChainCache = /* @__PURE__ */ new Map();
      }
      let chain = context.__localeChainCache.get(startLocale);
      if (!chain) {
        chain = [];
        let block = [start];
        while (isArray(block)) {
          block = appendBlockToChain(chain, block, fallback);
        }
        const defaults2 = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
        block = isString(defaults2) ? [defaults2] : defaults2;
        if (isArray(block)) {
          appendBlockToChain(chain, block, false);
        }
        context.__localeChainCache.set(startLocale, chain);
      }
      return chain;
    }
    function appendBlockToChain(chain, block, blocks) {
      let follow = true;
      for (let i = 0; i < block.length && isBoolean(follow); i++) {
        const locale = block[i];
        if (isString(locale)) {
          follow = appendLocaleToChain(chain, block[i], blocks);
        }
      }
      return follow;
    }
    function appendLocaleToChain(chain, locale, blocks) {
      let follow;
      const tokens = locale.split("-");
      do {
        const target = tokens.join("-");
        follow = appendItemToChain(chain, target, blocks);
        tokens.splice(-1, 1);
      } while (tokens.length && follow === true);
      return follow;
    }
    function appendItemToChain(chain, target, blocks) {
      let follow = false;
      if (!chain.includes(target)) {
        follow = true;
        if (target) {
          follow = target[target.length - 1] !== "!";
          const locale = target.replace(/!/g, "");
          chain.push(locale);
          if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale]) {
            follow = blocks[locale];
          }
        }
      }
      return follow;
    }
    const VERSION$1 = "9.2.2";
    const NOT_REOSLVED = -1;
    const DEFAULT_LOCALE = "en-US";
    const MISSING_RESOLVE_VALUE = "";
    const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
    function getDefaultLinkedModifiers() {
      return {
        upper: (val, type2) => {
          return type2 === "text" && isString(val) ? val.toUpperCase() : type2 === "vnode" && isObject(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
        },
        lower: (val, type2) => {
          return type2 === "text" && isString(val) ? val.toLowerCase() : type2 === "vnode" && isObject(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
        },
        capitalize: (val, type2) => {
          return type2 === "text" && isString(val) ? capitalize(val) : type2 === "vnode" && isObject(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
        }
      };
    }
    let _compiler;
    function registerMessageCompiler(compiler) {
      _compiler = compiler;
    }
    let _resolver;
    function registerMessageResolver(resolver) {
      _resolver = resolver;
    }
    let _fallbacker;
    function registerLocaleFallbacker(fallbacker) {
      _fallbacker = fallbacker;
    }
    let _additionalMeta = null;
    const setAdditionalMeta = (meta) => {
      _additionalMeta = meta;
    };
    const getAdditionalMeta = () => _additionalMeta;
    let _fallbackContext = null;
    const setFallbackContext = (context) => {
      _fallbackContext = context;
    };
    const getFallbackContext = () => _fallbackContext;
    let _cid = 0;
    function createCoreContext(options = {}) {
      const version2 = isString(options.version) ? options.version : VERSION$1;
      const locale = isString(options.locale) ? options.locale : DEFAULT_LOCALE;
      const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
      const messages2 = isPlainObject(options.messages) ? options.messages : { [locale]: {} };
      const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [locale]: {} };
      const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : { [locale]: {} };
      const modifiers = assign({}, options.modifiers || {}, getDefaultLinkedModifiers());
      const pluralRules = options.pluralRules || {};
      const missing = isFunction(options.missing) ? options.missing : null;
      const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
      const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
      const fallbackFormat = !!options.fallbackFormat;
      const unresolving = !!options.unresolving;
      const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
      const processor = isPlainObject(options.processor) ? options.processor : null;
      const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
      const escapeParameter = !!options.escapeParameter;
      const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
      const messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
      const localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
      const fallbackContext = isObject(options.fallbackContext) ? options.fallbackContext : void 0;
      const onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
      const internalOptions = options;
      const __datetimeFormatters = isObject(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
      const __numberFormatters = isObject(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
      const __meta = isObject(internalOptions.__meta) ? internalOptions.__meta : {};
      _cid++;
      const context = {
        version: version2,
        cid: _cid,
        locale,
        fallbackLocale,
        messages: messages2,
        modifiers,
        pluralRules,
        missing,
        missingWarn,
        fallbackWarn,
        fallbackFormat,
        unresolving,
        postTranslation,
        processor,
        warnHtmlMessage,
        escapeParameter,
        messageCompiler,
        messageResolver,
        localeFallbacker,
        fallbackContext,
        onWarn,
        __meta
      };
      {
        context.datetimeFormats = datetimeFormats;
        context.numberFormats = numberFormats;
        context.__datetimeFormatters = __datetimeFormatters;
        context.__numberFormatters = __numberFormatters;
      }
      if (__INTLIFY_PROD_DEVTOOLS__) {
        initI18nDevTools(context, version2, __meta);
      }
      return context;
    }
    function handleMissing(context, key, locale, missingWarn, type2) {
      const { missing, onWarn } = context;
      if (missing !== null) {
        const ret = missing(context, locale, key, type2);
        return isString(ret) ? ret : key;
      } else {
        return key;
      }
    }
    function updateFallbackLocale(ctx, locale, fallback) {
      const context = ctx;
      context.__localeChainCache = /* @__PURE__ */ new Map();
      ctx.localeFallbacker(ctx, fallback, locale);
    }
    const defaultOnCacheKey = (source) => source;
    let compileCache = /* @__PURE__ */ Object.create(null);
    function compileToFunction(source, options = {}) {
      {
        const onCacheKey = options.onCacheKey || defaultOnCacheKey;
        const key = onCacheKey(source);
        const cached = compileCache[key];
        if (cached) {
          return cached;
        }
        let occurred = false;
        const onError = options.onError || defaultOnError;
        options.onError = (err) => {
          occurred = true;
          onError(err);
        };
        const { code: code2 } = baseCompile(source, options);
        const msg = new Function(`return ${code2}`)();
        return !occurred ? compileCache[key] = msg : msg;
      }
    }
    let code$1 = CompileErrorCodes.__EXTEND_POINT__;
    const inc$1 = () => ++code$1;
    const CoreErrorCodes = {
      INVALID_ARGUMENT: code$1,
      INVALID_DATE_ARGUMENT: inc$1(),
      INVALID_ISO_DATE_ARGUMENT: inc$1(),
      __EXTEND_POINT__: inc$1()
    };
    function createCoreError(code2) {
      return createCompileError(code2, null, void 0);
    }
    const NOOP_MESSAGE_FUNCTION = () => "";
    const isMessageFunction = (val) => isFunction(val);
    function translate(context, ...args) {
      const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages: messages2 } = context;
      const [key, options] = parseTranslateArgs(...args);
      const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
      const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
      const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
      const resolvedMessage = !!options.resolvedMessage;
      const defaultMsgOrKey = isString(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
      const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
      const locale = isString(options.locale) ? options.locale : context.locale;
      escapeParameter && escapeParams(options);
      let [formatScope, targetLocale, message2] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
        key,
        locale,
        messages2[locale] || {}
      ];
      let format2 = formatScope;
      let cacheBaseKey = key;
      if (!resolvedMessage && !(isString(format2) || isMessageFunction(format2))) {
        if (enableDefaultMsg) {
          format2 = defaultMsgOrKey;
          cacheBaseKey = format2;
        }
      }
      if (!resolvedMessage && (!(isString(format2) || isMessageFunction(format2)) || !isString(targetLocale))) {
        return unresolving ? NOT_REOSLVED : key;
      }
      let occurred = false;
      const errorDetector = () => {
        occurred = true;
      };
      const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, errorDetector) : format2;
      if (occurred) {
        return format2;
      }
      const ctxOptions = getMessageContextOptions(context, targetLocale, message2, options);
      const msgContext = createMessageContext(ctxOptions);
      const messaged = evaluateMessage(context, msg, msgContext);
      const ret = postTranslation ? postTranslation(messaged, key) : messaged;
      if (__INTLIFY_PROD_DEVTOOLS__) {
        const payloads = {
          timestamp: Date.now(),
          key: isString(key) ? key : isMessageFunction(format2) ? format2.key : "",
          locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
          format: isString(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
          message: ret
        };
        payloads.meta = assign({}, context.__meta, getAdditionalMeta() || {});
        translateDevTools(payloads);
      }
      return ret;
    }
    function escapeParams(options) {
      if (isArray(options.list)) {
        options.list = options.list.map((item) => isString(item) ? escapeHtml(item) : item);
      } else if (isObject(options.named)) {
        Object.keys(options.named).forEach((key) => {
          if (isString(options.named[key])) {
            options.named[key] = escapeHtml(options.named[key]);
          }
        });
      }
    }
    function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
      const { messages: messages2, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
      const locales = localeFallbacker(context, fallbackLocale, locale);
      let message2 = {};
      let targetLocale;
      let format2 = null;
      const type2 = "translate";
      for (let i = 0; i < locales.length; i++) {
        targetLocale = locales[i];
        message2 = messages2[targetLocale] || {};
        if ((format2 = resolveValue2(message2, key)) === null) {
          format2 = message2[key];
        }
        if (isString(format2) || isFunction(format2))
          break;
        const missingRet = handleMissing(
          context,
          key,
          targetLocale,
          missingWarn,
          type2
        );
        if (missingRet !== key) {
          format2 = missingRet;
        }
      }
      return [format2, targetLocale, message2];
    }
    function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, errorDetector) {
      const { messageCompiler, warnHtmlMessage } = context;
      if (isMessageFunction(format2)) {
        const msg2 = format2;
        msg2.locale = msg2.locale || targetLocale;
        msg2.key = msg2.key || key;
        return msg2;
      }
      if (messageCompiler == null) {
        const msg2 = () => format2;
        msg2.locale = targetLocale;
        msg2.key = key;
        return msg2;
      }
      const msg = messageCompiler(format2, getCompileOptions(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, errorDetector));
      msg.locale = targetLocale;
      msg.key = key;
      msg.source = format2;
      return msg;
    }
    function evaluateMessage(context, msg, msgCtx) {
      const messaged = msg(msgCtx);
      return messaged;
    }
    function parseTranslateArgs(...args) {
      const [arg1, arg2, arg3] = args;
      const options = {};
      if (!isString(arg1) && !isNumber(arg1) && !isMessageFunction(arg1)) {
        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
      }
      const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
      if (isNumber(arg2)) {
        options.plural = arg2;
      } else if (isString(arg2)) {
        options.default = arg2;
      } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
        options.named = arg2;
      } else if (isArray(arg2)) {
        options.list = arg2;
      }
      if (isNumber(arg3)) {
        options.plural = arg3;
      } else if (isString(arg3)) {
        options.default = arg3;
      } else if (isPlainObject(arg3)) {
        assign(options, arg3);
      }
      return [key, options];
    }
    function getCompileOptions(context, locale, key, source, warnHtmlMessage, errorDetector) {
      return {
        warnHtmlMessage,
        onError: (err) => {
          errorDetector && errorDetector(err);
          {
            throw err;
          }
        },
        onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
      };
    }
    function getMessageContextOptions(context, locale, message2, options) {
      const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
      const resolveMessage = (key) => {
        let val = resolveValue2(message2, key);
        if (val == null && fallbackContext) {
          const [, , message3] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
          val = resolveValue2(message3, key);
        }
        if (isString(val)) {
          let occurred = false;
          const errorDetector = () => {
            occurred = true;
          };
          const msg = compileMessageFormat(context, key, locale, val, key, errorDetector);
          return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
        } else if (isMessageFunction(val)) {
          return val;
        } else {
          return NOOP_MESSAGE_FUNCTION;
        }
      };
      const ctxOptions = {
        locale,
        modifiers,
        pluralRules,
        messages: resolveMessage
      };
      if (context.processor) {
        ctxOptions.processor = context.processor;
      }
      if (options.list) {
        ctxOptions.list = options.list;
      }
      if (options.named) {
        ctxOptions.named = options.named;
      }
      if (isNumber(options.plural)) {
        ctxOptions.pluralIndex = options.plural;
      }
      return ctxOptions;
    }
    function datetime(context, ...args) {
      const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
      const { __datetimeFormatters } = context;
      const [key, value, options, overrides] = parseDateTimeArgs(...args);
      const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
      isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
      const part = !!options.part;
      const locale = isString(options.locale) ? options.locale : context.locale;
      const locales = localeFallbacker(
        context,
        fallbackLocale,
        locale
      );
      if (!isString(key) || key === "") {
        return new Intl.DateTimeFormat(locale, overrides).format(value);
      }
      let datetimeFormat = {};
      let targetLocale;
      let format2 = null;
      const type2 = "datetime format";
      for (let i = 0; i < locales.length; i++) {
        targetLocale = locales[i];
        datetimeFormat = datetimeFormats[targetLocale] || {};
        format2 = datetimeFormat[key];
        if (isPlainObject(format2))
          break;
        handleMissing(context, key, targetLocale, missingWarn, type2);
      }
      if (!isPlainObject(format2) || !isString(targetLocale)) {
        return unresolving ? NOT_REOSLVED : key;
      }
      let id2 = `${targetLocale}__${key}`;
      if (!isEmptyObject(overrides)) {
        id2 = `${id2}__${JSON.stringify(overrides)}`;
      }
      let formatter2 = __datetimeFormatters.get(id2);
      if (!formatter2) {
        formatter2 = new Intl.DateTimeFormat(targetLocale, assign({}, format2, overrides));
        __datetimeFormatters.set(id2, formatter2);
      }
      return !part ? formatter2.format(value) : formatter2.formatToParts(value);
    }
    const DATETIME_FORMAT_OPTIONS_KEYS = [
      "localeMatcher",
      "weekday",
      "era",
      "year",
      "month",
      "day",
      "hour",
      "minute",
      "second",
      "timeZoneName",
      "formatMatcher",
      "hour12",
      "timeZone",
      "dateStyle",
      "timeStyle",
      "calendar",
      "dayPeriod",
      "numberingSystem",
      "hourCycle",
      "fractionalSecondDigits"
    ];
    function parseDateTimeArgs(...args) {
      const [arg1, arg2, arg3, arg4] = args;
      const options = {};
      let overrides = {};
      let value;
      if (isString(arg1)) {
        const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
        if (!matches) {
          throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
        }
        const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
        value = new Date(dateTime);
        try {
          value.toISOString();
        } catch (e) {
          throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
        }
      } else if (isDate(arg1)) {
        if (isNaN(arg1.getTime())) {
          throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
        }
        value = arg1;
      } else if (isNumber(arg1)) {
        value = arg1;
      } else {
        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
      }
      if (isString(arg2)) {
        options.key = arg2;
      } else if (isPlainObject(arg2)) {
        Object.keys(arg2).forEach((key) => {
          if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
            overrides[key] = arg2[key];
          } else {
            options[key] = arg2[key];
          }
        });
      }
      if (isString(arg3)) {
        options.locale = arg3;
      } else if (isPlainObject(arg3)) {
        overrides = arg3;
      }
      if (isPlainObject(arg4)) {
        overrides = arg4;
      }
      return [options.key || "", value, options, overrides];
    }
    function clearDateTimeFormat(ctx, locale, format2) {
      const context = ctx;
      for (const key in format2) {
        const id2 = `${locale}__${key}`;
        if (!context.__datetimeFormatters.has(id2)) {
          continue;
        }
        context.__datetimeFormatters.delete(id2);
      }
    }
    function number(context, ...args) {
      const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
      const { __numberFormatters } = context;
      const [key, value, options, overrides] = parseNumberArgs(...args);
      const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
      isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
      const part = !!options.part;
      const locale = isString(options.locale) ? options.locale : context.locale;
      const locales = localeFallbacker(
        context,
        fallbackLocale,
        locale
      );
      if (!isString(key) || key === "") {
        return new Intl.NumberFormat(locale, overrides).format(value);
      }
      let numberFormat = {};
      let targetLocale;
      let format2 = null;
      const type2 = "number format";
      for (let i = 0; i < locales.length; i++) {
        targetLocale = locales[i];
        numberFormat = numberFormats[targetLocale] || {};
        format2 = numberFormat[key];
        if (isPlainObject(format2))
          break;
        handleMissing(context, key, targetLocale, missingWarn, type2);
      }
      if (!isPlainObject(format2) || !isString(targetLocale)) {
        return unresolving ? NOT_REOSLVED : key;
      }
      let id2 = `${targetLocale}__${key}`;
      if (!isEmptyObject(overrides)) {
        id2 = `${id2}__${JSON.stringify(overrides)}`;
      }
      let formatter2 = __numberFormatters.get(id2);
      if (!formatter2) {
        formatter2 = new Intl.NumberFormat(targetLocale, assign({}, format2, overrides));
        __numberFormatters.set(id2, formatter2);
      }
      return !part ? formatter2.format(value) : formatter2.formatToParts(value);
    }
    const NUMBER_FORMAT_OPTIONS_KEYS = [
      "localeMatcher",
      "style",
      "currency",
      "currencyDisplay",
      "currencySign",
      "useGrouping",
      "minimumIntegerDigits",
      "minimumFractionDigits",
      "maximumFractionDigits",
      "minimumSignificantDigits",
      "maximumSignificantDigits",
      "compactDisplay",
      "notation",
      "signDisplay",
      "unit",
      "unitDisplay",
      "roundingMode",
      "roundingPriority",
      "roundingIncrement",
      "trailingZeroDisplay"
    ];
    function parseNumberArgs(...args) {
      const [arg1, arg2, arg3, arg4] = args;
      const options = {};
      let overrides = {};
      if (!isNumber(arg1)) {
        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
      }
      const value = arg1;
      if (isString(arg2)) {
        options.key = arg2;
      } else if (isPlainObject(arg2)) {
        Object.keys(arg2).forEach((key) => {
          if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
            overrides[key] = arg2[key];
          } else {
            options[key] = arg2[key];
          }
        });
      }
      if (isString(arg3)) {
        options.locale = arg3;
      } else if (isPlainObject(arg3)) {
        overrides = arg3;
      }
      if (isPlainObject(arg4)) {
        overrides = arg4;
      }
      return [options.key || "", value, options, overrides];
    }
    function clearNumberFormat(ctx, locale, format2) {
      const context = ctx;
      for (const key in format2) {
        const id2 = `${locale}__${key}`;
        if (!context.__numberFormatters.has(id2)) {
          continue;
        }
        context.__numberFormatters.delete(id2);
      }
    }
    {
      if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
        getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
      }
    }
    /*!
      * vue-i18n v9.2.2
      * (c) 2022 kazuya kawaguchi
      * Released under the MIT License.
      */
    const VERSION = "9.2.2";
    function initFeatureFlags() {
      if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
        getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
      }
      if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
        getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
      }
      if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
        getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
      }
    }
    CoreWarnCodes.__EXTEND_POINT__;
    let code = CompileErrorCodes.__EXTEND_POINT__;
    const inc = () => ++code;
    const I18nErrorCodes = {
      UNEXPECTED_RETURN_TYPE: code,
      INVALID_ARGUMENT: inc(),
      MUST_BE_CALL_SETUP_TOP: inc(),
      NOT_INSLALLED: inc(),
      NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
      REQUIRED_VALUE: inc(),
      INVALID_VALUE: inc(),
      CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
      NOT_INSLALLED_WITH_PROVIDE: inc(),
      UNEXPECTED_ERROR: inc(),
      NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
      BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
      MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
      NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
      __EXTEND_POINT__: inc()
    };
    function createI18nError(code2, ...args) {
      return createCompileError(code2, null, void 0);
    }
    const TransrateVNodeSymbol = /* @__PURE__ */ makeSymbol("__transrateVNode");
    const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
    const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
    const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
    makeSymbol("__intlifyMeta");
    const InejctWithOption = /* @__PURE__ */ makeSymbol("__injectWithOption");
    function handleFlatJson(obj) {
      if (!isObject(obj)) {
        return obj;
      }
      for (const key in obj) {
        if (!hasOwn(obj, key)) {
          continue;
        }
        if (!key.includes(".")) {
          if (isObject(obj[key])) {
            handleFlatJson(obj[key]);
          }
        } else {
          const subKeys = key.split(".");
          const lastIndex = subKeys.length - 1;
          let currentObj = obj;
          for (let i = 0; i < lastIndex; i++) {
            if (!(subKeys[i] in currentObj)) {
              currentObj[subKeys[i]] = {};
            }
            currentObj = currentObj[subKeys[i]];
          }
          currentObj[subKeys[lastIndex]] = obj[key];
          delete obj[key];
          if (isObject(currentObj[subKeys[lastIndex]])) {
            handleFlatJson(currentObj[subKeys[lastIndex]]);
          }
        }
      }
      return obj;
    }
    function getLocaleMessages(locale, options) {
      const { messages: messages2, __i18n, messageResolver, flatJson } = options;
      const ret = isPlainObject(messages2) ? messages2 : isArray(__i18n) ? {} : { [locale]: {} };
      if (isArray(__i18n)) {
        __i18n.forEach((custom) => {
          if ("locale" in custom && "resource" in custom) {
            const { locale: locale2, resource } = custom;
            if (locale2) {
              ret[locale2] = ret[locale2] || {};
              deepCopy(resource, ret[locale2]);
            } else {
              deepCopy(resource, ret);
            }
          } else {
            isString(custom) && deepCopy(JSON.parse(custom), ret);
          }
        });
      }
      if (messageResolver == null && flatJson) {
        for (const key in ret) {
          if (hasOwn(ret, key)) {
            handleFlatJson(ret[key]);
          }
        }
      }
      return ret;
    }
    const isNotObjectOrIsArray = (val) => !isObject(val) || isArray(val);
    function deepCopy(src, des) {
      if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
        throw createI18nError(I18nErrorCodes.INVALID_VALUE);
      }
      for (const key in src) {
        if (hasOwn(src, key)) {
          if (isNotObjectOrIsArray(src[key]) || isNotObjectOrIsArray(des[key])) {
            des[key] = src[key];
          } else {
            deepCopy(src[key], des[key]);
          }
        }
      }
    }
    function getComponentOptions(instance) {
      return instance.type;
    }
    function adjustI18nResources(global2, options, componentOptions) {
      let messages2 = isObject(options.messages) ? options.messages : {};
      if ("__i18nGlobal" in componentOptions) {
        messages2 = getLocaleMessages(global2.locale.value, {
          messages: messages2,
          __i18n: componentOptions.__i18nGlobal
        });
      }
      const locales = Object.keys(messages2);
      if (locales.length) {
        locales.forEach((locale) => {
          global2.mergeLocaleMessage(locale, messages2[locale]);
        });
      }
      {
        if (isObject(options.datetimeFormats)) {
          const locales2 = Object.keys(options.datetimeFormats);
          if (locales2.length) {
            locales2.forEach((locale) => {
              global2.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
            });
          }
        }
        if (isObject(options.numberFormats)) {
          const locales2 = Object.keys(options.numberFormats);
          if (locales2.length) {
            locales2.forEach((locale) => {
              global2.mergeNumberFormat(locale, options.numberFormats[locale]);
            });
          }
        }
      }
    }
    function createTextNode(key) {
      return createVNode(Text, null, key, 0);
    }
    const DEVTOOLS_META = "__INTLIFY_META__";
    let composerID = 0;
    function defineCoreMissingHandler(missing) {
      return (ctx, locale, key, type2) => {
        return missing(locale, key, getCurrentInstance() || void 0, type2);
      };
    }
    const getMetaInfo = () => {
      const instance = getCurrentInstance();
      let meta = null;
      return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
    };
    function createComposer(options = {}, VueI18nLegacy) {
      const { __root } = options;
      const _isGlobal = __root === void 0;
      let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
      const _locale = ref(
        __root && _inheritLocale ? __root.locale.value : isString(options.locale) ? options.locale : DEFAULT_LOCALE
      );
      const _fallbackLocale = ref(
        __root && _inheritLocale ? __root.fallbackLocale.value : isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
      );
      const _messages = ref(getLocaleMessages(_locale.value, options));
      const _datetimeFormats = ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
      const _numberFormats = ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
      let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
      let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
      let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
      let _fallbackFormat = !!options.fallbackFormat;
      let _missing = isFunction(options.missing) ? options.missing : null;
      let _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
      let _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
      let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
      let _escapeParameter = !!options.escapeParameter;
      const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
      let _pluralRules = options.pluralRules || __root && __root.pluralRules;
      let _context;
      const getCoreContext = () => {
        _isGlobal && setFallbackContext(null);
        const ctxOptions = {
          version: VERSION,
          locale: _locale.value,
          fallbackLocale: _fallbackLocale.value,
          messages: _messages.value,
          modifiers: _modifiers,
          pluralRules: _pluralRules,
          missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
          missingWarn: _missingWarn,
          fallbackWarn: _fallbackWarn,
          fallbackFormat: _fallbackFormat,
          unresolving: true,
          postTranslation: _postTranslation === null ? void 0 : _postTranslation,
          warnHtmlMessage: _warnHtmlMessage,
          escapeParameter: _escapeParameter,
          messageResolver: options.messageResolver,
          __meta: { framework: "vue" }
        };
        {
          ctxOptions.datetimeFormats = _datetimeFormats.value;
          ctxOptions.numberFormats = _numberFormats.value;
          ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
          ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
        }
        const ctx = createCoreContext(ctxOptions);
        _isGlobal && setFallbackContext(ctx);
        return ctx;
      };
      _context = getCoreContext();
      updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      function trackReactivityValues() {
        return [
          _locale.value,
          _fallbackLocale.value,
          _messages.value,
          _datetimeFormats.value,
          _numberFormats.value
        ];
      }
      const locale = computed({
        get: () => _locale.value,
        set: (val) => {
          _locale.value = val;
          _context.locale = _locale.value;
        }
      });
      const fallbackLocale = computed({
        get: () => _fallbackLocale.value,
        set: (val) => {
          _fallbackLocale.value = val;
          _context.fallbackLocale = _fallbackLocale.value;
          updateFallbackLocale(_context, _locale.value, val);
        }
      });
      const messages2 = computed(() => _messages.value);
      const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
      const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
      function getPostTranslationHandler() {
        return isFunction(_postTranslation) ? _postTranslation : null;
      }
      function setPostTranslationHandler(handler) {
        _postTranslation = handler;
        _context.postTranslation = handler;
      }
      function getMissingHandler() {
        return _missing;
      }
      function setMissingHandler(handler) {
        if (handler !== null) {
          _runtimeMissing = defineCoreMissingHandler(handler);
        }
        _missing = handler;
        _context.missing = _runtimeMissing;
      }
      const wrapWithDeps = (fn2, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
        trackReactivityValues();
        let ret;
        if (__INTLIFY_PROD_DEVTOOLS__) {
          try {
            setAdditionalMeta(getMetaInfo());
            if (!_isGlobal) {
              _context.fallbackContext = __root ? getFallbackContext() : void 0;
            }
            ret = fn2(_context);
          } finally {
            setAdditionalMeta(null);
            if (!_isGlobal) {
              _context.fallbackContext = void 0;
            }
          }
        } else {
          ret = fn2(_context);
        }
        if (isNumber(ret) && ret === NOT_REOSLVED) {
          const [key, arg2] = argumentParser();
          return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
        } else if (successCondition(ret)) {
          return ret;
        } else {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
        }
      };
      function t(...args) {
        return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root2) => Reflect.apply(root2.t, root2, [...args]), (key) => key, (val) => isString(val));
      }
      function rt2(...args) {
        const [arg1, arg2, arg3] = args;
        if (arg3 && !isObject(arg3)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        return t(...[arg1, arg2, assign({ resolvedMessage: true }, arg3 || {})]);
      }
      function d2(...args) {
        return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root2) => Reflect.apply(root2.d, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
      }
      function n(...args) {
        return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root2) => Reflect.apply(root2.n, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
      }
      function normalize(values) {
        return values.map((val) => isString(val) || isNumber(val) || isBoolean(val) ? createTextNode(String(val)) : val);
      }
      const interpolate = (val) => val;
      const processor = {
        normalize,
        interpolate,
        type: "vnode"
      };
      function transrateVNode(...args) {
        return wrapWithDeps(
          (context) => {
            let ret;
            const _context2 = context;
            try {
              _context2.processor = processor;
              ret = Reflect.apply(translate, null, [_context2, ...args]);
            } finally {
              _context2.processor = null;
            }
            return ret;
          },
          () => parseTranslateArgs(...args),
          "translate",
          (root2) => root2[TransrateVNodeSymbol](...args),
          (key) => [createTextNode(key)],
          (val) => isArray(val)
        );
      }
      function numberParts(...args) {
        return wrapWithDeps(
          (context) => Reflect.apply(number, null, [context, ...args]),
          () => parseNumberArgs(...args),
          "number format",
          (root2) => root2[NumberPartsSymbol](...args),
          () => [],
          (val) => isString(val) || isArray(val)
        );
      }
      function datetimeParts(...args) {
        return wrapWithDeps(
          (context) => Reflect.apply(datetime, null, [context, ...args]),
          () => parseDateTimeArgs(...args),
          "datetime format",
          (root2) => root2[DatetimePartsSymbol](...args),
          () => [],
          (val) => isString(val) || isArray(val)
        );
      }
      function setPluralRules(rules2) {
        _pluralRules = rules2;
        _context.pluralRules = _pluralRules;
      }
      function te2(key, locale2) {
        const targetLocale = isString(locale2) ? locale2 : _locale.value;
        const message2 = getLocaleMessage(targetLocale);
        return _context.messageResolver(message2, key) !== null;
      }
      function resolveMessages(key) {
        let messages3 = null;
        const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
        for (let i = 0; i < locales.length; i++) {
          const targetLocaleMessages = _messages.value[locales[i]] || {};
          const messageValue = _context.messageResolver(targetLocaleMessages, key);
          if (messageValue != null) {
            messages3 = messageValue;
            break;
          }
        }
        return messages3;
      }
      function tm(key) {
        const messages3 = resolveMessages(key);
        return messages3 != null ? messages3 : __root ? __root.tm(key) || {} : {};
      }
      function getLocaleMessage(locale2) {
        return _messages.value[locale2] || {};
      }
      function setLocaleMessage(locale2, message2) {
        _messages.value[locale2] = message2;
        _context.messages = _messages.value;
      }
      function mergeLocaleMessage(locale2, message2) {
        _messages.value[locale2] = _messages.value[locale2] || {};
        deepCopy(message2, _messages.value[locale2]);
        _context.messages = _messages.value;
      }
      function getDateTimeFormat(locale2) {
        return _datetimeFormats.value[locale2] || {};
      }
      function setDateTimeFormat(locale2, format2) {
        _datetimeFormats.value[locale2] = format2;
        _context.datetimeFormats = _datetimeFormats.value;
        clearDateTimeFormat(_context, locale2, format2);
      }
      function mergeDateTimeFormat(locale2, format2) {
        _datetimeFormats.value[locale2] = assign(_datetimeFormats.value[locale2] || {}, format2);
        _context.datetimeFormats = _datetimeFormats.value;
        clearDateTimeFormat(_context, locale2, format2);
      }
      function getNumberFormat(locale2) {
        return _numberFormats.value[locale2] || {};
      }
      function setNumberFormat(locale2, format2) {
        _numberFormats.value[locale2] = format2;
        _context.numberFormats = _numberFormats.value;
        clearNumberFormat(_context, locale2, format2);
      }
      function mergeNumberFormat(locale2, format2) {
        _numberFormats.value[locale2] = assign(_numberFormats.value[locale2] || {}, format2);
        _context.numberFormats = _numberFormats.value;
        clearNumberFormat(_context, locale2, format2);
      }
      composerID++;
      if (__root && inBrowser) {
        watch(__root.locale, (val) => {
          if (_inheritLocale) {
            _locale.value = val;
            _context.locale = val;
            updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
          }
        });
        watch(__root.fallbackLocale, (val) => {
          if (_inheritLocale) {
            _fallbackLocale.value = val;
            _context.fallbackLocale = val;
            updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
          }
        });
      }
      const composer = {
        id: composerID,
        locale,
        fallbackLocale,
        get inheritLocale() {
          return _inheritLocale;
        },
        set inheritLocale(val) {
          _inheritLocale = val;
          if (val && __root) {
            _locale.value = __root.locale.value;
            _fallbackLocale.value = __root.fallbackLocale.value;
            updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
          }
        },
        get availableLocales() {
          return Object.keys(_messages.value).sort();
        },
        messages: messages2,
        get modifiers() {
          return _modifiers;
        },
        get pluralRules() {
          return _pluralRules || {};
        },
        get isGlobal() {
          return _isGlobal;
        },
        get missingWarn() {
          return _missingWarn;
        },
        set missingWarn(val) {
          _missingWarn = val;
          _context.missingWarn = _missingWarn;
        },
        get fallbackWarn() {
          return _fallbackWarn;
        },
        set fallbackWarn(val) {
          _fallbackWarn = val;
          _context.fallbackWarn = _fallbackWarn;
        },
        get fallbackRoot() {
          return _fallbackRoot;
        },
        set fallbackRoot(val) {
          _fallbackRoot = val;
        },
        get fallbackFormat() {
          return _fallbackFormat;
        },
        set fallbackFormat(val) {
          _fallbackFormat = val;
          _context.fallbackFormat = _fallbackFormat;
        },
        get warnHtmlMessage() {
          return _warnHtmlMessage;
        },
        set warnHtmlMessage(val) {
          _warnHtmlMessage = val;
          _context.warnHtmlMessage = val;
        },
        get escapeParameter() {
          return _escapeParameter;
        },
        set escapeParameter(val) {
          _escapeParameter = val;
          _context.escapeParameter = val;
        },
        t,
        getLocaleMessage,
        setLocaleMessage,
        mergeLocaleMessage,
        getPostTranslationHandler,
        setPostTranslationHandler,
        getMissingHandler,
        setMissingHandler,
        [SetPluralRulesSymbol]: setPluralRules
      };
      {
        composer.datetimeFormats = datetimeFormats;
        composer.numberFormats = numberFormats;
        composer.rt = rt2;
        composer.te = te2;
        composer.tm = tm;
        composer.d = d2;
        composer.n = n;
        composer.getDateTimeFormat = getDateTimeFormat;
        composer.setDateTimeFormat = setDateTimeFormat;
        composer.mergeDateTimeFormat = mergeDateTimeFormat;
        composer.getNumberFormat = getNumberFormat;
        composer.setNumberFormat = setNumberFormat;
        composer.mergeNumberFormat = mergeNumberFormat;
        composer[InejctWithOption] = options.__injectWithOption;
        composer[TransrateVNodeSymbol] = transrateVNode;
        composer[DatetimePartsSymbol] = datetimeParts;
        composer[NumberPartsSymbol] = numberParts;
      }
      return composer;
    }
    function convertComposerOptions(options) {
      const locale = isString(options.locale) ? options.locale : DEFAULT_LOCALE;
      const fallbackLocale = isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
      const missing = isFunction(options.missing) ? options.missing : void 0;
      const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
      const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
      const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
      const fallbackFormat = !!options.formatFallbackMessages;
      const modifiers = isPlainObject(options.modifiers) ? options.modifiers : {};
      const pluralizationRules = options.pluralizationRules;
      const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : void 0;
      const warnHtmlMessage = isString(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
      const escapeParameter = !!options.escapeParameterHtml;
      const inheritLocale = isBoolean(options.sync) ? options.sync : true;
      let messages2 = options.messages;
      if (isPlainObject(options.sharedMessages)) {
        const sharedMessages = options.sharedMessages;
        const locales = Object.keys(sharedMessages);
        messages2 = locales.reduce((messages3, locale2) => {
          const message2 = messages3[locale2] || (messages3[locale2] = {});
          assign(message2, sharedMessages[locale2]);
          return messages3;
        }, messages2 || {});
      }
      const { __i18n, __root, __injectWithOption } = options;
      const datetimeFormats = options.datetimeFormats;
      const numberFormats = options.numberFormats;
      const flatJson = options.flatJson;
      return {
        locale,
        fallbackLocale,
        messages: messages2,
        flatJson,
        datetimeFormats,
        numberFormats,
        missing,
        missingWarn,
        fallbackWarn,
        fallbackRoot,
        fallbackFormat,
        modifiers,
        pluralRules: pluralizationRules,
        postTranslation,
        warnHtmlMessage,
        escapeParameter,
        messageResolver: options.messageResolver,
        inheritLocale,
        __i18n,
        __root,
        __injectWithOption
      };
    }
    function createVueI18n(options = {}, VueI18nLegacy) {
      {
        const composer = createComposer(convertComposerOptions(options));
        const vueI18n = {
          id: composer.id,
          get locale() {
            return composer.locale.value;
          },
          set locale(val) {
            composer.locale.value = val;
          },
          get fallbackLocale() {
            return composer.fallbackLocale.value;
          },
          set fallbackLocale(val) {
            composer.fallbackLocale.value = val;
          },
          get messages() {
            return composer.messages.value;
          },
          get datetimeFormats() {
            return composer.datetimeFormats.value;
          },
          get numberFormats() {
            return composer.numberFormats.value;
          },
          get availableLocales() {
            return composer.availableLocales;
          },
          get formatter() {
            return {
              interpolate() {
                return [];
              }
            };
          },
          set formatter(val) {
          },
          get missing() {
            return composer.getMissingHandler();
          },
          set missing(handler) {
            composer.setMissingHandler(handler);
          },
          get silentTranslationWarn() {
            return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
          },
          set silentTranslationWarn(val) {
            composer.missingWarn = isBoolean(val) ? !val : val;
          },
          get silentFallbackWarn() {
            return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
          },
          set silentFallbackWarn(val) {
            composer.fallbackWarn = isBoolean(val) ? !val : val;
          },
          get modifiers() {
            return composer.modifiers;
          },
          get formatFallbackMessages() {
            return composer.fallbackFormat;
          },
          set formatFallbackMessages(val) {
            composer.fallbackFormat = val;
          },
          get postTranslation() {
            return composer.getPostTranslationHandler();
          },
          set postTranslation(handler) {
            composer.setPostTranslationHandler(handler);
          },
          get sync() {
            return composer.inheritLocale;
          },
          set sync(val) {
            composer.inheritLocale = val;
          },
          get warnHtmlInMessage() {
            return composer.warnHtmlMessage ? "warn" : "off";
          },
          set warnHtmlInMessage(val) {
            composer.warnHtmlMessage = val !== "off";
          },
          get escapeParameterHtml() {
            return composer.escapeParameter;
          },
          set escapeParameterHtml(val) {
            composer.escapeParameter = val;
          },
          get preserveDirectiveContent() {
            return true;
          },
          set preserveDirectiveContent(val) {
          },
          get pluralizationRules() {
            return composer.pluralRules || {};
          },
          __composer: composer,
          t(...args) {
            const [arg1, arg2, arg3] = args;
            const options2 = {};
            let list = null;
            let named = null;
            if (!isString(arg1)) {
              throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
            }
            const key = arg1;
            if (isString(arg2)) {
              options2.locale = arg2;
            } else if (isArray(arg2)) {
              list = arg2;
            } else if (isPlainObject(arg2)) {
              named = arg2;
            }
            if (isArray(arg3)) {
              list = arg3;
            } else if (isPlainObject(arg3)) {
              named = arg3;
            }
            return Reflect.apply(composer.t, composer, [
              key,
              list || named || {},
              options2
            ]);
          },
          rt(...args) {
            return Reflect.apply(composer.rt, composer, [...args]);
          },
          tc(...args) {
            const [arg1, arg2, arg3] = args;
            const options2 = { plural: 1 };
            let list = null;
            let named = null;
            if (!isString(arg1)) {
              throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
            }
            const key = arg1;
            if (isString(arg2)) {
              options2.locale = arg2;
            } else if (isNumber(arg2)) {
              options2.plural = arg2;
            } else if (isArray(arg2)) {
              list = arg2;
            } else if (isPlainObject(arg2)) {
              named = arg2;
            }
            if (isString(arg3)) {
              options2.locale = arg3;
            } else if (isArray(arg3)) {
              list = arg3;
            } else if (isPlainObject(arg3)) {
              named = arg3;
            }
            return Reflect.apply(composer.t, composer, [
              key,
              list || named || {},
              options2
            ]);
          },
          te(key, locale) {
            return composer.te(key, locale);
          },
          tm(key) {
            return composer.tm(key);
          },
          getLocaleMessage(locale) {
            return composer.getLocaleMessage(locale);
          },
          setLocaleMessage(locale, message2) {
            composer.setLocaleMessage(locale, message2);
          },
          mergeLocaleMessage(locale, message2) {
            composer.mergeLocaleMessage(locale, message2);
          },
          d(...args) {
            return Reflect.apply(composer.d, composer, [...args]);
          },
          getDateTimeFormat(locale) {
            return composer.getDateTimeFormat(locale);
          },
          setDateTimeFormat(locale, format2) {
            composer.setDateTimeFormat(locale, format2);
          },
          mergeDateTimeFormat(locale, format2) {
            composer.mergeDateTimeFormat(locale, format2);
          },
          n(...args) {
            return Reflect.apply(composer.n, composer, [...args]);
          },
          getNumberFormat(locale) {
            return composer.getNumberFormat(locale);
          },
          setNumberFormat(locale, format2) {
            composer.setNumberFormat(locale, format2);
          },
          mergeNumberFormat(locale, format2) {
            composer.mergeNumberFormat(locale, format2);
          },
          getChoiceIndex(choice, choicesLength) {
            return -1;
          },
          __onComponentInstanceCreated(target) {
            const { componentInstanceCreatedListener } = options;
            if (componentInstanceCreatedListener) {
              componentInstanceCreatedListener(target, vueI18n);
            }
          }
        };
        return vueI18n;
      }
    }
    const baseFormatProps = {
      tag: {
        type: [String, Object]
      },
      locale: {
        type: String
      },
      scope: {
        type: String,
        validator: (val) => val === "parent" || val === "global",
        default: "parent"
      },
      i18n: {
        type: Object
      }
    };
    function getInterpolateArg({ slots }, keys2) {
      if (keys2.length === 1 && keys2[0] === "default") {
        const ret = slots.default ? slots.default() : [];
        return ret.reduce((slot, current) => {
          return slot = [
            ...slot,
            ...isArray(current.children) ? current.children : [current]
          ];
        }, []);
      } else {
        return keys2.reduce((arg, key) => {
          const slot = slots[key];
          if (slot) {
            arg[key] = slot();
          }
          return arg;
        }, {});
      }
    }
    function getFragmentableTag(tag) {
      return Fragment;
    }
    const Translation = {
      name: "i18n-t",
      props: assign({
        keypath: {
          type: String,
          required: true
        },
        plural: {
          type: [Number, String],
          validator: (val) => isNumber(val) || !isNaN(val)
        }
      }, baseFormatProps),
      setup(props, context) {
        const { slots, attrs } = context;
        const i18n2 = props.i18n || useI18n({
          useScope: props.scope,
          __useComponent: true
        });
        return () => {
          const keys2 = Object.keys(slots).filter((key) => key !== "_");
          const options = {};
          if (props.locale) {
            options.locale = props.locale;
          }
          if (props.plural !== void 0) {
            options.plural = isString(props.plural) ? +props.plural : props.plural;
          }
          const arg = getInterpolateArg(context, keys2);
          const children = i18n2[TransrateVNodeSymbol](props.keypath, arg, options);
          const assignedAttrs = assign({}, attrs);
          const tag = isString(props.tag) || isObject(props.tag) ? props.tag : getFragmentableTag();
          return h$1(tag, assignedAttrs, children);
        };
      }
    };
    function isVNode(target) {
      return isArray(target) && !isString(target[0]);
    }
    function renderFormatter(props, context, slotKeys, partFormatter) {
      const { slots, attrs } = context;
      return () => {
        const options = { part: true };
        let overrides = {};
        if (props.locale) {
          options.locale = props.locale;
        }
        if (isString(props.format)) {
          options.key = props.format;
        } else if (isObject(props.format)) {
          if (isString(props.format.key)) {
            options.key = props.format.key;
          }
          overrides = Object.keys(props.format).reduce((options2, prop) => {
            return slotKeys.includes(prop) ? assign({}, options2, { [prop]: props.format[prop] }) : options2;
          }, {});
        }
        const parts = partFormatter(...[props.value, options, overrides]);
        let children = [options.key];
        if (isArray(parts)) {
          children = parts.map((part, index2) => {
            const slot = slots[part.type];
            const node = slot ? slot({ [part.type]: part.value, index: index2, parts }) : [part.value];
            if (isVNode(node)) {
              node[0].key = `${part.type}-${index2}`;
            }
            return node;
          });
        } else if (isString(parts)) {
          children = [parts];
        }
        const assignedAttrs = assign({}, attrs);
        const tag = isString(props.tag) || isObject(props.tag) ? props.tag : getFragmentableTag();
        return h$1(tag, assignedAttrs, children);
      };
    }
    const NumberFormat = {
      name: "i18n-n",
      props: assign({
        value: {
          type: Number,
          required: true
        },
        format: {
          type: [String, Object]
        }
      }, baseFormatProps),
      setup(props, context) {
        const i18n2 = props.i18n || useI18n({ useScope: "parent", __useComponent: true });
        return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => i18n2[NumberPartsSymbol](...args));
      }
    };
    const DatetimeFormat = {
      name: "i18n-d",
      props: assign({
        value: {
          type: [Number, Date],
          required: true
        },
        format: {
          type: [String, Object]
        }
      }, baseFormatProps),
      setup(props, context) {
        const i18n2 = props.i18n || useI18n({ useScope: "parent", __useComponent: true });
        return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => i18n2[DatetimePartsSymbol](...args));
      }
    };
    function getComposer$2(i18n2, instance) {
      const i18nInternal = i18n2;
      if (i18n2.mode === "composition") {
        return i18nInternal.__getInstance(instance) || i18n2.global;
      } else {
        const vueI18n = i18nInternal.__getInstance(instance);
        return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
      }
    }
    function vTDirective(i18n2) {
      const _process = (binding) => {
        const { instance, modifiers, value } = binding;
        if (!instance || !instance.$) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const composer = getComposer$2(i18n2, instance.$);
        const parsedValue2 = parseValue(value);
        return [
          Reflect.apply(composer.t, composer, [...makeParams(parsedValue2)]),
          composer
        ];
      };
      const register = (el, binding) => {
        const [textContent, composer] = _process(binding);
        if (inBrowser && i18n2.global === composer) {
          el.__i18nWatcher = watch(composer.locale, () => {
            binding.instance && binding.instance.$forceUpdate();
          });
        }
        el.__composer = composer;
        el.textContent = textContent;
      };
      const unregister = (el) => {
        if (inBrowser && el.__i18nWatcher) {
          el.__i18nWatcher();
          el.__i18nWatcher = void 0;
          delete el.__i18nWatcher;
        }
        if (el.__composer) {
          el.__composer = void 0;
          delete el.__composer;
        }
      };
      const update = (el, { value }) => {
        if (el.__composer) {
          const composer = el.__composer;
          const parsedValue2 = parseValue(value);
          el.textContent = Reflect.apply(composer.t, composer, [
            ...makeParams(parsedValue2)
          ]);
        }
      };
      const getSSRProps = (binding) => {
        const [textContent] = _process(binding);
        return { textContent };
      };
      return {
        created: register,
        unmounted: unregister,
        beforeUpdate: update,
        getSSRProps
      };
    }
    function parseValue(value) {
      if (isString(value)) {
        return { path: value };
      } else if (isPlainObject(value)) {
        if (!("path" in value)) {
          throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
        }
        return value;
      } else {
        throw createI18nError(I18nErrorCodes.INVALID_VALUE);
      }
    }
    function makeParams(value) {
      const { path, locale, args, choice, plural } = value;
      const options = {};
      const named = args || {};
      if (isString(locale)) {
        options.locale = locale;
      }
      if (isNumber(choice)) {
        options.plural = choice;
      }
      if (isNumber(plural)) {
        options.plural = plural;
      }
      return [path, named, options];
    }
    function apply(app2, i18n2, ...options) {
      const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
      const useI18nComponentName = !!pluginOptions.useI18nComponentName;
      const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
      if (globalInstall) {
        app2.component(!useI18nComponentName ? Translation.name : "i18n", Translation);
        app2.component(NumberFormat.name, NumberFormat);
        app2.component(DatetimeFormat.name, DatetimeFormat);
      }
      {
        app2.directive("t", vTDirective(i18n2));
      }
    }
    function defineMixin(vuei18n, composer, i18n2) {
      return {
        beforeCreate() {
          const instance = getCurrentInstance();
          if (!instance) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
          }
          const options = this.$options;
          if (options.i18n) {
            const optionsI18n = options.i18n;
            if (options.__i18n) {
              optionsI18n.__i18n = options.__i18n;
            }
            optionsI18n.__root = composer;
            if (this === this.$root) {
              this.$i18n = mergeToRoot(vuei18n, optionsI18n);
            } else {
              optionsI18n.__injectWithOption = true;
              this.$i18n = createVueI18n(optionsI18n);
            }
          } else if (options.__i18n) {
            if (this === this.$root) {
              this.$i18n = mergeToRoot(vuei18n, options);
            } else {
              this.$i18n = createVueI18n({
                __i18n: options.__i18n,
                __injectWithOption: true,
                __root: composer
              });
            }
          } else {
            this.$i18n = vuei18n;
          }
          if (options.__i18nGlobal) {
            adjustI18nResources(composer, options, options);
          }
          vuei18n.__onComponentInstanceCreated(this.$i18n);
          i18n2.__setInstance(instance, this.$i18n);
          this.$t = (...args) => this.$i18n.t(...args);
          this.$rt = (...args) => this.$i18n.rt(...args);
          this.$tc = (...args) => this.$i18n.tc(...args);
          this.$te = (key, locale) => this.$i18n.te(key, locale);
          this.$d = (...args) => this.$i18n.d(...args);
          this.$n = (...args) => this.$i18n.n(...args);
          this.$tm = (key) => this.$i18n.tm(key);
        },
        mounted() {
        },
        unmounted() {
          const instance = getCurrentInstance();
          if (!instance) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
          }
          delete this.$t;
          delete this.$rt;
          delete this.$tc;
          delete this.$te;
          delete this.$d;
          delete this.$n;
          delete this.$tm;
          i18n2.__deleteInstance(instance);
          delete this.$i18n;
        }
      };
    }
    function mergeToRoot(root2, options) {
      root2.locale = options.locale || root2.locale;
      root2.fallbackLocale = options.fallbackLocale || root2.fallbackLocale;
      root2.missing = options.missing || root2.missing;
      root2.silentTranslationWarn = options.silentTranslationWarn || root2.silentFallbackWarn;
      root2.silentFallbackWarn = options.silentFallbackWarn || root2.silentFallbackWarn;
      root2.formatFallbackMessages = options.formatFallbackMessages || root2.formatFallbackMessages;
      root2.postTranslation = options.postTranslation || root2.postTranslation;
      root2.warnHtmlInMessage = options.warnHtmlInMessage || root2.warnHtmlInMessage;
      root2.escapeParameterHtml = options.escapeParameterHtml || root2.escapeParameterHtml;
      root2.sync = options.sync || root2.sync;
      root2.__composer[SetPluralRulesSymbol](options.pluralizationRules || root2.pluralizationRules);
      const messages2 = getLocaleMessages(root2.locale, {
        messages: options.messages,
        __i18n: options.__i18n
      });
      Object.keys(messages2).forEach((locale) => root2.mergeLocaleMessage(locale, messages2[locale]));
      if (options.datetimeFormats) {
        Object.keys(options.datetimeFormats).forEach((locale) => root2.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
      }
      if (options.numberFormats) {
        Object.keys(options.numberFormats).forEach((locale) => root2.mergeNumberFormat(locale, options.numberFormats[locale]));
      }
      return root2;
    }
    const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
    function createI18n(options = {}, VueI18nLegacy) {
      const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
      const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
      const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;
      const __instances = /* @__PURE__ */ new Map();
      const [globalScope, __global] = createGlobal(options, __legacyMode);
      const symbol = makeSymbol("");
      function __getInstance(component2) {
        return __instances.get(component2) || null;
      }
      function __setInstance(component2, instance) {
        __instances.set(component2, instance);
      }
      function __deleteInstance(component2) {
        __instances.delete(component2);
      }
      {
        const i18n2 = {
          get mode() {
            return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
          },
          get allowComposition() {
            return __allowComposition;
          },
          async install(app2, ...options2) {
            app2.__VUE_I18N_SYMBOL__ = symbol;
            app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
            if (!__legacyMode && __globalInjection) {
              injectGlobalFields(app2, i18n2.global);
            }
            if (__VUE_I18N_FULL_INSTALL__) {
              apply(app2, i18n2, ...options2);
            }
            if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
              app2.mixin(defineMixin(__global, __global.__composer, i18n2));
            }
            const unmountApp = app2.unmount;
            app2.unmount = () => {
              i18n2.dispose();
              unmountApp();
            };
          },
          get global() {
            return __global;
          },
          dispose() {
            globalScope.stop();
          },
          __instances,
          __getInstance,
          __setInstance,
          __deleteInstance
        };
        return i18n2;
      }
    }
    function useI18n(options = {}) {
      const instance = getCurrentInstance();
      if (instance == null) {
        throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
      }
      if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
        throw createI18nError(I18nErrorCodes.NOT_INSLALLED);
      }
      const i18n2 = getI18nInstance(instance);
      const global2 = getGlobalComposer(i18n2);
      const componentOptions = getComponentOptions(instance);
      const scope = getScope(options, componentOptions);
      if (__VUE_I18N_LEGACY_API__) {
        if (i18n2.mode === "legacy" && !options.__useComponent) {
          if (!i18n2.allowComposition) {
            throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
          }
          return useI18nForLegacy(instance, scope, global2, options);
        }
      }
      if (scope === "global") {
        adjustI18nResources(global2, options, componentOptions);
        return global2;
      }
      if (scope === "parent") {
        let composer2 = getComposer(i18n2, instance, options.__useComponent);
        if (composer2 == null) {
          composer2 = global2;
        }
        return composer2;
      }
      const i18nInternal = i18n2;
      let composer = i18nInternal.__getInstance(instance);
      if (composer == null) {
        const composerOptions = assign({}, options);
        if ("__i18n" in componentOptions) {
          composerOptions.__i18n = componentOptions.__i18n;
        }
        if (global2) {
          composerOptions.__root = global2;
        }
        composer = createComposer(composerOptions);
        setupLifeCycle(i18nInternal, instance);
        i18nInternal.__setInstance(instance, composer);
      }
      return composer;
    }
    function createGlobal(options, legacyMode, VueI18nLegacy) {
      const scope = effectScope();
      {
        const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
        if (obj == null) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        return [scope, obj];
      }
    }
    function getI18nInstance(instance) {
      {
        const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
        if (!i18n2) {
          throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSLALLED_WITH_PROVIDE);
        }
        return i18n2;
      }
    }
    function getScope(options, componentOptions) {
      return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
    }
    function getGlobalComposer(i18n2) {
      return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
    }
    function getComposer(i18n2, target, useComponent = false) {
      let composer = null;
      const root2 = target.root;
      let current = target.parent;
      while (current != null) {
        const i18nInternal = i18n2;
        if (i18n2.mode === "composition") {
          composer = i18nInternal.__getInstance(current);
        } else {
          if (__VUE_I18N_LEGACY_API__) {
            const vueI18n = i18nInternal.__getInstance(current);
            if (vueI18n != null) {
              composer = vueI18n.__composer;
              if (useComponent && composer && !composer[InejctWithOption]) {
                composer = null;
              }
            }
          }
        }
        if (composer != null) {
          break;
        }
        if (root2 === current) {
          break;
        }
        current = current.parent;
      }
      return composer;
    }
    function setupLifeCycle(i18n2, target, composer) {
      {
        onMounted(() => {
        }, target);
        onUnmounted(() => {
          i18n2.__deleteInstance(target);
        }, target);
      }
    }
    function useI18nForLegacy(instance, scope, root2, options = {}) {
      const isLocale = scope === "local";
      const _composer = shallowRef(null);
      if (isLocale && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
        throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
      }
      const _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
      const _locale = ref(
        isLocale && _inheritLocale ? root2.locale.value : isString(options.locale) ? options.locale : DEFAULT_LOCALE
      );
      const _fallbackLocale = ref(
        isLocale && _inheritLocale ? root2.fallbackLocale.value : isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
      );
      const _messages = ref(getLocaleMessages(_locale.value, options));
      const _datetimeFormats = ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
      const _numberFormats = ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
      const _missingWarn = isLocale ? root2.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
      const _fallbackWarn = isLocale ? root2.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
      const _fallbackRoot = isLocale ? root2.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
      const _fallbackFormat = !!options.fallbackFormat;
      const _missing = isFunction(options.missing) ? options.missing : null;
      const _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
      const _warnHtmlMessage = isLocale ? root2.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
      const _escapeParameter = !!options.escapeParameter;
      const _modifiers = isLocale ? root2.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
      const _pluralRules = options.pluralRules || isLocale && root2.pluralRules;
      function trackReactivityValues() {
        return [
          _locale.value,
          _fallbackLocale.value,
          _messages.value,
          _datetimeFormats.value,
          _numberFormats.value
        ];
      }
      const locale = computed({
        get: () => {
          return _composer.value ? _composer.value.locale.value : _locale.value;
        },
        set: (val) => {
          if (_composer.value) {
            _composer.value.locale.value = val;
          }
          _locale.value = val;
        }
      });
      const fallbackLocale = computed({
        get: () => {
          return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
        },
        set: (val) => {
          if (_composer.value) {
            _composer.value.fallbackLocale.value = val;
          }
          _fallbackLocale.value = val;
        }
      });
      const messages2 = computed(() => {
        if (_composer.value) {
          return _composer.value.messages.value;
        } else {
          return _messages.value;
        }
      });
      const datetimeFormats = computed(() => _datetimeFormats.value);
      const numberFormats = computed(() => _numberFormats.value);
      function getPostTranslationHandler() {
        return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
      }
      function setPostTranslationHandler(handler) {
        if (_composer.value) {
          _composer.value.setPostTranslationHandler(handler);
        }
      }
      function getMissingHandler() {
        return _composer.value ? _composer.value.getMissingHandler() : _missing;
      }
      function setMissingHandler(handler) {
        if (_composer.value) {
          _composer.value.setMissingHandler(handler);
        }
      }
      function warpWithDeps(fn2) {
        trackReactivityValues();
        return fn2();
      }
      function t(...args) {
        return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
      }
      function rt2(...args) {
        return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
      }
      function d2(...args) {
        return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
      }
      function n(...args) {
        return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
      }
      function tm(key) {
        return _composer.value ? _composer.value.tm(key) : {};
      }
      function te2(key, locale2) {
        return _composer.value ? _composer.value.te(key, locale2) : false;
      }
      function getLocaleMessage(locale2) {
        return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
      }
      function setLocaleMessage(locale2, message2) {
        if (_composer.value) {
          _composer.value.setLocaleMessage(locale2, message2);
          _messages.value[locale2] = message2;
        }
      }
      function mergeLocaleMessage(locale2, message2) {
        if (_composer.value) {
          _composer.value.mergeLocaleMessage(locale2, message2);
        }
      }
      function getDateTimeFormat(locale2) {
        return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
      }
      function setDateTimeFormat(locale2, format2) {
        if (_composer.value) {
          _composer.value.setDateTimeFormat(locale2, format2);
          _datetimeFormats.value[locale2] = format2;
        }
      }
      function mergeDateTimeFormat(locale2, format2) {
        if (_composer.value) {
          _composer.value.mergeDateTimeFormat(locale2, format2);
        }
      }
      function getNumberFormat(locale2) {
        return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
      }
      function setNumberFormat(locale2, format2) {
        if (_composer.value) {
          _composer.value.setNumberFormat(locale2, format2);
          _numberFormats.value[locale2] = format2;
        }
      }
      function mergeNumberFormat(locale2, format2) {
        if (_composer.value) {
          _composer.value.mergeNumberFormat(locale2, format2);
        }
      }
      const wrapper = {
        get id() {
          return _composer.value ? _composer.value.id : -1;
        },
        locale,
        fallbackLocale,
        messages: messages2,
        datetimeFormats,
        numberFormats,
        get inheritLocale() {
          return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
        },
        set inheritLocale(val) {
          if (_composer.value) {
            _composer.value.inheritLocale = val;
          }
        },
        get availableLocales() {
          return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
        },
        get modifiers() {
          return _composer.value ? _composer.value.modifiers : _modifiers;
        },
        get pluralRules() {
          return _composer.value ? _composer.value.pluralRules : _pluralRules;
        },
        get isGlobal() {
          return _composer.value ? _composer.value.isGlobal : false;
        },
        get missingWarn() {
          return _composer.value ? _composer.value.missingWarn : _missingWarn;
        },
        set missingWarn(val) {
          if (_composer.value) {
            _composer.value.missingWarn = val;
          }
        },
        get fallbackWarn() {
          return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
        },
        set fallbackWarn(val) {
          if (_composer.value) {
            _composer.value.missingWarn = val;
          }
        },
        get fallbackRoot() {
          return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
        },
        set fallbackRoot(val) {
          if (_composer.value) {
            _composer.value.fallbackRoot = val;
          }
        },
        get fallbackFormat() {
          return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
        },
        set fallbackFormat(val) {
          if (_composer.value) {
            _composer.value.fallbackFormat = val;
          }
        },
        get warnHtmlMessage() {
          return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
        },
        set warnHtmlMessage(val) {
          if (_composer.value) {
            _composer.value.warnHtmlMessage = val;
          }
        },
        get escapeParameter() {
          return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
        },
        set escapeParameter(val) {
          if (_composer.value) {
            _composer.value.escapeParameter = val;
          }
        },
        t,
        getPostTranslationHandler,
        setPostTranslationHandler,
        getMissingHandler,
        setMissingHandler,
        rt: rt2,
        d: d2,
        n,
        tm,
        te: te2,
        getLocaleMessage,
        setLocaleMessage,
        mergeLocaleMessage,
        getDateTimeFormat,
        setDateTimeFormat,
        mergeDateTimeFormat,
        getNumberFormat,
        setNumberFormat,
        mergeNumberFormat
      };
      function sync(composer) {
        composer.locale.value = _locale.value;
        composer.fallbackLocale.value = _fallbackLocale.value;
        Object.keys(_messages.value).forEach((locale2) => {
          composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
        });
        Object.keys(_datetimeFormats.value).forEach((locale2) => {
          composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
        });
        Object.keys(_numberFormats.value).forEach((locale2) => {
          composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
        });
        composer.escapeParameter = _escapeParameter;
        composer.fallbackFormat = _fallbackFormat;
        composer.fallbackRoot = _fallbackRoot;
        composer.fallbackWarn = _fallbackWarn;
        composer.missingWarn = _missingWarn;
        composer.warnHtmlMessage = _warnHtmlMessage;
      }
      onBeforeMount(() => {
        if (instance.proxy == null || instance.proxy.$i18n == null) {
          throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
        }
        const composer = _composer.value = instance.proxy.$i18n.__composer;
        if (scope === "global") {
          _locale.value = composer.locale.value;
          _fallbackLocale.value = composer.fallbackLocale.value;
          _messages.value = composer.messages.value;
          _datetimeFormats.value = composer.datetimeFormats.value;
          _numberFormats.value = composer.numberFormats.value;
        } else if (isLocale) {
          sync(composer);
        }
      });
      return wrapper;
    }
    const globalExportProps = [
      "locale",
      "fallbackLocale",
      "availableLocales"
    ];
    const globalExportMethods = ["t", "rt", "d", "n", "tm"];
    function injectGlobalFields(app2, composer) {
      const i18n2 = /* @__PURE__ */ Object.create(null);
      globalExportProps.forEach((prop) => {
        const desc = Object.getOwnPropertyDescriptor(composer, prop);
        if (!desc) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const wrap = isRef(desc.value) ? {
          get() {
            return desc.value.value;
          },
          set(val) {
            desc.value.value = val;
          }
        } : {
          get() {
            return desc.get && desc.get();
          }
        };
        Object.defineProperty(i18n2, prop, wrap);
      });
      app2.config.globalProperties.$i18n = i18n2;
      globalExportMethods.forEach((method2) => {
        const desc = Object.getOwnPropertyDescriptor(composer, method2);
        if (!desc || !desc.value) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        Object.defineProperty(app2.config.globalProperties, `$${method2}`, desc);
      });
    }
    registerMessageCompiler(compileToFunction);
    registerMessageResolver(resolveValue);
    registerLocaleFallbacker(fallbackWithLocaleChain);
    {
      initFeatureFlags();
    }
    if (__INTLIFY_PROD_DEVTOOLS__) {
      const target = getGlobalThis();
      target.__INTLIFY__ = true;
      setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
    }
    const ConfigList_vue_vue_type_style_index_0_lang = "";
    const _hoisted_1$1 = { class: "common-layout" };
    const _hoisted_2$1 = /* @__PURE__ */ createTextVNode(" \xA0\xA0Smart Config \xA0\xA0\xA0\xA0\xA0\xA0\xA0\xA0 ");
    const _hoisted_3$1 = /* @__PURE__ */ createTextVNode(" \u5E2E\u52A9 ");
    const _hoisted_4$1 = /* @__PURE__ */ createTextVNode("\u9884\u7559\u4F4D\u7F6E");
    const _hoisted_5$1 = { style: { "margin-bottom": "10px", "text-align": "right" } };
    const _hoisted_6 = { key: 0 };
    const _hoisted_7 = { key: 1 };
    const _hoisted_8 = { key: 0 };
    const _hoisted_9 = { style: { "text-align": "center" } };
    const _hoisted_10 = /* @__PURE__ */ createTextVNode(" \xA0\xA0Smart Config \xA0\xA0\xA0\xA0\xA0\xA0\xA0\xA0 ");
    const _hoisted_11 = { class: "view-value" };
    const _hoisted_12 = { class: "edit-container" };
    const _hoisted_13 = /* @__PURE__ */ createTextVNode(" Key \xA0\xA0\xA0\xA0\xA0\xA0\xA0\xA0\xA0\xA0\xA0 ");
    const _hoisted_14 = /* @__PURE__ */ createTextVNode(" Value\xA0\xA0\xA0\xA0\xA0\xA0\xA0\xA0\xA0 ");
    const _hoisted_15 = /* @__PURE__ */ createTextVNode(" Comment\xA0\xA0 ");
    const _hoisted_16 = {
      slot: "footer",
      class: "dialog-footer",
      style: { "display": "flex", "justify-content": "flex-end" }
    };
    const _hoisted_17 = /* @__PURE__ */ createTextVNode("\u53D6 \u6D88");
    const _hoisted_18 = /* @__PURE__ */ createTextVNode("\u786E \u5B9A");
    const _hoisted_19 = { class: "export-container" };
    const _hoisted_20 = /* @__PURE__ */ createTextVNode("Properties");
    const _hoisted_21 = /* @__PURE__ */ createTextVNode("JSON");
    const _hoisted_22 = /* @__PURE__ */ createTextVNode("YAML");
    const _hoisted_23 = { class: "dialog-footer" };
    const _sfc_main$2 = {
      __name: "ConfigList",
      emits: ["loginPast"],
      setup(__props, { emit: emits }) {
        const valueVisible = ref(false);
        const viewValue = ref("");
        const configList = ref([]);
        const editValueVisible = ref(false);
        const editViewValue = ref("");
        const editViewComment = ref("");
        const editViewKey = ref("");
        const editViewKeyDisable = ref(false);
        const exportVisible = ref(false);
        const exportType = ref("properties");
        const language = () => {
          return localStorage.getItem("locale");
        };
        const { t } = useI18n();
        const showTableVal = (row, col, cell, event) => {
          let colKey = col.property;
          if ("key" === colKey || "value" === colKey) {
            try {
              const jsonObject = JSON.parse(row[col.property]);
              viewValue.value = JSON.stringify(jsonObject, null, 2);
            } catch (e) {
              console.log("not json");
              viewValue.value = row[col.property];
            }
            valueVisible.value = true;
            return;
          }
          if ("opt" === colKey) {
            let configKey = row.key;
            let configValue = row.value;
            let comment = row.desc;
            showEditValue(configKey, configValue, comment);
            return;
          }
        };
        const showEditValue = (configKey, configValue, comment) => {
          editViewKeyDisable.value = !!configKey;
          editViewKey.value = configKey;
          editViewValue.value = configValue;
          editViewComment.value = comment;
          editValueVisible.value = true;
        };
        const getConfigList = () => {
          request.post("/config/list").then((resp) => {
            configList.value = resp.data.data;
          }).catch((e) => {
            loginPast(e);
          });
        };
        getConfigList();
        const doReleaseConfig = () => {
          request.post("/config/release").then((resp) => {
            resp.data.data;
            ElNotification({
              title: t("config.releaseSuccessTitle"),
              type: "success",
              duration: 1e3
            });
            getConfigList();
          }).catch((e) => {
            loginPast(e);
          }).finally(() => {
            editValueVisible.value = false;
          });
        };
        const loginPast = (e) => {
          if (e === 401) {
            emits("loginPast");
            return;
          }
        };
        const doEditConfig = () => {
          request.post("/config/save", {
            key: editViewKey.value,
            value: editViewValue.value,
            desc: editViewComment.value
          }).then((resp) => {
            resp.data.data;
            getConfigList();
          }).catch((e) => {
            loginPast(e);
          }).finally(() => {
            editValueVisible.value = false;
          });
        };
        const showExportDialog = () => {
          exportVisible.value = true;
        };
        const doExportConfig = () => {
          const link = document.createElement("a");
          link.href = `${request.defaults.baseURL}config/export?type=${exportType.value}`;
          link.click();
          exportVisible.value = false;
        };
        const tableColClassName = ({ row, column, rowIndex, columnIndex }) => {
          if (columnIndex === 1 || columnIndex === 2) {
            return "opt-icon";
          }
          if (columnIndex === 3) {
            return "my-col";
          }
          if (columnIndex === 4 || columnIndex === 5) {
            return "date-col";
          }
          return "";
        };
        const tableRowClassName = ({ row, rowIndex }) => {
          const cycleIndex = rowIndex % 5;
          if (cycleIndex === 0) {
            return "warning-row";
          } else if (cycleIndex === 1) {
            return "success-row";
          } else if (cycleIndex === 2) {
            return "info-row";
          } else if (cycleIndex === 3) {
            return "primary-row";
          } else if (cycleIndex === 4) {
            return "danger-row";
          }
          return "";
        };
        return (_ctx, _cache) => {
          const _component_el_avatar = ElAvatar;
          const _component_el_link = ElLink;
          const _component_el_icon = ElIcon;
          const _component_el_header = ElHeader;
          const _component_el_aside = ElAside;
          const _component_el_button = ElButton;
          const _component_el_table_column = ElTableColumn;
          const _component_el_tag = ElTag;
          const _component_el_table = ElTable;
          const _component_el_main = ElMain;
          const _component_el_footer = ElFooter;
          const _component_el_container = ElContainer;
          const _component_el_dialog = ElDialog;
          const _component_el_input = ElInput;
          const _component_el_divider = ElDivider;
          const _component_el_radio = ElRadio;
          const _component_el_radio_group = ElRadioGroup;
          return openBlock(), createElementBlock("div", null, [
            createBaseVNode("div", _hoisted_1$1, [
              createVNode(_component_el_container, null, {
                default: withCtx(() => [
                  createVNode(_component_el_header, null, {
                    default: withCtx(() => [
                      createVNode(_component_el_link, {
                        class: "my-link",
                        underline: false,
                        target: "_blank",
                        href: "https://github.com/yangfeng20/smart-config"
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_avatar, {
                            size: 25,
                            src: "https://github.githubassets.com/favicons/favicon.png"
                          }),
                          _hoisted_2$1
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_link, {
                        class: "my-link",
                        underline: false,
                        target: "_blank",
                        href: "https://github.com/yangfeng20/smart-config"
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_icon, null, {
                            default: withCtx(() => [
                              createVNode(unref(info_filled_default))
                            ]),
                            _: 1
                          }),
                          _hoisted_3$1
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_container, null, {
                    default: withCtx(() => [
                      createVNode(_component_el_aside, { width: "0" }, {
                        default: withCtx(() => [
                          _hoisted_4$1
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_container, null, {
                        default: withCtx(() => [
                          createVNode(_component_el_main, null, {
                            default: withCtx(() => [
                              createBaseVNode("div", _hoisted_5$1, [
                                createVNode(_component_el_button, {
                                  type: "success",
                                  onClick: doReleaseConfig
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString$1(unref(t)("config.releaseConfig")), 1)
                                  ]),
                                  _: 1
                                }),
                                createVNode(_component_el_button, {
                                  type: "warning",
                                  onClick: _cache[0] || (_cache[0] = ($event) => showEditValue(null, null, null))
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString$1(unref(t)("config.addConfig")), 1)
                                  ]),
                                  _: 1
                                }),
                                createVNode(_component_el_button, {
                                  type: "primary",
                                  onClick: showExportDialog
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString$1(unref(t)("config.exportConfig")), 1)
                                  ]),
                                  _: 1
                                })
                              ]),
                              createVNode(_component_el_table, {
                                border: "",
                                data: configList.value,
                                style: { "width": "100%" },
                                onCellClick: showTableVal,
                                "cell-class-name": tableColClassName,
                                "row-class-name": tableRowClassName
                              }, {
                                default: withCtx(() => [
                                  createVNode(_component_el_table_column, {
                                    prop: "status",
                                    label: unref(t)("config.row.status"),
                                    align: "center",
                                    width: "140"
                                  }, {
                                    default: withCtx(({ row }) => [
                                      createBaseVNode("div", {
                                        class: normalizeClass(row.status === "\u672A\u53D1\u5E03" ? "status un-release-status" : row.status === "\u5DF2\u53D1\u5E03" ? "status release-status" : "")
                                      }, [
                                        language() === "zh_CN" ? (openBlock(), createElementBlock("span", _hoisted_6, toDisplayString$1(row.status), 1)) : (openBlock(), createElementBlock("span", _hoisted_7, toDisplayString$1(row.status === "\u672A\u53D1\u5E03" ? "Not Release" : "Released"), 1))
                                      ], 2)
                                    ]),
                                    _: 1
                                  }, 8, ["label"]),
                                  createVNode(_component_el_table_column, {
                                    class: "opt-icon",
                                    prop: "key",
                                    label: unref(t)("config.row.key"),
                                    width: "290"
                                  }, {
                                    default: withCtx(({ row }) => [
                                      createBaseVNode("div", null, [
                                        createTextVNode(toDisplayString$1(row.key) + " ", 1),
                                        row.durable === "false" ? (openBlock(), createElementBlock("span", _hoisted_8, [
                                          createVNode(_component_el_tag, {
                                            effect: "dark",
                                            type: "warning",
                                            size: "small"
                                          }, {
                                            default: withCtx(() => [
                                              createVNode(_component_el_icon, null, {
                                                default: withCtx(() => [
                                                  createVNode(unref(warning_filled_default))
                                                ]),
                                                _: 1
                                              }),
                                              createTextVNode(toDisplayString$1(unref(t)("config.notDurable")), 1)
                                            ]),
                                            _: 1
                                          })
                                        ])) : createCommentVNode("", true)
                                      ])
                                    ]),
                                    _: 1
                                  }, 8, ["label"]),
                                  createVNode(_component_el_table_column, {
                                    class: "opt-icon",
                                    prop: "value",
                                    label: unref(t)("config.row.value"),
                                    width: "450"
                                  }, null, 8, ["label"]),
                                  createVNode(_component_el_table_column, {
                                    class: "my-col",
                                    prop: "desc",
                                    label: unref(t)("config.row.desc"),
                                    width: "180"
                                  }, null, 8, ["label"]),
                                  createVNode(_component_el_table_column, {
                                    prop: "createDate",
                                    label: unref(t)("config.row.createDate"),
                                    width: "170"
                                  }, null, 8, ["label"]),
                                  createVNode(_component_el_table_column, {
                                    prop: "updateDate",
                                    label: unref(t)("config.row.updateDate"),
                                    width: "170"
                                  }, null, 8, ["label"]),
                                  createVNode(_component_el_table_column, {
                                    prop: "opt",
                                    label: unref(t)("config.row.opt"),
                                    width: "80"
                                  }, {
                                    default: withCtx(() => [
                                      createVNode(_component_el_button, {
                                        type: "success",
                                        icon: unref(edit_default),
                                        circle: ""
                                      }, null, 8, ["icon"])
                                    ]),
                                    _: 1
                                  }, 8, ["label"])
                                ]),
                                _: 1
                              }, 8, ["data"])
                            ]),
                            _: 1
                          }),
                          createVNode(_component_el_footer, null, {
                            default: withCtx(() => [
                              createBaseVNode("div", _hoisted_9, [
                                createVNode(_component_el_link, {
                                  class: "my-link",
                                  underline: false,
                                  target: "_blank",
                                  href: "https://github.com/yangfeng20/smart-config"
                                }, {
                                  default: withCtx(() => [
                                    createVNode(_component_el_avatar, {
                                      size: 20,
                                      src: "https://github.githubassets.com/favicons/favicon.png"
                                    }),
                                    _hoisted_10
                                  ]),
                                  _: 1
                                })
                              ])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            createVNode(_component_el_dialog, {
              class: "dialog-div",
              title: unref(t)("config.viewTitle"),
              modelValue: valueVisible.value,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => valueVisible.value = $event),
              width: "60%"
            }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_11, toDisplayString$1(viewValue.value), 1)
              ]),
              _: 1
            }, 8, ["title", "modelValue"]),
            createVNode(_component_el_dialog, {
              class: "dialog-div",
              title: unref(t)("config.editViewTitle"),
              modelValue: editValueVisible.value,
              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => editValueVisible.value = $event),
              width: "60%"
            }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_12, [
                  createBaseVNode("div", null, [
                    _hoisted_13,
                    createVNode(_component_el_input, {
                      modelValue: editViewKey.value,
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => editViewKey.value = $event),
                      style: { "width": "80%" },
                      disabled: editViewKeyDisable.value,
                      placeholder: "Config Key"
                    }, null, 8, ["modelValue", "disabled"])
                  ]),
                  createBaseVNode("div", null, [
                    _hoisted_14,
                    createVNode(_component_el_input, {
                      modelValue: editViewValue.value,
                      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => editViewValue.value = $event),
                      style: { "width": "80%" },
                      autosize: { minRows: 3, maxRows: 2e3 },
                      type: "textarea",
                      placeholder: "Config Value"
                    }, null, 8, ["modelValue"])
                  ]),
                  createBaseVNode("div", null, [
                    _hoisted_15,
                    createVNode(_component_el_input, {
                      modelValue: editViewComment.value,
                      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => editViewComment.value = $event),
                      style: { "width": "80%" },
                      autosize: { minRows: 2, maxRows: 10 },
                      type: "textarea",
                      placeholder: "Comment"
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                createVNode(_component_el_divider),
                createBaseVNode("div", _hoisted_16, [
                  createVNode(_component_el_button, {
                    size: "small",
                    onClick: _cache[5] || (_cache[5] = ($event) => {
                      editValueVisible.value = false;
                    })
                  }, {
                    default: withCtx(() => [
                      _hoisted_17
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_button, {
                    size: "small",
                    type: "primary",
                    onClick: doEditConfig
                  }, {
                    default: withCtx(() => [
                      _hoisted_18
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 1
            }, 8, ["title", "modelValue"]),
            createVNode(_component_el_dialog, {
              class: "dialog-div",
              title: unref(t)("config.exportTitle"),
              modelValue: exportVisible.value,
              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => exportVisible.value = $event),
              width: "30%"
            }, {
              footer: withCtx(() => [
                createBaseVNode("span", _hoisted_23, [
                  createVNode(_component_el_button, {
                    onClick: _cache[8] || (_cache[8] = ($event) => exportVisible.value = false)
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString$1(unref(t)("common.cancel")), 1)
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: doExportConfig
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString$1(unref(t)("common.confirm")), 1)
                    ]),
                    _: 1
                  })
                ])
              ]),
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_19, [
                  createVNode(_component_el_radio_group, {
                    modelValue: exportType.value,
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => exportType.value = $event)
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_radio, { label: "properties" }, {
                        default: withCtx(() => [
                          _hoisted_20
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_radio, { label: "json" }, {
                        default: withCtx(() => [
                          _hoisted_21
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_radio, { label: "yaml" }, {
                        default: withCtx(() => [
                          _hoisted_22
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["modelValue"])
                ])
              ]),
              _: 1
            }, 8, ["title", "modelValue"])
          ]);
        };
      }
    };
    var cryptoJs = { exports: {} };
    function commonjsRequire(path) {
      throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }
    var core = { exports: {} };
    const __viteBrowserExternal = {};
    const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: __viteBrowserExternal
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
    var hasRequiredCore;
    function requireCore() {
      if (hasRequiredCore)
        return core.exports;
      hasRequiredCore = 1;
      (function(module2, exports2) {
        (function(root2, factory) {
          {
            module2.exports = factory();
          }
        })(commonjsGlobal, function() {
          var CryptoJS2 = CryptoJS2 || function(Math2, undefined$1) {
            var crypto;
            if (typeof window !== "undefined" && window.crypto) {
              crypto = window.crypto;
            }
            if (typeof self !== "undefined" && self.crypto) {
              crypto = self.crypto;
            }
            if (typeof globalThis !== "undefined" && globalThis.crypto) {
              crypto = globalThis.crypto;
            }
            if (!crypto && typeof window !== "undefined" && window.msCrypto) {
              crypto = window.msCrypto;
            }
            if (!crypto && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
              crypto = commonjsGlobal.crypto;
            }
            if (!crypto && typeof commonjsRequire === "function") {
              try {
                crypto = require$$0;
              } catch (err) {
              }
            }
            var cryptoSecureRandomInt = function() {
              if (crypto) {
                if (typeof crypto.getRandomValues === "function") {
                  try {
                    return crypto.getRandomValues(new Uint32Array(1))[0];
                  } catch (err) {
                  }
                }
                if (typeof crypto.randomBytes === "function") {
                  try {
                    return crypto.randomBytes(4).readInt32LE();
                  } catch (err) {
                  }
                }
              }
              throw new Error("Native crypto module could not be used to get secure random number.");
            };
            var create = Object.create || function() {
              function F2() {
              }
              return function(obj) {
                var subtype;
                F2.prototype = obj;
                subtype = new F2();
                F2.prototype = null;
                return subtype;
              };
            }();
            var C2 = {};
            var C_lib = C2.lib = {};
            var Base = C_lib.Base = function() {
              return {
                extend: function(overrides) {
                  var subtype = create(this);
                  if (overrides) {
                    subtype.mixIn(overrides);
                  }
                  if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                    subtype.init = function() {
                      subtype.$super.init.apply(this, arguments);
                    };
                  }
                  subtype.init.prototype = subtype;
                  subtype.$super = this;
                  return subtype;
                },
                create: function() {
                  var instance = this.extend();
                  instance.init.apply(instance, arguments);
                  return instance;
                },
                init: function() {
                },
                mixIn: function(properties) {
                  for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                      this[propertyName] = properties[propertyName];
                    }
                  }
                  if (properties.hasOwnProperty("toString")) {
                    this.toString = properties.toString;
                  }
                },
                clone: function() {
                  return this.init.prototype.extend(this);
                }
              };
            }();
            var WordArray = C_lib.WordArray = Base.extend({
              init: function(words, sigBytes) {
                words = this.words = words || [];
                if (sigBytes != undefined$1) {
                  this.sigBytes = sigBytes;
                } else {
                  this.sigBytes = words.length * 4;
                }
              },
              toString: function(encoder) {
                return (encoder || Hex).stringify(this);
              },
              concat: function(wordArray) {
                var thisWords = this.words;
                var thatWords = wordArray.words;
                var thisSigBytes = this.sigBytes;
                var thatSigBytes = wordArray.sigBytes;
                this.clamp();
                if (thisSigBytes % 4) {
                  for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
                  }
                } else {
                  for (var j = 0; j < thatSigBytes; j += 4) {
                    thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
                  }
                }
                this.sigBytes += thatSigBytes;
                return this;
              },
              clamp: function() {
                var words = this.words;
                var sigBytes = this.sigBytes;
                words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
                words.length = Math2.ceil(sigBytes / 4);
              },
              clone: function() {
                var clone2 = Base.clone.call(this);
                clone2.words = this.words.slice(0);
                return clone2;
              },
              random: function(nBytes) {
                var words = [];
                for (var i = 0; i < nBytes; i += 4) {
                  words.push(cryptoSecureRandomInt());
                }
                return new WordArray.init(words, nBytes);
              }
            });
            var C_enc = C2.enc = {};
            var Hex = C_enc.Hex = {
              stringify: function(wordArray) {
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;
                var hexChars = [];
                for (var i = 0; i < sigBytes; i++) {
                  var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                  hexChars.push((bite >>> 4).toString(16));
                  hexChars.push((bite & 15).toString(16));
                }
                return hexChars.join("");
              },
              parse: function(hexStr) {
                var hexStrLength = hexStr.length;
                var words = [];
                for (var i = 0; i < hexStrLength; i += 2) {
                  words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
                }
                return new WordArray.init(words, hexStrLength / 2);
              }
            };
            var Latin1 = C_enc.Latin1 = {
              stringify: function(wordArray) {
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;
                var latin1Chars = [];
                for (var i = 0; i < sigBytes; i++) {
                  var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                  latin1Chars.push(String.fromCharCode(bite));
                }
                return latin1Chars.join("");
              },
              parse: function(latin1Str) {
                var latin1StrLength = latin1Str.length;
                var words = [];
                for (var i = 0; i < latin1StrLength; i++) {
                  words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
                }
                return new WordArray.init(words, latin1StrLength);
              }
            };
            var Utf8 = C_enc.Utf8 = {
              stringify: function(wordArray) {
                try {
                  return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                } catch (e) {
                  throw new Error("Malformed UTF-8 data");
                }
              },
              parse: function(utf8Str) {
                return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
              }
            };
            var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
              reset: function() {
                this._data = new WordArray.init();
                this._nDataBytes = 0;
              },
              _append: function(data) {
                if (typeof data == "string") {
                  data = Utf8.parse(data);
                }
                this._data.concat(data);
                this._nDataBytes += data.sigBytes;
              },
              _process: function(doFlush) {
                var processedWords;
                var data = this._data;
                var dataWords = data.words;
                var dataSigBytes = data.sigBytes;
                var blockSize = this.blockSize;
                var blockSizeBytes = blockSize * 4;
                var nBlocksReady = dataSigBytes / blockSizeBytes;
                if (doFlush) {
                  nBlocksReady = Math2.ceil(nBlocksReady);
                } else {
                  nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
                }
                var nWordsReady = nBlocksReady * blockSize;
                var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
                if (nWordsReady) {
                  for (var offset2 = 0; offset2 < nWordsReady; offset2 += blockSize) {
                    this._doProcessBlock(dataWords, offset2);
                  }
                  processedWords = dataWords.splice(0, nWordsReady);
                  data.sigBytes -= nBytesReady;
                }
                return new WordArray.init(processedWords, nBytesReady);
              },
              clone: function() {
                var clone2 = Base.clone.call(this);
                clone2._data = this._data.clone();
                return clone2;
              },
              _minBufferSize: 0
            });
            C_lib.Hasher = BufferedBlockAlgorithm.extend({
              cfg: Base.extend(),
              init: function(cfg) {
                this.cfg = this.cfg.extend(cfg);
                this.reset();
              },
              reset: function() {
                BufferedBlockAlgorithm.reset.call(this);
                this._doReset();
              },
              update: function(messageUpdate) {
                this._append(messageUpdate);
                this._process();
                return this;
              },
              finalize: function(messageUpdate) {
                if (messageUpdate) {
                  this._append(messageUpdate);
                }
                var hash = this._doFinalize();
                return hash;
              },
              blockSize: 512 / 32,
              _createHelper: function(hasher) {
                return function(message2, cfg) {
                  return new hasher.init(cfg).finalize(message2);
                };
              },
              _createHmacHelper: function(hasher) {
                return function(message2, key) {
                  return new C_algo.HMAC.init(hasher, key).finalize(message2);
                };
              }
            });
            var C_algo = C2.algo = {};
            return C2;
          }(Math);
          return CryptoJS2;
        });
      })(core);
      return core.exports;
    }
    var x64Core = { exports: {} };
    var hasRequiredX64Core;
    function requireX64Core() {
      if (hasRequiredX64Core)
        return x64Core.exports;
      hasRequiredX64Core = 1;
      (function(module2, exports2) {
        (function(root2, factory) {
          {
            module2.exports = factory(requireCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function(undefined$1) {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var Base = C_lib.Base;
            var X32WordArray = C_lib.WordArray;
            var C_x64 = C2.x64 = {};
            C_x64.Word = Base.extend({
              init: function(high, low) {
                this.high = high;
                this.low = low;
              }
            });
            C_x64.WordArray = Base.extend({
              init: function(words, sigBytes) {
                words = this.words = words || [];
                if (sigBytes != undefined$1) {
                  this.sigBytes = sigBytes;
                } else {
                  this.sigBytes = words.length * 8;
                }
              },
              toX32: function() {
                var x64Words = this.words;
                var x64WordsLength = x64Words.length;
                var x32Words = [];
                for (var i = 0; i < x64WordsLength; i++) {
                  var x64Word = x64Words[i];
                  x32Words.push(x64Word.high);
                  x32Words.push(x64Word.low);
                }
                return X32WordArray.create(x32Words, this.sigBytes);
              },
              clone: function() {
                var clone2 = Base.clone.call(this);
                var words = clone2.words = this.words.slice(0);
                var wordsLength = words.length;
                for (var i = 0; i < wordsLength; i++) {
                  words[i] = words[i].clone();
                }
                return clone2;
              }
            });
          })();
          return CryptoJS2;
        });
      })(x64Core);
      return x64Core.exports;
    }
    var libTypedarrays = { exports: {} };
    var hasRequiredLibTypedarrays;
    function requireLibTypedarrays() {
      if (hasRequiredLibTypedarrays)
        return libTypedarrays.exports;
      hasRequiredLibTypedarrays = 1;
      (function(module2, exports2) {
        (function(root2, factory) {
          {
            module2.exports = factory(requireCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            if (typeof ArrayBuffer != "function") {
              return;
            }
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var WordArray = C_lib.WordArray;
            var superInit = WordArray.init;
            var subInit = WordArray.init = function(typedArray) {
              if (typedArray instanceof ArrayBuffer) {
                typedArray = new Uint8Array(typedArray);
              }
              if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
                typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
              }
              if (typedArray instanceof Uint8Array) {
                var typedArrayByteLength = typedArray.byteLength;
                var words = [];
                for (var i = 0; i < typedArrayByteLength; i++) {
                  words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
                }
                superInit.call(this, words, typedArrayByteLength);
              } else {
                superInit.apply(this, arguments);
              }
            };
            subInit.prototype = WordArray;
          })();
          return CryptoJS2.lib.WordArray;
        });
      })(libTypedarrays);
      return libTypedarrays.exports;
    }
    var encUtf16 = { exports: {} };
    var hasRequiredEncUtf16;
    function requireEncUtf16() {
      if (hasRequiredEncUtf16)
        return encUtf16.exports;
      hasRequiredEncUtf16 = 1;
      (function(module2, exports2) {
        (function(root2, factory) {
          {
            module2.exports = factory(requireCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var WordArray = C_lib.WordArray;
            var C_enc = C2.enc;
            C_enc.Utf16 = C_enc.Utf16BE = {
              stringify: function(wordArray) {
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;
                var utf16Chars = [];
                for (var i = 0; i < sigBytes; i += 2) {
                  var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
                  utf16Chars.push(String.fromCharCode(codePoint));
                }
                return utf16Chars.join("");
              },
              parse: function(utf16Str) {
                var utf16StrLength = utf16Str.length;
                var words = [];
                for (var i = 0; i < utf16StrLength; i++) {
                  words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
                }
                return WordArray.create(words, utf16StrLength * 2);
              }
            };
            C_enc.Utf16LE = {
              stringify: function(wordArray) {
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;
                var utf16Chars = [];
                for (var i = 0; i < sigBytes; i += 2) {
                  var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
                  utf16Chars.push(String.fromCharCode(codePoint));
                }
                return utf16Chars.join("");
              },
              parse: function(utf16Str) {
                var utf16StrLength = utf16Str.length;
                var words = [];
                for (var i = 0; i < utf16StrLength; i++) {
                  words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
                }
                return WordArray.create(words, utf16StrLength * 2);
              }
            };
            function swapEndian(word) {
              return word << 8 & 4278255360 | word >>> 8 & 16711935;
            }
          })();
          return CryptoJS2.enc.Utf16;
        });
      })(encUtf16);
      return encUtf16.exports;
    }
    var encBase64 = { exports: {} };
    var hasRequiredEncBase64;
    function requireEncBase64() {
      if (hasRequiredEncBase64)
        return encBase64.exports;
      hasRequiredEncBase64 = 1;
      (function(module2, exports2) {
        (function(root2, factory) {
          {
            module2.exports = factory(requireCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var WordArray = C_lib.WordArray;
            var C_enc = C2.enc;
            C_enc.Base64 = {
              stringify: function(wordArray) {
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;
                var map = this._map;
                wordArray.clamp();
                var base64Chars = [];
                for (var i = 0; i < sigBytes; i += 3) {
                  var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                  var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                  var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                  var triplet = byte1 << 16 | byte2 << 8 | byte3;
                  for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                    base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                  }
                }
                var paddingChar = map.charAt(64);
                if (paddingChar) {
                  while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                  }
                }
                return base64Chars.join("");
              },
              parse: function(base64Str) {
                var base64StrLength = base64Str.length;
                var map = this._map;
                var reverseMap = this._reverseMap;
                if (!reverseMap) {
                  reverseMap = this._reverseMap = [];
                  for (var j = 0; j < map.length; j++) {
                    reverseMap[map.charCodeAt(j)] = j;
                  }
                }
                var paddingChar = map.charAt(64);
                if (paddingChar) {
                  var paddingIndex = base64Str.indexOf(paddingChar);
                  if (paddingIndex !== -1) {
                    base64StrLength = paddingIndex;
                  }
                }
                return parseLoop(base64Str, base64StrLength, reverseMap);
              },
              _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
            };
            function parseLoop(base64Str, base64StrLength, reverseMap) {
              var words = [];
              var nBytes = 0;
              for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                  var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                  var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                  var bitsCombined = bits1 | bits2;
                  words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                  nBytes++;
                }
              }
              return WordArray.create(words, nBytes);
            }
          })();
          return CryptoJS2.enc.Base64;
        });
      })(encBase64);
      return encBase64.exports;
    }
    var encBase64url = { exports: {} };
    var hasRequiredEncBase64url;
    function requireEncBase64url() {
      if (hasRequiredEncBase64url)
        return encBase64url.exports;
      hasRequiredEncBase64url = 1;
      (function(module2, exports2) {
        (function(root2, factory) {
          {
            module2.exports = factory(requireCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var WordArray = C_lib.WordArray;
            var C_enc = C2.enc;
            C_enc.Base64url = {
              stringify: function(wordArray, urlSafe) {
                if (urlSafe === void 0) {
                  urlSafe = true;
                }
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;
                var map = urlSafe ? this._safe_map : this._map;
                wordArray.clamp();
                var base64Chars = [];
                for (var i = 0; i < sigBytes; i += 3) {
                  var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                  var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                  var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                  var triplet = byte1 << 16 | byte2 << 8 | byte3;
                  for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                    base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                  }
                }
                var paddingChar = map.charAt(64);
                if (paddingChar) {
                  while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                  }
                }
                return base64Chars.join("");
              },
              parse: function(base64Str, urlSafe) {
                if (urlSafe === void 0) {
                  urlSafe = true;
                }
                var base64StrLength = base64Str.length;
                var map = urlSafe ? this._safe_map : this._map;
                var reverseMap = this._reverseMap;
                if (!reverseMap) {
                  reverseMap = this._reverseMap = [];
                  for (var j = 0; j < map.length; j++) {
                    reverseMap[map.charCodeAt(j)] = j;
                  }
                }
                var paddingChar = map.charAt(64);
                if (paddingChar) {
                  var paddingIndex = base64Str.indexOf(paddingChar);
                  if (paddingIndex !== -1) {
                    base64StrLength = paddingIndex;
                  }
                }
                return parseLoop(base64Str, base64StrLength, reverseMap);
              },
              _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
              _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
            };
            function parseLoop(base64Str, base64StrLength, reverseMap) {
              var words = [];
              var nBytes = 0;
              for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                  var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                  var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                  var bitsCombined = bits1 | bits2;
                  words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                  nBytes++;
                }
              }
              return WordArray.create(words, nBytes);
            }
          })();
          return CryptoJS2.enc.Base64url;
        });
      })(encBase64url);
      return encBase64url.exports;
    }
    var md5 = { exports: {} };
    var hasRequiredMd5;
    function requireMd5() {
      if (hasRequiredMd5)
        return md5.exports;
      hasRequiredMd5 = 1;
      (function(module2, exports2) {
        (function(root2, factory) {
          {
            module2.exports = factory(requireCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function(Math2) {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C2.algo;
            var T2 = [];
            (function() {
              for (var i = 0; i < 64; i++) {
                T2[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
              }
            })();
            var MD5 = C_algo.MD5 = Hasher.extend({
              _doReset: function() {
                this._hash = new WordArray.init([
                  1732584193,
                  4023233417,
                  2562383102,
                  271733878
                ]);
              },
              _doProcessBlock: function(M2, offset2) {
                for (var i = 0; i < 16; i++) {
                  var offset_i = offset2 + i;
                  var M_offset_i = M2[offset_i];
                  M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
                }
                var H2 = this._hash.words;
                var M_offset_0 = M2[offset2 + 0];
                var M_offset_1 = M2[offset2 + 1];
                var M_offset_2 = M2[offset2 + 2];
                var M_offset_3 = M2[offset2 + 3];
                var M_offset_4 = M2[offset2 + 4];
                var M_offset_5 = M2[offset2 + 5];
                var M_offset_6 = M2[offset2 + 6];
                var M_offset_7 = M2[offset2 + 7];
                var M_offset_8 = M2[offset2 + 8];
                var M_offset_9 = M2[offset2 + 9];
                var M_offset_10 = M2[offset2 + 10];
                var M_offset_11 = M2[offset2 + 11];
                var M_offset_12 = M2[offset2 + 12];
                var M_offset_13 = M2[offset2 + 13];
                var M_offset_14 = M2[offset2 + 14];
                var M_offset_15 = M2[offset2 + 15];
                var a2 = H2[0];
                var b2 = H2[1];
                var c2 = H2[2];
                var d2 = H2[3];
                a2 = FF(a2, b2, c2, d2, M_offset_0, 7, T2[0]);
                d2 = FF(d2, a2, b2, c2, M_offset_1, 12, T2[1]);
                c2 = FF(c2, d2, a2, b2, M_offset_2, 17, T2[2]);
                b2 = FF(b2, c2, d2, a2, M_offset_3, 22, T2[3]);
                a2 = FF(a2, b2, c2, d2, M_offset_4, 7, T2[4]);
                d2 = FF(d2, a2, b2, c2, M_offset_5, 12, T2[5]);
                c2 = FF(c2, d2, a2, b2, M_offset_6, 17, T2[6]);
                b2 = FF(b2, c2, d2, a2, M_offset_7, 22, T2[7]);
                a2 = FF(a2, b2, c2, d2, M_offset_8, 7, T2[8]);
                d2 = FF(d2, a2, b2, c2, M_offset_9, 12, T2[9]);
                c2 = FF(c2, d2, a2, b2, M_offset_10, 17, T2[10]);
                b2 = FF(b2, c2, d2, a2, M_offset_11, 22, T2[11]);
                a2 = FF(a2, b2, c2, d2, M_offset_12, 7, T2[12]);
                d2 = FF(d2, a2, b2, c2, M_offset_13, 12, T2[13]);
                c2 = FF(c2, d2, a2, b2, M_offset_14, 17, T2[14]);
                b2 = FF(b2, c2, d2, a2, M_offset_15, 22, T2[15]);
                a2 = GG(a2, b2, c2, d2, M_offset_1, 5, T2[16]);
                d2 = GG(d2, a2, b2, c2, M_offset_6, 9, T2[17]);
                c2 = GG(c2, d2, a2, b2, M_offset_11, 14, T2[18]);
                b2 = GG(b2, c2, d2, a2, M_offset_0, 20, T2[19]);
                a2 = GG(a2, b2, c2, d2, M_offset_5, 5, T2[20]);
                d2 = GG(d2, a2, b2, c2, M_offset_10, 9, T2[21]);
                c2 = GG(c2, d2, a2, b2, M_offset_15, 14, T2[22]);
                b2 = GG(b2, c2, d2, a2, M_offset_4, 20, T2[23]);
                a2 = GG(a2, b2, c2, d2, M_offset_9, 5, T2[24]);
                d2 = GG(d2, a2, b2, c2, M_offset_14, 9, T2[25]);
                c2 = GG(c2, d2, a2, b2, M_offset_3, 14, T2[26]);
                b2 = GG(b2, c2, d2, a2, M_offset_8, 20, T2[27]);
                a2 = GG(a2, b2, c2, d2, M_offset_13, 5, T2[28]);
                d2 = GG(d2, a2, b2, c2, M_offset_2, 9, T2[29]);
                c2 = GG(c2, d2, a2, b2, M_offset_7, 14, T2[30]);
                b2 = GG(b2, c2, d2, a2, M_offset_12, 20, T2[31]);
                a2 = HH(a2, b2, c2, d2, M_offset_5, 4, T2[32]);
                d2 = HH(d2, a2, b2, c2, M_offset_8, 11, T2[33]);
                c2 = HH(c2, d2, a2, b2, M_offset_11, 16, T2[34]);
                b2 = HH(b2, c2, d2, a2, M_offset_14, 23, T2[35]);
                a2 = HH(a2, b2, c2, d2, M_offset_1, 4, T2[36]);
                d2 = HH(d2, a2, b2, c2, M_offset_4, 11, T2[37]);
                c2 = HH(c2, d2, a2, b2, M_offset_7, 16, T2[38]);
                b2 = HH(b2, c2, d2, a2, M_offset_10, 23, T2[39]);
                a2 = HH(a2, b2, c2, d2, M_offset_13, 4, T2[40]);
                d2 = HH(d2, a2, b2, c2, M_offset_0, 11, T2[41]);
                c2 = HH(c2, d2, a2, b2, M_offset_3, 16, T2[42]);
                b2 = HH(b2, c2, d2, a2, M_offset_6, 23, T2[43]);
                a2 = HH(a2, b2, c2, d2, M_offset_9, 4, T2[44]);
                d2 = HH(d2, a2, b2, c2, M_offset_12, 11, T2[45]);
                c2 = HH(c2, d2, a2, b2, M_offset_15, 16, T2[46]);
                b2 = HH(b2, c2, d2, a2, M_offset_2, 23, T2[47]);
                a2 = II(a2, b2, c2, d2, M_offset_0, 6, T2[48]);
                d2 = II(d2, a2, b2, c2, M_offset_7, 10, T2[49]);
                c2 = II(c2, d2, a2, b2, M_offset_14, 15, T2[50]);
                b2 = II(b2, c2, d2, a2, M_offset_5, 21, T2[51]);
                a2 = II(a2, b2, c2, d2, M_offset_12, 6, T2[52]);
                d2 = II(d2, a2, b2, c2, M_offset_3, 10, T2[53]);
                c2 = II(c2, d2, a2, b2, M_offset_10, 15, T2[54]);
                b2 = II(b2, c2, d2, a2, M_offset_1, 21, T2[55]);
                a2 = II(a2, b2, c2, d2, M_offset_8, 6, T2[56]);
                d2 = II(d2, a2, b2, c2, M_offset_15, 10, T2[57]);
                c2 = II(c2, d2, a2, b2, M_offset_6, 15, T2[58]);
                b2 = II(b2, c2, d2, a2, M_offset_13, 21, T2[59]);
                a2 = II(a2, b2, c2, d2, M_offset_4, 6, T2[60]);
                d2 = II(d2, a2, b2, c2, M_offset_11, 10, T2[61]);
                c2 = II(c2, d2, a2, b2, M_offset_2, 15, T2[62]);
                b2 = II(b2, c2, d2, a2, M_offset_9, 21, T2[63]);
                H2[0] = H2[0] + a2 | 0;
                H2[1] = H2[1] + b2 | 0;
                H2[2] = H2[2] + c2 | 0;
                H2[3] = H2[3] + d2 | 0;
              },
              _doFinalize: function() {
                var data = this._data;
                var dataWords = data.words;
                var nBitsTotal = this._nDataBytes * 8;
                var nBitsLeft = data.sigBytes * 8;
                dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
                var nBitsTotalL = nBitsTotal;
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
                data.sigBytes = (dataWords.length + 1) * 4;
                this._process();
                var hash = this._hash;
                var H2 = hash.words;
                for (var i = 0; i < 4; i++) {
                  var H_i = H2[i];
                  H2[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
                }
                return hash;
              },
              clone: function() {
                var clone2 = Hasher.clone.call(this);
                clone2._hash = this._hash.clone();
                return clone2;
              }
            });
            function FF(a2, b2, c2, d2, x2, s2, t) {
              var n = a2 + (b2 & c2 | ~b2 & d2) + x2 + t;
              return (n << s2 | n >>> 32 - s2) + b2;
            }
            function GG(a2, b2, c2, d2, x2, s2, t) {
              var n = a2 + (b2 & d2 | c2 & ~d2) + x2 + t;
              return (n << s2 | n >>> 32 - s2) + b2;
            }
            function HH(a2, b2, c2, d2, x2, s2, t) {
              var n = a2 + (b2 ^ c2 ^ d2) + x2 + t;
              return (n << s2 | n >>> 32 - s2) + b2;
            }
            function II(a2, b2, c2, d2, x2, s2, t) {
              var n = a2 + (c2 ^ (b2 | ~d2)) + x2 + t;
              return (n << s2 | n >>> 32 - s2) + b2;
            }
            C2.MD5 = Hasher._createHelper(MD5);
            C2.HmacMD5 = Hasher._createHmacHelper(MD5);
          })(Math);
          return CryptoJS2.MD5;
        });
      })(md5);
      return md5.exports;
    }
    var sha1 = { exports: {} };
    var hasRequiredSha1;
    function requireSha1() {
      if (hasRequiredSha1)
        return sha1.exports;
      hasRequiredSha1 = 1;
      (function(module2, exports2) {
        (function(root2, factory) {
          {
            module2.exports = factory(requireCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C2.algo;
            var W2 = [];
            var SHA1 = C_algo.SHA1 = Hasher.extend({
              _doReset: function() {
                this._hash = new WordArray.init([
                  1732584193,
                  4023233417,
                  2562383102,
                  271733878,
                  3285377520
                ]);
              },
              _doProcessBlock: function(M2, offset2) {
                var H2 = this._hash.words;
                var a2 = H2[0];
                var b2 = H2[1];
                var c2 = H2[2];
                var d2 = H2[3];
                var e = H2[4];
                for (var i = 0; i < 80; i++) {
                  if (i < 16) {
                    W2[i] = M2[offset2 + i] | 0;
                  } else {
                    var n = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
                    W2[i] = n << 1 | n >>> 31;
                  }
                  var t = (a2 << 5 | a2 >>> 27) + e + W2[i];
                  if (i < 20) {
                    t += (b2 & c2 | ~b2 & d2) + 1518500249;
                  } else if (i < 40) {
                    t += (b2 ^ c2 ^ d2) + 1859775393;
                  } else if (i < 60) {
                    t += (b2 & c2 | b2 & d2 | c2 & d2) - 1894007588;
                  } else {
                    t += (b2 ^ c2 ^ d2) - 899497514;
                  }
                  e = d2;
                  d2 = c2;
                  c2 = b2 << 30 | b2 >>> 2;
                  b2 = a2;
                  a2 = t;
                }
                H2[0] = H2[0] + a2 | 0;
                H2[1] = H2[1] + b2 | 0;
                H2[2] = H2[2] + c2 | 0;
                H2[3] = H2[3] + d2 | 0;
                H2[4] = H2[4] + e | 0;
              },
              _doFinalize: function() {
                var data = this._data;
                var dataWords = data.words;
                var nBitsTotal = this._nDataBytes * 8;
                var nBitsLeft = data.sigBytes * 8;
                dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                data.sigBytes = dataWords.length * 4;
                this._process();
                return this._hash;
              },
              clone: function() {
                var clone2 = Hasher.clone.call(this);
                clone2._hash = this._hash.clone();
                return clone2;
              }
            });
            C2.SHA1 = Hasher._createHelper(SHA1);
            C2.HmacSHA1 = Hasher._createHmacHelper(SHA1);
          })();
          return CryptoJS2.SHA1;
        });
      })(sha1);
      return sha1.exports;
    }
    var sha256 = { exports: {} };
    var hasRequiredSha256;
    function requireSha256() {
      if (hasRequiredSha256)
        return sha256.exports;
      hasRequiredSha256 = 1;
      (function(module2, exports2) {
        (function(root2, factory) {
          {
            module2.exports = factory(requireCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function(Math2) {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C2.algo;
            var H2 = [];
            var K2 = [];
            (function() {
              function isPrime(n2) {
                var sqrtN = Math2.sqrt(n2);
                for (var factor = 2; factor <= sqrtN; factor++) {
                  if (!(n2 % factor)) {
                    return false;
                  }
                }
                return true;
              }
              function getFractionalBits(n2) {
                return (n2 - (n2 | 0)) * 4294967296 | 0;
              }
              var n = 2;
              var nPrime = 0;
              while (nPrime < 64) {
                if (isPrime(n)) {
                  if (nPrime < 8) {
                    H2[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
                  }
                  K2[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
                  nPrime++;
                }
                n++;
              }
            })();
            var W2 = [];
            var SHA256 = C_algo.SHA256 = Hasher.extend({
              _doReset: function() {
                this._hash = new WordArray.init(H2.slice(0));
              },
              _doProcessBlock: function(M2, offset2) {
                var H3 = this._hash.words;
                var a2 = H3[0];
                var b2 = H3[1];
                var c2 = H3[2];
                var d2 = H3[3];
                var e = H3[4];
                var f2 = H3[5];
                var g = H3[6];
                var h2 = H3[7];
                for (var i = 0; i < 64; i++) {
                  if (i < 16) {
                    W2[i] = M2[offset2 + i] | 0;
                  } else {
                    var gamma0x = W2[i - 15];
                    var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                    var gamma1x = W2[i - 2];
                    var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                    W2[i] = gamma0 + W2[i - 7] + gamma1 + W2[i - 16];
                  }
                  var ch = e & f2 ^ ~e & g;
                  var maj = a2 & b2 ^ a2 & c2 ^ b2 & c2;
                  var sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
                  var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
                  var t1 = h2 + sigma1 + ch + K2[i] + W2[i];
                  var t2 = sigma0 + maj;
                  h2 = g;
                  g = f2;
                  f2 = e;
                  e = d2 + t1 | 0;
                  d2 = c2;
                  c2 = b2;
                  b2 = a2;
                  a2 = t1 + t2 | 0;
                }
                H3[0] = H3[0] + a2 | 0;
                H3[1] = H3[1] + b2 | 0;
                H3[2] = H3[2] + c2 | 0;
                H3[3] = H3[3] + d2 | 0;
                H3[4] = H3[4] + e | 0;
                H3[5] = H3[5] + f2 | 0;
                H3[6] = H3[6] + g | 0;
                H3[7] = H3[7] + h2 | 0;
              },
              _doFinalize: function() {
                var data = this._data;
                var dataWords = data.words;
                var nBitsTotal = this._nDataBytes * 8;
                var nBitsLeft = data.sigBytes * 8;
                dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                data.sigBytes = dataWords.length * 4;
                this._process();
                return this._hash;
              },
              clone: function() {
                var clone2 = Hasher.clone.call(this);
                clone2._hash = this._hash.clone();
                return clone2;
              }
            });
            C2.SHA256 = Hasher._createHelper(SHA256);
            C2.HmacSHA256 = Hasher._createHmacHelper(SHA256);
          })(Math);
          return CryptoJS2.SHA256;
        });
      })(sha256);
      return sha256.exports;
    }
    var sha224 = { exports: {} };
    var hasRequiredSha224;
    function requireSha224() {
      if (hasRequiredSha224)
        return sha224.exports;
      hasRequiredSha224 = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireSha256());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var WordArray = C_lib.WordArray;
            var C_algo = C2.algo;
            var SHA256 = C_algo.SHA256;
            var SHA224 = C_algo.SHA224 = SHA256.extend({
              _doReset: function() {
                this._hash = new WordArray.init([
                  3238371032,
                  914150663,
                  812702999,
                  4144912697,
                  4290775857,
                  1750603025,
                  1694076839,
                  3204075428
                ]);
              },
              _doFinalize: function() {
                var hash = SHA256._doFinalize.call(this);
                hash.sigBytes -= 4;
                return hash;
              }
            });
            C2.SHA224 = SHA256._createHelper(SHA224);
            C2.HmacSHA224 = SHA256._createHmacHelper(SHA224);
          })();
          return CryptoJS2.SHA224;
        });
      })(sha224);
      return sha224.exports;
    }
    var sha512 = { exports: {} };
    var hasRequiredSha512;
    function requireSha512() {
      if (hasRequiredSha512)
        return sha512.exports;
      hasRequiredSha512 = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireX64Core());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var Hasher = C_lib.Hasher;
            var C_x64 = C2.x64;
            var X64Word = C_x64.Word;
            var X64WordArray = C_x64.WordArray;
            var C_algo = C2.algo;
            function X64Word_create() {
              return X64Word.create.apply(X64Word, arguments);
            }
            var K2 = [
              X64Word_create(1116352408, 3609767458),
              X64Word_create(1899447441, 602891725),
              X64Word_create(3049323471, 3964484399),
              X64Word_create(3921009573, 2173295548),
              X64Word_create(961987163, 4081628472),
              X64Word_create(1508970993, 3053834265),
              X64Word_create(2453635748, 2937671579),
              X64Word_create(2870763221, 3664609560),
              X64Word_create(3624381080, 2734883394),
              X64Word_create(310598401, 1164996542),
              X64Word_create(607225278, 1323610764),
              X64Word_create(1426881987, 3590304994),
              X64Word_create(1925078388, 4068182383),
              X64Word_create(2162078206, 991336113),
              X64Word_create(2614888103, 633803317),
              X64Word_create(3248222580, 3479774868),
              X64Word_create(3835390401, 2666613458),
              X64Word_create(4022224774, 944711139),
              X64Word_create(264347078, 2341262773),
              X64Word_create(604807628, 2007800933),
              X64Word_create(770255983, 1495990901),
              X64Word_create(1249150122, 1856431235),
              X64Word_create(1555081692, 3175218132),
              X64Word_create(1996064986, 2198950837),
              X64Word_create(2554220882, 3999719339),
              X64Word_create(2821834349, 766784016),
              X64Word_create(2952996808, 2566594879),
              X64Word_create(3210313671, 3203337956),
              X64Word_create(3336571891, 1034457026),
              X64Word_create(3584528711, 2466948901),
              X64Word_create(113926993, 3758326383),
              X64Word_create(338241895, 168717936),
              X64Word_create(666307205, 1188179964),
              X64Word_create(773529912, 1546045734),
              X64Word_create(1294757372, 1522805485),
              X64Word_create(1396182291, 2643833823),
              X64Word_create(1695183700, 2343527390),
              X64Word_create(1986661051, 1014477480),
              X64Word_create(2177026350, 1206759142),
              X64Word_create(2456956037, 344077627),
              X64Word_create(2730485921, 1290863460),
              X64Word_create(2820302411, 3158454273),
              X64Word_create(3259730800, 3505952657),
              X64Word_create(3345764771, 106217008),
              X64Word_create(3516065817, 3606008344),
              X64Word_create(3600352804, 1432725776),
              X64Word_create(4094571909, 1467031594),
              X64Word_create(275423344, 851169720),
              X64Word_create(430227734, 3100823752),
              X64Word_create(506948616, 1363258195),
              X64Word_create(659060556, 3750685593),
              X64Word_create(883997877, 3785050280),
              X64Word_create(958139571, 3318307427),
              X64Word_create(1322822218, 3812723403),
              X64Word_create(1537002063, 2003034995),
              X64Word_create(1747873779, 3602036899),
              X64Word_create(1955562222, 1575990012),
              X64Word_create(2024104815, 1125592928),
              X64Word_create(2227730452, 2716904306),
              X64Word_create(2361852424, 442776044),
              X64Word_create(2428436474, 593698344),
              X64Word_create(2756734187, 3733110249),
              X64Word_create(3204031479, 2999351573),
              X64Word_create(3329325298, 3815920427),
              X64Word_create(3391569614, 3928383900),
              X64Word_create(3515267271, 566280711),
              X64Word_create(3940187606, 3454069534),
              X64Word_create(4118630271, 4000239992),
              X64Word_create(116418474, 1914138554),
              X64Word_create(174292421, 2731055270),
              X64Word_create(289380356, 3203993006),
              X64Word_create(460393269, 320620315),
              X64Word_create(685471733, 587496836),
              X64Word_create(852142971, 1086792851),
              X64Word_create(1017036298, 365543100),
              X64Word_create(1126000580, 2618297676),
              X64Word_create(1288033470, 3409855158),
              X64Word_create(1501505948, 4234509866),
              X64Word_create(1607167915, 987167468),
              X64Word_create(1816402316, 1246189591)
            ];
            var W2 = [];
            (function() {
              for (var i = 0; i < 80; i++) {
                W2[i] = X64Word_create();
              }
            })();
            var SHA512 = C_algo.SHA512 = Hasher.extend({
              _doReset: function() {
                this._hash = new X64WordArray.init([
                  new X64Word.init(1779033703, 4089235720),
                  new X64Word.init(3144134277, 2227873595),
                  new X64Word.init(1013904242, 4271175723),
                  new X64Word.init(2773480762, 1595750129),
                  new X64Word.init(1359893119, 2917565137),
                  new X64Word.init(2600822924, 725511199),
                  new X64Word.init(528734635, 4215389547),
                  new X64Word.init(1541459225, 327033209)
                ]);
              },
              _doProcessBlock: function(M2, offset2) {
                var H2 = this._hash.words;
                var H0 = H2[0];
                var H1 = H2[1];
                var H22 = H2[2];
                var H3 = H2[3];
                var H4 = H2[4];
                var H5 = H2[5];
                var H6 = H2[6];
                var H7 = H2[7];
                var H0h = H0.high;
                var H0l = H0.low;
                var H1h = H1.high;
                var H1l = H1.low;
                var H2h = H22.high;
                var H2l = H22.low;
                var H3h = H3.high;
                var H3l = H3.low;
                var H4h = H4.high;
                var H4l = H4.low;
                var H5h = H5.high;
                var H5l = H5.low;
                var H6h = H6.high;
                var H6l = H6.low;
                var H7h = H7.high;
                var H7l = H7.low;
                var ah = H0h;
                var al = H0l;
                var bh = H1h;
                var bl = H1l;
                var ch = H2h;
                var cl = H2l;
                var dh = H3h;
                var dl = H3l;
                var eh = H4h;
                var el = H4l;
                var fh = H5h;
                var fl = H5l;
                var gh = H6h;
                var gl = H6l;
                var hh = H7h;
                var hl = H7l;
                for (var i = 0; i < 80; i++) {
                  var Wil;
                  var Wih;
                  var Wi = W2[i];
                  if (i < 16) {
                    Wih = Wi.high = M2[offset2 + i * 2] | 0;
                    Wil = Wi.low = M2[offset2 + i * 2 + 1] | 0;
                  } else {
                    var gamma0x = W2[i - 15];
                    var gamma0xh = gamma0x.high;
                    var gamma0xl = gamma0x.low;
                    var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                    var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                    var gamma1x = W2[i - 2];
                    var gamma1xh = gamma1x.high;
                    var gamma1xl = gamma1x.low;
                    var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                    var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                    var Wi7 = W2[i - 7];
                    var Wi7h = Wi7.high;
                    var Wi7l = Wi7.low;
                    var Wi16 = W2[i - 16];
                    var Wi16h = Wi16.high;
                    var Wi16l = Wi16.low;
                    Wil = gamma0l + Wi7l;
                    Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                    Wil = Wil + gamma1l;
                    Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                    Wil = Wil + Wi16l;
                    Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                    Wi.high = Wih;
                    Wi.low = Wil;
                  }
                  var chh = eh & fh ^ ~eh & gh;
                  var chl = el & fl ^ ~el & gl;
                  var majh = ah & bh ^ ah & ch ^ bh & ch;
                  var majl = al & bl ^ al & cl ^ bl & cl;
                  var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
                  var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
                  var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
                  var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
                  var Ki = K2[i];
                  var Kih = Ki.high;
                  var Kil = Ki.low;
                  var t1l = hl + sigma1l;
                  var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
                  var t1l = t1l + chl;
                  var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
                  var t1l = t1l + Kil;
                  var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
                  var t1l = t1l + Wil;
                  var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
                  var t2l = sigma0l + majl;
                  var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
                  hh = gh;
                  hl = gl;
                  gh = fh;
                  gl = fl;
                  fh = eh;
                  fl = el;
                  el = dl + t1l | 0;
                  eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                  dh = ch;
                  dl = cl;
                  ch = bh;
                  cl = bl;
                  bh = ah;
                  bl = al;
                  al = t1l + t2l | 0;
                  ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
                }
                H0l = H0.low = H0l + al;
                H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
                H1l = H1.low = H1l + bl;
                H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
                H2l = H22.low = H2l + cl;
                H22.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
                H3l = H3.low = H3l + dl;
                H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
                H4l = H4.low = H4l + el;
                H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
                H5l = H5.low = H5l + fl;
                H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
                H6l = H6.low = H6l + gl;
                H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
                H7l = H7.low = H7l + hl;
                H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
              },
              _doFinalize: function() {
                var data = this._data;
                var dataWords = data.words;
                var nBitsTotal = this._nDataBytes * 8;
                var nBitsLeft = data.sigBytes * 8;
                dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
                dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
                data.sigBytes = dataWords.length * 4;
                this._process();
                var hash = this._hash.toX32();
                return hash;
              },
              clone: function() {
                var clone2 = Hasher.clone.call(this);
                clone2._hash = this._hash.clone();
                return clone2;
              },
              blockSize: 1024 / 32
            });
            C2.SHA512 = Hasher._createHelper(SHA512);
            C2.HmacSHA512 = Hasher._createHmacHelper(SHA512);
          })();
          return CryptoJS2.SHA512;
        });
      })(sha512);
      return sha512.exports;
    }
    var sha384 = { exports: {} };
    var hasRequiredSha384;
    function requireSha384() {
      if (hasRequiredSha384)
        return sha384.exports;
      hasRequiredSha384 = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireX64Core(), requireSha512());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_x64 = C2.x64;
            var X64Word = C_x64.Word;
            var X64WordArray = C_x64.WordArray;
            var C_algo = C2.algo;
            var SHA512 = C_algo.SHA512;
            var SHA384 = C_algo.SHA384 = SHA512.extend({
              _doReset: function() {
                this._hash = new X64WordArray.init([
                  new X64Word.init(3418070365, 3238371032),
                  new X64Word.init(1654270250, 914150663),
                  new X64Word.init(2438529370, 812702999),
                  new X64Word.init(355462360, 4144912697),
                  new X64Word.init(1731405415, 4290775857),
                  new X64Word.init(2394180231, 1750603025),
                  new X64Word.init(3675008525, 1694076839),
                  new X64Word.init(1203062813, 3204075428)
                ]);
              },
              _doFinalize: function() {
                var hash = SHA512._doFinalize.call(this);
                hash.sigBytes -= 16;
                return hash;
              }
            });
            C2.SHA384 = SHA512._createHelper(SHA384);
            C2.HmacSHA384 = SHA512._createHmacHelper(SHA384);
          })();
          return CryptoJS2.SHA384;
        });
      })(sha384);
      return sha384.exports;
    }
    var sha3 = { exports: {} };
    var hasRequiredSha3;
    function requireSha3() {
      if (hasRequiredSha3)
        return sha3.exports;
      hasRequiredSha3 = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireX64Core());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function(Math2) {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_x64 = C2.x64;
            var X64Word = C_x64.Word;
            var C_algo = C2.algo;
            var RHO_OFFSETS = [];
            var PI_INDEXES = [];
            var ROUND_CONSTANTS = [];
            (function() {
              var x2 = 1, y = 0;
              for (var t = 0; t < 24; t++) {
                RHO_OFFSETS[x2 + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
                var newX = y % 5;
                var newY = (2 * x2 + 3 * y) % 5;
                x2 = newX;
                y = newY;
              }
              for (var x2 = 0; x2 < 5; x2++) {
                for (var y = 0; y < 5; y++) {
                  PI_INDEXES[x2 + 5 * y] = y + (2 * x2 + 3 * y) % 5 * 5;
                }
              }
              var LFSR = 1;
              for (var i = 0; i < 24; i++) {
                var roundConstantMsw = 0;
                var roundConstantLsw = 0;
                for (var j = 0; j < 7; j++) {
                  if (LFSR & 1) {
                    var bitPosition = (1 << j) - 1;
                    if (bitPosition < 32) {
                      roundConstantLsw ^= 1 << bitPosition;
                    } else {
                      roundConstantMsw ^= 1 << bitPosition - 32;
                    }
                  }
                  if (LFSR & 128) {
                    LFSR = LFSR << 1 ^ 113;
                  } else {
                    LFSR <<= 1;
                  }
                }
                ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
              }
            })();
            var T2 = [];
            (function() {
              for (var i = 0; i < 25; i++) {
                T2[i] = X64Word.create();
              }
            })();
            var SHA3 = C_algo.SHA3 = Hasher.extend({
              cfg: Hasher.cfg.extend({
                outputLength: 512
              }),
              _doReset: function() {
                var state = this._state = [];
                for (var i = 0; i < 25; i++) {
                  state[i] = new X64Word.init();
                }
                this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
              },
              _doProcessBlock: function(M2, offset2) {
                var state = this._state;
                var nBlockSizeLanes = this.blockSize / 2;
                for (var i = 0; i < nBlockSizeLanes; i++) {
                  var M2i = M2[offset2 + 2 * i];
                  var M2i1 = M2[offset2 + 2 * i + 1];
                  M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
                  M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
                  var lane = state[i];
                  lane.high ^= M2i1;
                  lane.low ^= M2i;
                }
                for (var round2 = 0; round2 < 24; round2++) {
                  for (var x2 = 0; x2 < 5; x2++) {
                    var tMsw = 0, tLsw = 0;
                    for (var y = 0; y < 5; y++) {
                      var lane = state[x2 + 5 * y];
                      tMsw ^= lane.high;
                      tLsw ^= lane.low;
                    }
                    var Tx = T2[x2];
                    Tx.high = tMsw;
                    Tx.low = tLsw;
                  }
                  for (var x2 = 0; x2 < 5; x2++) {
                    var Tx4 = T2[(x2 + 4) % 5];
                    var Tx1 = T2[(x2 + 1) % 5];
                    var Tx1Msw = Tx1.high;
                    var Tx1Lsw = Tx1.low;
                    var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                    var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                    for (var y = 0; y < 5; y++) {
                      var lane = state[x2 + 5 * y];
                      lane.high ^= tMsw;
                      lane.low ^= tLsw;
                    }
                  }
                  for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                    var tMsw;
                    var tLsw;
                    var lane = state[laneIndex];
                    var laneMsw = lane.high;
                    var laneLsw = lane.low;
                    var rhoOffset = RHO_OFFSETS[laneIndex];
                    if (rhoOffset < 32) {
                      tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                      tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                    } else {
                      tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                      tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                    }
                    var TPiLane = T2[PI_INDEXES[laneIndex]];
                    TPiLane.high = tMsw;
                    TPiLane.low = tLsw;
                  }
                  var T0 = T2[0];
                  var state0 = state[0];
                  T0.high = state0.high;
                  T0.low = state0.low;
                  for (var x2 = 0; x2 < 5; x2++) {
                    for (var y = 0; y < 5; y++) {
                      var laneIndex = x2 + 5 * y;
                      var lane = state[laneIndex];
                      var TLane = T2[laneIndex];
                      var Tx1Lane = T2[(x2 + 1) % 5 + 5 * y];
                      var Tx2Lane = T2[(x2 + 2) % 5 + 5 * y];
                      lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                      lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                    }
                  }
                  var lane = state[0];
                  var roundConstant = ROUND_CONSTANTS[round2];
                  lane.high ^= roundConstant.high;
                  lane.low ^= roundConstant.low;
                }
              },
              _doFinalize: function() {
                var data = this._data;
                var dataWords = data.words;
                this._nDataBytes * 8;
                var nBitsLeft = data.sigBytes * 8;
                var blockSizeBits = this.blockSize * 32;
                dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
                dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
                data.sigBytes = dataWords.length * 4;
                this._process();
                var state = this._state;
                var outputLengthBytes = this.cfg.outputLength / 8;
                var outputLengthLanes = outputLengthBytes / 8;
                var hashWords = [];
                for (var i = 0; i < outputLengthLanes; i++) {
                  var lane = state[i];
                  var laneMsw = lane.high;
                  var laneLsw = lane.low;
                  laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
                  laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
                  hashWords.push(laneLsw);
                  hashWords.push(laneMsw);
                }
                return new WordArray.init(hashWords, outputLengthBytes);
              },
              clone: function() {
                var clone2 = Hasher.clone.call(this);
                var state = clone2._state = this._state.slice(0);
                for (var i = 0; i < 25; i++) {
                  state[i] = state[i].clone();
                }
                return clone2;
              }
            });
            C2.SHA3 = Hasher._createHelper(SHA3);
            C2.HmacSHA3 = Hasher._createHmacHelper(SHA3);
          })(Math);
          return CryptoJS2.SHA3;
        });
      })(sha3);
      return sha3.exports;
    }
    var ripemd160 = { exports: {} };
    var hasRequiredRipemd160;
    function requireRipemd160() {
      if (hasRequiredRipemd160)
        return ripemd160.exports;
      hasRequiredRipemd160 = 1;
      (function(module2, exports2) {
        (function(root2, factory) {
          {
            module2.exports = factory(requireCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          /** @preserve
          			(c) 2012 by Cédric Mesnil. All rights reserved.
          
          			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
          
          			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
          			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
          
          			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
          			*/
          (function(Math2) {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C2.algo;
            var _zl = WordArray.create([
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              7,
              4,
              13,
              1,
              10,
              6,
              15,
              3,
              12,
              0,
              9,
              5,
              2,
              14,
              11,
              8,
              3,
              10,
              14,
              4,
              9,
              15,
              8,
              1,
              2,
              7,
              0,
              6,
              13,
              11,
              5,
              12,
              1,
              9,
              11,
              10,
              0,
              8,
              12,
              4,
              13,
              3,
              7,
              15,
              14,
              5,
              6,
              2,
              4,
              0,
              5,
              9,
              7,
              12,
              2,
              10,
              14,
              1,
              3,
              8,
              11,
              6,
              15,
              13
            ]);
            var _zr = WordArray.create([
              5,
              14,
              7,
              0,
              9,
              2,
              11,
              4,
              13,
              6,
              15,
              8,
              1,
              10,
              3,
              12,
              6,
              11,
              3,
              7,
              0,
              13,
              5,
              10,
              14,
              15,
              8,
              12,
              4,
              9,
              1,
              2,
              15,
              5,
              1,
              3,
              7,
              14,
              6,
              9,
              11,
              8,
              12,
              2,
              10,
              0,
              4,
              13,
              8,
              6,
              4,
              1,
              3,
              11,
              15,
              0,
              5,
              12,
              2,
              13,
              9,
              7,
              10,
              14,
              12,
              15,
              10,
              4,
              1,
              5,
              8,
              7,
              6,
              2,
              13,
              14,
              0,
              3,
              9,
              11
            ]);
            var _sl = WordArray.create([
              11,
              14,
              15,
              12,
              5,
              8,
              7,
              9,
              11,
              13,
              14,
              15,
              6,
              7,
              9,
              8,
              7,
              6,
              8,
              13,
              11,
              9,
              7,
              15,
              7,
              12,
              15,
              9,
              11,
              7,
              13,
              12,
              11,
              13,
              6,
              7,
              14,
              9,
              13,
              15,
              14,
              8,
              13,
              6,
              5,
              12,
              7,
              5,
              11,
              12,
              14,
              15,
              14,
              15,
              9,
              8,
              9,
              14,
              5,
              6,
              8,
              6,
              5,
              12,
              9,
              15,
              5,
              11,
              6,
              8,
              13,
              12,
              5,
              12,
              13,
              14,
              11,
              8,
              5,
              6
            ]);
            var _sr = WordArray.create([
              8,
              9,
              9,
              11,
              13,
              15,
              15,
              5,
              7,
              7,
              8,
              11,
              14,
              14,
              12,
              6,
              9,
              13,
              15,
              7,
              12,
              8,
              9,
              11,
              7,
              7,
              12,
              7,
              6,
              15,
              13,
              11,
              9,
              7,
              15,
              11,
              8,
              6,
              6,
              14,
              12,
              13,
              5,
              14,
              13,
              13,
              7,
              5,
              15,
              5,
              8,
              11,
              14,
              14,
              6,
              14,
              6,
              9,
              12,
              9,
              12,
              5,
              15,
              8,
              8,
              5,
              12,
              9,
              12,
              5,
              14,
              6,
              8,
              13,
              6,
              5,
              15,
              13,
              11,
              11
            ]);
            var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
            var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
            var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
              _doReset: function() {
                this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
              },
              _doProcessBlock: function(M2, offset2) {
                for (var i = 0; i < 16; i++) {
                  var offset_i = offset2 + i;
                  var M_offset_i = M2[offset_i];
                  M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
                }
                var H2 = this._hash.words;
                var hl = _hl.words;
                var hr = _hr.words;
                var zl = _zl.words;
                var zr = _zr.words;
                var sl = _sl.words;
                var sr = _sr.words;
                var al, bl, cl, dl, el;
                var ar, br, cr, dr, er;
                ar = al = H2[0];
                br = bl = H2[1];
                cr = cl = H2[2];
                dr = dl = H2[3];
                er = el = H2[4];
                var t;
                for (var i = 0; i < 80; i += 1) {
                  t = al + M2[offset2 + zl[i]] | 0;
                  if (i < 16) {
                    t += f1(bl, cl, dl) + hl[0];
                  } else if (i < 32) {
                    t += f2(bl, cl, dl) + hl[1];
                  } else if (i < 48) {
                    t += f3(bl, cl, dl) + hl[2];
                  } else if (i < 64) {
                    t += f4(bl, cl, dl) + hl[3];
                  } else {
                    t += f5(bl, cl, dl) + hl[4];
                  }
                  t = t | 0;
                  t = rotl(t, sl[i]);
                  t = t + el | 0;
                  al = el;
                  el = dl;
                  dl = rotl(cl, 10);
                  cl = bl;
                  bl = t;
                  t = ar + M2[offset2 + zr[i]] | 0;
                  if (i < 16) {
                    t += f5(br, cr, dr) + hr[0];
                  } else if (i < 32) {
                    t += f4(br, cr, dr) + hr[1];
                  } else if (i < 48) {
                    t += f3(br, cr, dr) + hr[2];
                  } else if (i < 64) {
                    t += f2(br, cr, dr) + hr[3];
                  } else {
                    t += f1(br, cr, dr) + hr[4];
                  }
                  t = t | 0;
                  t = rotl(t, sr[i]);
                  t = t + er | 0;
                  ar = er;
                  er = dr;
                  dr = rotl(cr, 10);
                  cr = br;
                  br = t;
                }
                t = H2[1] + cl + dr | 0;
                H2[1] = H2[2] + dl + er | 0;
                H2[2] = H2[3] + el + ar | 0;
                H2[3] = H2[4] + al + br | 0;
                H2[4] = H2[0] + bl + cr | 0;
                H2[0] = t;
              },
              _doFinalize: function() {
                var data = this._data;
                var dataWords = data.words;
                var nBitsTotal = this._nDataBytes * 8;
                var nBitsLeft = data.sigBytes * 8;
                dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
                data.sigBytes = (dataWords.length + 1) * 4;
                this._process();
                var hash = this._hash;
                var H2 = hash.words;
                for (var i = 0; i < 5; i++) {
                  var H_i = H2[i];
                  H2[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
                }
                return hash;
              },
              clone: function() {
                var clone2 = Hasher.clone.call(this);
                clone2._hash = this._hash.clone();
                return clone2;
              }
            });
            function f1(x2, y, z) {
              return x2 ^ y ^ z;
            }
            function f2(x2, y, z) {
              return x2 & y | ~x2 & z;
            }
            function f3(x2, y, z) {
              return (x2 | ~y) ^ z;
            }
            function f4(x2, y, z) {
              return x2 & z | y & ~z;
            }
            function f5(x2, y, z) {
              return x2 ^ (y | ~z);
            }
            function rotl(x2, n) {
              return x2 << n | x2 >>> 32 - n;
            }
            C2.RIPEMD160 = Hasher._createHelper(RIPEMD160);
            C2.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
          })();
          return CryptoJS2.RIPEMD160;
        });
      })(ripemd160);
      return ripemd160.exports;
    }
    var hmac = { exports: {} };
    var hasRequiredHmac;
    function requireHmac() {
      if (hasRequiredHmac)
        return hmac.exports;
      hasRequiredHmac = 1;
      (function(module2, exports2) {
        (function(root2, factory) {
          {
            module2.exports = factory(requireCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var Base = C_lib.Base;
            var C_enc = C2.enc;
            var Utf8 = C_enc.Utf8;
            var C_algo = C2.algo;
            C_algo.HMAC = Base.extend({
              init: function(hasher, key) {
                hasher = this._hasher = new hasher.init();
                if (typeof key == "string") {
                  key = Utf8.parse(key);
                }
                var hasherBlockSize = hasher.blockSize;
                var hasherBlockSizeBytes = hasherBlockSize * 4;
                if (key.sigBytes > hasherBlockSizeBytes) {
                  key = hasher.finalize(key);
                }
                key.clamp();
                var oKey = this._oKey = key.clone();
                var iKey = this._iKey = key.clone();
                var oKeyWords = oKey.words;
                var iKeyWords = iKey.words;
                for (var i = 0; i < hasherBlockSize; i++) {
                  oKeyWords[i] ^= 1549556828;
                  iKeyWords[i] ^= 909522486;
                }
                oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
                this.reset();
              },
              reset: function() {
                var hasher = this._hasher;
                hasher.reset();
                hasher.update(this._iKey);
              },
              update: function(messageUpdate) {
                this._hasher.update(messageUpdate);
                return this;
              },
              finalize: function(messageUpdate) {
                var hasher = this._hasher;
                var innerHash = hasher.finalize(messageUpdate);
                hasher.reset();
                var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
                return hmac2;
              }
            });
          })();
        });
      })(hmac);
      return hmac.exports;
    }
    var pbkdf2 = { exports: {} };
    var hasRequiredPbkdf2;
    function requirePbkdf2() {
      if (hasRequiredPbkdf2)
        return pbkdf2.exports;
      hasRequiredPbkdf2 = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireSha256(), requireHmac());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var C_algo = C2.algo;
            var SHA256 = C_algo.SHA256;
            var HMAC = C_algo.HMAC;
            var PBKDF2 = C_algo.PBKDF2 = Base.extend({
              cfg: Base.extend({
                keySize: 128 / 32,
                hasher: SHA256,
                iterations: 25e4
              }),
              init: function(cfg) {
                this.cfg = this.cfg.extend(cfg);
              },
              compute: function(password, salt) {
                var cfg = this.cfg;
                var hmac2 = HMAC.create(cfg.hasher, password);
                var derivedKey = WordArray.create();
                var blockIndex = WordArray.create([1]);
                var derivedKeyWords = derivedKey.words;
                var blockIndexWords = blockIndex.words;
                var keySize = cfg.keySize;
                var iterations = cfg.iterations;
                while (derivedKeyWords.length < keySize) {
                  var block = hmac2.update(salt).finalize(blockIndex);
                  hmac2.reset();
                  var blockWords = block.words;
                  var blockWordsLength = blockWords.length;
                  var intermediate = block;
                  for (var i = 1; i < iterations; i++) {
                    intermediate = hmac2.finalize(intermediate);
                    hmac2.reset();
                    var intermediateWords = intermediate.words;
                    for (var j = 0; j < blockWordsLength; j++) {
                      blockWords[j] ^= intermediateWords[j];
                    }
                  }
                  derivedKey.concat(block);
                  blockIndexWords[0]++;
                }
                derivedKey.sigBytes = keySize * 4;
                return derivedKey;
              }
            });
            C2.PBKDF2 = function(password, salt, cfg) {
              return PBKDF2.create(cfg).compute(password, salt);
            };
          })();
          return CryptoJS2.PBKDF2;
        });
      })(pbkdf2);
      return pbkdf2.exports;
    }
    var evpkdf = { exports: {} };
    var hasRequiredEvpkdf;
    function requireEvpkdf() {
      if (hasRequiredEvpkdf)
        return evpkdf.exports;
      hasRequiredEvpkdf = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireSha1(), requireHmac());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var C_algo = C2.algo;
            var MD5 = C_algo.MD5;
            var EvpKDF = C_algo.EvpKDF = Base.extend({
              cfg: Base.extend({
                keySize: 128 / 32,
                hasher: MD5,
                iterations: 1
              }),
              init: function(cfg) {
                this.cfg = this.cfg.extend(cfg);
              },
              compute: function(password, salt) {
                var block;
                var cfg = this.cfg;
                var hasher = cfg.hasher.create();
                var derivedKey = WordArray.create();
                var derivedKeyWords = derivedKey.words;
                var keySize = cfg.keySize;
                var iterations = cfg.iterations;
                while (derivedKeyWords.length < keySize) {
                  if (block) {
                    hasher.update(block);
                  }
                  block = hasher.update(password).finalize(salt);
                  hasher.reset();
                  for (var i = 1; i < iterations; i++) {
                    block = hasher.finalize(block);
                    hasher.reset();
                  }
                  derivedKey.concat(block);
                }
                derivedKey.sigBytes = keySize * 4;
                return derivedKey;
              }
            });
            C2.EvpKDF = function(password, salt, cfg) {
              return EvpKDF.create(cfg).compute(password, salt);
            };
          })();
          return CryptoJS2.EvpKDF;
        });
      })(evpkdf);
      return evpkdf.exports;
    }
    var cipherCore = { exports: {} };
    var hasRequiredCipherCore;
    function requireCipherCore() {
      if (hasRequiredCipherCore)
        return cipherCore.exports;
      hasRequiredCipherCore = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireEvpkdf());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          CryptoJS2.lib.Cipher || function(undefined$1) {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
            var C_enc = C2.enc;
            C_enc.Utf8;
            var Base64 = C_enc.Base64;
            var C_algo = C2.algo;
            var EvpKDF = C_algo.EvpKDF;
            var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
              cfg: Base.extend(),
              createEncryptor: function(key, cfg) {
                return this.create(this._ENC_XFORM_MODE, key, cfg);
              },
              createDecryptor: function(key, cfg) {
                return this.create(this._DEC_XFORM_MODE, key, cfg);
              },
              init: function(xformMode, key, cfg) {
                this.cfg = this.cfg.extend(cfg);
                this._xformMode = xformMode;
                this._key = key;
                this.reset();
              },
              reset: function() {
                BufferedBlockAlgorithm.reset.call(this);
                this._doReset();
              },
              process: function(dataUpdate) {
                this._append(dataUpdate);
                return this._process();
              },
              finalize: function(dataUpdate) {
                if (dataUpdate) {
                  this._append(dataUpdate);
                }
                var finalProcessedData = this._doFinalize();
                return finalProcessedData;
              },
              keySize: 128 / 32,
              ivSize: 128 / 32,
              _ENC_XFORM_MODE: 1,
              _DEC_XFORM_MODE: 2,
              _createHelper: function() {
                function selectCipherStrategy(key) {
                  if (typeof key == "string") {
                    return PasswordBasedCipher;
                  } else {
                    return SerializableCipher;
                  }
                }
                return function(cipher) {
                  return {
                    encrypt: function(message2, key, cfg) {
                      return selectCipherStrategy(key).encrypt(cipher, message2, key, cfg);
                    },
                    decrypt: function(ciphertext, key, cfg) {
                      return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                    }
                  };
                };
              }()
            });
            C_lib.StreamCipher = Cipher.extend({
              _doFinalize: function() {
                var finalProcessedBlocks = this._process(true);
                return finalProcessedBlocks;
              },
              blockSize: 1
            });
            var C_mode = C2.mode = {};
            var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
              createEncryptor: function(cipher, iv) {
                return this.Encryptor.create(cipher, iv);
              },
              createDecryptor: function(cipher, iv) {
                return this.Decryptor.create(cipher, iv);
              },
              init: function(cipher, iv) {
                this._cipher = cipher;
                this._iv = iv;
              }
            });
            var CBC = C_mode.CBC = function() {
              var CBC2 = BlockCipherMode.extend();
              CBC2.Encryptor = CBC2.extend({
                processBlock: function(words, offset2) {
                  var cipher = this._cipher;
                  var blockSize = cipher.blockSize;
                  xorBlock.call(this, words, offset2, blockSize);
                  cipher.encryptBlock(words, offset2);
                  this._prevBlock = words.slice(offset2, offset2 + blockSize);
                }
              });
              CBC2.Decryptor = CBC2.extend({
                processBlock: function(words, offset2) {
                  var cipher = this._cipher;
                  var blockSize = cipher.blockSize;
                  var thisBlock = words.slice(offset2, offset2 + blockSize);
                  cipher.decryptBlock(words, offset2);
                  xorBlock.call(this, words, offset2, blockSize);
                  this._prevBlock = thisBlock;
                }
              });
              function xorBlock(words, offset2, blockSize) {
                var block;
                var iv = this._iv;
                if (iv) {
                  block = iv;
                  this._iv = undefined$1;
                } else {
                  block = this._prevBlock;
                }
                for (var i = 0; i < blockSize; i++) {
                  words[offset2 + i] ^= block[i];
                }
              }
              return CBC2;
            }();
            var C_pad = C2.pad = {};
            var Pkcs7 = C_pad.Pkcs7 = {
              pad: function(data, blockSize) {
                var blockSizeBytes = blockSize * 4;
                var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
                var paddingWords = [];
                for (var i = 0; i < nPaddingBytes; i += 4) {
                  paddingWords.push(paddingWord);
                }
                var padding = WordArray.create(paddingWords, nPaddingBytes);
                data.concat(padding);
              },
              unpad: function(data) {
                var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                data.sigBytes -= nPaddingBytes;
              }
            };
            C_lib.BlockCipher = Cipher.extend({
              cfg: Cipher.cfg.extend({
                mode: CBC,
                padding: Pkcs7
              }),
              reset: function() {
                var modeCreator;
                Cipher.reset.call(this);
                var cfg = this.cfg;
                var iv = cfg.iv;
                var mode = cfg.mode;
                if (this._xformMode == this._ENC_XFORM_MODE) {
                  modeCreator = mode.createEncryptor;
                } else {
                  modeCreator = mode.createDecryptor;
                  this._minBufferSize = 1;
                }
                if (this._mode && this._mode.__creator == modeCreator) {
                  this._mode.init(this, iv && iv.words);
                } else {
                  this._mode = modeCreator.call(mode, this, iv && iv.words);
                  this._mode.__creator = modeCreator;
                }
              },
              _doProcessBlock: function(words, offset2) {
                this._mode.processBlock(words, offset2);
              },
              _doFinalize: function() {
                var finalProcessedBlocks;
                var padding = this.cfg.padding;
                if (this._xformMode == this._ENC_XFORM_MODE) {
                  padding.pad(this._data, this.blockSize);
                  finalProcessedBlocks = this._process(true);
                } else {
                  finalProcessedBlocks = this._process(true);
                  padding.unpad(finalProcessedBlocks);
                }
                return finalProcessedBlocks;
              },
              blockSize: 128 / 32
            });
            var CipherParams = C_lib.CipherParams = Base.extend({
              init: function(cipherParams) {
                this.mixIn(cipherParams);
              },
              toString: function(formatter2) {
                return (formatter2 || this.formatter).stringify(this);
              }
            });
            var C_format = C2.format = {};
            var OpenSSLFormatter = C_format.OpenSSL = {
              stringify: function(cipherParams) {
                var wordArray;
                var ciphertext = cipherParams.ciphertext;
                var salt = cipherParams.salt;
                if (salt) {
                  wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
                } else {
                  wordArray = ciphertext;
                }
                return wordArray.toString(Base64);
              },
              parse: function(openSSLStr) {
                var salt;
                var ciphertext = Base64.parse(openSSLStr);
                var ciphertextWords = ciphertext.words;
                if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
                  salt = WordArray.create(ciphertextWords.slice(2, 4));
                  ciphertextWords.splice(0, 4);
                  ciphertext.sigBytes -= 16;
                }
                return CipherParams.create({ ciphertext, salt });
              }
            };
            var SerializableCipher = C_lib.SerializableCipher = Base.extend({
              cfg: Base.extend({
                format: OpenSSLFormatter
              }),
              encrypt: function(cipher, message2, key, cfg) {
                cfg = this.cfg.extend(cfg);
                var encryptor = cipher.createEncryptor(key, cfg);
                var ciphertext = encryptor.finalize(message2);
                var cipherCfg = encryptor.cfg;
                return CipherParams.create({
                  ciphertext,
                  key,
                  iv: cipherCfg.iv,
                  algorithm: cipher,
                  mode: cipherCfg.mode,
                  padding: cipherCfg.padding,
                  blockSize: cipher.blockSize,
                  formatter: cfg.format
                });
              },
              decrypt: function(cipher, ciphertext, key, cfg) {
                cfg = this.cfg.extend(cfg);
                ciphertext = this._parse(ciphertext, cfg.format);
                var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
                return plaintext;
              },
              _parse: function(ciphertext, format2) {
                if (typeof ciphertext == "string") {
                  return format2.parse(ciphertext, this);
                } else {
                  return ciphertext;
                }
              }
            });
            var C_kdf = C2.kdf = {};
            var OpenSSLKdf = C_kdf.OpenSSL = {
              execute: function(password, keySize, ivSize, salt, hasher) {
                if (!salt) {
                  salt = WordArray.random(64 / 8);
                }
                if (!hasher) {
                  var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
                } else {
                  var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
                }
                var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
                key.sigBytes = keySize * 4;
                return CipherParams.create({ key, iv, salt });
              }
            };
            var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
              cfg: SerializableCipher.cfg.extend({
                kdf: OpenSSLKdf
              }),
              encrypt: function(cipher, message2, password, cfg) {
                cfg = this.cfg.extend(cfg);
                var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
                cfg.iv = derivedParams.iv;
                var ciphertext = SerializableCipher.encrypt.call(this, cipher, message2, derivedParams.key, cfg);
                ciphertext.mixIn(derivedParams);
                return ciphertext;
              },
              decrypt: function(cipher, ciphertext, password, cfg) {
                cfg = this.cfg.extend(cfg);
                ciphertext = this._parse(ciphertext, cfg.format);
                var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
                cfg.iv = derivedParams.iv;
                var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
                return plaintext;
              }
            });
          }();
        });
      })(cipherCore);
      return cipherCore.exports;
    }
    var modeCfb = { exports: {} };
    var hasRequiredModeCfb;
    function requireModeCfb() {
      if (hasRequiredModeCfb)
        return modeCfb.exports;
      hasRequiredModeCfb = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          CryptoJS2.mode.CFB = function() {
            var CFB = CryptoJS2.lib.BlockCipherMode.extend();
            CFB.Encryptor = CFB.extend({
              processBlock: function(words, offset2) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                generateKeystreamAndEncrypt.call(this, words, offset2, blockSize, cipher);
                this._prevBlock = words.slice(offset2, offset2 + blockSize);
              }
            });
            CFB.Decryptor = CFB.extend({
              processBlock: function(words, offset2) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                var thisBlock = words.slice(offset2, offset2 + blockSize);
                generateKeystreamAndEncrypt.call(this, words, offset2, blockSize, cipher);
                this._prevBlock = thisBlock;
              }
            });
            function generateKeystreamAndEncrypt(words, offset2, blockSize, cipher) {
              var keystream;
              var iv = this._iv;
              if (iv) {
                keystream = iv.slice(0);
                this._iv = void 0;
              } else {
                keystream = this._prevBlock;
              }
              cipher.encryptBlock(keystream, 0);
              for (var i = 0; i < blockSize; i++) {
                words[offset2 + i] ^= keystream[i];
              }
            }
            return CFB;
          }();
          return CryptoJS2.mode.CFB;
        });
      })(modeCfb);
      return modeCfb.exports;
    }
    var modeCtr = { exports: {} };
    var hasRequiredModeCtr;
    function requireModeCtr() {
      if (hasRequiredModeCtr)
        return modeCtr.exports;
      hasRequiredModeCtr = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          CryptoJS2.mode.CTR = function() {
            var CTR = CryptoJS2.lib.BlockCipherMode.extend();
            var Encryptor = CTR.Encryptor = CTR.extend({
              processBlock: function(words, offset2) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                var iv = this._iv;
                var counter = this._counter;
                if (iv) {
                  counter = this._counter = iv.slice(0);
                  this._iv = void 0;
                }
                var keystream = counter.slice(0);
                cipher.encryptBlock(keystream, 0);
                counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
                for (var i = 0; i < blockSize; i++) {
                  words[offset2 + i] ^= keystream[i];
                }
              }
            });
            CTR.Decryptor = Encryptor;
            return CTR;
          }();
          return CryptoJS2.mode.CTR;
        });
      })(modeCtr);
      return modeCtr.exports;
    }
    var modeCtrGladman = { exports: {} };
    var hasRequiredModeCtrGladman;
    function requireModeCtrGladman() {
      if (hasRequiredModeCtrGladman)
        return modeCtrGladman.exports;
      hasRequiredModeCtrGladman = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          /** @preserve
           * Counter block mode compatible with  Dr Brian Gladman fileenc.c
           * derived from CryptoJS.mode.CTR
           * Jan Hruby jhruby.web@gmail.com
           */
          CryptoJS2.mode.CTRGladman = function() {
            var CTRGladman = CryptoJS2.lib.BlockCipherMode.extend();
            function incWord(word) {
              if ((word >> 24 & 255) === 255) {
                var b1 = word >> 16 & 255;
                var b2 = word >> 8 & 255;
                var b3 = word & 255;
                if (b1 === 255) {
                  b1 = 0;
                  if (b2 === 255) {
                    b2 = 0;
                    if (b3 === 255) {
                      b3 = 0;
                    } else {
                      ++b3;
                    }
                  } else {
                    ++b2;
                  }
                } else {
                  ++b1;
                }
                word = 0;
                word += b1 << 16;
                word += b2 << 8;
                word += b3;
              } else {
                word += 1 << 24;
              }
              return word;
            }
            function incCounter(counter) {
              if ((counter[0] = incWord(counter[0])) === 0) {
                counter[1] = incWord(counter[1]);
              }
              return counter;
            }
            var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
              processBlock: function(words, offset2) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                var iv = this._iv;
                var counter = this._counter;
                if (iv) {
                  counter = this._counter = iv.slice(0);
                  this._iv = void 0;
                }
                incCounter(counter);
                var keystream = counter.slice(0);
                cipher.encryptBlock(keystream, 0);
                for (var i = 0; i < blockSize; i++) {
                  words[offset2 + i] ^= keystream[i];
                }
              }
            });
            CTRGladman.Decryptor = Encryptor;
            return CTRGladman;
          }();
          return CryptoJS2.mode.CTRGladman;
        });
      })(modeCtrGladman);
      return modeCtrGladman.exports;
    }
    var modeOfb = { exports: {} };
    var hasRequiredModeOfb;
    function requireModeOfb() {
      if (hasRequiredModeOfb)
        return modeOfb.exports;
      hasRequiredModeOfb = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          CryptoJS2.mode.OFB = function() {
            var OFB = CryptoJS2.lib.BlockCipherMode.extend();
            var Encryptor = OFB.Encryptor = OFB.extend({
              processBlock: function(words, offset2) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                var iv = this._iv;
                var keystream = this._keystream;
                if (iv) {
                  keystream = this._keystream = iv.slice(0);
                  this._iv = void 0;
                }
                cipher.encryptBlock(keystream, 0);
                for (var i = 0; i < blockSize; i++) {
                  words[offset2 + i] ^= keystream[i];
                }
              }
            });
            OFB.Decryptor = Encryptor;
            return OFB;
          }();
          return CryptoJS2.mode.OFB;
        });
      })(modeOfb);
      return modeOfb.exports;
    }
    var modeEcb = { exports: {} };
    var hasRequiredModeEcb;
    function requireModeEcb() {
      if (hasRequiredModeEcb)
        return modeEcb.exports;
      hasRequiredModeEcb = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          CryptoJS2.mode.ECB = function() {
            var ECB = CryptoJS2.lib.BlockCipherMode.extend();
            ECB.Encryptor = ECB.extend({
              processBlock: function(words, offset2) {
                this._cipher.encryptBlock(words, offset2);
              }
            });
            ECB.Decryptor = ECB.extend({
              processBlock: function(words, offset2) {
                this._cipher.decryptBlock(words, offset2);
              }
            });
            return ECB;
          }();
          return CryptoJS2.mode.ECB;
        });
      })(modeEcb);
      return modeEcb.exports;
    }
    var padAnsix923 = { exports: {} };
    var hasRequiredPadAnsix923;
    function requirePadAnsix923() {
      if (hasRequiredPadAnsix923)
        return padAnsix923.exports;
      hasRequiredPadAnsix923 = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          CryptoJS2.pad.AnsiX923 = {
            pad: function(data, blockSize) {
              var dataSigBytes = data.sigBytes;
              var blockSizeBytes = blockSize * 4;
              var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
              var lastBytePos = dataSigBytes + nPaddingBytes - 1;
              data.clamp();
              data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
              data.sigBytes += nPaddingBytes;
            },
            unpad: function(data) {
              var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
              data.sigBytes -= nPaddingBytes;
            }
          };
          return CryptoJS2.pad.Ansix923;
        });
      })(padAnsix923);
      return padAnsix923.exports;
    }
    var padIso10126 = { exports: {} };
    var hasRequiredPadIso10126;
    function requirePadIso10126() {
      if (hasRequiredPadIso10126)
        return padIso10126.exports;
      hasRequiredPadIso10126 = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          CryptoJS2.pad.Iso10126 = {
            pad: function(data, blockSize) {
              var blockSizeBytes = blockSize * 4;
              var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
              data.concat(CryptoJS2.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS2.lib.WordArray.create([nPaddingBytes << 24], 1));
            },
            unpad: function(data) {
              var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
              data.sigBytes -= nPaddingBytes;
            }
          };
          return CryptoJS2.pad.Iso10126;
        });
      })(padIso10126);
      return padIso10126.exports;
    }
    var padIso97971 = { exports: {} };
    var hasRequiredPadIso97971;
    function requirePadIso97971() {
      if (hasRequiredPadIso97971)
        return padIso97971.exports;
      hasRequiredPadIso97971 = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          CryptoJS2.pad.Iso97971 = {
            pad: function(data, blockSize) {
              data.concat(CryptoJS2.lib.WordArray.create([2147483648], 1));
              CryptoJS2.pad.ZeroPadding.pad(data, blockSize);
            },
            unpad: function(data) {
              CryptoJS2.pad.ZeroPadding.unpad(data);
              data.sigBytes--;
            }
          };
          return CryptoJS2.pad.Iso97971;
        });
      })(padIso97971);
      return padIso97971.exports;
    }
    var padZeropadding = { exports: {} };
    var hasRequiredPadZeropadding;
    function requirePadZeropadding() {
      if (hasRequiredPadZeropadding)
        return padZeropadding.exports;
      hasRequiredPadZeropadding = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          CryptoJS2.pad.ZeroPadding = {
            pad: function(data, blockSize) {
              var blockSizeBytes = blockSize * 4;
              data.clamp();
              data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
            },
            unpad: function(data) {
              var dataWords = data.words;
              var i = data.sigBytes - 1;
              for (var i = data.sigBytes - 1; i >= 0; i--) {
                if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
                  data.sigBytes = i + 1;
                  break;
                }
              }
            }
          };
          return CryptoJS2.pad.ZeroPadding;
        });
      })(padZeropadding);
      return padZeropadding.exports;
    }
    var padNopadding = { exports: {} };
    var hasRequiredPadNopadding;
    function requirePadNopadding() {
      if (hasRequiredPadNopadding)
        return padNopadding.exports;
      hasRequiredPadNopadding = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          CryptoJS2.pad.NoPadding = {
            pad: function() {
            },
            unpad: function() {
            }
          };
          return CryptoJS2.pad.NoPadding;
        });
      })(padNopadding);
      return padNopadding.exports;
    }
    var formatHex = { exports: {} };
    var hasRequiredFormatHex;
    function requireFormatHex() {
      if (hasRequiredFormatHex)
        return formatHex.exports;
      hasRequiredFormatHex = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function(undefined$1) {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var CipherParams = C_lib.CipherParams;
            var C_enc = C2.enc;
            var Hex = C_enc.Hex;
            var C_format = C2.format;
            C_format.Hex = {
              stringify: function(cipherParams) {
                return cipherParams.ciphertext.toString(Hex);
              },
              parse: function(input) {
                var ciphertext = Hex.parse(input);
                return CipherParams.create({ ciphertext });
              }
            };
          })();
          return CryptoJS2.format.Hex;
        });
      })(formatHex);
      return formatHex.exports;
    }
    var aes = { exports: {} };
    var hasRequiredAes;
    function requireAes() {
      if (hasRequiredAes)
        return aes.exports;
      hasRequiredAes = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var BlockCipher = C_lib.BlockCipher;
            var C_algo = C2.algo;
            var SBOX = [];
            var INV_SBOX = [];
            var SUB_MIX_0 = [];
            var SUB_MIX_1 = [];
            var SUB_MIX_2 = [];
            var SUB_MIX_3 = [];
            var INV_SUB_MIX_0 = [];
            var INV_SUB_MIX_1 = [];
            var INV_SUB_MIX_2 = [];
            var INV_SUB_MIX_3 = [];
            (function() {
              var d2 = [];
              for (var i = 0; i < 256; i++) {
                if (i < 128) {
                  d2[i] = i << 1;
                } else {
                  d2[i] = i << 1 ^ 283;
                }
              }
              var x2 = 0;
              var xi = 0;
              for (var i = 0; i < 256; i++) {
                var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
                sx = sx >>> 8 ^ sx & 255 ^ 99;
                SBOX[x2] = sx;
                INV_SBOX[sx] = x2;
                var x22 = d2[x2];
                var x4 = d2[x22];
                var x8 = d2[x4];
                var t = d2[sx] * 257 ^ sx * 16843008;
                SUB_MIX_0[x2] = t << 24 | t >>> 8;
                SUB_MIX_1[x2] = t << 16 | t >>> 16;
                SUB_MIX_2[x2] = t << 8 | t >>> 24;
                SUB_MIX_3[x2] = t;
                var t = x8 * 16843009 ^ x4 * 65537 ^ x22 * 257 ^ x2 * 16843008;
                INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
                INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
                INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
                INV_SUB_MIX_3[sx] = t;
                if (!x2) {
                  x2 = xi = 1;
                } else {
                  x2 = x22 ^ d2[d2[d2[x8 ^ x22]]];
                  xi ^= d2[d2[xi]];
                }
              }
            })();
            var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
            var AES = C_algo.AES = BlockCipher.extend({
              _doReset: function() {
                var t;
                if (this._nRounds && this._keyPriorReset === this._key) {
                  return;
                }
                var key = this._keyPriorReset = this._key;
                var keyWords = key.words;
                var keySize = key.sigBytes / 4;
                var nRounds = this._nRounds = keySize + 6;
                var ksRows = (nRounds + 1) * 4;
                var keySchedule = this._keySchedule = [];
                for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                  if (ksRow < keySize) {
                    keySchedule[ksRow] = keyWords[ksRow];
                  } else {
                    t = keySchedule[ksRow - 1];
                    if (!(ksRow % keySize)) {
                      t = t << 8 | t >>> 24;
                      t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                      t ^= RCON[ksRow / keySize | 0] << 24;
                    } else if (keySize > 6 && ksRow % keySize == 4) {
                      t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                    }
                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                  }
                }
                var invKeySchedule = this._invKeySchedule = [];
                for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                  var ksRow = ksRows - invKsRow;
                  if (invKsRow % 4) {
                    var t = keySchedule[ksRow];
                  } else {
                    var t = keySchedule[ksRow - 4];
                  }
                  if (invKsRow < 4 || ksRow <= 4) {
                    invKeySchedule[invKsRow] = t;
                  } else {
                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
                  }
                }
              },
              encryptBlock: function(M2, offset2) {
                this._doCryptBlock(M2, offset2, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
              },
              decryptBlock: function(M2, offset2) {
                var t = M2[offset2 + 1];
                M2[offset2 + 1] = M2[offset2 + 3];
                M2[offset2 + 3] = t;
                this._doCryptBlock(M2, offset2, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
                var t = M2[offset2 + 1];
                M2[offset2 + 1] = M2[offset2 + 3];
                M2[offset2 + 3] = t;
              },
              _doCryptBlock: function(M2, offset2, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
                var nRounds = this._nRounds;
                var s0 = M2[offset2] ^ keySchedule[0];
                var s1 = M2[offset2 + 1] ^ keySchedule[1];
                var s2 = M2[offset2 + 2] ^ keySchedule[2];
                var s3 = M2[offset2 + 3] ^ keySchedule[3];
                var ksRow = 4;
                for (var round2 = 1; round2 < nRounds; round2++) {
                  var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
                  var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
                  var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
                  var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
                  s0 = t0;
                  s1 = t1;
                  s2 = t2;
                  s3 = t3;
                }
                var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
                var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
                var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
                var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
                M2[offset2] = t0;
                M2[offset2 + 1] = t1;
                M2[offset2 + 2] = t2;
                M2[offset2 + 3] = t3;
              },
              keySize: 256 / 32
            });
            C2.AES = BlockCipher._createHelper(AES);
          })();
          return CryptoJS2.AES;
        });
      })(aes);
      return aes.exports;
    }
    var tripledes = { exports: {} };
    var hasRequiredTripledes;
    function requireTripledes() {
      if (hasRequiredTripledes)
        return tripledes.exports;
      hasRequiredTripledes = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var WordArray = C_lib.WordArray;
            var BlockCipher = C_lib.BlockCipher;
            var C_algo = C2.algo;
            var PC1 = [
              57,
              49,
              41,
              33,
              25,
              17,
              9,
              1,
              58,
              50,
              42,
              34,
              26,
              18,
              10,
              2,
              59,
              51,
              43,
              35,
              27,
              19,
              11,
              3,
              60,
              52,
              44,
              36,
              63,
              55,
              47,
              39,
              31,
              23,
              15,
              7,
              62,
              54,
              46,
              38,
              30,
              22,
              14,
              6,
              61,
              53,
              45,
              37,
              29,
              21,
              13,
              5,
              28,
              20,
              12,
              4
            ];
            var PC2 = [
              14,
              17,
              11,
              24,
              1,
              5,
              3,
              28,
              15,
              6,
              21,
              10,
              23,
              19,
              12,
              4,
              26,
              8,
              16,
              7,
              27,
              20,
              13,
              2,
              41,
              52,
              31,
              37,
              47,
              55,
              30,
              40,
              51,
              45,
              33,
              48,
              44,
              49,
              39,
              56,
              34,
              53,
              46,
              42,
              50,
              36,
              29,
              32
            ];
            var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
            var SBOX_P = [
              {
                0: 8421888,
                268435456: 32768,
                536870912: 8421378,
                805306368: 2,
                1073741824: 512,
                1342177280: 8421890,
                1610612736: 8389122,
                1879048192: 8388608,
                2147483648: 514,
                2415919104: 8389120,
                2684354560: 33280,
                2952790016: 8421376,
                3221225472: 32770,
                3489660928: 8388610,
                3758096384: 0,
                4026531840: 33282,
                134217728: 0,
                402653184: 8421890,
                671088640: 33282,
                939524096: 32768,
                1207959552: 8421888,
                1476395008: 512,
                1744830464: 8421378,
                2013265920: 2,
                2281701376: 8389120,
                2550136832: 33280,
                2818572288: 8421376,
                3087007744: 8389122,
                3355443200: 8388610,
                3623878656: 32770,
                3892314112: 514,
                4160749568: 8388608,
                1: 32768,
                268435457: 2,
                536870913: 8421888,
                805306369: 8388608,
                1073741825: 8421378,
                1342177281: 33280,
                1610612737: 512,
                1879048193: 8389122,
                2147483649: 8421890,
                2415919105: 8421376,
                2684354561: 8388610,
                2952790017: 33282,
                3221225473: 514,
                3489660929: 8389120,
                3758096385: 32770,
                4026531841: 0,
                134217729: 8421890,
                402653185: 8421376,
                671088641: 8388608,
                939524097: 512,
                1207959553: 32768,
                1476395009: 8388610,
                1744830465: 2,
                2013265921: 33282,
                2281701377: 32770,
                2550136833: 8389122,
                2818572289: 514,
                3087007745: 8421888,
                3355443201: 8389120,
                3623878657: 0,
                3892314113: 33280,
                4160749569: 8421378
              },
              {
                0: 1074282512,
                16777216: 16384,
                33554432: 524288,
                50331648: 1074266128,
                67108864: 1073741840,
                83886080: 1074282496,
                100663296: 1073758208,
                117440512: 16,
                134217728: 540672,
                150994944: 1073758224,
                167772160: 1073741824,
                184549376: 540688,
                201326592: 524304,
                218103808: 0,
                234881024: 16400,
                251658240: 1074266112,
                8388608: 1073758208,
                25165824: 540688,
                41943040: 16,
                58720256: 1073758224,
                75497472: 1074282512,
                92274688: 1073741824,
                109051904: 524288,
                125829120: 1074266128,
                142606336: 524304,
                159383552: 0,
                176160768: 16384,
                192937984: 1074266112,
                209715200: 1073741840,
                226492416: 540672,
                243269632: 1074282496,
                260046848: 16400,
                268435456: 0,
                285212672: 1074266128,
                301989888: 1073758224,
                318767104: 1074282496,
                335544320: 1074266112,
                352321536: 16,
                369098752: 540688,
                385875968: 16384,
                402653184: 16400,
                419430400: 524288,
                436207616: 524304,
                452984832: 1073741840,
                469762048: 540672,
                486539264: 1073758208,
                503316480: 1073741824,
                520093696: 1074282512,
                276824064: 540688,
                293601280: 524288,
                310378496: 1074266112,
                327155712: 16384,
                343932928: 1073758208,
                360710144: 1074282512,
                377487360: 16,
                394264576: 1073741824,
                411041792: 1074282496,
                427819008: 1073741840,
                444596224: 1073758224,
                461373440: 524304,
                478150656: 0,
                494927872: 16400,
                511705088: 1074266128,
                528482304: 540672
              },
              {
                0: 260,
                1048576: 0,
                2097152: 67109120,
                3145728: 65796,
                4194304: 65540,
                5242880: 67108868,
                6291456: 67174660,
                7340032: 67174400,
                8388608: 67108864,
                9437184: 67174656,
                10485760: 65792,
                11534336: 67174404,
                12582912: 67109124,
                13631488: 65536,
                14680064: 4,
                15728640: 256,
                524288: 67174656,
                1572864: 67174404,
                2621440: 0,
                3670016: 67109120,
                4718592: 67108868,
                5767168: 65536,
                6815744: 65540,
                7864320: 260,
                8912896: 4,
                9961472: 256,
                11010048: 67174400,
                12058624: 65796,
                13107200: 65792,
                14155776: 67109124,
                15204352: 67174660,
                16252928: 67108864,
                16777216: 67174656,
                17825792: 65540,
                18874368: 65536,
                19922944: 67109120,
                20971520: 256,
                22020096: 67174660,
                23068672: 67108868,
                24117248: 0,
                25165824: 67109124,
                26214400: 67108864,
                27262976: 4,
                28311552: 65792,
                29360128: 67174400,
                30408704: 260,
                31457280: 65796,
                32505856: 67174404,
                17301504: 67108864,
                18350080: 260,
                19398656: 67174656,
                20447232: 0,
                21495808: 65540,
                22544384: 67109120,
                23592960: 256,
                24641536: 67174404,
                25690112: 65536,
                26738688: 67174660,
                27787264: 65796,
                28835840: 67108868,
                29884416: 67109124,
                30932992: 67174400,
                31981568: 4,
                33030144: 65792
              },
              {
                0: 2151682048,
                65536: 2147487808,
                131072: 4198464,
                196608: 2151677952,
                262144: 0,
                327680: 4198400,
                393216: 2147483712,
                458752: 4194368,
                524288: 2147483648,
                589824: 4194304,
                655360: 64,
                720896: 2147487744,
                786432: 2151678016,
                851968: 4160,
                917504: 4096,
                983040: 2151682112,
                32768: 2147487808,
                98304: 64,
                163840: 2151678016,
                229376: 2147487744,
                294912: 4198400,
                360448: 2151682112,
                425984: 0,
                491520: 2151677952,
                557056: 4096,
                622592: 2151682048,
                688128: 4194304,
                753664: 4160,
                819200: 2147483648,
                884736: 4194368,
                950272: 4198464,
                1015808: 2147483712,
                1048576: 4194368,
                1114112: 4198400,
                1179648: 2147483712,
                1245184: 0,
                1310720: 4160,
                1376256: 2151678016,
                1441792: 2151682048,
                1507328: 2147487808,
                1572864: 2151682112,
                1638400: 2147483648,
                1703936: 2151677952,
                1769472: 4198464,
                1835008: 2147487744,
                1900544: 4194304,
                1966080: 64,
                2031616: 4096,
                1081344: 2151677952,
                1146880: 2151682112,
                1212416: 0,
                1277952: 4198400,
                1343488: 4194368,
                1409024: 2147483648,
                1474560: 2147487808,
                1540096: 64,
                1605632: 2147483712,
                1671168: 4096,
                1736704: 2147487744,
                1802240: 2151678016,
                1867776: 4160,
                1933312: 2151682048,
                1998848: 4194304,
                2064384: 4198464
              },
              {
                0: 128,
                4096: 17039360,
                8192: 262144,
                12288: 536870912,
                16384: 537133184,
                20480: 16777344,
                24576: 553648256,
                28672: 262272,
                32768: 16777216,
                36864: 537133056,
                40960: 536871040,
                45056: 553910400,
                49152: 553910272,
                53248: 0,
                57344: 17039488,
                61440: 553648128,
                2048: 17039488,
                6144: 553648256,
                10240: 128,
                14336: 17039360,
                18432: 262144,
                22528: 537133184,
                26624: 553910272,
                30720: 536870912,
                34816: 537133056,
                38912: 0,
                43008: 553910400,
                47104: 16777344,
                51200: 536871040,
                55296: 553648128,
                59392: 16777216,
                63488: 262272,
                65536: 262144,
                69632: 128,
                73728: 536870912,
                77824: 553648256,
                81920: 16777344,
                86016: 553910272,
                90112: 537133184,
                94208: 16777216,
                98304: 553910400,
                102400: 553648128,
                106496: 17039360,
                110592: 537133056,
                114688: 262272,
                118784: 536871040,
                122880: 0,
                126976: 17039488,
                67584: 553648256,
                71680: 16777216,
                75776: 17039360,
                79872: 537133184,
                83968: 536870912,
                88064: 17039488,
                92160: 128,
                96256: 553910272,
                100352: 262272,
                104448: 553910400,
                108544: 0,
                112640: 553648128,
                116736: 16777344,
                120832: 262144,
                124928: 537133056,
                129024: 536871040
              },
              {
                0: 268435464,
                256: 8192,
                512: 270532608,
                768: 270540808,
                1024: 268443648,
                1280: 2097152,
                1536: 2097160,
                1792: 268435456,
                2048: 0,
                2304: 268443656,
                2560: 2105344,
                2816: 8,
                3072: 270532616,
                3328: 2105352,
                3584: 8200,
                3840: 270540800,
                128: 270532608,
                384: 270540808,
                640: 8,
                896: 2097152,
                1152: 2105352,
                1408: 268435464,
                1664: 268443648,
                1920: 8200,
                2176: 2097160,
                2432: 8192,
                2688: 268443656,
                2944: 270532616,
                3200: 0,
                3456: 270540800,
                3712: 2105344,
                3968: 268435456,
                4096: 268443648,
                4352: 270532616,
                4608: 270540808,
                4864: 8200,
                5120: 2097152,
                5376: 268435456,
                5632: 268435464,
                5888: 2105344,
                6144: 2105352,
                6400: 0,
                6656: 8,
                6912: 270532608,
                7168: 8192,
                7424: 268443656,
                7680: 270540800,
                7936: 2097160,
                4224: 8,
                4480: 2105344,
                4736: 2097152,
                4992: 268435464,
                5248: 268443648,
                5504: 8200,
                5760: 270540808,
                6016: 270532608,
                6272: 270540800,
                6528: 270532616,
                6784: 8192,
                7040: 2105352,
                7296: 2097160,
                7552: 0,
                7808: 268435456,
                8064: 268443656
              },
              {
                0: 1048576,
                16: 33555457,
                32: 1024,
                48: 1049601,
                64: 34604033,
                80: 0,
                96: 1,
                112: 34603009,
                128: 33555456,
                144: 1048577,
                160: 33554433,
                176: 34604032,
                192: 34603008,
                208: 1025,
                224: 1049600,
                240: 33554432,
                8: 34603009,
                24: 0,
                40: 33555457,
                56: 34604032,
                72: 1048576,
                88: 33554433,
                104: 33554432,
                120: 1025,
                136: 1049601,
                152: 33555456,
                168: 34603008,
                184: 1048577,
                200: 1024,
                216: 34604033,
                232: 1,
                248: 1049600,
                256: 33554432,
                272: 1048576,
                288: 33555457,
                304: 34603009,
                320: 1048577,
                336: 33555456,
                352: 34604032,
                368: 1049601,
                384: 1025,
                400: 34604033,
                416: 1049600,
                432: 1,
                448: 0,
                464: 34603008,
                480: 33554433,
                496: 1024,
                264: 1049600,
                280: 33555457,
                296: 34603009,
                312: 1,
                328: 33554432,
                344: 1048576,
                360: 1025,
                376: 34604032,
                392: 33554433,
                408: 34603008,
                424: 0,
                440: 34604033,
                456: 1049601,
                472: 1024,
                488: 33555456,
                504: 1048577
              },
              {
                0: 134219808,
                1: 131072,
                2: 134217728,
                3: 32,
                4: 131104,
                5: 134350880,
                6: 134350848,
                7: 2048,
                8: 134348800,
                9: 134219776,
                10: 133120,
                11: 134348832,
                12: 2080,
                13: 0,
                14: 134217760,
                15: 133152,
                2147483648: 2048,
                2147483649: 134350880,
                2147483650: 134219808,
                2147483651: 134217728,
                2147483652: 134348800,
                2147483653: 133120,
                2147483654: 133152,
                2147483655: 32,
                2147483656: 134217760,
                2147483657: 2080,
                2147483658: 131104,
                2147483659: 134350848,
                2147483660: 0,
                2147483661: 134348832,
                2147483662: 134219776,
                2147483663: 131072,
                16: 133152,
                17: 134350848,
                18: 32,
                19: 2048,
                20: 134219776,
                21: 134217760,
                22: 134348832,
                23: 131072,
                24: 0,
                25: 131104,
                26: 134348800,
                27: 134219808,
                28: 134350880,
                29: 133120,
                30: 2080,
                31: 134217728,
                2147483664: 131072,
                2147483665: 2048,
                2147483666: 134348832,
                2147483667: 133152,
                2147483668: 32,
                2147483669: 134348800,
                2147483670: 134217728,
                2147483671: 134219808,
                2147483672: 134350880,
                2147483673: 134217760,
                2147483674: 134219776,
                2147483675: 0,
                2147483676: 133120,
                2147483677: 2080,
                2147483678: 131104,
                2147483679: 134350848
              }
            ];
            var SBOX_MASK = [
              4160749569,
              528482304,
              33030144,
              2064384,
              129024,
              8064,
              504,
              2147483679
            ];
            var DES = C_algo.DES = BlockCipher.extend({
              _doReset: function() {
                var key = this._key;
                var keyWords = key.words;
                var keyBits = [];
                for (var i = 0; i < 56; i++) {
                  var keyBitPos = PC1[i] - 1;
                  keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
                }
                var subKeys = this._subKeys = [];
                for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                  var subKey = subKeys[nSubKey] = [];
                  var bitShift = BIT_SHIFTS[nSubKey];
                  for (var i = 0; i < 24; i++) {
                    subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                    subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
                  }
                  subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
                  for (var i = 1; i < 7; i++) {
                    subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
                  }
                  subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
                }
                var invSubKeys = this._invSubKeys = [];
                for (var i = 0; i < 16; i++) {
                  invSubKeys[i] = subKeys[15 - i];
                }
              },
              encryptBlock: function(M2, offset2) {
                this._doCryptBlock(M2, offset2, this._subKeys);
              },
              decryptBlock: function(M2, offset2) {
                this._doCryptBlock(M2, offset2, this._invSubKeys);
              },
              _doCryptBlock: function(M2, offset2, subKeys) {
                this._lBlock = M2[offset2];
                this._rBlock = M2[offset2 + 1];
                exchangeLR.call(this, 4, 252645135);
                exchangeLR.call(this, 16, 65535);
                exchangeRL.call(this, 2, 858993459);
                exchangeRL.call(this, 8, 16711935);
                exchangeLR.call(this, 1, 1431655765);
                for (var round2 = 0; round2 < 16; round2++) {
                  var subKey = subKeys[round2];
                  var lBlock = this._lBlock;
                  var rBlock = this._rBlock;
                  var f2 = 0;
                  for (var i = 0; i < 8; i++) {
                    f2 |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                  }
                  this._lBlock = rBlock;
                  this._rBlock = lBlock ^ f2;
                }
                var t = this._lBlock;
                this._lBlock = this._rBlock;
                this._rBlock = t;
                exchangeLR.call(this, 1, 1431655765);
                exchangeRL.call(this, 8, 16711935);
                exchangeRL.call(this, 2, 858993459);
                exchangeLR.call(this, 16, 65535);
                exchangeLR.call(this, 4, 252645135);
                M2[offset2] = this._lBlock;
                M2[offset2 + 1] = this._rBlock;
              },
              keySize: 64 / 32,
              ivSize: 64 / 32,
              blockSize: 64 / 32
            });
            function exchangeLR(offset2, mask) {
              var t = (this._lBlock >>> offset2 ^ this._rBlock) & mask;
              this._rBlock ^= t;
              this._lBlock ^= t << offset2;
            }
            function exchangeRL(offset2, mask) {
              var t = (this._rBlock >>> offset2 ^ this._lBlock) & mask;
              this._lBlock ^= t;
              this._rBlock ^= t << offset2;
            }
            C2.DES = BlockCipher._createHelper(DES);
            var TripleDES = C_algo.TripleDES = BlockCipher.extend({
              _doReset: function() {
                var key = this._key;
                var keyWords = key.words;
                if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
                  throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                }
                var key1 = keyWords.slice(0, 2);
                var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
                var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
                this._des1 = DES.createEncryptor(WordArray.create(key1));
                this._des2 = DES.createEncryptor(WordArray.create(key2));
                this._des3 = DES.createEncryptor(WordArray.create(key3));
              },
              encryptBlock: function(M2, offset2) {
                this._des1.encryptBlock(M2, offset2);
                this._des2.decryptBlock(M2, offset2);
                this._des3.encryptBlock(M2, offset2);
              },
              decryptBlock: function(M2, offset2) {
                this._des3.decryptBlock(M2, offset2);
                this._des2.encryptBlock(M2, offset2);
                this._des1.decryptBlock(M2, offset2);
              },
              keySize: 192 / 32,
              ivSize: 64 / 32,
              blockSize: 64 / 32
            });
            C2.TripleDES = BlockCipher._createHelper(TripleDES);
          })();
          return CryptoJS2.TripleDES;
        });
      })(tripledes);
      return tripledes.exports;
    }
    var rc4 = { exports: {} };
    var hasRequiredRc4;
    function requireRc4() {
      if (hasRequiredRc4)
        return rc4.exports;
      hasRequiredRc4 = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var StreamCipher = C_lib.StreamCipher;
            var C_algo = C2.algo;
            var RC4 = C_algo.RC4 = StreamCipher.extend({
              _doReset: function() {
                var key = this._key;
                var keyWords = key.words;
                var keySigBytes = key.sigBytes;
                var S2 = this._S = [];
                for (var i = 0; i < 256; i++) {
                  S2[i] = i;
                }
                for (var i = 0, j = 0; i < 256; i++) {
                  var keyByteIndex = i % keySigBytes;
                  var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
                  j = (j + S2[i] + keyByte) % 256;
                  var t = S2[i];
                  S2[i] = S2[j];
                  S2[j] = t;
                }
                this._i = this._j = 0;
              },
              _doProcessBlock: function(M2, offset2) {
                M2[offset2] ^= generateKeystreamWord.call(this);
              },
              keySize: 256 / 32,
              ivSize: 0
            });
            function generateKeystreamWord() {
              var S2 = this._S;
              var i = this._i;
              var j = this._j;
              var keystreamWord = 0;
              for (var n = 0; n < 4; n++) {
                i = (i + 1) % 256;
                j = (j + S2[i]) % 256;
                var t = S2[i];
                S2[i] = S2[j];
                S2[j] = t;
                keystreamWord |= S2[(S2[i] + S2[j]) % 256] << 24 - n * 8;
              }
              this._i = i;
              this._j = j;
              return keystreamWord;
            }
            C2.RC4 = StreamCipher._createHelper(RC4);
            var RC4Drop = C_algo.RC4Drop = RC4.extend({
              cfg: RC4.cfg.extend({
                drop: 192
              }),
              _doReset: function() {
                RC4._doReset.call(this);
                for (var i = this.cfg.drop; i > 0; i--) {
                  generateKeystreamWord.call(this);
                }
              }
            });
            C2.RC4Drop = StreamCipher._createHelper(RC4Drop);
          })();
          return CryptoJS2.RC4;
        });
      })(rc4);
      return rc4.exports;
    }
    var rabbit = { exports: {} };
    var hasRequiredRabbit;
    function requireRabbit() {
      if (hasRequiredRabbit)
        return rabbit.exports;
      hasRequiredRabbit = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var StreamCipher = C_lib.StreamCipher;
            var C_algo = C2.algo;
            var S2 = [];
            var C_ = [];
            var G2 = [];
            var Rabbit = C_algo.Rabbit = StreamCipher.extend({
              _doReset: function() {
                var K2 = this._key.words;
                var iv = this.cfg.iv;
                for (var i = 0; i < 4; i++) {
                  K2[i] = (K2[i] << 8 | K2[i] >>> 24) & 16711935 | (K2[i] << 24 | K2[i] >>> 8) & 4278255360;
                }
                var X2 = this._X = [
                  K2[0],
                  K2[3] << 16 | K2[2] >>> 16,
                  K2[1],
                  K2[0] << 16 | K2[3] >>> 16,
                  K2[2],
                  K2[1] << 16 | K2[0] >>> 16,
                  K2[3],
                  K2[2] << 16 | K2[1] >>> 16
                ];
                var C3 = this._C = [
                  K2[2] << 16 | K2[2] >>> 16,
                  K2[0] & 4294901760 | K2[1] & 65535,
                  K2[3] << 16 | K2[3] >>> 16,
                  K2[1] & 4294901760 | K2[2] & 65535,
                  K2[0] << 16 | K2[0] >>> 16,
                  K2[2] & 4294901760 | K2[3] & 65535,
                  K2[1] << 16 | K2[1] >>> 16,
                  K2[3] & 4294901760 | K2[0] & 65535
                ];
                this._b = 0;
                for (var i = 0; i < 4; i++) {
                  nextState.call(this);
                }
                for (var i = 0; i < 8; i++) {
                  C3[i] ^= X2[i + 4 & 7];
                }
                if (iv) {
                  var IV = iv.words;
                  var IV_0 = IV[0];
                  var IV_1 = IV[1];
                  var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                  var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                  var i1 = i0 >>> 16 | i2 & 4294901760;
                  var i3 = i2 << 16 | i0 & 65535;
                  C3[0] ^= i0;
                  C3[1] ^= i1;
                  C3[2] ^= i2;
                  C3[3] ^= i3;
                  C3[4] ^= i0;
                  C3[5] ^= i1;
                  C3[6] ^= i2;
                  C3[7] ^= i3;
                  for (var i = 0; i < 4; i++) {
                    nextState.call(this);
                  }
                }
              },
              _doProcessBlock: function(M2, offset2) {
                var X2 = this._X;
                nextState.call(this);
                S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
                S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
                S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
                S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
                for (var i = 0; i < 4; i++) {
                  S2[i] = (S2[i] << 8 | S2[i] >>> 24) & 16711935 | (S2[i] << 24 | S2[i] >>> 8) & 4278255360;
                  M2[offset2 + i] ^= S2[i];
                }
              },
              blockSize: 128 / 32,
              ivSize: 64 / 32
            });
            function nextState() {
              var X2 = this._X;
              var C3 = this._C;
              for (var i = 0; i < 8; i++) {
                C_[i] = C3[i];
              }
              C3[0] = C3[0] + 1295307597 + this._b | 0;
              C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
              C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
              C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
              C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
              C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
              C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
              C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
              this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
              for (var i = 0; i < 8; i++) {
                var gx = X2[i] + C3[i];
                var ga = gx & 65535;
                var gb = gx >>> 16;
                var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
                G2[i] = gh ^ gl;
              }
              X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
              X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
              X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
              X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
              X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
              X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
              X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
              X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
            }
            C2.Rabbit = StreamCipher._createHelper(Rabbit);
          })();
          return CryptoJS2.Rabbit;
        });
      })(rabbit);
      return rabbit.exports;
    }
    var rabbitLegacy = { exports: {} };
    var hasRequiredRabbitLegacy;
    function requireRabbitLegacy() {
      if (hasRequiredRabbitLegacy)
        return rabbitLegacy.exports;
      hasRequiredRabbitLegacy = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var StreamCipher = C_lib.StreamCipher;
            var C_algo = C2.algo;
            var S2 = [];
            var C_ = [];
            var G2 = [];
            var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
              _doReset: function() {
                var K2 = this._key.words;
                var iv = this.cfg.iv;
                var X2 = this._X = [
                  K2[0],
                  K2[3] << 16 | K2[2] >>> 16,
                  K2[1],
                  K2[0] << 16 | K2[3] >>> 16,
                  K2[2],
                  K2[1] << 16 | K2[0] >>> 16,
                  K2[3],
                  K2[2] << 16 | K2[1] >>> 16
                ];
                var C3 = this._C = [
                  K2[2] << 16 | K2[2] >>> 16,
                  K2[0] & 4294901760 | K2[1] & 65535,
                  K2[3] << 16 | K2[3] >>> 16,
                  K2[1] & 4294901760 | K2[2] & 65535,
                  K2[0] << 16 | K2[0] >>> 16,
                  K2[2] & 4294901760 | K2[3] & 65535,
                  K2[1] << 16 | K2[1] >>> 16,
                  K2[3] & 4294901760 | K2[0] & 65535
                ];
                this._b = 0;
                for (var i = 0; i < 4; i++) {
                  nextState.call(this);
                }
                for (var i = 0; i < 8; i++) {
                  C3[i] ^= X2[i + 4 & 7];
                }
                if (iv) {
                  var IV = iv.words;
                  var IV_0 = IV[0];
                  var IV_1 = IV[1];
                  var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                  var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                  var i1 = i0 >>> 16 | i2 & 4294901760;
                  var i3 = i2 << 16 | i0 & 65535;
                  C3[0] ^= i0;
                  C3[1] ^= i1;
                  C3[2] ^= i2;
                  C3[3] ^= i3;
                  C3[4] ^= i0;
                  C3[5] ^= i1;
                  C3[6] ^= i2;
                  C3[7] ^= i3;
                  for (var i = 0; i < 4; i++) {
                    nextState.call(this);
                  }
                }
              },
              _doProcessBlock: function(M2, offset2) {
                var X2 = this._X;
                nextState.call(this);
                S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
                S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
                S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
                S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
                for (var i = 0; i < 4; i++) {
                  S2[i] = (S2[i] << 8 | S2[i] >>> 24) & 16711935 | (S2[i] << 24 | S2[i] >>> 8) & 4278255360;
                  M2[offset2 + i] ^= S2[i];
                }
              },
              blockSize: 128 / 32,
              ivSize: 64 / 32
            });
            function nextState() {
              var X2 = this._X;
              var C3 = this._C;
              for (var i = 0; i < 8; i++) {
                C_[i] = C3[i];
              }
              C3[0] = C3[0] + 1295307597 + this._b | 0;
              C3[1] = C3[1] + 3545052371 + (C3[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
              C3[2] = C3[2] + 886263092 + (C3[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
              C3[3] = C3[3] + 1295307597 + (C3[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
              C3[4] = C3[4] + 3545052371 + (C3[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
              C3[5] = C3[5] + 886263092 + (C3[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
              C3[6] = C3[6] + 1295307597 + (C3[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
              C3[7] = C3[7] + 3545052371 + (C3[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
              this._b = C3[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
              for (var i = 0; i < 8; i++) {
                var gx = X2[i] + C3[i];
                var ga = gx & 65535;
                var gb = gx >>> 16;
                var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
                G2[i] = gh ^ gl;
              }
              X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
              X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
              X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
              X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
              X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
              X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
              X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
              X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
            }
            C2.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
          })();
          return CryptoJS2.RabbitLegacy;
        });
      })(rabbitLegacy);
      return rabbitLegacy.exports;
    }
    var blowfish = { exports: {} };
    var hasRequiredBlowfish;
    function requireBlowfish() {
      if (hasRequiredBlowfish)
        return blowfish.exports;
      hasRequiredBlowfish = 1;
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS2) {
          (function() {
            var C2 = CryptoJS2;
            var C_lib = C2.lib;
            var BlockCipher = C_lib.BlockCipher;
            var C_algo = C2.algo;
            const N2 = 16;
            const ORIG_P = [
              608135816,
              2242054355,
              320440878,
              57701188,
              2752067618,
              698298832,
              137296536,
              3964562569,
              1160258022,
              953160567,
              3193202383,
              887688300,
              3232508343,
              3380367581,
              1065670069,
              3041331479,
              2450970073,
              2306472731
            ];
            const ORIG_S = [
              [
                3509652390,
                2564797868,
                805139163,
                3491422135,
                3101798381,
                1780907670,
                3128725573,
                4046225305,
                614570311,
                3012652279,
                134345442,
                2240740374,
                1667834072,
                1901547113,
                2757295779,
                4103290238,
                227898511,
                1921955416,
                1904987480,
                2182433518,
                2069144605,
                3260701109,
                2620446009,
                720527379,
                3318853667,
                677414384,
                3393288472,
                3101374703,
                2390351024,
                1614419982,
                1822297739,
                2954791486,
                3608508353,
                3174124327,
                2024746970,
                1432378464,
                3864339955,
                2857741204,
                1464375394,
                1676153920,
                1439316330,
                715854006,
                3033291828,
                289532110,
                2706671279,
                2087905683,
                3018724369,
                1668267050,
                732546397,
                1947742710,
                3462151702,
                2609353502,
                2950085171,
                1814351708,
                2050118529,
                680887927,
                999245976,
                1800124847,
                3300911131,
                1713906067,
                1641548236,
                4213287313,
                1216130144,
                1575780402,
                4018429277,
                3917837745,
                3693486850,
                3949271944,
                596196993,
                3549867205,
                258830323,
                2213823033,
                772490370,
                2760122372,
                1774776394,
                2652871518,
                566650946,
                4142492826,
                1728879713,
                2882767088,
                1783734482,
                3629395816,
                2517608232,
                2874225571,
                1861159788,
                326777828,
                3124490320,
                2130389656,
                2716951837,
                967770486,
                1724537150,
                2185432712,
                2364442137,
                1164943284,
                2105845187,
                998989502,
                3765401048,
                2244026483,
                1075463327,
                1455516326,
                1322494562,
                910128902,
                469688178,
                1117454909,
                936433444,
                3490320968,
                3675253459,
                1240580251,
                122909385,
                2157517691,
                634681816,
                4142456567,
                3825094682,
                3061402683,
                2540495037,
                79693498,
                3249098678,
                1084186820,
                1583128258,
                426386531,
                1761308591,
                1047286709,
                322548459,
                995290223,
                1845252383,
                2603652396,
                3431023940,
                2942221577,
                3202600964,
                3727903485,
                1712269319,
                422464435,
                3234572375,
                1170764815,
                3523960633,
                3117677531,
                1434042557,
                442511882,
                3600875718,
                1076654713,
                1738483198,
                4213154764,
                2393238008,
                3677496056,
                1014306527,
                4251020053,
                793779912,
                2902807211,
                842905082,
                4246964064,
                1395751752,
                1040244610,
                2656851899,
                3396308128,
                445077038,
                3742853595,
                3577915638,
                679411651,
                2892444358,
                2354009459,
                1767581616,
                3150600392,
                3791627101,
                3102740896,
                284835224,
                4246832056,
                1258075500,
                768725851,
                2589189241,
                3069724005,
                3532540348,
                1274779536,
                3789419226,
                2764799539,
                1660621633,
                3471099624,
                4011903706,
                913787905,
                3497959166,
                737222580,
                2514213453,
                2928710040,
                3937242737,
                1804850592,
                3499020752,
                2949064160,
                2386320175,
                2390070455,
                2415321851,
                4061277028,
                2290661394,
                2416832540,
                1336762016,
                1754252060,
                3520065937,
                3014181293,
                791618072,
                3188594551,
                3933548030,
                2332172193,
                3852520463,
                3043980520,
                413987798,
                3465142937,
                3030929376,
                4245938359,
                2093235073,
                3534596313,
                375366246,
                2157278981,
                2479649556,
                555357303,
                3870105701,
                2008414854,
                3344188149,
                4221384143,
                3956125452,
                2067696032,
                3594591187,
                2921233993,
                2428461,
                544322398,
                577241275,
                1471733935,
                610547355,
                4027169054,
                1432588573,
                1507829418,
                2025931657,
                3646575487,
                545086370,
                48609733,
                2200306550,
                1653985193,
                298326376,
                1316178497,
                3007786442,
                2064951626,
                458293330,
                2589141269,
                3591329599,
                3164325604,
                727753846,
                2179363840,
                146436021,
                1461446943,
                4069977195,
                705550613,
                3059967265,
                3887724982,
                4281599278,
                3313849956,
                1404054877,
                2845806497,
                146425753,
                1854211946
              ],
              [
                1266315497,
                3048417604,
                3681880366,
                3289982499,
                290971e4,
                1235738493,
                2632868024,
                2414719590,
                3970600049,
                1771706367,
                1449415276,
                3266420449,
                422970021,
                1963543593,
                2690192192,
                3826793022,
                1062508698,
                1531092325,
                1804592342,
                2583117782,
                2714934279,
                4024971509,
                1294809318,
                4028980673,
                1289560198,
                2221992742,
                1669523910,
                35572830,
                157838143,
                1052438473,
                1016535060,
                1802137761,
                1753167236,
                1386275462,
                3080475397,
                2857371447,
                1040679964,
                2145300060,
                2390574316,
                1461121720,
                2956646967,
                4031777805,
                4028374788,
                33600511,
                2920084762,
                1018524850,
                629373528,
                3691585981,
                3515945977,
                2091462646,
                2486323059,
                586499841,
                988145025,
                935516892,
                3367335476,
                2599673255,
                2839830854,
                265290510,
                3972581182,
                2759138881,
                3795373465,
                1005194799,
                847297441,
                406762289,
                1314163512,
                1332590856,
                1866599683,
                4127851711,
                750260880,
                613907577,
                1450815602,
                3165620655,
                3734664991,
                3650291728,
                3012275730,
                3704569646,
                1427272223,
                778793252,
                1343938022,
                2676280711,
                2052605720,
                1946737175,
                3164576444,
                3914038668,
                3967478842,
                3682934266,
                1661551462,
                3294938066,
                4011595847,
                840292616,
                3712170807,
                616741398,
                312560963,
                711312465,
                1351876610,
                322626781,
                1910503582,
                271666773,
                2175563734,
                1594956187,
                70604529,
                3617834859,
                1007753275,
                1495573769,
                4069517037,
                2549218298,
                2663038764,
                504708206,
                2263041392,
                3941167025,
                2249088522,
                1514023603,
                1998579484,
                1312622330,
                694541497,
                2582060303,
                2151582166,
                1382467621,
                776784248,
                2618340202,
                3323268794,
                2497899128,
                2784771155,
                503983604,
                4076293799,
                907881277,
                423175695,
                432175456,
                1378068232,
                4145222326,
                3954048622,
                3938656102,
                3820766613,
                2793130115,
                2977904593,
                26017576,
                3274890735,
                3194772133,
                1700274565,
                1756076034,
                4006520079,
                3677328699,
                720338349,
                1533947780,
                354530856,
                688349552,
                3973924725,
                1637815568,
                332179504,
                3949051286,
                53804574,
                2852348879,
                3044236432,
                1282449977,
                3583942155,
                3416972820,
                4006381244,
                1617046695,
                2628476075,
                3002303598,
                1686838959,
                431878346,
                2686675385,
                1700445008,
                1080580658,
                1009431731,
                832498133,
                3223435511,
                2605976345,
                2271191193,
                2516031870,
                1648197032,
                4164389018,
                2548247927,
                300782431,
                375919233,
                238389289,
                3353747414,
                2531188641,
                2019080857,
                1475708069,
                455242339,
                2609103871,
                448939670,
                3451063019,
                1395535956,
                2413381860,
                1841049896,
                1491858159,
                885456874,
                4264095073,
                4001119347,
                1565136089,
                3898914787,
                1108368660,
                540939232,
                1173283510,
                2745871338,
                3681308437,
                4207628240,
                3343053890,
                4016749493,
                1699691293,
                1103962373,
                3625875870,
                2256883143,
                3830138730,
                1031889488,
                3479347698,
                1535977030,
                4236805024,
                3251091107,
                2132092099,
                1774941330,
                1199868427,
                1452454533,
                157007616,
                2904115357,
                342012276,
                595725824,
                1480756522,
                206960106,
                497939518,
                591360097,
                863170706,
                2375253569,
                3596610801,
                1814182875,
                2094937945,
                3421402208,
                1082520231,
                3463918190,
                2785509508,
                435703966,
                3908032597,
                1641649973,
                2842273706,
                3305899714,
                1510255612,
                2148256476,
                2655287854,
                3276092548,
                4258621189,
                236887753,
                3681803219,
                274041037,
                1734335097,
                3815195456,
                3317970021,
                1899903192,
                1026095262,
                4050517792,
                356393447,
                2410691914,
                3873677099,
                3682840055
              ],
              [
                3913112168,
                2491498743,
                4132185628,
                2489919796,
                1091903735,
                1979897079,
                3170134830,
                3567386728,
                3557303409,
                857797738,
                1136121015,
                1342202287,
                507115054,
                2535736646,
                337727348,
                3213592640,
                1301675037,
                2528481711,
                1895095763,
                1721773893,
                3216771564,
                62756741,
                2142006736,
                835421444,
                2531993523,
                1442658625,
                3659876326,
                2882144922,
                676362277,
                1392781812,
                170690266,
                3921047035,
                1759253602,
                3611846912,
                1745797284,
                664899054,
                1329594018,
                3901205900,
                3045908486,
                2062866102,
                2865634940,
                3543621612,
                3464012697,
                1080764994,
                553557557,
                3656615353,
                3996768171,
                991055499,
                499776247,
                1265440854,
                648242737,
                3940784050,
                980351604,
                3713745714,
                1749149687,
                3396870395,
                4211799374,
                3640570775,
                1161844396,
                3125318951,
                1431517754,
                545492359,
                4268468663,
                3499529547,
                1437099964,
                2702547544,
                3433638243,
                2581715763,
                2787789398,
                1060185593,
                1593081372,
                2418618748,
                4260947970,
                69676912,
                2159744348,
                86519011,
                2512459080,
                3838209314,
                1220612927,
                3339683548,
                133810670,
                1090789135,
                1078426020,
                1569222167,
                845107691,
                3583754449,
                4072456591,
                1091646820,
                628848692,
                1613405280,
                3757631651,
                526609435,
                236106946,
                48312990,
                2942717905,
                3402727701,
                1797494240,
                859738849,
                992217954,
                4005476642,
                2243076622,
                3870952857,
                3732016268,
                765654824,
                3490871365,
                2511836413,
                1685915746,
                3888969200,
                1414112111,
                2273134842,
                3281911079,
                4080962846,
                172450625,
                2569994100,
                980381355,
                4109958455,
                2819808352,
                2716589560,
                2568741196,
                3681446669,
                3329971472,
                1835478071,
                660984891,
                3704678404,
                4045999559,
                3422617507,
                3040415634,
                1762651403,
                1719377915,
                3470491036,
                2693910283,
                3642056355,
                3138596744,
                1364962596,
                2073328063,
                1983633131,
                926494387,
                3423689081,
                2150032023,
                4096667949,
                1749200295,
                3328846651,
                309677260,
                2016342300,
                1779581495,
                3079819751,
                111262694,
                1274766160,
                443224088,
                298511866,
                1025883608,
                3806446537,
                1145181785,
                168956806,
                3641502830,
                3584813610,
                1689216846,
                3666258015,
                3200248200,
                1692713982,
                2646376535,
                4042768518,
                1618508792,
                1610833997,
                3523052358,
                4130873264,
                2001055236,
                3610705100,
                2202168115,
                4028541809,
                2961195399,
                1006657119,
                2006996926,
                3186142756,
                1430667929,
                3210227297,
                1314452623,
                4074634658,
                4101304120,
                2273951170,
                1399257539,
                3367210612,
                3027628629,
                1190975929,
                2062231137,
                2333990788,
                2221543033,
                2438960610,
                1181637006,
                548689776,
                2362791313,
                3372408396,
                3104550113,
                3145860560,
                296247880,
                1970579870,
                3078560182,
                3769228297,
                1714227617,
                3291629107,
                3898220290,
                166772364,
                1251581989,
                493813264,
                448347421,
                195405023,
                2709975567,
                677966185,
                3703036547,
                1463355134,
                2715995803,
                1338867538,
                1343315457,
                2802222074,
                2684532164,
                233230375,
                2599980071,
                2000651841,
                3277868038,
                1638401717,
                4028070440,
                3237316320,
                6314154,
                819756386,
                300326615,
                590932579,
                1405279636,
                3267499572,
                3150704214,
                2428286686,
                3959192993,
                3461946742,
                1862657033,
                1266418056,
                963775037,
                2089974820,
                2263052895,
                1917689273,
                448879540,
                3550394620,
                3981727096,
                150775221,
                3627908307,
                1303187396,
                508620638,
                2975983352,
                2726630617,
                1817252668,
                1876281319,
                1457606340,
                908771278,
                3720792119,
                3617206836,
                2455994898,
                1729034894,
                1080033504
              ],
              [
                976866871,
                3556439503,
                2881648439,
                1522871579,
                1555064734,
                1336096578,
                3548522304,
                2579274686,
                3574697629,
                3205460757,
                3593280638,
                3338716283,
                3079412587,
                564236357,
                2993598910,
                1781952180,
                1464380207,
                3163844217,
                3332601554,
                1699332808,
                1393555694,
                1183702653,
                3581086237,
                1288719814,
                691649499,
                2847557200,
                2895455976,
                3193889540,
                2717570544,
                1781354906,
                1676643554,
                2592534050,
                3230253752,
                1126444790,
                2770207658,
                2633158820,
                2210423226,
                2615765581,
                2414155088,
                3127139286,
                673620729,
                2805611233,
                1269405062,
                4015350505,
                3341807571,
                4149409754,
                1057255273,
                2012875353,
                2162469141,
                2276492801,
                2601117357,
                993977747,
                3918593370,
                2654263191,
                753973209,
                36408145,
                2530585658,
                25011837,
                3520020182,
                2088578344,
                530523599,
                2918365339,
                1524020338,
                1518925132,
                3760827505,
                3759777254,
                1202760957,
                3985898139,
                3906192525,
                674977740,
                4174734889,
                2031300136,
                2019492241,
                3983892565,
                4153806404,
                3822280332,
                352677332,
                2297720250,
                60907813,
                90501309,
                3286998549,
                1016092578,
                2535922412,
                2839152426,
                457141659,
                509813237,
                4120667899,
                652014361,
                1966332200,
                2975202805,
                55981186,
                2327461051,
                676427537,
                3255491064,
                2882294119,
                3433927263,
                1307055953,
                942726286,
                933058658,
                2468411793,
                3933900994,
                4215176142,
                1361170020,
                2001714738,
                2830558078,
                3274259782,
                1222529897,
                1679025792,
                2729314320,
                3714953764,
                1770335741,
                151462246,
                3013232138,
                1682292957,
                1483529935,
                471910574,
                1539241949,
                458788160,
                3436315007,
                1807016891,
                3718408830,
                978976581,
                1043663428,
                3165965781,
                1927990952,
                4200891579,
                2372276910,
                3208408903,
                3533431907,
                1412390302,
                2931980059,
                4132332400,
                1947078029,
                3881505623,
                4168226417,
                2941484381,
                1077988104,
                1320477388,
                886195818,
                18198404,
                3786409e3,
                2509781533,
                112762804,
                3463356488,
                1866414978,
                891333506,
                18488651,
                661792760,
                1628790961,
                3885187036,
                3141171499,
                876946877,
                2693282273,
                1372485963,
                791857591,
                2686433993,
                3759982718,
                3167212022,
                3472953795,
                2716379847,
                445679433,
                3561995674,
                3504004811,
                3574258232,
                54117162,
                3331405415,
                2381918588,
                3769707343,
                4154350007,
                1140177722,
                4074052095,
                668550556,
                3214352940,
                367459370,
                261225585,
                2610173221,
                4209349473,
                3468074219,
                3265815641,
                314222801,
                3066103646,
                3808782860,
                282218597,
                3406013506,
                3773591054,
                379116347,
                1285071038,
                846784868,
                2669647154,
                3771962079,
                3550491691,
                2305946142,
                453669953,
                1268987020,
                3317592352,
                3279303384,
                3744833421,
                2610507566,
                3859509063,
                266596637,
                3847019092,
                517658769,
                3462560207,
                3443424879,
                370717030,
                4247526661,
                2224018117,
                4143653529,
                4112773975,
                2788324899,
                2477274417,
                1456262402,
                2901442914,
                1517677493,
                1846949527,
                2295493580,
                3734397586,
                2176403920,
                1280348187,
                1908823572,
                3871786941,
                846861322,
                1172426758,
                3287448474,
                3383383037,
                1655181056,
                3139813346,
                901632758,
                1897031941,
                2986607138,
                3066810236,
                3447102507,
                1393639104,
                373351379,
                950779232,
                625454576,
                3124240540,
                4148612726,
                2007998917,
                544563296,
                2244738638,
                2330496472,
                2058025392,
                1291430526,
                424198748,
                50039436,
                29584100,
                3605783033,
                2429876329,
                2791104160,
                1057563949,
                3255363231,
                3075367218,
                3463963227,
                1469046755,
                985887462
              ]
            ];
            var BLOWFISH_CTX = {
              pbox: [],
              sbox: []
            };
            function F2(ctx, x2) {
              let a2 = x2 >> 24 & 255;
              let b2 = x2 >> 16 & 255;
              let c2 = x2 >> 8 & 255;
              let d2 = x2 & 255;
              let y = ctx.sbox[0][a2] + ctx.sbox[1][b2];
              y = y ^ ctx.sbox[2][c2];
              y = y + ctx.sbox[3][d2];
              return y;
            }
            function BlowFish_Encrypt(ctx, left2, right2) {
              let Xl = left2;
              let Xr = right2;
              let temp;
              for (let i = 0; i < N2; ++i) {
                Xl = Xl ^ ctx.pbox[i];
                Xr = F2(ctx, Xl) ^ Xr;
                temp = Xl;
                Xl = Xr;
                Xr = temp;
              }
              temp = Xl;
              Xl = Xr;
              Xr = temp;
              Xr = Xr ^ ctx.pbox[N2];
              Xl = Xl ^ ctx.pbox[N2 + 1];
              return { left: Xl, right: Xr };
            }
            function BlowFish_Decrypt(ctx, left2, right2) {
              let Xl = left2;
              let Xr = right2;
              let temp;
              for (let i = N2 + 1; i > 1; --i) {
                Xl = Xl ^ ctx.pbox[i];
                Xr = F2(ctx, Xl) ^ Xr;
                temp = Xl;
                Xl = Xr;
                Xr = temp;
              }
              temp = Xl;
              Xl = Xr;
              Xr = temp;
              Xr = Xr ^ ctx.pbox[1];
              Xl = Xl ^ ctx.pbox[0];
              return { left: Xl, right: Xr };
            }
            function BlowFishInit(ctx, key, keysize) {
              for (let Row2 = 0; Row2 < 4; Row2++) {
                ctx.sbox[Row2] = [];
                for (let Col2 = 0; Col2 < 256; Col2++) {
                  ctx.sbox[Row2][Col2] = ORIG_S[Row2][Col2];
                }
              }
              let keyIndex = 0;
              for (let index2 = 0; index2 < N2 + 2; index2++) {
                ctx.pbox[index2] = ORIG_P[index2] ^ key[keyIndex];
                keyIndex++;
                if (keyIndex >= keysize) {
                  keyIndex = 0;
                }
              }
              let Data1 = 0;
              let Data2 = 0;
              let res = 0;
              for (let i = 0; i < N2 + 2; i += 2) {
                res = BlowFish_Encrypt(ctx, Data1, Data2);
                Data1 = res.left;
                Data2 = res.right;
                ctx.pbox[i] = Data1;
                ctx.pbox[i + 1] = Data2;
              }
              for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 256; j += 2) {
                  res = BlowFish_Encrypt(ctx, Data1, Data2);
                  Data1 = res.left;
                  Data2 = res.right;
                  ctx.sbox[i][j] = Data1;
                  ctx.sbox[i][j + 1] = Data2;
                }
              }
              return true;
            }
            var Blowfish = C_algo.Blowfish = BlockCipher.extend({
              _doReset: function() {
                if (this._keyPriorReset === this._key) {
                  return;
                }
                var key = this._keyPriorReset = this._key;
                var keyWords = key.words;
                var keySize = key.sigBytes / 4;
                BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
              },
              encryptBlock: function(M2, offset2) {
                var res = BlowFish_Encrypt(BLOWFISH_CTX, M2[offset2], M2[offset2 + 1]);
                M2[offset2] = res.left;
                M2[offset2 + 1] = res.right;
              },
              decryptBlock: function(M2, offset2) {
                var res = BlowFish_Decrypt(BLOWFISH_CTX, M2[offset2], M2[offset2 + 1]);
                M2[offset2] = res.left;
                M2[offset2 + 1] = res.right;
              },
              blockSize: 64 / 32,
              keySize: 128 / 32,
              ivSize: 64 / 32
            });
            C2.Blowfish = BlockCipher._createHelper(Blowfish);
          })();
          return CryptoJS2.Blowfish;
        });
      })(blowfish);
      return blowfish.exports;
    }
    (function(module2, exports2) {
      (function(root2, factory, undef) {
        {
          module2.exports = factory(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy(), requireBlowfish());
        }
      })(commonjsGlobal, function(CryptoJS2) {
        return CryptoJS2;
      });
    })(cryptoJs);
    const CryptoJS = cryptoJs.exports;
    const NewLogin_vue_vue_type_style_index_0_lang = "";
    const _hoisted_1 = { class: "container" };
    const _hoisted_2 = { class: "login-wrapper" };
    const _hoisted_3 = /* @__PURE__ */ createBaseVNode("div", { class: "header" }, "Login", -1);
    const _hoisted_4 = { class: "form-wrapper" };
    const _hoisted_5 = /* @__PURE__ */ createBaseVNode("div", { class: "msg" }, " Smart Config Login ", -1);
    const _sfc_main$1 = {
      __name: "NewLogin",
      emits: ["loginSuccess"],
      setup(__props, { emit: emits }) {
        const { t } = useI18n();
        const username = ref("");
        const pwd = ref("");
        const loginHandler = () => {
          if (!username.value || !pwd.value) {
            ElNotification({
              title: t("login.errorTitle"),
              message: t("login.inputEmpty"),
              type: "warning",
              duration: 2e3
            });
            return;
          }
          login(username.value, pwd.value);
        };
        const login = (username2, pwd2) => {
          username2 = CryptoJS.SHA256(username2).toString();
          pwd2 = CryptoJS.SHA256(pwd2).toString();
          request.post(`/config/login`, {
            username: username2,
            pwd: pwd2
          }).then((resp) => {
            ElNotification({
              title: "\u767B\u5F55\u6210\u529F",
              message: "",
              type: "success"
            });
            emits("loginSuccess");
          }).catch((e) => {
          }).finally(() => {
          });
        };
        return (_ctx, _cache) => {
          const _component_el_input = ElInput;
          const _component_el_button = ElButton;
          return openBlock(), createElementBlock("div", null, [
            createBaseVNode("div", _hoisted_1, [
              createBaseVNode("div", _hoisted_2, [
                _hoisted_3,
                createBaseVNode("div", _hoisted_4, [
                  createVNode(_component_el_input, {
                    class: "input-item",
                    modelValue: username.value,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => username.value = $event),
                    placeholder: "USERNAME"
                  }, null, 8, ["modelValue"]),
                  createVNode(_component_el_input, {
                    class: "input-item",
                    type: "password",
                    modelValue: pwd.value,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => pwd.value = $event),
                    placeholder: "PASSWORD",
                    onKeydown: withKeys(loginHandler, ["enter"])
                  }, null, 8, ["modelValue", "onKeydown"]),
                  createVNode(_component_el_button, {
                    type: "primary",
                    class: "btn",
                    onClick: loginHandler
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString$1(unref(t)("button.login")), 1)
                    ]),
                    _: 1
                  })
                ]),
                _hoisted_5
              ])
            ])
          ]);
        };
      }
    };
    const elSwitch = "";
    /*! Element Plus v2.2.16 */
    var zhCn = {
      name: "zh-cn",
      el: {
        colorpicker: {
          confirm: "\u786E\u5B9A",
          clear: "\u6E05\u7A7A"
        },
        datepicker: {
          now: "\u6B64\u523B",
          today: "\u4ECA\u5929",
          cancel: "\u53D6\u6D88",
          clear: "\u6E05\u7A7A",
          confirm: "\u786E\u5B9A",
          selectDate: "\u9009\u62E9\u65E5\u671F",
          selectTime: "\u9009\u62E9\u65F6\u95F4",
          startDate: "\u5F00\u59CB\u65E5\u671F",
          startTime: "\u5F00\u59CB\u65F6\u95F4",
          endDate: "\u7ED3\u675F\u65E5\u671F",
          endTime: "\u7ED3\u675F\u65F6\u95F4",
          prevYear: "\u524D\u4E00\u5E74",
          nextYear: "\u540E\u4E00\u5E74",
          prevMonth: "\u4E0A\u4E2A\u6708",
          nextMonth: "\u4E0B\u4E2A\u6708",
          year: "\u5E74",
          month1: "1 \u6708",
          month2: "2 \u6708",
          month3: "3 \u6708",
          month4: "4 \u6708",
          month5: "5 \u6708",
          month6: "6 \u6708",
          month7: "7 \u6708",
          month8: "8 \u6708",
          month9: "9 \u6708",
          month10: "10 \u6708",
          month11: "11 \u6708",
          month12: "12 \u6708",
          weeks: {
            sun: "\u65E5",
            mon: "\u4E00",
            tue: "\u4E8C",
            wed: "\u4E09",
            thu: "\u56DB",
            fri: "\u4E94",
            sat: "\u516D"
          },
          months: {
            jan: "\u4E00\u6708",
            feb: "\u4E8C\u6708",
            mar: "\u4E09\u6708",
            apr: "\u56DB\u6708",
            may: "\u4E94\u6708",
            jun: "\u516D\u6708",
            jul: "\u4E03\u6708",
            aug: "\u516B\u6708",
            sep: "\u4E5D\u6708",
            oct: "\u5341\u6708",
            nov: "\u5341\u4E00\u6708",
            dec: "\u5341\u4E8C\u6708"
          }
        },
        select: {
          loading: "\u52A0\u8F7D\u4E2D",
          noMatch: "\u65E0\u5339\u914D\u6570\u636E",
          noData: "\u65E0\u6570\u636E",
          placeholder: "\u8BF7\u9009\u62E9"
        },
        cascader: {
          noMatch: "\u65E0\u5339\u914D\u6570\u636E",
          loading: "\u52A0\u8F7D\u4E2D",
          placeholder: "\u8BF7\u9009\u62E9",
          noData: "\u6682\u65E0\u6570\u636E"
        },
        pagination: {
          goto: "\u524D\u5F80",
          pagesize: "\u6761/\u9875",
          total: "\u5171 {total} \u6761",
          pageClassifier: "\u9875",
          deprecationWarning: "\u4F60\u4F7F\u7528\u4E86\u4E00\u4E9B\u5DF2\u88AB\u5E9F\u5F03\u7684\u7528\u6CD5\uFF0C\u8BF7\u53C2\u8003 el-pagination \u7684\u5B98\u65B9\u6587\u6863"
        },
        messagebox: {
          title: "\u63D0\u793A",
          confirm: "\u786E\u5B9A",
          cancel: "\u53D6\u6D88",
          error: "\u8F93\u5165\u7684\u6570\u636E\u4E0D\u5408\u6CD5!"
        },
        upload: {
          deleteTip: "\u6309 delete \u952E\u53EF\u5220\u9664",
          delete: "\u5220\u9664",
          preview: "\u67E5\u770B\u56FE\u7247",
          continue: "\u7EE7\u7EED\u4E0A\u4F20"
        },
        table: {
          emptyText: "\u6682\u65E0\u6570\u636E",
          confirmFilter: "\u7B5B\u9009",
          resetFilter: "\u91CD\u7F6E",
          clearFilter: "\u5168\u90E8",
          sumText: "\u5408\u8BA1"
        },
        tree: {
          emptyText: "\u6682\u65E0\u6570\u636E"
        },
        transfer: {
          noMatch: "\u65E0\u5339\u914D\u6570\u636E",
          noData: "\u65E0\u6570\u636E",
          titles: ["\u5217\u8868 1", "\u5217\u8868 2"],
          filterPlaceholder: "\u8BF7\u8F93\u5165\u641C\u7D22\u5185\u5BB9",
          noCheckedFormat: "\u5171 {total} \u9879",
          hasCheckedFormat: "\u5DF2\u9009 {checked}/{total} \u9879"
        },
        image: {
          error: "\u52A0\u8F7D\u5931\u8D25"
        },
        pageHeader: {
          title: "\u8FD4\u56DE"
        },
        popconfirm: {
          confirmButtonText: "\u786E\u5B9A",
          cancelButtonText: "\u53D6\u6D88"
        }
      }
    };
    /*! Element Plus v2.2.16 */
    var en = {
      name: "en",
      el: {
        colorpicker: {
          confirm: "OK",
          clear: "Clear",
          defaultLabel: "color picker",
          description: "current color is {color}. press enter to select a new color."
        },
        datepicker: {
          now: "Now",
          today: "Today",
          cancel: "Cancel",
          clear: "Clear",
          confirm: "OK",
          dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
          monthTablePrompt: "Use the arrow keys and enter to select the month",
          yearTablePrompt: "Use the arrow keys and enter to select the year",
          selectedDate: "Selected date",
          selectDate: "Select date",
          selectTime: "Select time",
          startDate: "Start Date",
          startTime: "Start Time",
          endDate: "End Date",
          endTime: "End Time",
          prevYear: "Previous Year",
          nextYear: "Next Year",
          prevMonth: "Previous Month",
          nextMonth: "Next Month",
          year: "",
          month1: "January",
          month2: "February",
          month3: "March",
          month4: "April",
          month5: "May",
          month6: "June",
          month7: "July",
          month8: "August",
          month9: "September",
          month10: "October",
          month11: "November",
          month12: "December",
          week: "week",
          weeks: {
            sun: "Sun",
            mon: "Mon",
            tue: "Tue",
            wed: "Wed",
            thu: "Thu",
            fri: "Fri",
            sat: "Sat"
          },
          weeksFull: {
            sun: "Sunday",
            mon: "Monday",
            tue: "Tuesday",
            wed: "Wednesday",
            thu: "Thursday",
            fri: "Friday",
            sat: "Saturday"
          },
          months: {
            jan: "Jan",
            feb: "Feb",
            mar: "Mar",
            apr: "Apr",
            may: "May",
            jun: "Jun",
            jul: "Jul",
            aug: "Aug",
            sep: "Sep",
            oct: "Oct",
            nov: "Nov",
            dec: "Dec"
          }
        },
        inputNumber: {
          decrease: "decrease number",
          increase: "increase number"
        },
        select: {
          loading: "Loading",
          noMatch: "No matching data",
          noData: "No data",
          placeholder: "Select"
        },
        dropdown: {
          toggleDropdown: "Toggle Dropdown"
        },
        cascader: {
          noMatch: "No matching data",
          loading: "Loading",
          placeholder: "Select",
          noData: "No data"
        },
        pagination: {
          goto: "Go to",
          pagesize: "/page",
          total: "Total {total}",
          pageClassifier: "",
          deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
        },
        dialog: {
          close: "Close this dialog"
        },
        drawer: {
          close: "Close this dialog"
        },
        messagebox: {
          title: "Message",
          confirm: "OK",
          cancel: "Cancel",
          error: "Illegal input",
          close: "Close this dialog"
        },
        upload: {
          deleteTip: "press delete to remove",
          delete: "Delete",
          preview: "Preview",
          continue: "Continue"
        },
        slider: {
          defaultLabel: "slider between {min} and {max}",
          defaultRangeStartLabel: "pick start value",
          defaultRangeEndLabel: "pick end value"
        },
        table: {
          emptyText: "No Data",
          confirmFilter: "Confirm",
          resetFilter: "Reset",
          clearFilter: "All",
          sumText: "Sum"
        },
        tree: {
          emptyText: "No Data"
        },
        transfer: {
          noMatch: "No matching data",
          noData: "No data",
          titles: ["List 1", "List 2"],
          filterPlaceholder: "Enter keyword",
          noCheckedFormat: "{total} items",
          hasCheckedFormat: "{checked}/{total} checked"
        },
        image: {
          error: "FAILED"
        },
        pageHeader: {
          title: "Back"
        },
        popconfirm: {
          confirmButtonText: "Yes",
          cancelButtonText: "No"
        }
      }
    };
    const _sfc_main = {
      __name: "App",
      setup(__props) {
        const getCookie = (cookieName) => {
          const cookies2 = document.cookie.split("; ");
          for (let i = 0; i < cookies2.length; i++) {
            const [name, value] = cookies2[i].split("=");
            if (name === cookieName) {
              return decodeURIComponent(value);
            }
          }
          return "";
        };
        const loginActive = !!getCookie("JSESSIONID") ? ref(true) : ref(false);
        const { locale } = useI18n({ useScope: "global" });
        locale.value = localStorage.getItem("locale") || "zh_CN";
        const elLocale = computed(() => locale.value === "zh_CN" ? zhCn : en);
        const langSwitch = ref(locale.value === "zh_CN");
        const handleChangeI18n = (val) => {
          locale.value = val ? "zh_CN" : "en_US";
          localStorage.setItem("locale", locale.value);
        };
        return (_ctx, _cache) => {
          const _component_el_switch = ElSwitch;
          const _component_new_login = _sfc_main$1;
          const _component_config_list = _sfc_main$2;
          const _component_el_config_provider = ElConfigProvider;
          return openBlock(), createElementBlock("div", null, [
            createVNode(_component_el_config_provider, { locale: unref(elLocale) }, {
              default: withCtx(() => [
                createVNode(_component_el_switch, {
                  modelValue: langSwitch.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => langSwitch.value = $event),
                  style: { "position": "absolute", "right": "200px", "top": "10px", "--el-switch-on-color": "#13ce66", "--el-switch-off-color": "#ff4949" },
                  "inline-prompt": "",
                  "active-text": "Zh",
                  "inactive-text": "En",
                  onChange: handleChangeI18n
                }, null, 8, ["modelValue"]),
                !unref(loginActive) ? (openBlock(), createBlock(_component_new_login, {
                  key: 0,
                  onLoginSuccess: _cache[1] || (_cache[1] = ($event) => loginActive.value = true)
                })) : createCommentVNode("", true),
                unref(loginActive) ? (openBlock(), createBlock(_component_config_list, {
                  key: 1,
                  onLoginPast: _cache[2] || (_cache[2] = ($event) => loginActive.value = false)
                })) : createCommentVNode("", true)
              ]),
              _: 1
            }, 8, ["locale"])
          ]);
        };
      }
    };
    const zh_CN = {
      title: {
        login: "\u767B\u5F55"
      },
      button: {
        login: "\u767B\u5F55",
        logout: "\u9000\u51FA\u767B\u5F55",
        isLogged: "\u5DF2\u767B\u5F55",
        submit: "\u63D0\u4EA4",
        reset: "\u91CD\u7F6E",
        openDrawer: "\u6253\u5F00\u62BD\u5C49"
      },
      login: {
        errorTitle: "\u767B\u5F55\u5931\u8D25",
        inputEmpty: "\u8D26\u53F7\u5BC6\u7801\u4E0D\u80FD\u4E3A\u7A7A"
      },
      config: {
        viewTitle: "\u67E5\u770B",
        editViewTitle: "\u4FEE\u6539\u914D\u7F6E",
        addViewTitle: "\u6DFB\u52A0\u914D\u7F6E",
        notDurable: "\u672A\u6301\u4E45\u5316",
        releaseConfig: "\u53D1\u5E03\u914D\u7F6E",
        addConfig: "\u65B0\u589E\u914D\u7F6E",
        exportConfig: "\u5BFC\u51FA\u914D\u7F6E",
        exportTitle: "\u5BFC\u51FA\u914D\u7F6E",
        releaseSuccessTitle: "\u914D\u7F6E\u53D1\u5E03\u6210\u529F",
        row: {
          key: "Key",
          value: "Value",
          desc: "\u5907\u6CE8",
          status: "\u53D1\u5E03\u72B6\u6001",
          durable: "\u6301\u4E45\u5316",
          createDate: "\u521B\u5EFA\u65F6\u95F4",
          updateDate: "\u66F4\u65B0\u65F6\u95F4",
          opt: "\u64CD\u4F5C"
        }
      },
      common: {
        confirm: "\u786E\u5B9A",
        cancel: "\u53D6\u6D88"
      }
    };
    const en_US = {
      title: {
        login: "Login"
      },
      button: {
        login: "Login",
        logout: "Logout",
        isLogged: "Logged",
        submit: "Submit",
        reset: "Reset",
        openDrawer: "Open Drawer"
      },
      login: {
        errorTitle: "Login failed",
        inputEmpty: "Account password cannot be empty"
      },
      config: {
        viewTitle: "View",
        editViewTitle: "Change configuration",
        addViewTitle: "Add configuration",
        notDurable: "Not durable",
        releaseConfig: "Release Config",
        addConfig: "Add Config",
        exportConfig: "Export config",
        exportTitle: "Export config",
        releaseSuccessTitle: "Configuration released successfully",
        row: {
          key: "Key",
          value: "Value",
          desc: "comment",
          status: "Release status",
          durable: "Durable",
          createDate: "Creation time",
          updateDate: "Update time",
          opt: "operate"
        }
      },
      common: {
        confirm: "Confirm",
        cancel: "Cancel"
      }
    };
    const i18n = createI18n({
      legacy: false,
      locale: "zh_CN",
      messages: {
        zh_CN,
        en_US
      }
    });
    const app = createApp(_sfc_main);
    app.config.globalProperties["$axios"] = request;
    app.use(installer, {
      locale: localStorage.getItem("locale") === "zh_CN" ? zhCn : en
    });
    app.use(i18n);
    app.mount("#app");
  }
});
export default require_index_9657b14c();
</script>
  <style rel="stylesheet">:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:'Helvetica Neue',Helvetica,'PingFang SC','Hiragino Sans GB','Microsoft YaHei','微软雅黑',Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:0.3s;--el-transition-duration-fast:0.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(0.645, 0.045, 0.355, 1);--el-transition-function-fast-bezier:cubic-bezier(0.23, 1, 0.32, 1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0, 0, 0, 0.04),0px 8px 20px rgba(0, 0, 0, 0.08);--el-box-shadow-light:0px 0px 12px rgba(0, 0, 0, 0.12);--el-box-shadow-lighter:0px 0px 6px rgba(0, 0, 0, 0.12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0, 0, 0, 0.08),0px 12px 32px rgba(0, 0, 0, 0.12),0px 8px 16px -8px rgba(0, 0, 0, 0.16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0, 0, 0, 0.8);--el-overlay-color-light:rgba(0, 0, 0, 0.7);--el-overlay-color-lighter:rgba(0, 0, 0, 0.5);--el-mask-color:rgba(255, 255, 255, 0.9);--el-mask-color-extra-light:rgba(255, 255, 255, 0.3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center top}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center bottom}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1,1);transition:var(--el-transition-md-fade);transform-origin:top left}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45,.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-icon-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@-webkit-keyframes rotating{0%{transform:rotateZ(0)}100%{transform:rotateZ(360deg)}}@keyframes rotating{0%{transform:rotateZ(0)}100%{transform:rotateZ(360deg)}}.el-icon{--color:inherit;height:1em;width:1em;line-height:1em;display:inline-flex;justify-content:center;align-items:center;position:relative;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.el-affix--fixed{position:fixed}.el-alert{--el-alert-padding:8px 16px;--el-alert-border-radius-base:var(--el-border-radius-base);--el-alert-title-font-size:13px;--el-alert-description-font-size:12px;--el-alert-close-font-size:12px;--el-alert-close-customed-font-size:13px;--el-alert-icon-size:16px;--el-alert-icon-large-size:28px;width:100%;padding:var(--el-alert-padding);margin:0;box-sizing:border-box;border-radius:var(--el-alert-border-radius-base);position:relative;background-color:var(--el-color-white);overflow:hidden;opacity:1;display:flex;align-items:center;transition:opacity var(--el-transition-duration-fast)}.el-alert.is-light .el-alert__close-btn{color:var(--el-text-color-placeholder)}.el-alert.is-dark .el-alert__close-btn{color:var(--el-color-white)}.el-alert.is-dark .el-alert__description{color:var(--el-color-white)}.el-alert.is-center{justify-content:center}.el-alert--success{--el-alert-bg-color:var(--el-color-success-light-9)}.el-alert--success.is-light{background-color:var(--el-alert-bg-color);color:var(--el-color-success)}.el-alert--success.is-light .el-alert__description{color:var(--el-color-success)}.el-alert--success.is-dark{background-color:var(--el-color-success);color:var(--el-color-white)}.el-alert--info{--el-alert-bg-color:var(--el-color-info-light-9)}.el-alert--info.is-light{background-color:var(--el-alert-bg-color);color:var(--el-color-info)}.el-alert--info.is-light .el-alert__description{color:var(--el-color-info)}.el-alert--info.is-dark{background-color:var(--el-color-info);color:var(--el-color-white)}.el-alert--warning{--el-alert-bg-color:var(--el-color-warning-light-9)}.el-alert--warning.is-light{background-color:var(--el-alert-bg-color);color:var(--el-color-warning)}.el-alert--warning.is-light .el-alert__description{color:var(--el-color-warning)}.el-alert--warning.is-dark{background-color:var(--el-color-warning);color:var(--el-color-white)}.el-alert--error{--el-alert-bg-color:var(--el-color-error-light-9)}.el-alert--error.is-light{background-color:var(--el-alert-bg-color);color:var(--el-color-error)}.el-alert--error.is-light .el-alert__description{color:var(--el-color-error)}.el-alert--error.is-dark{background-color:var(--el-color-error);color:var(--el-color-white)}.el-alert__content{display:table-cell;padding:0 8px}.el-alert .el-alert__icon{font-size:var(--el-alert-icon-size);width:var(--el-alert-icon-size)}.el-alert .el-alert__icon.is-big{font-size:var(--el-alert-icon-large-size);width:var(--el-alert-icon-large-size)}.el-alert__title{font-size:var(--el-alert-title-font-size);line-height:18px;vertical-align:text-top}.el-alert__title.is-bold{font-weight:700}.el-alert .el-alert__description{font-size:var(--el-alert-description-font-size);margin:5px 0 0 0}.el-alert .el-alert__close-btn{font-size:var(--el-alert-close-font-size);opacity:1;position:absolute;top:12px;right:15px;cursor:pointer}.el-alert .el-alert__close-btn.is-customed{font-style:normal;font-size:var(--el-alert-close-customed-font-size);top:9px}.el-alert-fade-enter-from,.el-alert-fade-leave-active{opacity:0}.el-aside{overflow:auto;box-sizing:border-box;flex-shrink:0;width:var(--el-aside-width,300px)}.el-autocomplete{position:relative;display:inline-block}.el-autocomplete__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-autocomplete__popper.el-popper .el-popper__arrow::before{border:1px solid var(--el-border-color-light)}.el-autocomplete__popper.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent;border-left-color:transparent}.el-autocomplete__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent;border-right-color:transparent}.el-autocomplete__popper.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent;border-bottom-color:transparent}.el-autocomplete__popper.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent;border-top-color:transparent}.el-autocomplete-suggestion{border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-autocomplete-suggestion__wrap{max-height:280px;padding:10px 0;box-sizing:border-box}.el-autocomplete-suggestion__list{margin:0;padding:0}.el-autocomplete-suggestion li{padding:0 20px;margin:0;line-height:34px;cursor:pointer;color:var(--el-text-color-regular);font-size:var(--el-font-size-base);list-style:none;text-align:left;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.el-autocomplete-suggestion li:hover{background-color:var(--el-fill-color-light)}.el-autocomplete-suggestion li.highlighted{background-color:var(--el-fill-color-light)}.el-autocomplete-suggestion li.divider{margin-top:6px;border-top:1px solid var(--el-color-black)}.el-autocomplete-suggestion li.divider:last-child{margin-bottom:-6px}.el-autocomplete-suggestion.is-loading li{text-align:center;height:100px;line-height:100px;font-size:20px;color:var(--el-text-color-secondary)}.el-autocomplete-suggestion.is-loading li::after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-autocomplete-suggestion.is-loading li:hover{background-color:var(--el-bg-color-overlay)}.el-autocomplete-suggestion.is-loading .el-icon-loading{vertical-align:middle}.el-avatar{--el-avatar-text-color:var(--el-color-white);--el-avatar-bg-color:var(--el-text-color-disabled);--el-avatar-text-size:14px;--el-avatar-icon-size:18px;--el-avatar-border-radius:var(--el-border-radius-base);--el-avatar-size-large:56px;--el-avatar-size:40px;--el-avatar-size-small:24px;--el-avatar-size:40px;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;text-align:center;overflow:hidden;color:var(--el-avatar-text-color);background:var(--el-avatar-bg-color);width:var(--el-avatar-size);height:var(--el-avatar-size);font-size:var(--el-avatar-text-size)}.el-avatar>img{display:block;height:100%}.el-avatar--circle{border-radius:50%}.el-avatar--square{border-radius:var(--el-avatar-border-radius)}.el-avatar--icon{font-size:var(--el-avatar-icon-size)}.el-avatar--small{--el-avatar-size:24px}.el-avatar--large{--el-avatar-size:56px}.el-backtop{--el-backtop-bg-color:var(--el-bg-color-overlay);--el-backtop-text-color:var(--el-color-primary);--el-backtop-hover-bg-color:var(--el-border-color-extra-light);position:fixed;background-color:var(--el-backtop-bg-color);width:40px;height:40px;border-radius:50%;color:var(--el-backtop-text-color);display:flex;align-items:center;justify-content:center;font-size:20px;box-shadow:var(--el-box-shadow-lighter);cursor:pointer;z-index:5}.el-backtop:hover{background-color:var(--el-backtop-hover-bg-color)}.el-backtop__icon{font-size:20px}.el-badge{--el-badge-bg-color:var(--el-color-danger);--el-badge-radius:10px;--el-badge-font-size:12px;--el-badge-padding:6px;--el-badge-size:18px;position:relative;vertical-align:middle;display:inline-block}.el-badge__content{background-color:var(--el-badge-bg-color);border-radius:var(--el-badge-radius);color:var(--el-color-white);display:inline-flex;justify-content:center;align-items:center;font-size:var(--el-badge-font-size);height:var(--el-badge-size);padding:0 var(--el-badge-padding);white-space:nowrap;border:1px solid var(--el-bg-color)}.el-badge__content.is-fixed{position:absolute;top:0;right:calc(1px + var(--el-badge-size)/ 2);transform:translateY(-50%) translateX(100%)}.el-badge__content.is-fixed.is-dot{right:5px}.el-badge__content.is-dot{height:8px;width:8px;padding:0;right:0;border-radius:50%}.el-badge__content--primary{background-color:var(--el-color-primary)}.el-badge__content--success{background-color:var(--el-color-success)}.el-badge__content--warning{background-color:var(--el-color-warning)}.el-badge__content--info{background-color:var(--el-color-info)}.el-badge__content--danger{background-color:var(--el-color-danger)}.el-breadcrumb{font-size:14px;line-height:1}.el-breadcrumb::after,.el-breadcrumb::before{display:table;content:""}.el-breadcrumb::after{clear:both}.el-breadcrumb__separator{margin:0 9px;font-weight:700;color:var(--el-text-color-placeholder)}.el-breadcrumb__separator.el-icon{margin:0 6px;font-weight:400}.el-breadcrumb__separator.el-icon svg{vertical-align:middle}.el-breadcrumb__item{float:left;display:flex;align-items:center}.el-breadcrumb__inner{color:var(--el-text-color-regular)}.el-breadcrumb__inner a,.el-breadcrumb__inner.is-link{font-weight:700;text-decoration:none;transition:var(--el-transition-color);color:var(--el-text-color-primary)}.el-breadcrumb__inner a:hover,.el-breadcrumb__inner.is-link:hover{color:var(--el-color-primary);cursor:pointer}.el-breadcrumb__item:last-child .el-breadcrumb__inner,.el-breadcrumb__item:last-child .el-breadcrumb__inner a,.el-breadcrumb__item:last-child .el-breadcrumb__inner a:hover,.el-breadcrumb__item:last-child .el-breadcrumb__inner:hover{font-weight:400;color:var(--el-text-color-regular);cursor:text}.el-breadcrumb__item:last-child .el-breadcrumb__separator{display:none}.el-button-group{display:inline-block;vertical-align:middle}.el-button-group::after,.el-button-group::before{display:table;content:""}.el-button-group::after{clear:both}.el-button-group>.el-button{float:left;position:relative}.el-button-group>.el-button+.el-button{margin-left:0}.el-button-group>.el-button:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.el-button-group>.el-button:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.el-button-group>.el-button:first-child:last-child{border-top-right-radius:var(--el-border-radius-base);border-bottom-right-radius:var(--el-border-radius-base);border-top-left-radius:var(--el-border-radius-base);border-bottom-left-radius:var(--el-border-radius-base)}.el-button-group>.el-button:first-child:last-child.is-round{border-radius:var(--el-border-radius-round)}.el-button-group>.el-button:first-child:last-child.is-circle{border-radius:50%}.el-button-group>.el-button:not(:first-child):not(:last-child){border-radius:0}.el-button-group>.el-button:not(:last-child){margin-right:-1px}.el-button-group>.el-button:active,.el-button-group>.el-button:focus,.el-button-group>.el-button:hover{z-index:1}.el-button-group>.el-button.is-active{z-index:1}.el-button-group>.el-dropdown>.el-button{border-top-left-radius:0;border-bottom-left-radius:0;border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255, 255, 255, 0.5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-color-info);--el-button-active-color:var(--el-text-color-primary)}.el-button{display:inline-flex;justify-content:center;align-items:center;line-height:1;height:32px;white-space:nowrap;cursor:pointer;color:var(--el-button-text-color);text-align:center;box-sizing:border-box;outline:0;transition:.1s;font-weight:var(--el-button-font-weight);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);padding:8px 15px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button:focus,.el-button:hover{color:var(--el-button-hover-text-color);border-color:var(--el-button-hover-border-color);background-color:var(--el-button-hover-bg-color);outline:0}.el-button:active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button>span{display:inline-flex;align-items:center}.el-button+.el-button{margin-left:12px}.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button.is-disabled,.el-button.is-disabled:focus,.el-button.is-disabled:hover{color:var(--el-button-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--el-button-disabled-bg-color);border-color:var(--el-button-disabled-border-color)}.el-button.is-loading{position:relative;pointer-events:none}.el-button.is-loading:before{z-index:1;pointer-events:none;content:"";position:absolute;left:-1px;top:-1px;right:-1px;bottom:-1px;border-radius:inherit;background-color:var(--el-mask-color-extra-light)}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px}.el-button.is-text{color:var(--el-button-text-color);border:0 solid transparent;background-color:transparent}.el-button.is-text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important}.el-button.is-text:not(.is-disabled):focus,.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:focus,.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{border-color:transparent;color:var(--el-button-text-color);background:0 0;padding:2px;height:auto}.el-button.is-link:focus,.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button.is-link:not(.is-disabled):focus,.el-button.is-link:not(.is-disabled):hover{border-color:transparent;background-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color);border-color:transparent;background-color:transparent}.el-button--text{border-color:transparent;background:0 0;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button--text:not(.is-disabled):focus,.el-button--text:not(.is-disabled):hover{color:var(--el-color-primary-light-3);border-color:transparent;background-color:transparent}.el-button--text:not(.is-disabled):active{color:var(--el-color-primary-dark-2);border-color:transparent;background-color:transparent}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{color:var(--el-color-primary-light-5);background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{color:var(--el-color-success-light-5);background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{color:var(--el-color-warning-light-5);background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{color:var(--el-color-danger-light-5);background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{color:var(--el-color-info-light-5);background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8)}.el-button--large{--el-button-size:40px;height:var(--el-button-size);padding:12px 19px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{width:var(--el-button-size);padding:12px}.el-button--small{--el-button-size:24px;height:var(--el-button-size);padding:5px 11px;font-size:12px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{width:var(--el-button-size);padding:5px}.el-calendar{--el-calendar-border:var(--el-table-border, 1px solid var(--el-border-color-lighter));--el-calendar-header-border-bottom:var(--el-calendar-border);--el-calendar-selected-bg-color:var(--el-color-primary-light-9);--el-calendar-cell-width:85px;background-color:var(--el-fill-color-blank)}.el-calendar__header{display:flex;justify-content:space-between;padding:12px 20px;border-bottom:var(--el-calendar-header-border-bottom)}.el-calendar__title{color:var(--el-text-color);align-self:center}.el-calendar__body{padding:12px 20px 35px}.el-calendar-table{table-layout:fixed;width:100%}.el-calendar-table thead th{padding:12px 0;color:var(--el-text-color-regular);font-weight:400}.el-calendar-table:not(.is-range) td.next,.el-calendar-table:not(.is-range) td.prev{color:var(--el-text-color-placeholder)}.el-calendar-table td{border-bottom:var(--el-calendar-border);border-right:var(--el-calendar-border);vertical-align:top;transition:background-color var(--el-transition-duration-fast) ease}.el-calendar-table td.is-selected{background-color:var(--el-calendar-selected-bg-color)}.el-calendar-table td.is-today{color:var(--el-color-primary)}.el-calendar-table tr:first-child td{border-top:var(--el-calendar-border)}.el-calendar-table tr td:first-child{border-left:var(--el-calendar-border)}.el-calendar-table tr.el-calendar-table__row--hide-border td{border-top:none}.el-calendar-table .el-calendar-day{box-sizing:border-box;padding:8px;height:var(--el-calendar-cell-width)}.el-calendar-table .el-calendar-day:hover{cursor:pointer;background-color:var(--el-calendar-selected-bg-color)}.el-card{--el-card-border-color:var(--el-border-color-light);--el-card-border-radius:4px;--el-card-padding:20px;--el-card-bg-color:var(--el-fill-color-blank)}.el-card{border-radius:var(--el-card-border-radius);border:1px solid var(--el-card-border-color);background-color:var(--el-card-bg-color);overflow:hidden;color:var(--el-text-color-primary);transition:var(--el-transition-duration)}.el-card.is-always-shadow{box-shadow:var(--el-box-shadow-light)}.el-card.is-hover-shadow:focus,.el-card.is-hover-shadow:hover{box-shadow:var(--el-box-shadow-light)}.el-card__header{padding:calc(var(--el-card-padding) - 2px) var(--el-card-padding);border-bottom:1px solid var(--el-card-border-color);box-sizing:border-box}.el-card__body{padding:var(--el-card-padding)}.el-carousel__item{position:absolute;top:0;left:0;width:100%;height:100%;display:inline-block;overflow:hidden;z-index:calc(var(--el-index-normal) - 1)}.el-carousel__item.is-active{z-index:calc(var(--el-index-normal) - 1)}.el-carousel__item.is-animating{transition:transform .4s ease-in-out}.el-carousel__item--card{width:50%;transition:transform .4s ease-in-out}.el-carousel__item--card.is-in-stage{cursor:pointer;z-index:var(--el-index-normal)}.el-carousel__item--card.is-in-stage.is-hover .el-carousel__mask,.el-carousel__item--card.is-in-stage:hover .el-carousel__mask{opacity:.12}.el-carousel__item--card.is-active{z-index:calc(var(--el-index-normal) + 1)}.el-carousel__mask{position:absolute;width:100%;height:100%;top:0;left:0;background-color:var(--el-color-white);opacity:.24;transition:var(--el-transition-duration-fast)}.el-carousel{--el-carousel-arrow-font-size:12px;--el-carousel-arrow-size:36px;--el-carousel-arrow-background:rgba(31, 45, 61, 0.11);--el-carousel-arrow-hover-background:rgba(31, 45, 61, 0.23);--el-carousel-indicator-width:30px;--el-carousel-indicator-height:2px;--el-carousel-indicator-padding-horizontal:4px;--el-carousel-indicator-padding-vertical:12px;--el-carousel-indicator-out-color:var(--el-border-color-hover);position:relative}.el-carousel--horizontal{overflow-x:hidden}.el-carousel--vertical{overflow-y:hidden}.el-carousel__container{position:relative;height:300px}.el-carousel__arrow{border:none;outline:0;padding:0;margin:0;height:var(--el-carousel-arrow-size);width:var(--el-carousel-arrow-size);cursor:pointer;transition:var(--el-transition-duration);border-radius:50%;background-color:var(--el-carousel-arrow-background);color:#fff;position:absolute;top:50%;z-index:10;transform:translateY(-50%);text-align:center;font-size:var(--el-carousel-arrow-font-size);display:inline-flex;justify-content:center;align-items:center}.el-carousel__arrow--left{left:16px}.el-carousel__arrow--right{right:16px}.el-carousel__arrow:hover{background-color:var(--el-carousel-arrow-hover-background)}.el-carousel__arrow i{cursor:pointer}.el-carousel__indicators{position:absolute;list-style:none;margin:0;padding:0;z-index:calc(var(--el-index-normal) + 1)}.el-carousel__indicators--horizontal{bottom:0;left:50%;transform:translateX(-50%)}.el-carousel__indicators--vertical{right:0;top:50%;transform:translateY(-50%)}.el-carousel__indicators--outside{bottom:calc(var(--el-carousel-indicator-height) + var(--el-carousel-indicator-padding-vertical) * 2);text-align:center;position:static;transform:none}.el-carousel__indicators--outside .el-carousel__indicator:hover button{opacity:.64}.el-carousel__indicators--outside button{background-color:var(--el-carousel-indicator-out-color);opacity:.24}.el-carousel__indicators--labels{left:0;right:0;transform:none;text-align:center}.el-carousel__indicators--labels .el-carousel__button{height:auto;width:auto;padding:2px 18px;font-size:12px}.el-carousel__indicators--labels .el-carousel__indicator{padding:6px 4px}.el-carousel__indicator{background-color:transparent;cursor:pointer}.el-carousel__indicator:hover button{opacity:.72}.el-carousel__indicator--horizontal{display:inline-block;padding:var(--el-carousel-indicator-padding-vertical) var(--el-carousel-indicator-padding-horizontal)}.el-carousel__indicator--vertical{padding:var(--el-carousel-indicator-padding-horizontal) var(--el-carousel-indicator-padding-vertical)}.el-carousel__indicator--vertical .el-carousel__button{width:var(--el-carousel-indicator-height);height:calc(var(--el-carousel-indicator-width)/ 2)}.el-carousel__indicator.is-active button{opacity:1}.el-carousel__button{display:block;opacity:.48;width:var(--el-carousel-indicator-width);height:var(--el-carousel-indicator-height);background-color:#fff;border:none;outline:0;padding:0;margin:0;cursor:pointer;transition:var(--el-transition-duration)}.carousel-arrow-left-enter-from,.carousel-arrow-left-leave-active{transform:translateY(-50%) translateX(-10px);opacity:0}.carousel-arrow-right-enter-from,.carousel-arrow-right-leave-active{transform:translateY(-50%) translateX(10px);opacity:0}.el-cascader-panel{--el-cascader-menu-text-color:var(--el-text-color-regular);--el-cascader-menu-selected-text-color:var(--el-color-primary);--el-cascader-menu-fill:var(--el-bg-color-overlay);--el-cascader-menu-font-size:var(--el-font-size-base);--el-cascader-menu-radius:var(--el-border-radius-base);--el-cascader-menu-border:solid 1px var(--el-border-color-light);--el-cascader-menu-shadow:var(--el-box-shadow-light);--el-cascader-node-background-hover:var(--el-fill-color-light);--el-cascader-node-color-disabled:var(--el-text-color-placeholder);--el-cascader-color-empty:var(--el-text-color-placeholder);--el-cascader-tag-background:var(--el-fill-color)}.el-cascader-panel{display:flex;border-radius:var(--el-cascader-menu-radius);font-size:var(--el-cascader-menu-font-size)}.el-cascader-panel.is-bordered{border:var(--el-cascader-menu-border);border-radius:var(--el-cascader-menu-radius)}.el-cascader-menu{min-width:180px;box-sizing:border-box;color:var(--el-cascader-menu-text-color);border-right:var(--el-cascader-menu-border)}.el-cascader-menu:last-child{border-right:none}.el-cascader-menu:last-child .el-cascader-node{padding-right:20px}.el-cascader-menu__wrap.el-scrollbar__wrap{height:204px}.el-cascader-menu__list{position:relative;min-height:100%;margin:0;padding:6px 0;list-style:none;box-sizing:border-box}.el-cascader-menu__hover-zone{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}.el-cascader-menu__empty-text{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);display:flex;align-items:center;color:var(--el-cascader-color-empty)}.el-cascader-menu__empty-text .is-loading{margin-right:2px}.el-cascader-node{position:relative;display:flex;align-items:center;padding:0 30px 0 20px;height:34px;line-height:34px;outline:0}.el-cascader-node.is-selectable.in-active-path{color:var(--el-cascader-menu-text-color)}.el-cascader-node.in-active-path,.el-cascader-node.is-active,.el-cascader-node.is-selectable.in-checked-path{color:var(--el-cascader-menu-selected-text-color);font-weight:700}.el-cascader-node:not(.is-disabled){cursor:pointer}.el-cascader-node:not(.is-disabled):focus,.el-cascader-node:not(.is-disabled):hover{background:var(--el-cascader-node-background-hover)}.el-cascader-node.is-disabled{color:var(--el-cascader-node-color-disabled);cursor:not-allowed}.el-cascader-node__prefix{position:absolute;left:10px}.el-cascader-node__postfix{position:absolute;right:10px}.el-cascader-node__label{flex:1;text-align:left;padding:0 8px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.el-cascader-node>.el-radio{margin-right:0}.el-cascader-node>.el-radio .el-radio__label{padding-left:0}.el-cascader{--el-cascader-menu-text-color:var(--el-text-color-regular);--el-cascader-menu-selected-text-color:var(--el-color-primary);--el-cascader-menu-fill:var(--el-bg-color-overlay);--el-cascader-menu-font-size:var(--el-font-size-base);--el-cascader-menu-radius:var(--el-border-radius-base);--el-cascader-menu-border:solid 1px var(--el-border-color-light);--el-cascader-menu-shadow:var(--el-box-shadow-light);--el-cascader-node-background-hover:var(--el-fill-color-light);--el-cascader-node-color-disabled:var(--el-text-color-placeholder);--el-cascader-color-empty:var(--el-text-color-placeholder);--el-cascader-tag-background:var(--el-fill-color);display:inline-block;position:relative;font-size:var(--el-font-size-base);line-height:32px;outline:0}.el-cascader:not(.is-disabled):hover .el-input__wrapper{cursor:pointer;box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-cascader .el-input{cursor:pointer}.el-cascader .el-input .el-input__inner{text-overflow:ellipsis;cursor:pointer}.el-cascader .el-input .el-input__inner::-moz-selection{outline:0}.el-cascader .el-input .el-input__inner::selection{outline:0}.el-cascader .el-input .el-input__suffix-inner .el-icon{height:calc(100% - 2px)}.el-cascader .el-input .el-input__suffix-inner .el-icon svg{vertical-align:middle}.el-cascader .el-input .icon-arrow-down{transition:transform var(--el-transition-duration);font-size:14px}.el-cascader .el-input .icon-arrow-down.is-reverse{transform:rotateZ(180deg)}.el-cascader .el-input .icon-circle-close:hover{color:var(--el-input-clear-hover-color,var(--el-text-color-secondary))}.el-cascader .el-input.is-focus .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-cascader--large{font-size:14px;line-height:40px}.el-cascader--small{font-size:12px;line-height:24px}.el-cascader.is-disabled .el-cascader__label{z-index:calc(var(--el-index-normal) + 1);color:var(--el-disabled-text-color)}.el-cascader__dropdown{--el-cascader-menu-text-color:var(--el-text-color-regular);--el-cascader-menu-selected-text-color:var(--el-color-primary);--el-cascader-menu-fill:var(--el-bg-color-overlay);--el-cascader-menu-font-size:var(--el-font-size-base);--el-cascader-menu-radius:var(--el-border-radius-base);--el-cascader-menu-border:solid 1px var(--el-border-color-light);--el-cascader-menu-shadow:var(--el-box-shadow-light);--el-cascader-node-background-hover:var(--el-fill-color-light);--el-cascader-node-color-disabled:var(--el-text-color-placeholder);--el-cascader-color-empty:var(--el-text-color-placeholder);--el-cascader-tag-background:var(--el-fill-color)}.el-cascader__dropdown{font-size:var(--el-cascader-menu-font-size);border-radius:var(--el-cascader-menu-radius)}.el-cascader__dropdown.el-popper{background:var(--el-cascader-menu-fill);border:var(--el-cascader-menu-border);box-shadow:var(--el-cascader-menu-shadow)}.el-cascader__dropdown.el-popper .el-popper__arrow::before{border:var(--el-cascader-menu-border)}.el-cascader__dropdown.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent;border-left-color:transparent}.el-cascader__dropdown.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent;border-right-color:transparent}.el-cascader__dropdown.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent;border-bottom-color:transparent}.el-cascader__dropdown.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent;border-top-color:transparent}.el-cascader__dropdown.el-popper{box-shadow:var(--el-cascader-menu-shadow)}.el-cascader__tags{position:absolute;left:0;right:30px;top:50%;transform:translateY(-50%);display:flex;flex-wrap:wrap;line-height:normal;text-align:left;box-sizing:border-box}.el-cascader__tags .el-tag{display:inline-flex;align-items:center;max-width:100%;margin:2px 0 2px 6px;text-overflow:ellipsis;background:var(--el-cascader-tag-background)}.el-cascader__tags .el-tag:not(.is-hit){border-color:transparent}.el-cascader__tags .el-tag>span{flex:1;overflow:hidden;text-overflow:ellipsis}.el-cascader__tags .el-tag .el-icon-close{flex:none;background-color:var(--el-text-color-placeholder);color:var(--el-color-white)}.el-cascader__tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-cascader__collapse-tags{white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap}.el-cascader__collapse-tag{line-height:inherit;height:inherit;display:flex}.el-cascader__suggestion-panel{border-radius:var(--el-cascader-menu-radius)}.el-cascader__suggestion-list{max-height:204px;margin:0;padding:6px 0;font-size:var(--el-font-size-base);color:var(--el-cascader-menu-text-color);text-align:center}.el-cascader__suggestion-item{display:flex;justify-content:space-between;align-items:center;height:34px;padding:0 15px;text-align:left;outline:0;cursor:pointer}.el-cascader__suggestion-item:focus,.el-cascader__suggestion-item:hover{background:var(--el-cascader-node-background-hover)}.el-cascader__suggestion-item.is-checked{color:var(--el-cascader-menu-selected-text-color);font-weight:700}.el-cascader__suggestion-item>span{margin-right:10px}.el-cascader__empty-text{margin:10px 0;color:var(--el-cascader-color-empty)}.el-cascader__search-input{flex:1;height:24px;min-width:60px;margin:2px 0 2px 11px;padding:0;color:var(--el-cascader-menu-text-color);border:none;outline:0;box-sizing:border-box;background:0 0}.el-cascader__search-input::-moz-placeholder{color:transparent}.el-cascader__search-input:-ms-input-placeholder{color:transparent}.el-cascader__search-input::placeholder{color:transparent}.el-check-tag{background-color:var(--el-color-info-light-9);border-radius:var(--el-border-radius-base);color:var(--el-color-info);cursor:pointer;display:inline-block;font-size:var(--el-font-size-base);line-height:var(--el-font-size-base);padding:7px 15px;transition:var(--el-transition-all);font-weight:700}.el-check-tag:hover{background-color:var(--el-color-info-light-7)}.el-check-tag.is-checked{background-color:var(--el-color-primary-light-8);color:var(--el-color-primary)}.el-check-tag.is-checked:hover{background-color:var(--el-color-primary-light-7)}.el-checkbox-button{--el-checkbox-button-checked-bg-color:var(--el-color-primary);--el-checkbox-button-checked-text-color:var(--el-color-white);--el-checkbox-button-checked-border-color:var(--el-color-primary)}.el-checkbox-button{position:relative;display:inline-block}.el-checkbox-button__inner{display:inline-block;line-height:1;font-weight:var(--el-checkbox-font-weight);white-space:nowrap;vertical-align:middle;cursor:pointer;background:var(--el-button-bg-color,var(--el-fill-color-blank));border:var(--el-border);border-left:0;color:var(--el-button-text-color,var(--el-text-color-regular));-webkit-appearance:none;text-align:center;box-sizing:border-box;outline:0;margin:0;position:relative;transition:var(--el-transition-all);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;padding:8px 15px;font-size:var(--el-font-size-base);border-radius:0}.el-checkbox-button__inner.is-round{padding:8px 15px}.el-checkbox-button__inner:hover{color:var(--el-color-primary)}.el-checkbox-button__inner [class*=el-icon-]{line-height:.9}.el-checkbox-button__inner [class*=el-icon-]+span{margin-left:5px}.el-checkbox-button__original{opacity:0;outline:0;position:absolute;margin:0;z-index:-1}.el-checkbox-button.is-checked .el-checkbox-button__inner{color:var(--el-checkbox-button-checked-text-color);background-color:var(--el-checkbox-button-checked-bg-color);border-color:var(--el-checkbox-button-checked-border-color);box-shadow:-1px 0 0 0 var(--el-color-primary-light-7)}.el-checkbox-button.is-checked:first-child .el-checkbox-button__inner{border-left-color:var(--el-checkbox-button-checked-border-color)}.el-checkbox-button.is-disabled .el-checkbox-button__inner{color:var(--el-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--el-button-disabled-bg-color,var(--el-fill-color-blank));border-color:var(--el-button-disabled-border-color,var(--el-border-color-light));box-shadow:none}.el-checkbox-button.is-disabled:first-child .el-checkbox-button__inner{border-left-color:var(--el-button-disabled-border-color,var(--el-border-color-light))}.el-checkbox-button:first-child .el-checkbox-button__inner{border-left:var(--el-border);border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);box-shadow:none!important}.el-checkbox-button.is-focus .el-checkbox-button__inner{border-color:var(--el-checkbox-button-checked-border-color)}.el-checkbox-button:last-child .el-checkbox-button__inner{border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0}.el-checkbox-button--large .el-checkbox-button__inner{padding:12px 19px;font-size:var(--el-font-size-base);border-radius:0}.el-checkbox-button--large .el-checkbox-button__inner.is-round{padding:12px 19px}.el-checkbox-button--small .el-checkbox-button__inner{padding:5px 11px;font-size:12px;border-radius:0}.el-checkbox-button--small .el-checkbox-button__inner.is-round{padding:5px 11px}.el-checkbox-group{font-size:0;line-height:0}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary)}.el-checkbox{color:var(--el-checkbox-text-color);font-weight:var(--el-checkbox-font-weight);font-size:var(--el-font-size-base);position:relative;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-right:30px;height:32px}.el-checkbox.is-bordered{padding:0 15px 0 9px;border-radius:var(--el-border-radius-base);border:var(--el-border);box-sizing:border-box}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter);cursor:not-allowed}.el-checkbox.is-bordered.el-checkbox--large{padding:0 19px 0 11px;border-radius:var(--el-border-radius-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{padding:0 11px 0 7px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner::after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px;border-radius:var(--el-checkbox-border-radius)}.el-checkbox__input{white-space:nowrap;cursor:pointer;outline:0;display:inline-flex;position:relative}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner::after{cursor:not-allowed;border-color:var(--el-checkbox-disabled-icon-color)}.el-checkbox__input.is-disabled .el-checkbox__inner+.el-checkbox__label{cursor:not-allowed}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner::after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner::before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner::after{transform:rotate(45deg) scaleY(1)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner::before{content:"";position:absolute;display:block;background-color:var(--el-checkbox-checked-icon-color);height:2px;transform:scale(.5);left:0;right:0;top:5px}.el-checkbox__input.is-indeterminate .el-checkbox__inner::after{display:none}.el-checkbox__inner{display:inline-block;position:relative;border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;width:var(--el-checkbox-input-width);height:var(--el-checkbox-input-height);background-color:var(--el-checkbox-bg-color);z-index:var(--el-index-normal);transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner::after{box-sizing:content-box;content:"";border:1px solid var(--el-checkbox-checked-icon-color);border-left:0;border-top:0;height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);width:3px;transition:transform .15s ease-in 50ms;transform-origin:center}.el-checkbox__original{opacity:0;outline:0;position:absolute;margin:0;width:0;height:0;z-index:-1}.el-checkbox__label{display:inline-block;padding-left:8px;line-height:1;font-size:var(--el-checkbox-font-size)}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{width:14px;height:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{width:12px;height:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner::before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner::after{width:2px;height:6px}.el-checkbox:last-of-type{margin-right:0}[class*=el-col-]{box-sizing:border-box}[class*=el-col-].is-guttered{display:block;min-height:1px}.el-col-0{display:none}.el-col-0.is-guttered{display:none}.el-col-0{max-width:0%;flex:0 0 0%}.el-col-offset-0{margin-left:0}.el-col-pull-0{position:relative;right:0}.el-col-push-0{position:relative;left:0}.el-col-1{max-width:4.1666666667%;flex:0 0 4.1666666667%}.el-col-offset-1{margin-left:4.1666666667%}.el-col-pull-1{position:relative;right:4.1666666667%}.el-col-push-1{position:relative;left:4.1666666667%}.el-col-2{max-width:8.3333333333%;flex:0 0 8.3333333333%}.el-col-offset-2{margin-left:8.3333333333%}.el-col-pull-2{position:relative;right:8.3333333333%}.el-col-push-2{position:relative;left:8.3333333333%}.el-col-3{max-width:12.5%;flex:0 0 12.5%}.el-col-offset-3{margin-left:12.5%}.el-col-pull-3{position:relative;right:12.5%}.el-col-push-3{position:relative;left:12.5%}.el-col-4{max-width:16.6666666667%;flex:0 0 16.6666666667%}.el-col-offset-4{margin-left:16.6666666667%}.el-col-pull-4{position:relative;right:16.6666666667%}.el-col-push-4{position:relative;left:16.6666666667%}.el-col-5{max-width:20.8333333333%;flex:0 0 20.8333333333%}.el-col-offset-5{margin-left:20.8333333333%}.el-col-pull-5{position:relative;right:20.8333333333%}.el-col-push-5{position:relative;left:20.8333333333%}.el-col-6{max-width:25%;flex:0 0 25%}.el-col-offset-6{margin-left:25%}.el-col-pull-6{position:relative;right:25%}.el-col-push-6{position:relative;left:25%}.el-col-7{max-width:29.1666666667%;flex:0 0 29.1666666667%}.el-col-offset-7{margin-left:29.1666666667%}.el-col-pull-7{position:relative;right:29.1666666667%}.el-col-push-7{position:relative;left:29.1666666667%}.el-col-8{max-width:33.3333333333%;flex:0 0 33.3333333333%}.el-col-offset-8{margin-left:33.3333333333%}.el-col-pull-8{position:relative;right:33.3333333333%}.el-col-push-8{position:relative;left:33.3333333333%}.el-col-9{max-width:37.5%;flex:0 0 37.5%}.el-col-offset-9{margin-left:37.5%}.el-col-pull-9{position:relative;right:37.5%}.el-col-push-9{position:relative;left:37.5%}.el-col-10{max-width:41.6666666667%;flex:0 0 41.6666666667%}.el-col-offset-10{margin-left:41.6666666667%}.el-col-pull-10{position:relative;right:41.6666666667%}.el-col-push-10{position:relative;left:41.6666666667%}.el-col-11{max-width:45.8333333333%;flex:0 0 45.8333333333%}.el-col-offset-11{margin-left:45.8333333333%}.el-col-pull-11{position:relative;right:45.8333333333%}.el-col-push-11{position:relative;left:45.8333333333%}.el-col-12{max-width:50%;flex:0 0 50%}.el-col-offset-12{margin-left:50%}.el-col-pull-12{position:relative;right:50%}.el-col-push-12{position:relative;left:50%}.el-col-13{max-width:54.1666666667%;flex:0 0 54.1666666667%}.el-col-offset-13{margin-left:54.1666666667%}.el-col-pull-13{position:relative;right:54.1666666667%}.el-col-push-13{position:relative;left:54.1666666667%}.el-col-14{max-width:58.3333333333%;flex:0 0 58.3333333333%}.el-col-offset-14{margin-left:58.3333333333%}.el-col-pull-14{position:relative;right:58.3333333333%}.el-col-push-14{position:relative;left:58.3333333333%}.el-col-15{max-width:62.5%;flex:0 0 62.5%}.el-col-offset-15{margin-left:62.5%}.el-col-pull-15{position:relative;right:62.5%}.el-col-push-15{position:relative;left:62.5%}.el-col-16{max-width:66.6666666667%;flex:0 0 66.6666666667%}.el-col-offset-16{margin-left:66.6666666667%}.el-col-pull-16{position:relative;right:66.6666666667%}.el-col-push-16{position:relative;left:66.6666666667%}.el-col-17{max-width:70.8333333333%;flex:0 0 70.8333333333%}.el-col-offset-17{margin-left:70.8333333333%}.el-col-pull-17{position:relative;right:70.8333333333%}.el-col-push-17{position:relative;left:70.8333333333%}.el-col-18{max-width:75%;flex:0 0 75%}.el-col-offset-18{margin-left:75%}.el-col-pull-18{position:relative;right:75%}.el-col-push-18{position:relative;left:75%}.el-col-19{max-width:79.1666666667%;flex:0 0 79.1666666667%}.el-col-offset-19{margin-left:79.1666666667%}.el-col-pull-19{position:relative;right:79.1666666667%}.el-col-push-19{position:relative;left:79.1666666667%}.el-col-20{max-width:83.3333333333%;flex:0 0 83.3333333333%}.el-col-offset-20{margin-left:83.3333333333%}.el-col-pull-20{position:relative;right:83.3333333333%}.el-col-push-20{position:relative;left:83.3333333333%}.el-col-21{max-width:87.5%;flex:0 0 87.5%}.el-col-offset-21{margin-left:87.5%}.el-col-pull-21{position:relative;right:87.5%}.el-col-push-21{position:relative;left:87.5%}.el-col-22{max-width:91.6666666667%;flex:0 0 91.6666666667%}.el-col-offset-22{margin-left:91.6666666667%}.el-col-pull-22{position:relative;right:91.6666666667%}.el-col-push-22{position:relative;left:91.6666666667%}.el-col-23{max-width:95.8333333333%;flex:0 0 95.8333333333%}.el-col-offset-23{margin-left:95.8333333333%}.el-col-pull-23{position:relative;right:95.8333333333%}.el-col-push-23{position:relative;left:95.8333333333%}.el-col-24{max-width:100%;flex:0 0 100%}.el-col-offset-24{margin-left:100%}.el-col-pull-24{position:relative;right:100%}.el-col-push-24{position:relative;left:100%}@media only screen and (max-width:768px){.el-col-xs-0{display:none}.el-col-xs-0.is-guttered{display:none}.el-col-xs-0{max-width:0%;flex:0 0 0%}.el-col-xs-offset-0{margin-left:0}.el-col-xs-pull-0{position:relative;right:0}.el-col-xs-push-0{position:relative;left:0}.el-col-xs-1{display:block;max-width:4.1666666667%;flex:0 0 4.1666666667%}.el-col-xs-offset-1{margin-left:4.1666666667%}.el-col-xs-pull-1{position:relative;right:4.1666666667%}.el-col-xs-push-1{position:relative;left:4.1666666667%}.el-col-xs-2{display:block;max-width:8.3333333333%;flex:0 0 8.3333333333%}.el-col-xs-offset-2{margin-left:8.3333333333%}.el-col-xs-pull-2{position:relative;right:8.3333333333%}.el-col-xs-push-2{position:relative;left:8.3333333333%}.el-col-xs-3{display:block;max-width:12.5%;flex:0 0 12.5%}.el-col-xs-offset-3{margin-left:12.5%}.el-col-xs-pull-3{position:relative;right:12.5%}.el-col-xs-push-3{position:relative;left:12.5%}.el-col-xs-4{display:block;max-width:16.6666666667%;flex:0 0 16.6666666667%}.el-col-xs-offset-4{margin-left:16.6666666667%}.el-col-xs-pull-4{position:relative;right:16.6666666667%}.el-col-xs-push-4{position:relative;left:16.6666666667%}.el-col-xs-5{display:block;max-width:20.8333333333%;flex:0 0 20.8333333333%}.el-col-xs-offset-5{margin-left:20.8333333333%}.el-col-xs-pull-5{position:relative;right:20.8333333333%}.el-col-xs-push-5{position:relative;left:20.8333333333%}.el-col-xs-6{display:block;max-width:25%;flex:0 0 25%}.el-col-xs-offset-6{margin-left:25%}.el-col-xs-pull-6{position:relative;right:25%}.el-col-xs-push-6{position:relative;left:25%}.el-col-xs-7{display:block;max-width:29.1666666667%;flex:0 0 29.1666666667%}.el-col-xs-offset-7{margin-left:29.1666666667%}.el-col-xs-pull-7{position:relative;right:29.1666666667%}.el-col-xs-push-7{position:relative;left:29.1666666667%}.el-col-xs-8{display:block;max-width:33.3333333333%;flex:0 0 33.3333333333%}.el-col-xs-offset-8{margin-left:33.3333333333%}.el-col-xs-pull-8{position:relative;right:33.3333333333%}.el-col-xs-push-8{position:relative;left:33.3333333333%}.el-col-xs-9{display:block;max-width:37.5%;flex:0 0 37.5%}.el-col-xs-offset-9{margin-left:37.5%}.el-col-xs-pull-9{position:relative;right:37.5%}.el-col-xs-push-9{position:relative;left:37.5%}.el-col-xs-10{display:block;max-width:41.6666666667%;flex:0 0 41.6666666667%}.el-col-xs-offset-10{margin-left:41.6666666667%}.el-col-xs-pull-10{position:relative;right:41.6666666667%}.el-col-xs-push-10{position:relative;left:41.6666666667%}.el-col-xs-11{display:block;max-width:45.8333333333%;flex:0 0 45.8333333333%}.el-col-xs-offset-11{margin-left:45.8333333333%}.el-col-xs-pull-11{position:relative;right:45.8333333333%}.el-col-xs-push-11{position:relative;left:45.8333333333%}.el-col-xs-12{display:block;max-width:50%;flex:0 0 50%}.el-col-xs-offset-12{margin-left:50%}.el-col-xs-pull-12{position:relative;right:50%}.el-col-xs-push-12{position:relative;left:50%}.el-col-xs-13{display:block;max-width:54.1666666667%;flex:0 0 54.1666666667%}.el-col-xs-offset-13{margin-left:54.1666666667%}.el-col-xs-pull-13{position:relative;right:54.1666666667%}.el-col-xs-push-13{position:relative;left:54.1666666667%}.el-col-xs-14{display:block;max-width:58.3333333333%;flex:0 0 58.3333333333%}.el-col-xs-offset-14{margin-left:58.3333333333%}.el-col-xs-pull-14{position:relative;right:58.3333333333%}.el-col-xs-push-14{position:relative;left:58.3333333333%}.el-col-xs-15{display:block;max-width:62.5%;flex:0 0 62.5%}.el-col-xs-offset-15{margin-left:62.5%}.el-col-xs-pull-15{position:relative;right:62.5%}.el-col-xs-push-15{position:relative;left:62.5%}.el-col-xs-16{display:block;max-width:66.6666666667%;flex:0 0 66.6666666667%}.el-col-xs-offset-16{margin-left:66.6666666667%}.el-col-xs-pull-16{position:relative;right:66.6666666667%}.el-col-xs-push-16{position:relative;left:66.6666666667%}.el-col-xs-17{display:block;max-width:70.8333333333%;flex:0 0 70.8333333333%}.el-col-xs-offset-17{margin-left:70.8333333333%}.el-col-xs-pull-17{position:relative;right:70.8333333333%}.el-col-xs-push-17{position:relative;left:70.8333333333%}.el-col-xs-18{display:block;max-width:75%;flex:0 0 75%}.el-col-xs-offset-18{margin-left:75%}.el-col-xs-pull-18{position:relative;right:75%}.el-col-xs-push-18{position:relative;left:75%}.el-col-xs-19{display:block;max-width:79.1666666667%;flex:0 0 79.1666666667%}.el-col-xs-offset-19{margin-left:79.1666666667%}.el-col-xs-pull-19{position:relative;right:79.1666666667%}.el-col-xs-push-19{position:relative;left:79.1666666667%}.el-col-xs-20{display:block;max-width:83.3333333333%;flex:0 0 83.3333333333%}.el-col-xs-offset-20{margin-left:83.3333333333%}.el-col-xs-pull-20{position:relative;right:83.3333333333%}.el-col-xs-push-20{position:relative;left:83.3333333333%}.el-col-xs-21{display:block;max-width:87.5%;flex:0 0 87.5%}.el-col-xs-offset-21{margin-left:87.5%}.el-col-xs-pull-21{position:relative;right:87.5%}.el-col-xs-push-21{position:relative;left:87.5%}.el-col-xs-22{display:block;max-width:91.6666666667%;flex:0 0 91.6666666667%}.el-col-xs-offset-22{margin-left:91.6666666667%}.el-col-xs-pull-22{position:relative;right:91.6666666667%}.el-col-xs-push-22{position:relative;left:91.6666666667%}.el-col-xs-23{display:block;max-width:95.8333333333%;flex:0 0 95.8333333333%}.el-col-xs-offset-23{margin-left:95.8333333333%}.el-col-xs-pull-23{position:relative;right:95.8333333333%}.el-col-xs-push-23{position:relative;left:95.8333333333%}.el-col-xs-24{display:block;max-width:100%;flex:0 0 100%}.el-col-xs-offset-24{margin-left:100%}.el-col-xs-pull-24{position:relative;right:100%}.el-col-xs-push-24{position:relative;left:100%}}@media only screen and (min-width:768px){.el-col-sm-0{display:none}.el-col-sm-0.is-guttered{display:none}.el-col-sm-0{max-width:0%;flex:0 0 0%}.el-col-sm-offset-0{margin-left:0}.el-col-sm-pull-0{position:relative;right:0}.el-col-sm-push-0{position:relative;left:0}.el-col-sm-1{display:block;max-width:4.1666666667%;flex:0 0 4.1666666667%}.el-col-sm-offset-1{margin-left:4.1666666667%}.el-col-sm-pull-1{position:relative;right:4.1666666667%}.el-col-sm-push-1{position:relative;left:4.1666666667%}.el-col-sm-2{display:block;max-width:8.3333333333%;flex:0 0 8.3333333333%}.el-col-sm-offset-2{margin-left:8.3333333333%}.el-col-sm-pull-2{position:relative;right:8.3333333333%}.el-col-sm-push-2{position:relative;left:8.3333333333%}.el-col-sm-3{display:block;max-width:12.5%;flex:0 0 12.5%}.el-col-sm-offset-3{margin-left:12.5%}.el-col-sm-pull-3{position:relative;right:12.5%}.el-col-sm-push-3{position:relative;left:12.5%}.el-col-sm-4{display:block;max-width:16.6666666667%;flex:0 0 16.6666666667%}.el-col-sm-offset-4{margin-left:16.6666666667%}.el-col-sm-pull-4{position:relative;right:16.6666666667%}.el-col-sm-push-4{position:relative;left:16.6666666667%}.el-col-sm-5{display:block;max-width:20.8333333333%;flex:0 0 20.8333333333%}.el-col-sm-offset-5{margin-left:20.8333333333%}.el-col-sm-pull-5{position:relative;right:20.8333333333%}.el-col-sm-push-5{position:relative;left:20.8333333333%}.el-col-sm-6{display:block;max-width:25%;flex:0 0 25%}.el-col-sm-offset-6{margin-left:25%}.el-col-sm-pull-6{position:relative;right:25%}.el-col-sm-push-6{position:relative;left:25%}.el-col-sm-7{display:block;max-width:29.1666666667%;flex:0 0 29.1666666667%}.el-col-sm-offset-7{margin-left:29.1666666667%}.el-col-sm-pull-7{position:relative;right:29.1666666667%}.el-col-sm-push-7{position:relative;left:29.1666666667%}.el-col-sm-8{display:block;max-width:33.3333333333%;flex:0 0 33.3333333333%}.el-col-sm-offset-8{margin-left:33.3333333333%}.el-col-sm-pull-8{position:relative;right:33.3333333333%}.el-col-sm-push-8{position:relative;left:33.3333333333%}.el-col-sm-9{display:block;max-width:37.5%;flex:0 0 37.5%}.el-col-sm-offset-9{margin-left:37.5%}.el-col-sm-pull-9{position:relative;right:37.5%}.el-col-sm-push-9{position:relative;left:37.5%}.el-col-sm-10{display:block;max-width:41.6666666667%;flex:0 0 41.6666666667%}.el-col-sm-offset-10{margin-left:41.6666666667%}.el-col-sm-pull-10{position:relative;right:41.6666666667%}.el-col-sm-push-10{position:relative;left:41.6666666667%}.el-col-sm-11{display:block;max-width:45.8333333333%;flex:0 0 45.8333333333%}.el-col-sm-offset-11{margin-left:45.8333333333%}.el-col-sm-pull-11{position:relative;right:45.8333333333%}.el-col-sm-push-11{position:relative;left:45.8333333333%}.el-col-sm-12{display:block;max-width:50%;flex:0 0 50%}.el-col-sm-offset-12{margin-left:50%}.el-col-sm-pull-12{position:relative;right:50%}.el-col-sm-push-12{position:relative;left:50%}.el-col-sm-13{display:block;max-width:54.1666666667%;flex:0 0 54.1666666667%}.el-col-sm-offset-13{margin-left:54.1666666667%}.el-col-sm-pull-13{position:relative;right:54.1666666667%}.el-col-sm-push-13{position:relative;left:54.1666666667%}.el-col-sm-14{display:block;max-width:58.3333333333%;flex:0 0 58.3333333333%}.el-col-sm-offset-14{margin-left:58.3333333333%}.el-col-sm-pull-14{position:relative;right:58.3333333333%}.el-col-sm-push-14{position:relative;left:58.3333333333%}.el-col-sm-15{display:block;max-width:62.5%;flex:0 0 62.5%}.el-col-sm-offset-15{margin-left:62.5%}.el-col-sm-pull-15{position:relative;right:62.5%}.el-col-sm-push-15{position:relative;left:62.5%}.el-col-sm-16{display:block;max-width:66.6666666667%;flex:0 0 66.6666666667%}.el-col-sm-offset-16{margin-left:66.6666666667%}.el-col-sm-pull-16{position:relative;right:66.6666666667%}.el-col-sm-push-16{position:relative;left:66.6666666667%}.el-col-sm-17{display:block;max-width:70.8333333333%;flex:0 0 70.8333333333%}.el-col-sm-offset-17{margin-left:70.8333333333%}.el-col-sm-pull-17{position:relative;right:70.8333333333%}.el-col-sm-push-17{position:relative;left:70.8333333333%}.el-col-sm-18{display:block;max-width:75%;flex:0 0 75%}.el-col-sm-offset-18{margin-left:75%}.el-col-sm-pull-18{position:relative;right:75%}.el-col-sm-push-18{position:relative;left:75%}.el-col-sm-19{display:block;max-width:79.1666666667%;flex:0 0 79.1666666667%}.el-col-sm-offset-19{margin-left:79.1666666667%}.el-col-sm-pull-19{position:relative;right:79.1666666667%}.el-col-sm-push-19{position:relative;left:79.1666666667%}.el-col-sm-20{display:block;max-width:83.3333333333%;flex:0 0 83.3333333333%}.el-col-sm-offset-20{margin-left:83.3333333333%}.el-col-sm-pull-20{position:relative;right:83.3333333333%}.el-col-sm-push-20{position:relative;left:83.3333333333%}.el-col-sm-21{display:block;max-width:87.5%;flex:0 0 87.5%}.el-col-sm-offset-21{margin-left:87.5%}.el-col-sm-pull-21{position:relative;right:87.5%}.el-col-sm-push-21{position:relative;left:87.5%}.el-col-sm-22{display:block;max-width:91.6666666667%;flex:0 0 91.6666666667%}.el-col-sm-offset-22{margin-left:91.6666666667%}.el-col-sm-pull-22{position:relative;right:91.6666666667%}.el-col-sm-push-22{position:relative;left:91.6666666667%}.el-col-sm-23{display:block;max-width:95.8333333333%;flex:0 0 95.8333333333%}.el-col-sm-offset-23{margin-left:95.8333333333%}.el-col-sm-pull-23{position:relative;right:95.8333333333%}.el-col-sm-push-23{position:relative;left:95.8333333333%}.el-col-sm-24{display:block;max-width:100%;flex:0 0 100%}.el-col-sm-offset-24{margin-left:100%}.el-col-sm-pull-24{position:relative;right:100%}.el-col-sm-push-24{position:relative;left:100%}}@media only screen and (min-width:992px){.el-col-md-0{display:none}.el-col-md-0.is-guttered{display:none}.el-col-md-0{max-width:0%;flex:0 0 0%}.el-col-md-offset-0{margin-left:0}.el-col-md-pull-0{position:relative;right:0}.el-col-md-push-0{position:relative;left:0}.el-col-md-1{display:block;max-width:4.1666666667%;flex:0 0 4.1666666667%}.el-col-md-offset-1{margin-left:4.1666666667%}.el-col-md-pull-1{position:relative;right:4.1666666667%}.el-col-md-push-1{position:relative;left:4.1666666667%}.el-col-md-2{display:block;max-width:8.3333333333%;flex:0 0 8.3333333333%}.el-col-md-offset-2{margin-left:8.3333333333%}.el-col-md-pull-2{position:relative;right:8.3333333333%}.el-col-md-push-2{position:relative;left:8.3333333333%}.el-col-md-3{display:block;max-width:12.5%;flex:0 0 12.5%}.el-col-md-offset-3{margin-left:12.5%}.el-col-md-pull-3{position:relative;right:12.5%}.el-col-md-push-3{position:relative;left:12.5%}.el-col-md-4{display:block;max-width:16.6666666667%;flex:0 0 16.6666666667%}.el-col-md-offset-4{margin-left:16.6666666667%}.el-col-md-pull-4{position:relative;right:16.6666666667%}.el-col-md-push-4{position:relative;left:16.6666666667%}.el-col-md-5{display:block;max-width:20.8333333333%;flex:0 0 20.8333333333%}.el-col-md-offset-5{margin-left:20.8333333333%}.el-col-md-pull-5{position:relative;right:20.8333333333%}.el-col-md-push-5{position:relative;left:20.8333333333%}.el-col-md-6{display:block;max-width:25%;flex:0 0 25%}.el-col-md-offset-6{margin-left:25%}.el-col-md-pull-6{position:relative;right:25%}.el-col-md-push-6{position:relative;left:25%}.el-col-md-7{display:block;max-width:29.1666666667%;flex:0 0 29.1666666667%}.el-col-md-offset-7{margin-left:29.1666666667%}.el-col-md-pull-7{position:relative;right:29.1666666667%}.el-col-md-push-7{position:relative;left:29.1666666667%}.el-col-md-8{display:block;max-width:33.3333333333%;flex:0 0 33.3333333333%}.el-col-md-offset-8{margin-left:33.3333333333%}.el-col-md-pull-8{position:relative;right:33.3333333333%}.el-col-md-push-8{position:relative;left:33.3333333333%}.el-col-md-9{display:block;max-width:37.5%;flex:0 0 37.5%}.el-col-md-offset-9{margin-left:37.5%}.el-col-md-pull-9{position:relative;right:37.5%}.el-col-md-push-9{position:relative;left:37.5%}.el-col-md-10{display:block;max-width:41.6666666667%;flex:0 0 41.6666666667%}.el-col-md-offset-10{margin-left:41.6666666667%}.el-col-md-pull-10{position:relative;right:41.6666666667%}.el-col-md-push-10{position:relative;left:41.6666666667%}.el-col-md-11{display:block;max-width:45.8333333333%;flex:0 0 45.8333333333%}.el-col-md-offset-11{margin-left:45.8333333333%}.el-col-md-pull-11{position:relative;right:45.8333333333%}.el-col-md-push-11{position:relative;left:45.8333333333%}.el-col-md-12{display:block;max-width:50%;flex:0 0 50%}.el-col-md-offset-12{margin-left:50%}.el-col-md-pull-12{position:relative;right:50%}.el-col-md-push-12{position:relative;left:50%}.el-col-md-13{display:block;max-width:54.1666666667%;flex:0 0 54.1666666667%}.el-col-md-offset-13{margin-left:54.1666666667%}.el-col-md-pull-13{position:relative;right:54.1666666667%}.el-col-md-push-13{position:relative;left:54.1666666667%}.el-col-md-14{display:block;max-width:58.3333333333%;flex:0 0 58.3333333333%}.el-col-md-offset-14{margin-left:58.3333333333%}.el-col-md-pull-14{position:relative;right:58.3333333333%}.el-col-md-push-14{position:relative;left:58.3333333333%}.el-col-md-15{display:block;max-width:62.5%;flex:0 0 62.5%}.el-col-md-offset-15{margin-left:62.5%}.el-col-md-pull-15{position:relative;right:62.5%}.el-col-md-push-15{position:relative;left:62.5%}.el-col-md-16{display:block;max-width:66.6666666667%;flex:0 0 66.6666666667%}.el-col-md-offset-16{margin-left:66.6666666667%}.el-col-md-pull-16{position:relative;right:66.6666666667%}.el-col-md-push-16{position:relative;left:66.6666666667%}.el-col-md-17{display:block;max-width:70.8333333333%;flex:0 0 70.8333333333%}.el-col-md-offset-17{margin-left:70.8333333333%}.el-col-md-pull-17{position:relative;right:70.8333333333%}.el-col-md-push-17{position:relative;left:70.8333333333%}.el-col-md-18{display:block;max-width:75%;flex:0 0 75%}.el-col-md-offset-18{margin-left:75%}.el-col-md-pull-18{position:relative;right:75%}.el-col-md-push-18{position:relative;left:75%}.el-col-md-19{display:block;max-width:79.1666666667%;flex:0 0 79.1666666667%}.el-col-md-offset-19{margin-left:79.1666666667%}.el-col-md-pull-19{position:relative;right:79.1666666667%}.el-col-md-push-19{position:relative;left:79.1666666667%}.el-col-md-20{display:block;max-width:83.3333333333%;flex:0 0 83.3333333333%}.el-col-md-offset-20{margin-left:83.3333333333%}.el-col-md-pull-20{position:relative;right:83.3333333333%}.el-col-md-push-20{position:relative;left:83.3333333333%}.el-col-md-21{display:block;max-width:87.5%;flex:0 0 87.5%}.el-col-md-offset-21{margin-left:87.5%}.el-col-md-pull-21{position:relative;right:87.5%}.el-col-md-push-21{position:relative;left:87.5%}.el-col-md-22{display:block;max-width:91.6666666667%;flex:0 0 91.6666666667%}.el-col-md-offset-22{margin-left:91.6666666667%}.el-col-md-pull-22{position:relative;right:91.6666666667%}.el-col-md-push-22{position:relative;left:91.6666666667%}.el-col-md-23{display:block;max-width:95.8333333333%;flex:0 0 95.8333333333%}.el-col-md-offset-23{margin-left:95.8333333333%}.el-col-md-pull-23{position:relative;right:95.8333333333%}.el-col-md-push-23{position:relative;left:95.8333333333%}.el-col-md-24{display:block;max-width:100%;flex:0 0 100%}.el-col-md-offset-24{margin-left:100%}.el-col-md-pull-24{position:relative;right:100%}.el-col-md-push-24{position:relative;left:100%}}@media only screen and (min-width:1200px){.el-col-lg-0{display:none}.el-col-lg-0.is-guttered{display:none}.el-col-lg-0{max-width:0%;flex:0 0 0%}.el-col-lg-offset-0{margin-left:0}.el-col-lg-pull-0{position:relative;right:0}.el-col-lg-push-0{position:relative;left:0}.el-col-lg-1{display:block;max-width:4.1666666667%;flex:0 0 4.1666666667%}.el-col-lg-offset-1{margin-left:4.1666666667%}.el-col-lg-pull-1{position:relative;right:4.1666666667%}.el-col-lg-push-1{position:relative;left:4.1666666667%}.el-col-lg-2{display:block;max-width:8.3333333333%;flex:0 0 8.3333333333%}.el-col-lg-offset-2{margin-left:8.3333333333%}.el-col-lg-pull-2{position:relative;right:8.3333333333%}.el-col-lg-push-2{position:relative;left:8.3333333333%}.el-col-lg-3{display:block;max-width:12.5%;flex:0 0 12.5%}.el-col-lg-offset-3{margin-left:12.5%}.el-col-lg-pull-3{position:relative;right:12.5%}.el-col-lg-push-3{position:relative;left:12.5%}.el-col-lg-4{display:block;max-width:16.6666666667%;flex:0 0 16.6666666667%}.el-col-lg-offset-4{margin-left:16.6666666667%}.el-col-lg-pull-4{position:relative;right:16.6666666667%}.el-col-lg-push-4{position:relative;left:16.6666666667%}.el-col-lg-5{display:block;max-width:20.8333333333%;flex:0 0 20.8333333333%}.el-col-lg-offset-5{margin-left:20.8333333333%}.el-col-lg-pull-5{position:relative;right:20.8333333333%}.el-col-lg-push-5{position:relative;left:20.8333333333%}.el-col-lg-6{display:block;max-width:25%;flex:0 0 25%}.el-col-lg-offset-6{margin-left:25%}.el-col-lg-pull-6{position:relative;right:25%}.el-col-lg-push-6{position:relative;left:25%}.el-col-lg-7{display:block;max-width:29.1666666667%;flex:0 0 29.1666666667%}.el-col-lg-offset-7{margin-left:29.1666666667%}.el-col-lg-pull-7{position:relative;right:29.1666666667%}.el-col-lg-push-7{position:relative;left:29.1666666667%}.el-col-lg-8{display:block;max-width:33.3333333333%;flex:0 0 33.3333333333%}.el-col-lg-offset-8{margin-left:33.3333333333%}.el-col-lg-pull-8{position:relative;right:33.3333333333%}.el-col-lg-push-8{position:relative;left:33.3333333333%}.el-col-lg-9{display:block;max-width:37.5%;flex:0 0 37.5%}.el-col-lg-offset-9{margin-left:37.5%}.el-col-lg-pull-9{position:relative;right:37.5%}.el-col-lg-push-9{position:relative;left:37.5%}.el-col-lg-10{display:block;max-width:41.6666666667%;flex:0 0 41.6666666667%}.el-col-lg-offset-10{margin-left:41.6666666667%}.el-col-lg-pull-10{position:relative;right:41.6666666667%}.el-col-lg-push-10{position:relative;left:41.6666666667%}.el-col-lg-11{display:block;max-width:45.8333333333%;flex:0 0 45.8333333333%}.el-col-lg-offset-11{margin-left:45.8333333333%}.el-col-lg-pull-11{position:relative;right:45.8333333333%}.el-col-lg-push-11{position:relative;left:45.8333333333%}.el-col-lg-12{display:block;max-width:50%;flex:0 0 50%}.el-col-lg-offset-12{margin-left:50%}.el-col-lg-pull-12{position:relative;right:50%}.el-col-lg-push-12{position:relative;left:50%}.el-col-lg-13{display:block;max-width:54.1666666667%;flex:0 0 54.1666666667%}.el-col-lg-offset-13{margin-left:54.1666666667%}.el-col-lg-pull-13{position:relative;right:54.1666666667%}.el-col-lg-push-13{position:relative;left:54.1666666667%}.el-col-lg-14{display:block;max-width:58.3333333333%;flex:0 0 58.3333333333%}.el-col-lg-offset-14{margin-left:58.3333333333%}.el-col-lg-pull-14{position:relative;right:58.3333333333%}.el-col-lg-push-14{position:relative;left:58.3333333333%}.el-col-lg-15{display:block;max-width:62.5%;flex:0 0 62.5%}.el-col-lg-offset-15{margin-left:62.5%}.el-col-lg-pull-15{position:relative;right:62.5%}.el-col-lg-push-15{position:relative;left:62.5%}.el-col-lg-16{display:block;max-width:66.6666666667%;flex:0 0 66.6666666667%}.el-col-lg-offset-16{margin-left:66.6666666667%}.el-col-lg-pull-16{position:relative;right:66.6666666667%}.el-col-lg-push-16{position:relative;left:66.6666666667%}.el-col-lg-17{display:block;max-width:70.8333333333%;flex:0 0 70.8333333333%}.el-col-lg-offset-17{margin-left:70.8333333333%}.el-col-lg-pull-17{position:relative;right:70.8333333333%}.el-col-lg-push-17{position:relative;left:70.8333333333%}.el-col-lg-18{display:block;max-width:75%;flex:0 0 75%}.el-col-lg-offset-18{margin-left:75%}.el-col-lg-pull-18{position:relative;right:75%}.el-col-lg-push-18{position:relative;left:75%}.el-col-lg-19{display:block;max-width:79.1666666667%;flex:0 0 79.1666666667%}.el-col-lg-offset-19{margin-left:79.1666666667%}.el-col-lg-pull-19{position:relative;right:79.1666666667%}.el-col-lg-push-19{position:relative;left:79.1666666667%}.el-col-lg-20{display:block;max-width:83.3333333333%;flex:0 0 83.3333333333%}.el-col-lg-offset-20{margin-left:83.3333333333%}.el-col-lg-pull-20{position:relative;right:83.3333333333%}.el-col-lg-push-20{position:relative;left:83.3333333333%}.el-col-lg-21{display:block;max-width:87.5%;flex:0 0 87.5%}.el-col-lg-offset-21{margin-left:87.5%}.el-col-lg-pull-21{position:relative;right:87.5%}.el-col-lg-push-21{position:relative;left:87.5%}.el-col-lg-22{display:block;max-width:91.6666666667%;flex:0 0 91.6666666667%}.el-col-lg-offset-22{margin-left:91.6666666667%}.el-col-lg-pull-22{position:relative;right:91.6666666667%}.el-col-lg-push-22{position:relative;left:91.6666666667%}.el-col-lg-23{display:block;max-width:95.8333333333%;flex:0 0 95.8333333333%}.el-col-lg-offset-23{margin-left:95.8333333333%}.el-col-lg-pull-23{position:relative;right:95.8333333333%}.el-col-lg-push-23{position:relative;left:95.8333333333%}.el-col-lg-24{display:block;max-width:100%;flex:0 0 100%}.el-col-lg-offset-24{margin-left:100%}.el-col-lg-pull-24{position:relative;right:100%}.el-col-lg-push-24{position:relative;left:100%}}@media only screen and (min-width:1920px){.el-col-xl-0{display:none}.el-col-xl-0.is-guttered{display:none}.el-col-xl-0{max-width:0%;flex:0 0 0%}.el-col-xl-offset-0{margin-left:0}.el-col-xl-pull-0{position:relative;right:0}.el-col-xl-push-0{position:relative;left:0}.el-col-xl-1{display:block;max-width:4.1666666667%;flex:0 0 4.1666666667%}.el-col-xl-offset-1{margin-left:4.1666666667%}.el-col-xl-pull-1{position:relative;right:4.1666666667%}.el-col-xl-push-1{position:relative;left:4.1666666667%}.el-col-xl-2{display:block;max-width:8.3333333333%;flex:0 0 8.3333333333%}.el-col-xl-offset-2{margin-left:8.3333333333%}.el-col-xl-pull-2{position:relative;right:8.3333333333%}.el-col-xl-push-2{position:relative;left:8.3333333333%}.el-col-xl-3{display:block;max-width:12.5%;flex:0 0 12.5%}.el-col-xl-offset-3{margin-left:12.5%}.el-col-xl-pull-3{position:relative;right:12.5%}.el-col-xl-push-3{position:relative;left:12.5%}.el-col-xl-4{display:block;max-width:16.6666666667%;flex:0 0 16.6666666667%}.el-col-xl-offset-4{margin-left:16.6666666667%}.el-col-xl-pull-4{position:relative;right:16.6666666667%}.el-col-xl-push-4{position:relative;left:16.6666666667%}.el-col-xl-5{display:block;max-width:20.8333333333%;flex:0 0 20.8333333333%}.el-col-xl-offset-5{margin-left:20.8333333333%}.el-col-xl-pull-5{position:relative;right:20.8333333333%}.el-col-xl-push-5{position:relative;left:20.8333333333%}.el-col-xl-6{display:block;max-width:25%;flex:0 0 25%}.el-col-xl-offset-6{margin-left:25%}.el-col-xl-pull-6{position:relative;right:25%}.el-col-xl-push-6{position:relative;left:25%}.el-col-xl-7{display:block;max-width:29.1666666667%;flex:0 0 29.1666666667%}.el-col-xl-offset-7{margin-left:29.1666666667%}.el-col-xl-pull-7{position:relative;right:29.1666666667%}.el-col-xl-push-7{position:relative;left:29.1666666667%}.el-col-xl-8{display:block;max-width:33.3333333333%;flex:0 0 33.3333333333%}.el-col-xl-offset-8{margin-left:33.3333333333%}.el-col-xl-pull-8{position:relative;right:33.3333333333%}.el-col-xl-push-8{position:relative;left:33.3333333333%}.el-col-xl-9{display:block;max-width:37.5%;flex:0 0 37.5%}.el-col-xl-offset-9{margin-left:37.5%}.el-col-xl-pull-9{position:relative;right:37.5%}.el-col-xl-push-9{position:relative;left:37.5%}.el-col-xl-10{display:block;max-width:41.6666666667%;flex:0 0 41.6666666667%}.el-col-xl-offset-10{margin-left:41.6666666667%}.el-col-xl-pull-10{position:relative;right:41.6666666667%}.el-col-xl-push-10{position:relative;left:41.6666666667%}.el-col-xl-11{display:block;max-width:45.8333333333%;flex:0 0 45.8333333333%}.el-col-xl-offset-11{margin-left:45.8333333333%}.el-col-xl-pull-11{position:relative;right:45.8333333333%}.el-col-xl-push-11{position:relative;left:45.8333333333%}.el-col-xl-12{display:block;max-width:50%;flex:0 0 50%}.el-col-xl-offset-12{margin-left:50%}.el-col-xl-pull-12{position:relative;right:50%}.el-col-xl-push-12{position:relative;left:50%}.el-col-xl-13{display:block;max-width:54.1666666667%;flex:0 0 54.1666666667%}.el-col-xl-offset-13{margin-left:54.1666666667%}.el-col-xl-pull-13{position:relative;right:54.1666666667%}.el-col-xl-push-13{position:relative;left:54.1666666667%}.el-col-xl-14{display:block;max-width:58.3333333333%;flex:0 0 58.3333333333%}.el-col-xl-offset-14{margin-left:58.3333333333%}.el-col-xl-pull-14{position:relative;right:58.3333333333%}.el-col-xl-push-14{position:relative;left:58.3333333333%}.el-col-xl-15{display:block;max-width:62.5%;flex:0 0 62.5%}.el-col-xl-offset-15{margin-left:62.5%}.el-col-xl-pull-15{position:relative;right:62.5%}.el-col-xl-push-15{position:relative;left:62.5%}.el-col-xl-16{display:block;max-width:66.6666666667%;flex:0 0 66.6666666667%}.el-col-xl-offset-16{margin-left:66.6666666667%}.el-col-xl-pull-16{position:relative;right:66.6666666667%}.el-col-xl-push-16{position:relative;left:66.6666666667%}.el-col-xl-17{display:block;max-width:70.8333333333%;flex:0 0 70.8333333333%}.el-col-xl-offset-17{margin-left:70.8333333333%}.el-col-xl-pull-17{position:relative;right:70.8333333333%}.el-col-xl-push-17{position:relative;left:70.8333333333%}.el-col-xl-18{display:block;max-width:75%;flex:0 0 75%}.el-col-xl-offset-18{margin-left:75%}.el-col-xl-pull-18{position:relative;right:75%}.el-col-xl-push-18{position:relative;left:75%}.el-col-xl-19{display:block;max-width:79.1666666667%;flex:0 0 79.1666666667%}.el-col-xl-offset-19{margin-left:79.1666666667%}.el-col-xl-pull-19{position:relative;right:79.1666666667%}.el-col-xl-push-19{position:relative;left:79.1666666667%}.el-col-xl-20{display:block;max-width:83.3333333333%;flex:0 0 83.3333333333%}.el-col-xl-offset-20{margin-left:83.3333333333%}.el-col-xl-pull-20{position:relative;right:83.3333333333%}.el-col-xl-push-20{position:relative;left:83.3333333333%}.el-col-xl-21{display:block;max-width:87.5%;flex:0 0 87.5%}.el-col-xl-offset-21{margin-left:87.5%}.el-col-xl-pull-21{position:relative;right:87.5%}.el-col-xl-push-21{position:relative;left:87.5%}.el-col-xl-22{display:block;max-width:91.6666666667%;flex:0 0 91.6666666667%}.el-col-xl-offset-22{margin-left:91.6666666667%}.el-col-xl-pull-22{position:relative;right:91.6666666667%}.el-col-xl-push-22{position:relative;left:91.6666666667%}.el-col-xl-23{display:block;max-width:95.8333333333%;flex:0 0 95.8333333333%}.el-col-xl-offset-23{margin-left:95.8333333333%}.el-col-xl-pull-23{position:relative;right:95.8333333333%}.el-col-xl-push-23{position:relative;left:95.8333333333%}.el-col-xl-24{display:block;max-width:100%;flex:0 0 100%}.el-col-xl-offset-24{margin-left:100%}.el-col-xl-pull-24{position:relative;right:100%}.el-col-xl-push-24{position:relative;left:100%}}.el-collapse{--el-collapse-border-color:var(--el-border-color-lighter);--el-collapse-header-height:48px;--el-collapse-header-bg-color:var(--el-fill-color-blank);--el-collapse-header-text-color:var(--el-text-color-primary);--el-collapse-header-font-size:13px;--el-collapse-content-bg-color:var(--el-fill-color-blank);--el-collapse-content-font-size:13px;--el-collapse-content-text-color:var(--el-text-color-primary);border-top:1px solid var(--el-collapse-border-color);border-bottom:1px solid var(--el-collapse-border-color)}.el-collapse-item.is-disabled .el-collapse-item__header{color:var(--el-text-color-disabled);cursor:not-allowed}.el-collapse-item__header{display:flex;align-items:center;height:var(--el-collapse-header-height);line-height:var(--el-collapse-header-height);background-color:var(--el-collapse-header-bg-color);color:var(--el-collapse-header-text-color);cursor:pointer;border-bottom:1px solid var(--el-collapse-border-color);font-size:var(--el-collapse-header-font-size);font-weight:500;transition:border-bottom-color var(--el-transition-duration);outline:0}.el-collapse-item__arrow{margin:0 8px 0 auto;transition:transform var(--el-transition-duration);font-weight:300}.el-collapse-item__arrow.is-active{transform:rotate(90deg)}.el-collapse-item__header.focusing:focus:not(:hover){color:var(--el-color-primary)}.el-collapse-item__header.is-active{border-bottom-color:transparent}.el-collapse-item__wrap{will-change:height;background-color:var(--el-collapse-content-bg-color);overflow:hidden;box-sizing:border-box;border-bottom:1px solid var(--el-collapse-border-color)}.el-collapse-item__content{padding-bottom:25px;font-size:var(--el-collapse-content-font-size);color:var(--el-collapse-content-text-color);line-height:1.7692307692}.el-collapse-item:last-child{margin-bottom:-1px}.el-color-predefine{display:flex;font-size:12px;margin-top:8px;width:280px}.el-color-predefine__colors{display:flex;flex:1;flex-wrap:wrap}.el-color-predefine__color-selector{margin:0 0 8px 8px;width:20px;height:20px;border-radius:4px;cursor:pointer}.el-color-predefine__color-selector:nth-child(10n+1){margin-left:0}.el-color-predefine__color-selector.selected{box-shadow:0 0 3px 2px var(--el-color-primary)}.el-color-predefine__color-selector>div{display:flex;height:100%;border-radius:3px}.el-color-predefine__color-selector.is-alpha{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==)}.el-color-hue-slider{position:relative;box-sizing:border-box;width:280px;height:12px;background-color:red;padding:0 2px;float:right}.el-color-hue-slider__bar{position:relative;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%);height:100%}.el-color-hue-slider__thumb{position:absolute;cursor:pointer;box-sizing:border-box;left:0;top:0;width:4px;height:100%;border-radius:1px;background:#fff;border:1px solid var(--el-border-color-lighter);box-shadow:0 0 2px rgba(0,0,0,.6);z-index:1}.el-color-hue-slider.is-vertical{width:12px;height:180px;padding:2px 0}.el-color-hue-slider.is-vertical .el-color-hue-slider__bar{background:linear-gradient(to bottom,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}.el-color-hue-slider.is-vertical .el-color-hue-slider__thumb{left:0;top:0;width:100%;height:4px}.el-color-svpanel{position:relative;width:280px;height:180px}.el-color-svpanel__black,.el-color-svpanel__white{position:absolute;top:0;left:0;right:0;bottom:0}.el-color-svpanel__white{background:linear-gradient(to right,#fff,rgba(255,255,255,0))}.el-color-svpanel__black{background:linear-gradient(to top,#000,rgba(0,0,0,0))}.el-color-svpanel__cursor{position:absolute}.el-color-svpanel__cursor>div{cursor:head;width:4px;height:4px;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px rgba(0,0,0,.3),0 0 1px 2px rgba(0,0,0,.4);border-radius:50%;transform:translate(-2px,-2px)}.el-color-alpha-slider{position:relative;box-sizing:border-box;width:280px;height:12px;background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-size:12px 12px;background-position:0 0,6px 0,6px -6px,0 6px}.el-color-alpha-slider__bar{position:relative;background:linear-gradient(to right,rgba(255,255,255,0) 0,var(--el-bg-color) 100%);height:100%}.el-color-alpha-slider__thumb{position:absolute;cursor:pointer;box-sizing:border-box;left:0;top:0;width:4px;height:100%;border-radius:1px;background:#fff;border:1px solid var(--el-border-color-lighter);box-shadow:0 0 2px rgba(0,0,0,.6);z-index:1}.el-color-alpha-slider.is-vertical{width:20px;height:180px}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__bar{background:linear-gradient(to bottom,rgba(255,255,255,0) 0,#fff 100%)}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__thumb{left:0;top:0;width:100%;height:4px}.el-color-dropdown{width:300px}.el-color-dropdown__main-wrapper{margin-bottom:6px}.el-color-dropdown__main-wrapper::after{content:"";display:table;clear:both}.el-color-dropdown__btns{margin-top:12px;text-align:right}.el-color-dropdown__value{float:left;line-height:26px;font-size:12px;color:#000;width:160px}.el-color-picker{display:inline-block;position:relative;line-height:normal}.el-color-picker.is-disabled .el-color-picker__trigger{cursor:not-allowed}.el-color-picker--large{height:40px}.el-color-picker--large .el-color-picker__trigger{height:40px;width:40px}.el-color-picker--large .el-color-picker__mask{height:38px;width:38px}.el-color-picker--small{height:24px}.el-color-picker--small .el-color-picker__trigger{height:24px;width:24px}.el-color-picker--small .el-color-picker__mask{height:22px;width:22px}.el-color-picker--small .el-color-picker__empty,.el-color-picker--small .el-color-picker__icon{transform:scale(.8)}.el-color-picker__mask{height:38px;width:38px;border-radius:4px;position:absolute;top:1px;left:1px;z-index:1;cursor:not-allowed;background-color:rgba(255,255,255,.7)}.el-color-picker__trigger{display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;height:32px;width:32px;padding:4px;border:1px solid var(--el-border-color);border-radius:4px;font-size:0;position:relative;cursor:pointer}.el-color-picker__color{position:relative;display:block;box-sizing:border-box;border:1px solid var(--el-text-color-secondary);border-radius:var(--el-border-radius-small);width:100%;height:100%;text-align:center}.el-color-picker__color.is-alpha{background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-size:12px 12px;background-position:0 0,6px 0,6px -6px,0 6px}.el-color-picker__color-inner{display:inline-flex;justify-content:center;align-items:center;width:100%;height:100%}.el-color-picker .el-color-picker__empty{font-size:12px;color:var(--el-text-color-secondary)}.el-color-picker .el-color-picker__icon{display:inline-flex;justify-content:center;align-items:center;color:#fff;font-size:12px}.el-color-picker__panel{position:absolute;z-index:10;padding:6px;box-sizing:content-box;background-color:#fff;border-radius:var(--el-border-radius-base);box-shadow:var(--el-box-shadow-light)}.el-color-picker__panel.el-popper{border:1px solid var(--el-border-color-lighter)}.el-color-picker,.el-color-picker__panel{--el-color-picker-alpha-bg-a:#ccc;--el-color-picker-alpha-bg-b:transparent}.dark .el-color-picker,.dark .el-color-picker__panel{--el-color-picker-alpha-bg-a:#333333}.el-container{display:flex;flex-direction:row;flex:1;flex-basis:auto;box-sizing:border-box;min-width:0}.el-container.is-vertical{flex-direction:column}.el-date-table{font-size:12px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-date-table.is-week-mode .el-date-table__row:hover .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table.is-week-mode .el-date-table__row:hover td.available:hover{color:var(--el-datepicker-text-color)}.el-date-table.is-week-mode .el-date-table__row:hover td:first-child .el-date-table-cell{margin-left:5px;border-top-left-radius:15px;border-bottom-left-radius:15px}.el-date-table.is-week-mode .el-date-table__row:hover td:last-child .el-date-table-cell{margin-right:5px;border-top-right-radius:15px;border-bottom-right-radius:15px}.el-date-table.is-week-mode .el-date-table__row.current .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table td{width:32px;height:30px;padding:4px 0;box-sizing:border-box;text-align:center;cursor:pointer;position:relative}.el-date-table td .el-date-table-cell{height:30px;padding:3px 0;box-sizing:border-box}.el-date-table td .el-date-table-cell .el-date-table-cell__text{width:24px;height:24px;display:block;margin:0 auto;line-height:24px;position:absolute;left:50%;transform:translateX(-50%);border-radius:50%}.el-date-table td.next-month,.el-date-table td.prev-month{color:var(--el-datepicker-off-text-color)}.el-date-table td.today{position:relative}.el-date-table td.today .el-date-table-cell__text{color:var(--el-color-primary);font-weight:700}.el-date-table td.today.end-date .el-date-table-cell__text,.el-date-table td.today.start-date .el-date-table-cell__text{color:#fff}.el-date-table td.available:hover{color:var(--el-datepicker-hover-text-color)}.el-date-table td.in-range .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table td.in-range .el-date-table-cell:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-date-table td.current:not(.disabled) .el-date-table-cell__text{color:#fff;background-color:var(--el-datepicker-active-color)}.el-date-table td.current:not(.disabled):focus-visible .el-date-table-cell__text{outline:2px solid var(--el-datepicker-active-color);outline-offset:1px}.el-date-table td.end-date .el-date-table-cell,.el-date-table td.start-date .el-date-table-cell{color:#fff}.el-date-table td.end-date .el-date-table-cell__text,.el-date-table td.start-date .el-date-table-cell__text{background-color:var(--el-datepicker-active-color)}.el-date-table td.start-date .el-date-table-cell{margin-left:5px;border-top-left-radius:15px;border-bottom-left-radius:15px}.el-date-table td.end-date .el-date-table-cell{margin-right:5px;border-top-right-radius:15px;border-bottom-right-radius:15px}.el-date-table td.disabled .el-date-table-cell{background-color:var(--el-fill-color-light);opacity:1;cursor:not-allowed;color:var(--el-text-color-placeholder)}.el-date-table td.selected .el-date-table-cell{margin-left:5px;margin-right:5px;background-color:var(--el-datepicker-inrange-bg-color);border-radius:15px}.el-date-table td.selected .el-date-table-cell:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-date-table td.selected .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);color:#fff;border-radius:15px}.el-date-table td.week{font-size:80%;color:var(--el-datepicker-header-text-color)}.el-date-table td:focus{outline:0}.el-date-table th{padding:5px;color:var(--el-datepicker-header-text-color);font-weight:400;border-bottom:solid 1px var(--el-border-color-lighter)}.el-month-table{font-size:12px;margin:-1px;border-collapse:collapse}.el-month-table td{text-align:center;padding:8px 0;cursor:pointer}.el-month-table td div{height:48px;padding:6px 0;box-sizing:border-box}.el-month-table td.today .cell{color:var(--el-color-primary);font-weight:700}.el-month-table td.today.end-date .cell,.el-month-table td.today.start-date .cell{color:#fff}.el-month-table td.disabled .cell{background-color:var(--el-fill-color-light);cursor:not-allowed;color:var(--el-text-color-placeholder)}.el-month-table td.disabled .cell:hover{color:var(--el-text-color-placeholder)}.el-month-table td .cell{width:60px;height:36px;display:block;line-height:36px;color:var(--el-datepicker-text-color);margin:0 auto;border-radius:18px}.el-month-table td .cell:hover{color:var(--el-datepicker-hover-text-color)}.el-month-table td.in-range div{background-color:var(--el-datepicker-inrange-bg-color)}.el-month-table td.in-range div:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-month-table td.end-date div,.el-month-table td.start-date div{color:#fff}.el-month-table td.end-date .cell,.el-month-table td.start-date .cell{color:#fff;background-color:var(--el-datepicker-active-color)}.el-month-table td.start-date div{border-top-left-radius:24px;border-bottom-left-radius:24px}.el-month-table td.end-date div{border-top-right-radius:24px;border-bottom-right-radius:24px}.el-month-table td.current:not(.disabled) .cell{color:var(--el-datepicker-active-color)}.el-month-table td:focus-visible{outline:0}.el-month-table td:focus-visible .cell{outline:2px solid var(--el-datepicker-active-color)}.el-year-table{font-size:12px;margin:-1px;border-collapse:collapse}.el-year-table .el-icon{color:var(--el-datepicker-icon-color)}.el-year-table td{text-align:center;padding:20px 3px;cursor:pointer}.el-year-table td.today .cell{color:var(--el-color-primary);font-weight:700}.el-year-table td.disabled .cell{background-color:var(--el-fill-color-light);cursor:not-allowed;color:var(--el-text-color-placeholder)}.el-year-table td.disabled .cell:hover{color:var(--el-text-color-placeholder)}.el-year-table td .cell{width:48px;height:36px;display:block;line-height:36px;color:var(--el-datepicker-text-color);border-radius:18px;margin:0 auto}.el-year-table td .cell:hover{color:var(--el-datepicker-hover-text-color)}.el-year-table td.current:not(.disabled) .cell{color:var(--el-datepicker-active-color)}.el-year-table td:focus-visible{outline:0}.el-year-table td:focus-visible .cell{outline:2px solid var(--el-datepicker-active-color)}.el-time-spinner.has-seconds .el-time-spinner__wrapper{width:33.3%}.el-time-spinner__wrapper{max-height:192px;overflow:auto;display:inline-block;width:50%;vertical-align:top;position:relative}.el-time-spinner__wrapper.el-scrollbar__wrap:not(.el-scrollbar__wrap--hidden-default){padding-bottom:15px}.el-time-spinner__wrapper.is-arrow{box-sizing:border-box;text-align:center;overflow:hidden}.el-time-spinner__wrapper.is-arrow .el-time-spinner__list{transform:translateY(-32px)}.el-time-spinner__wrapper.is-arrow .el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:default}.el-time-spinner__arrow{font-size:12px;color:var(--el-text-color-secondary);position:absolute;left:0;width:100%;z-index:var(--el-index-normal);text-align:center;height:30px;line-height:30px;cursor:pointer}.el-time-spinner__arrow:hover{color:var(--el-color-primary)}.el-time-spinner__arrow.arrow-up{top:10px}.el-time-spinner__arrow.arrow-down{bottom:10px}.el-time-spinner__input.el-input{width:70%}.el-time-spinner__input.el-input .el-input__inner{padding:0;text-align:center}.el-time-spinner__list{padding:0;margin:0;list-style:none;text-align:center}.el-time-spinner__list::after,.el-time-spinner__list::before{content:"";display:block;width:100%;height:80px}.el-time-spinner__item{height:32px;line-height:32px;font-size:12px;color:var(--el-text-color-regular)}.el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:pointer}.el-time-spinner__item.is-active:not(.is-disabled){color:var(--el-text-color-primary);font-weight:700}.el-time-spinner__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-picker__popper{--el-datepicker-border-color:var(--el-disabled-border-color)}.el-picker__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-datepicker-border-color);box-shadow:var(--el-box-shadow-light)}.el-picker__popper.el-popper .el-popper__arrow::before{border:1px solid var(--el-datepicker-border-color)}.el-picker__popper.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent;border-left-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent;border-right-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent;border-bottom-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent;border-top-color:transparent}.el-date-editor{--el-date-editor-width:220px;--el-date-editor-monthrange-width:300px;--el-date-editor-daterange-width:350px;--el-date-editor-datetimerange-width:400px;--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);position:relative;display:inline-block;text-align:left}.el-date-editor.el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-date-editor.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-date-editor.el-input,.el-date-editor.el-input__wrapper{width:var(--el-date-editor-width);height:var(--el-input-height,var(--el-component-size))}.el-date-editor--monthrange{--el-date-editor-width:var(--el-date-editor-monthrange-width)}.el-date-editor--daterange,.el-date-editor--timerange{--el-date-editor-width:var(--el-date-editor-daterange-width)}.el-date-editor--datetimerange{--el-date-editor-width:var(--el-date-editor-datetimerange-width)}.el-date-editor--dates .el-input__wrapper{text-overflow:ellipsis;white-space:nowrap}.el-date-editor .close-icon{cursor:pointer}.el-date-editor .clear-icon{cursor:pointer}.el-date-editor .clear-icon:hover{color:var(--el-text-color-secondary)}.el-date-editor .el-range__icon{height:inherit;font-size:14px;color:var(--el-text-color-placeholder);float:left}.el-date-editor .el-range__icon svg{vertical-align:middle}.el-date-editor .el-range-input{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:0;display:inline-block;height:30px;line-height:30px;margin:0;padding:0;width:39%;text-align:center;font-size:var(--el-font-size-base);color:var(--el-text-color-regular);background-color:transparent}.el-date-editor .el-range-input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-input:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-input::placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-separator{flex:1;display:inline-flex;justify-content:center;align-items:center;height:100%;padding:0 5px;margin:0;font-size:14px;word-break:keep-all;color:var(--el-text-color-primary)}.el-date-editor .el-range__close-icon{font-size:14px;color:var(--el-text-color-placeholder);height:inherit;width:unset;cursor:pointer}.el-date-editor .el-range__close-icon:hover{color:var(--el-text-color-secondary)}.el-date-editor .el-range__close-icon svg{vertical-align:middle}.el-date-editor .el-range__close-icon--hidden{opacity:0;visibility:hidden}.el-range-editor.el-input__wrapper{display:inline-flex;align-items:center;padding:0 10px}.el-range-editor.is-active{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-range-editor.is-active:hover{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-range-editor--large{line-height:var(--el-component-size-large)}.el-range-editor--large.el-input__wrapper{height:var(--el-component-size-large)}.el-range-editor--large .el-range-separator{line-height:40px;font-size:14px}.el-range-editor--large .el-range-input{height:38px;line-height:38px;font-size:14px}.el-range-editor--small{line-height:var(--el-component-size-small)}.el-range-editor--small.el-input__wrapper{height:var(--el-component-size-small)}.el-range-editor--small .el-range-separator{line-height:24px;font-size:12px}.el-range-editor--small .el-range-input{height:22px;line-height:22px;font-size:12px}.el-range-editor.is-disabled{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled:focus,.el-range-editor.is-disabled:hover{border-color:var(--el-disabled-border-color)}.el-range-editor.is-disabled input{background-color:var(--el-disabled-bg-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled input:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled input::placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled .el-range-separator{color:var(--el-disabled-text-color)}.el-picker-panel{color:var(--el-text-color-regular);background:var(--el-bg-color-overlay);border-radius:var(--el-border-radius-base);line-height:30px}.el-picker-panel .el-time-panel{margin:5px 0;border:solid 1px var(--el-datepicker-border-color);background-color:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-picker-panel__body-wrapper::after,.el-picker-panel__body::after{content:"";display:table;clear:both}.el-picker-panel__content{position:relative;margin:15px}.el-picker-panel__footer{border-top:1px solid var(--el-datepicker-inner-border-color);padding:4px 12px;text-align:right;background-color:var(--el-bg-color-overlay);position:relative;font-size:0}.el-picker-panel__shortcut{display:block;width:100%;border:0;background-color:transparent;line-height:28px;font-size:14px;color:var(--el-datepicker-text-color);padding-left:12px;text-align:left;outline:0;cursor:pointer}.el-picker-panel__shortcut:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__shortcut.active{background-color:#e6f1fe;color:var(--el-datepicker-active-color)}.el-picker-panel__btn{border:1px solid var(--el-fill-color-darker);color:var(--el-text-color-primary);line-height:24px;border-radius:2px;padding:0 20px;cursor:pointer;background-color:transparent;outline:0;font-size:12px}.el-picker-panel__btn[disabled]{color:var(--el-text-color-disabled);cursor:not-allowed}.el-picker-panel__icon-btn{font-size:12px;color:var(--el-datepicker-icon-color);border:0;background:0 0;cursor:pointer;outline:0;margin-top:8px}.el-picker-panel__icon-btn:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn:focus-visible{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn.is-disabled{color:var(--el-text-color-disabled)}.el-picker-panel__icon-btn.is-disabled:hover{cursor:not-allowed}.el-picker-panel__icon-btn .el-icon{cursor:pointer;font-size:inherit}.el-picker-panel__link-btn{vertical-align:middle}.el-picker-panel [slot=sidebar],.el-picker-panel__sidebar{position:absolute;top:0;bottom:0;width:110px;border-right:1px solid var(--el-datepicker-inner-border-color);box-sizing:border-box;padding-top:6px;background-color:var(--el-bg-color-overlay);overflow:auto}.el-picker-panel [slot=sidebar]+.el-picker-panel__body,.el-picker-panel__sidebar+.el-picker-panel__body{margin-left:110px}.el-date-picker{--el-datepicker-text-color:var(--el-text-color-regular);--el-datepicker-off-text-color:var(--el-text-color-placeholder);--el-datepicker-header-text-color:var(--el-text-color-regular);--el-datepicker-icon-color:var(--el-text-color-primary);--el-datepicker-border-color:var(--el-disabled-border-color);--el-datepicker-inner-border-color:var(--el-border-color-light);--el-datepicker-inrange-bg-color:var(--el-border-color-extra-light);--el-datepicker-inrange-hover-bg-color:var(--el-border-color-extra-light);--el-datepicker-active-color:var(--el-color-primary);--el-datepicker-hover-text-color:var(--el-color-primary)}.el-date-picker{width:322px}.el-date-picker.has-sidebar.has-time{width:434px}.el-date-picker.has-sidebar{width:438px}.el-date-picker.has-time .el-picker-panel__body-wrapper{position:relative}.el-date-picker .el-picker-panel__content{width:292px}.el-date-picker table{table-layout:fixed;width:100%}.el-date-picker__editor-wrap{position:relative;display:table-cell;padding:0 5px}.el-date-picker__time-header{position:relative;border-bottom:1px solid var(--el-datepicker-inner-border-color);font-size:12px;padding:8px 5px 5px;display:table;width:100%;box-sizing:border-box}.el-date-picker__header{margin:12px;text-align:center}.el-date-picker__header--bordered{margin-bottom:0;padding-bottom:12px;border-bottom:solid 1px var(--el-border-color-lighter)}.el-date-picker__header--bordered+.el-picker-panel__content{margin-top:0}.el-date-picker__header-label{font-size:16px;font-weight:500;padding:0 5px;line-height:22px;text-align:center;cursor:pointer;color:var(--el-text-color-regular)}.el-date-picker__header-label:hover{color:var(--el-datepicker-hover-text-color)}.el-date-picker__header-label:focus-visible{outline:0;color:var(--el-datepicker-hover-text-color)}.el-date-picker__header-label.active{color:var(--el-datepicker-active-color)}.el-date-picker__prev-btn{float:left}.el-date-picker__next-btn{float:right}.el-date-picker__time-wrap{padding:10px;text-align:center}.el-date-picker__time-label{float:left;cursor:pointer;line-height:30px;margin-left:10px}.el-date-picker .el-time-panel{position:absolute}.el-date-range-picker{--el-datepicker-text-color:var(--el-text-color-regular);--el-datepicker-off-text-color:var(--el-text-color-placeholder);--el-datepicker-header-text-color:var(--el-text-color-regular);--el-datepicker-icon-color:var(--el-text-color-primary);--el-datepicker-border-color:var(--el-disabled-border-color);--el-datepicker-inner-border-color:var(--el-border-color-light);--el-datepicker-inrange-bg-color:var(--el-border-color-extra-light);--el-datepicker-inrange-hover-bg-color:var(--el-border-color-extra-light);--el-datepicker-active-color:var(--el-color-primary);--el-datepicker-hover-text-color:var(--el-color-primary)}.el-date-range-picker{width:646px}.el-date-range-picker.has-sidebar{width:756px}.el-date-range-picker.has-time .el-picker-panel__body-wrapper{position:relative}.el-date-range-picker table{table-layout:fixed;width:100%}.el-date-range-picker .el-picker-panel__body{min-width:513px}.el-date-range-picker .el-picker-panel__content{margin:0}.el-date-range-picker__header{position:relative;text-align:center;height:28px}.el-date-range-picker__header [class*=arrow-left]{float:left}.el-date-range-picker__header [class*=arrow-right]{float:right}.el-date-range-picker__header div{font-size:16px;font-weight:500;margin-right:50px}.el-date-range-picker__content{float:left;width:50%;box-sizing:border-box;margin:0;padding:16px}.el-date-range-picker__content.is-left{border-right:1px solid var(--el-datepicker-inner-border-color)}.el-date-range-picker__content .el-date-range-picker__header div{margin-left:50px;margin-right:50px}.el-date-range-picker__editors-wrap{box-sizing:border-box;display:table-cell}.el-date-range-picker__editors-wrap.is-right{text-align:right}.el-date-range-picker__time-header{position:relative;border-bottom:1px solid var(--el-datepicker-inner-border-color);font-size:12px;padding:8px 5px 5px 5px;display:table;width:100%;box-sizing:border-box}.el-date-range-picker__time-header>.el-icon-arrow-right{font-size:20px;vertical-align:middle;display:table-cell;color:var(--el-datepicker-icon-color)}.el-date-range-picker__time-picker-wrap{position:relative;display:table-cell;padding:0 5px}.el-date-range-picker__time-picker-wrap .el-picker-panel{position:absolute;top:13px;right:0;z-index:1;background:#fff}.el-date-range-picker__time-picker-wrap .el-time-panel{position:absolute}.el-time-range-picker{width:354px;overflow:visible}.el-time-range-picker__content{position:relative;text-align:center;padding:10px;z-index:1}.el-time-range-picker__cell{box-sizing:border-box;margin:0;padding:4px 7px 7px;width:50%;display:inline-block}.el-time-range-picker__header{margin-bottom:5px;text-align:center;font-size:14px}.el-time-range-picker__body{border-radius:2px;border:1px solid var(--el-datepicker-border-color)}.el-time-panel{border-radius:2px;position:relative;width:180px;left:0;z-index:var(--el-index-top);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;box-sizing:content-box}.el-time-panel__content{font-size:0;position:relative;overflow:hidden}.el-time-panel__content::after,.el-time-panel__content::before{content:"";top:50%;position:absolute;margin-top:-16px;height:32px;z-index:-1;left:0;right:0;box-sizing:border-box;padding-top:6px;text-align:left}.el-time-panel__content::after{left:50%;margin-left:12%;margin-right:12%}.el-time-panel__content::before{padding-left:50%;margin-right:12%;margin-left:12%;border-top:1px solid var(--el-border-color-light);border-bottom:1px solid var(--el-border-color-light)}.el-time-panel__content.has-seconds::after{left:66.6666666667%}.el-time-panel__content.has-seconds::before{padding-left:33.3333333333%}.el-time-panel__footer{border-top:1px solid var(--el-timepicker-inner-border-color,var(--el-border-color-light));padding:4px;height:36px;line-height:25px;text-align:right;box-sizing:border-box}.el-time-panel__btn{border:none;line-height:28px;padding:0 5px;margin:0 5px;cursor:pointer;background-color:transparent;outline:0;font-size:12px;color:var(--el-text-color-primary)}.el-time-panel__btn.confirm{font-weight:800;color:var(--el-timepicker-active-color,var(--el-color-primary))}.el-descriptions{--el-descriptions-table-border:1px solid var(--el-border-color-lighter);--el-descriptions-item-bordered-label-background:var(--el-fill-color-light);box-sizing:border-box;font-size:var(--el-font-size-base);color:var(--el-text-color-primary)}.el-descriptions__header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}.el-descriptions__title{color:var(--el-text-color-primary);font-size:16px;font-weight:700}.el-descriptions__body{background-color:var(--el-fill-color-blank)}.el-descriptions__body .el-descriptions__table{border-collapse:collapse;width:100%}.el-descriptions__body .el-descriptions__table .el-descriptions__cell{box-sizing:border-box;text-align:left;font-weight:400;line-height:23px;font-size:14px}.el-descriptions__body .el-descriptions__table .el-descriptions__cell.is-left{text-align:left}.el-descriptions__body .el-descriptions__table .el-descriptions__cell.is-center{text-align:center}.el-descriptions__body .el-descriptions__table .el-descriptions__cell.is-right{text-align:right}.el-descriptions__body .el-descriptions__table.is-bordered .el-descriptions__cell{border:var(--el-descriptions-table-border);padding:8px 11px}.el-descriptions__body .el-descriptions__table:not(.is-bordered) .el-descriptions__cell{padding-bottom:12px}.el-descriptions--large{font-size:14px}.el-descriptions--large .el-descriptions__header{margin-bottom:20px}.el-descriptions--large .el-descriptions__header .el-descriptions__title{font-size:16px}.el-descriptions--large .el-descriptions__body .el-descriptions__table .el-descriptions__cell{font-size:14px}.el-descriptions--large .el-descriptions__body .el-descriptions__table.is-bordered .el-descriptions__cell{padding:12px 15px}.el-descriptions--large .el-descriptions__body .el-descriptions__table:not(.is-bordered) .el-descriptions__cell{padding-bottom:16px}.el-descriptions--small{font-size:12px}.el-descriptions--small .el-descriptions__header{margin-bottom:12px}.el-descriptions--small .el-descriptions__header .el-descriptions__title{font-size:14px}.el-descriptions--small .el-descriptions__body .el-descriptions__table .el-descriptions__cell{font-size:12px}.el-descriptions--small .el-descriptions__body .el-descriptions__table.is-bordered .el-descriptions__cell{padding:4px 7px}.el-descriptions--small .el-descriptions__body .el-descriptions__table:not(.is-bordered) .el-descriptions__cell{padding-bottom:8px}.el-descriptions__label.el-descriptions__cell.is-bordered-label{font-weight:700;color:var(--el-text-color-regular);background:var(--el-descriptions-item-bordered-label-background)}.el-descriptions__label:not(.is-bordered-label){color:var(--el-text-color-primary);margin-right:16px}.el-descriptions__label.el-descriptions__cell:not(.is-bordered-label).is-vertical-label{padding-bottom:6px}.el-descriptions__content.el-descriptions__cell.is-bordered-content{color:var(--el-text-color-primary)}.el-descriptions__content:not(.is-bordered-label){color:var(--el-text-color-regular)}.el-descriptions--large .el-descriptions__label:not(.is-bordered-label){margin-right:16px}.el-descriptions--large .el-descriptions__label.el-descriptions__cell:not(.is-bordered-label).is-vertical-label{padding-bottom:8px}.el-descriptions--small .el-descriptions__label:not(.is-bordered-label){margin-right:12px}.el-descriptions--small .el-descriptions__label.el-descriptions__cell:not(.is-bordered-label).is-vertical-label{padding-bottom:4px}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:0.5}.v-modal-enter{-webkit-animation:v-modal-in var(--el-transition-duration-fast) ease;animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{-webkit-animation:v-modal-out var(--el-transition-duration-fast) ease forwards;animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@-webkit-keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-in{0%{opacity:0}}@-webkit-keyframes v-modal-out{100%{opacity:0}}@keyframes v-modal-out{100%{opacity:0}}.v-modal{position:fixed;left:0;top:0;width:100%;height:100%;opacity:var(--el-popup-modal-opacity);background:var(--el-popup-modal-bg-color)}.el-popup-parent--hidden{overflow:hidden}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:20px;--el-dialog-border-radius:var(--el-border-radius-small);position:relative;margin:var(--el-dialog-margin-top,15vh) auto 50px;background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:0!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;margin-bottom:0;height:100%;overflow:auto}.el-dialog__wrapper{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto;margin:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-dialog__header{padding:var(--el-dialog-padding-primary);padding-bottom:10px;margin-right:16px;word-break:break-all}.el-dialog__headerbtn{position:absolute;top:6px;right:0;padding:0;width:54px;height:54px;background:0 0;border:none;outline:0;cursor:pointer;font-size:var(--el-message-close-size,16px)}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{line-height:var(--el-dialog-font-line-height);font-size:var(--el-dialog-title-font-size);color:var(--el-text-color-primary)}.el-dialog__body{padding:calc(var(--el-dialog-padding-primary) + 10px) var(--el-dialog-padding-primary);color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size);word-break:break-all}.el-dialog__footer{padding:var(--el-dialog-padding-primary);padding-top:10px;text-align:right;box-sizing:border-box}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial;padding:25px calc(var(--el-dialog-padding-primary) + 5px) 30px}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto}.dialog-fade-enter-active{-webkit-animation:modal-fade-in var(--el-transition-duration);animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{-webkit-animation:dialog-fade-in var(--el-transition-duration);animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{-webkit-animation:modal-fade-out var(--el-transition-duration);animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{-webkit-animation:dialog-fade-out var(--el-transition-duration);animation:dialog-fade-out var(--el-transition-duration)}@-webkit-keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@-webkit-keyframes dialog-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}@keyframes dialog-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}@-webkit-keyframes modal-fade-in{0%{opacity:0}100%{opacity:1}}@keyframes modal-fade-in{0%{opacity:0}100%{opacity:1}}@-webkit-keyframes modal-fade-out{0%{opacity:1}100%{opacity:0}}@keyframes modal-fade-out{0%{opacity:1}100%{opacity:0}}.el-divider{position:relative}.el-divider--horizontal{display:block;height:1px;width:100%;margin:24px 0;border-top:1px var(--el-border-color) var(--el-border-style)}.el-divider--vertical{display:inline-block;width:1px;height:1em;margin:0 8px;vertical-align:middle;position:relative;border-left:1px var(--el-border-color) var(--el-border-style)}.el-divider__text{position:absolute;background-color:var(--el-bg-color);padding:0 20px;font-weight:500;color:var(--el-text-color-primary);font-size:14px}.el-divider__text.is-left{left:20px;transform:translateY(-50%)}.el-divider__text.is-center{left:50%;transform:translateX(-50%) translateY(-50%)}.el-divider__text.is-right{right:20px;transform:translateY(-50%)}.el-drawer{--el-drawer-bg-color:var(--el-dialog-bg-color, var(--el-bg-color));--el-drawer-padding-primary:var(--el-dialog-padding-primary, 20px)}.el-drawer{position:absolute;box-sizing:border-box;background-color:var(--el-drawer-bg-color);display:flex;flex-direction:column;box-shadow:var(--el-box-shadow-dark);overflow:hidden;transition:all var(--el-transition-duration)}.el-drawer .rtl{transform:translate(0,0)}.el-drawer .ltr{transform:translate(0,0)}.el-drawer .ttb{transform:translate(0,0)}.el-drawer .btt{transform:translate(0,0)}.el-drawer__sr-focus:focus{outline:0!important}.el-drawer__header{align-items:center;color:#72767b;display:flex;margin-bottom:32px;padding:var(--el-drawer-padding-primary);padding-bottom:0}.el-drawer__header>:first-child{flex:1}.el-drawer__title{margin:0;flex:1;line-height:inherit;font-size:1rem}.el-drawer__footer{padding:var(--el-drawer-padding-primary);padding-top:10px;text-align:right}.el-drawer__close-btn{border:none;cursor:pointer;font-size:var(--el-font-size-extra-large);color:inherit;background-color:transparent;outline:0}.el-drawer__close-btn:focus i,.el-drawer__close-btn:hover i{color:var(--el-color-primary)}.el-drawer__close-btn .el-icon{font-size:inherit;vertical-align:text-bottom}.el-drawer__body{flex:1;padding:var(--el-drawer-padding-primary);overflow:auto}.el-drawer__body>*{box-sizing:border-box}.el-drawer.ltr,.el-drawer.rtl{height:100%;top:0;bottom:0}.el-drawer.btt,.el-drawer.ttb{width:100%;left:0;right:0}.el-drawer.ltr{left:0}.el-drawer.rtl{right:0}.el-drawer.ttb{top:0}.el-drawer.btt{bottom:0}.el-drawer-fade-enter-active,.el-drawer-fade-leave-active{transition:all var(--el-transition-duration)}.el-drawer-fade-enter-active,.el-drawer-fade-enter-from,.el-drawer-fade-enter-to,.el-drawer-fade-leave-active,.el-drawer-fade-leave-from,.el-drawer-fade-leave-to{overflow:hidden!important}.el-drawer-fade-enter-from,.el-drawer-fade-leave-to{opacity:0}.el-drawer-fade-enter-to,.el-drawer-fade-leave-from{opacity:1}.el-drawer-fade-enter-from .rtl,.el-drawer-fade-leave-to .rtl{transform:translateX(100%)}.el-drawer-fade-enter-from .ltr,.el-drawer-fade-leave-to .ltr{transform:translateX(-100%)}.el-drawer-fade-enter-from .ttb,.el-drawer-fade-leave-to .ttb{transform:translateY(-100%)}.el-drawer-fade-enter-from .btt,.el-drawer-fade-leave-to .btt{transform:translateY(100%)}.el-dropdown{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10;display:inline-flex;position:relative;color:var(--el-text-color-regular);font-size:var(--el-font-size-base);line-height:1;vertical-align:top}.el-dropdown.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-dropdown__popper{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10}.el-dropdown__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-dropdown-menu-box-shadow)}.el-dropdown__popper.el-popper .el-popper__arrow::before{border:1px solid var(--el-border-color-light)}.el-dropdown__popper.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent;border-left-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent;border-right-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent;border-bottom-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent;border-top-color:transparent}.el-dropdown__popper .el-dropdown-menu{border:none}.el-dropdown__popper .el-dropdown__popper-selfdefine{outline:0}.el-dropdown__popper .el-scrollbar__bar{z-index:calc(var(--el-dropdown-menu-index) + 1)}.el-dropdown__popper .el-dropdown__list{list-style:none;padding:0;margin:0;box-sizing:border-box}.el-dropdown .el-dropdown__caret-button{padding-left:0;padding-right:0;display:inline-flex;justify-content:center;align-items:center;width:32px;border-left:none}.el-dropdown .el-dropdown__caret-button>span{display:inline-flex}.el-dropdown .el-dropdown__caret-button::before{content:"";position:absolute;display:block;width:1px;top:-1px;bottom:-1px;left:0;background:var(--el-overlay-color-lighter)}.el-dropdown .el-dropdown__caret-button.el-button::before{background:var(--el-border-color);opacity:.5}.el-dropdown .el-dropdown__caret-button .el-dropdown__icon{font-size:inherit;padding-left:0}.el-dropdown .el-dropdown-selfdefine{outline:0}.el-dropdown--large .el-dropdown__caret-button{width:40px}.el-dropdown--small .el-dropdown__caret-button{width:24px}.el-dropdown-menu{position:relative;top:0;left:0;z-index:var(--el-dropdown-menu-index);padding:5px 0;margin:0;background-color:var(--el-bg-color-overlay);border:none;border-radius:var(--el-border-radius-base);box-shadow:none;list-style:none}.el-dropdown-menu__item{display:flex;align-items:center;white-space:nowrap;list-style:none;line-height:22px;padding:5px 16px;margin:0;font-size:var(--el-font-size-base);color:var(--el-text-color-regular);cursor:pointer;outline:0}.el-dropdown-menu__item:not(.is-disabled):focus{background-color:var(--el-dropdown-menuItem-hover-fill);color:var(--el-dropdown-menuItem-hover-color)}.el-dropdown-menu__item i{margin-right:5px}.el-dropdown-menu__item--divided{margin:6px 0;border-top:1px solid var(--el-border-color-lighter)}.el-dropdown-menu__item.is-disabled{cursor:not-allowed;color:var(--el-text-color-disabled)}.el-dropdown-menu--large{padding:7px 0}.el-dropdown-menu--large .el-dropdown-menu__item{padding:7px 20px;line-height:22px;font-size:14px}.el-dropdown-menu--large .el-dropdown-menu__item--divided{margin:8px 0}.el-dropdown-menu--small{padding:3px 0}.el-dropdown-menu--small .el-dropdown-menu__item{padding:2px 12px;line-height:20px;font-size:12px}.el-dropdown-menu--small .el-dropdown-menu__item--divided{margin:4px 0}.el-empty{--el-empty-padding:40px 0;--el-empty-image-width:160px;--el-empty-description-margin-top:20px;--el-empty-bottom-margin-top:20px;--el-empty-fill-color-0:var(--el-color-white);--el-empty-fill-color-1:#fcfcfd;--el-empty-fill-color-2:#f8f9fb;--el-empty-fill-color-3:#f7f8fc;--el-empty-fill-color-4:#eeeff3;--el-empty-fill-color-5:#edeef2;--el-empty-fill-color-6:#e9ebef;--el-empty-fill-color-7:#e5e7e9;--el-empty-fill-color-8:#e0e3e9;--el-empty-fill-color-9:#d5d7de;display:flex;justify-content:center;align-items:center;flex-direction:column;text-align:center;box-sizing:border-box;padding:var(--el-empty-padding)}.el-empty__image{width:var(--el-empty-image-width)}.el-empty__image img{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:100%;height:100%;vertical-align:top;-o-object-fit:contain;object-fit:contain}.el-empty__image svg{color:var(--el-svg-monochrome-grey);fill:currentColor;width:100%;height:100%;vertical-align:top}.el-empty__description{margin-top:var(--el-empty-description-margin-top)}.el-empty__description p{margin:0;font-size:var(--el-font-size-base);color:var(--el-text-color-secondary)}.el-empty__bottom{margin-top:var(--el-empty-bottom-margin-top)}.el-footer{--el-footer-padding:0 20px;--el-footer-height:60px;padding:var(--el-footer-padding);box-sizing:border-box;flex-shrink:0;height:var(--el-footer-height)}.el-form{--el-form-label-font-size:var(--el-font-size-base)}.el-form--label-left .el-form-item__label{justify-content:flex-start}.el-form--label-top .el-form-item{display:block}.el-form--label-top .el-form-item .el-form-item__label{display:block;height:auto;text-align:left;margin-bottom:8px;line-height:22px}.el-form--inline .el-form-item{display:inline-flex;vertical-align:middle;margin-right:32px}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form--large.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:12px;line-height:22px}.el-form--default.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:8px;line-height:22px}.el-form--small.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:4px;line-height:20px}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item__label-wrap{display:flex}.el-form-item__label{display:inline-flex;justify-content:flex-end;align-items:flex-start;flex:0 0 auto;font-size:var(--el-form-label-font-size);color:var(--el-text-color-regular);height:32px;line-height:32px;padding:0 12px 0 0;box-sizing:border-box}.el-form-item__content{display:flex;flex-wrap:wrap;align-items:center;flex:1;line-height:32px;position:relative;font-size:var(--font-size);min-width:0}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;line-height:1;padding-top:2px;position:absolute;top:100%;left:0}.el-form-item__error--inline{position:relative;top:auto;left:auto;display:inline-block;margin-left:10px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{content:"*";color:var(--el-color-danger);margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{content:"*";color:var(--el-color-danger);margin-left:4px}.el-form-item.is-error .el-select-v2__wrapper,.el-form-item.is-error .el-select-v2__wrapper:focus,.el-form-item.is-error .el-textarea__inner,.el-form-item.is-error .el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-input-group__prepend .el-input__wrapper{box-shadow:0 0 0 1px transparent inset}.el-form-item.is-error .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.el-header{--el-header-padding:0 20px;--el-header-height:60px;padding:var(--el-header-padding);box-sizing:border-box;flex-shrink:0;height:var(--el-header-height)}.el-image-viewer__wrapper{position:fixed;top:0;right:0;bottom:0;left:0}.el-image-viewer__btn{position:absolute;z-index:1;display:flex;align-items:center;justify-content:center;border-radius:50%;opacity:.8;cursor:pointer;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-image-viewer__btn .el-icon{font-size:inherit;cursor:pointer}.el-image-viewer__close{top:40px;right:40px;width:40px;height:40px;font-size:40px}.el-image-viewer__canvas{width:100%;height:100%;display:flex;justify-content:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-image-viewer__actions{left:50%;bottom:30px;transform:translateX(-50%);width:282px;height:44px;padding:0 23px;background-color:var(--el-text-color-regular);border-color:#fff;border-radius:22px}.el-image-viewer__actions__inner{width:100%;height:100%;text-align:justify;cursor:default;font-size:23px;color:#fff;display:flex;align-items:center;justify-content:space-around}.el-image-viewer__prev{top:50%;transform:translateY(-50%);left:40px;width:44px;height:44px;font-size:24px;color:#fff;background-color:var(--el-text-color-regular);border-color:#fff}.el-image-viewer__next{top:50%;transform:translateY(-50%);right:40px;text-indent:2px;width:44px;height:44px;font-size:24px;color:#fff;background-color:var(--el-text-color-regular);border-color:#fff}.el-image-viewer__close{width:44px;height:44px;font-size:24px;color:#fff;background-color:var(--el-text-color-regular);border-color:#fff}.el-image-viewer__mask{position:absolute;width:100%;height:100%;top:0;left:0;opacity:.5;background:#000}.viewer-fade-enter-active{-webkit-animation:viewer-fade-in var(--el-transition-duration);animation:viewer-fade-in var(--el-transition-duration)}.viewer-fade-leave-active{-webkit-animation:viewer-fade-out var(--el-transition-duration);animation:viewer-fade-out var(--el-transition-duration)}@-webkit-keyframes viewer-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@keyframes viewer-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@-webkit-keyframes viewer-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}@keyframes viewer-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}.el-image__error,.el-image__inner,.el-image__placeholder,.el-image__wrapper{width:100%;height:100%}.el-image{position:relative;display:inline-block;overflow:hidden}.el-image__inner{vertical-align:top;opacity:1}.el-image__inner.is-loading{opacity:0}.el-image__wrapper{position:absolute;top:0;left:0}.el-image__placeholder{background:var(--el-fill-color-light)}.el-image__error{display:flex;justify-content:center;align-items:center;font-size:14px;background:var(--el-fill-color-light);color:var(--el-text-color-placeholder);vertical-align:middle}.el-image__preview{cursor:pointer}.el-input-number{position:relative;display:inline-block;width:150px;line-height:30px}.el-input-number .el-input__wrapper{padding-left:42px;padding-right:42px}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:textfield;text-align:center;line-height:1}.el-input-number .el-input__inner::-webkit-inner-spin-button,.el-input-number .el-input__inner::-webkit-outer-spin-button{margin:0;-webkit-appearance:none}.el-input-number__decrease,.el-input-number__increase{display:flex;justify-content:center;align-items:center;height:auto;position:absolute;z-index:1;top:1px;bottom:1px;width:32px;background:var(--el-fill-color-light);color:var(--el-text-color-regular);cursor:pointer;font-size:13px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:var(--el-color-primary)}.el-input-number__decrease:hover~.el-input:not(.is-disabled) .el-input_wrapper,.el-input-number__increase:hover~.el-input:not(.is-disabled) .el-input_wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input-number__increase{right:1px;border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0;border-left:var(--el-border)}.el-input-number__decrease{left:1px;border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);border-right:var(--el-border)}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:var(--el-disabled-border-color);color:var(--el-disabled-border-color)}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:var(--el-disabled-border-color);cursor:not-allowed}.el-input-number--large{width:180px;line-height:38px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{width:40px;font-size:14px}.el-input-number--large .el-input__wrapper{padding-left:47px;padding-right:47px}.el-input-number--small{width:120px;line-height:22px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{width:24px;font-size:12px}.el-input-number--small .el-input__wrapper{padding-left:31px;padding-right:31px}.el-input-number--small .el-input-number__decrease [class*=el-icon],.el-input-number--small .el-input-number__increase [class*=el-icon]{transform:scale(.9)}.el-input-number.is-without-controls .el-input__wrapper{padding-left:15px;padding-right:15px}.el-input-number.is-controls-right .el-input__wrapper{padding-left:15px;padding-right:42px}.el-input-number.is-controls-right .el-input-number__decrease,.el-input-number.is-controls-right .el-input-number__increase{--el-input-number-controls-height:15px;height:var(--el-input-number-controls-height);line-height:var(--el-input-number-controls-height)}.el-input-number.is-controls-right .el-input-number__decrease [class*=el-icon],.el-input-number.is-controls-right .el-input-number__increase [class*=el-icon]{transform:scale(.8)}.el-input-number.is-controls-right .el-input-number__increase{bottom:auto;left:auto;border-radius:0 var(--el-border-radius-base) 0 0;border-bottom:var(--el-border)}.el-input-number.is-controls-right .el-input-number__decrease{right:1px;top:auto;left:auto;border-right:none;border-left:var(--el-border);border-radius:0 0 var(--el-border-radius-base) 0}.el-input-number.is-controls-right[class*=large] [class*=decrease],.el-input-number.is-controls-right[class*=large] [class*=increase]{--el-input-number-controls-height:19px}.el-input-number.is-controls-right[class*=small] [class*=decrease],.el-input-number.is-controls-right[class*=small] [class*=increase]{--el-input-number-controls-height:11px}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary)}.el-textarea{position:relative;display:inline-block;width:100%;vertical-align:bottom;font-size:var(--el-font-size-base)}.el-textarea__inner{position:relative;display:block;resize:vertical;padding:5px 11px;line-height:1.5;box-sizing:border-box;width:100%;font-size:inherit;font-family:inherit;color:var(--el-input-text-color,var(--el-text-color-regular));background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;-webkit-appearance:none;box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);border:none}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{outline:0;box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-textarea .el-input__count{color:var(--el-color-info);background:var(--el-fill-color-blank);position:absolute;font-size:12px;line-height:14px;bottom:5px;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{border-color:var(--el-color-danger)}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary)}.el-input{--el-input-height:var(--el-component-size);position:relative;font-size:var(--el-font-size-base);display:inline-flex;width:100%;line-height:var(--el-input-height);box-sizing:border-box}.el-input::-webkit-scrollbar{z-index:11;width:6px}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{border-radius:5px;width:6px;background:var(--el-text-color-disabled)}.el-input::-webkit-scrollbar-corner{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);font-size:14px;cursor:pointer}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{height:100%;display:inline-flex;align-items:center;color:var(--el-color-info);font-size:12px}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);line-height:initial;display:inline-block;padding-left:8px}.el-input__wrapper{display:inline-flex;flex-grow:1;align-items:center;justify-content:center;padding:1px 11px;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);width:100%;flex-grow:1;-webkit-appearance:none;color:var(--el-input-text-color,var(--el-text-color-regular));font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);padding:0;outline:0;border:none;background:0 0;box-sizing:border-box}.el-input__inner:focus{outline:0}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__prefix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__prefix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__suffix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{height:inherit;line-height:inherit;display:flex;justify-content:center;align-items:center;transition:all var(--el-transition-duration);margin-left:8px}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color,) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{display:inline-flex;width:100%;align-items:stretch}.el-input-group__append,.el-input-group__prepend{background-color:var(--el-fill-color-light);color:var(--el-color-info);position:relative;display:inline-flex;align-items:center;justify-content:center;min-height:100%;border-radius:var(--el-input-border-radius);padding:0 20px;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:0}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-input__wrapper,.el-input-group__append div.el-select:hover .el-input__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-input__wrapper,.el-input-group__prepend div.el-select:hover .el-input__wrapper{border-color:transparent;background-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-right:0;border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper{box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important;z-index:2}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper:focus{outline:0;z-index:2;box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__wrapper{z-index:1;box-shadow:1px 0 0 0 var(--el-input-hover-border-color) inset,1px 0 0 0 var(--el-input-hover-border-color),0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}.el-input-group--append>.el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__wrapper{z-index:2;box-shadow:-1px 0 0 0 var(--el-input-focus-border-color),-1px 0 0 0 var(--el-input-focus-border-color) inset,0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__wrapper{z-index:1;box-shadow:-1px 0 0 0 var(--el-input-hover-border-color),-1px 0 0 0 var(--el-input-hover-border-color) inset,0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}.el-link{--el-link-font-size:var(--el-font-size-base);--el-link-font-weight:var(--el-font-weight-primary);--el-link-text-color:var(--el-text-color-regular);--el-link-hover-text-color:var(--el-color-primary);--el-link-disabled-text-color:var(--el-text-color-placeholder)}.el-link{display:inline-flex;flex-direction:row;align-items:center;justify-content:center;vertical-align:middle;position:relative;text-decoration:none;outline:0;cursor:pointer;padding:0;font-size:var(--el-link-font-size);font-weight:var(--el-link-font-weight);color:var(--el-link-text-color)}.el-link:hover{color:var(--el-link-hover-text-color)}.el-link.is-underline:hover:after{content:"";position:absolute;left:0;right:0;height:0;bottom:0;border-bottom:1px solid var(--el-link-hover-text-color)}.el-link.is-disabled{color:var(--el-link-disabled-text-color);cursor:not-allowed}.el-link [class*=el-icon-]+span{margin-left:5px}.el-link.el-link--default:after{border-color:var(--el-link-hover-text-color)}.el-link__inner{display:inline-flex;justify-content:center;align-items:center}.el-link.el-link--primary{--el-link-text-color:var(--el-color-primary);--el-link-hover-text-color:var(--el-color-primary-light-3);--el-link-disabled-text-color:var(--el-color-primary-light-5)}.el-link.el-link--primary:after{border-color:var(--el-link-text-color)}.el-link.el-link--primary.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--success{--el-link-text-color:var(--el-color-success);--el-link-hover-text-color:var(--el-color-success-light-3);--el-link-disabled-text-color:var(--el-color-success-light-5)}.el-link.el-link--success:after{border-color:var(--el-link-text-color)}.el-link.el-link--success.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--warning{--el-link-text-color:var(--el-color-warning);--el-link-hover-text-color:var(--el-color-warning-light-3);--el-link-disabled-text-color:var(--el-color-warning-light-5)}.el-link.el-link--warning:after{border-color:var(--el-link-text-color)}.el-link.el-link--warning.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--danger{--el-link-text-color:var(--el-color-danger);--el-link-hover-text-color:var(--el-color-danger-light-3);--el-link-disabled-text-color:var(--el-color-danger-light-5)}.el-link.el-link--danger:after{border-color:var(--el-link-text-color)}.el-link.el-link--danger.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--error{--el-link-text-color:var(--el-color-error);--el-link-hover-text-color:var(--el-color-error-light-3);--el-link-disabled-text-color:var(--el-color-error-light-5)}.el-link.el-link--error:after{border-color:var(--el-link-text-color)}.el-link.el-link--error.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--info{--el-link-text-color:var(--el-color-info);--el-link-hover-text-color:var(--el-color-info-light-3);--el-link-disabled-text-color:var(--el-color-info-light-5)}.el-link.el-link--info:after{border-color:var(--el-link-text-color)}.el-link.el-link--info.is-underline:hover:after{border-color:var(--el-link-text-color)}:root{--el-loading-spinner-size:42px;--el-loading-fullscreen-spinner-size:50px}.el-loading-parent--relative{position:relative!important;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-loading-parent--hidden{overflow:hidden!important}.el-loading-mask{position:absolute;z-index:2000;background-color:var(--el-mask-color);margin:0;top:0;right:0;bottom:0;left:0;transition:opacity var(--el-transition-duration)}.el-loading-mask.is-fullscreen{position:fixed}.el-loading-mask.is-fullscreen .el-loading-spinner{margin-top:calc((0px - var(--el-loading-fullscreen-spinner-size))/ 2)}.el-loading-mask.is-fullscreen .el-loading-spinner .circular{height:var(--el-loading-fullscreen-spinner-size);width:var(--el-loading-fullscreen-spinner-size)}.el-loading-spinner{top:50%;margin-top:calc((0px - var(--el-loading-spinner-size))/ 2);width:100%;text-align:center;position:absolute}.el-loading-spinner .el-loading-text{color:var(--el-color-primary);margin:3px 0;font-size:14px}.el-loading-spinner .circular{display:inline;height:var(--el-loading-spinner-size);width:var(--el-loading-spinner-size);-webkit-animation:loading-rotate 2s linear infinite;animation:loading-rotate 2s linear infinite}.el-loading-spinner .path{-webkit-animation:loading-dash 1.5s ease-in-out infinite;animation:loading-dash 1.5s ease-in-out infinite;stroke-dasharray:90,150;stroke-dashoffset:0;stroke-width:2;stroke:var(--el-color-primary);stroke-linecap:round}.el-loading-spinner i{color:var(--el-color-primary)}.el-loading-fade-enter-from,.el-loading-fade-leave-to{opacity:0}@-webkit-keyframes loading-rotate{100%{transform:rotate(360deg)}}@keyframes loading-rotate{100%{transform:rotate(360deg)}}@-webkit-keyframes loading-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40px}100%{stroke-dasharray:90,150;stroke-dashoffset:-120px}}@keyframes loading-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40px}100%{stroke-dasharray:90,150;stroke-dashoffset:-120px}}.el-main{--el-main-padding:20px;display:block;flex:1;flex-basis:auto;overflow:auto;box-sizing:border-box;padding:var(--el-main-padding)}:root{--el-menu-active-color:var(--el-color-primary);--el-menu-text-color:var(--el-text-color-primary);--el-menu-hover-text-color:var(--el-color-primary);--el-menu-bg-color:var(--el-fill-color-blank);--el-menu-hover-bg-color:var(--el-color-primary-light-9);--el-menu-item-height:56px;--el-menu-sub-item-height:calc(var(--el-menu-item-height) - 6px);--el-menu-horizontal-sub-item-height:36px;--el-menu-item-font-size:var(--el-font-size-base);--el-menu-item-hover-fill:var(--el-color-primary-light-9);--el-menu-border-color:var(--el-border-color);--el-menu-base-level-padding:20px;--el-menu-level-padding:20px;--el-menu-icon-width:24px}.el-menu{border-right:solid 1px var(--el-menu-border-color);list-style:none;position:relative;margin:0;padding-left:0;background-color:var(--el-menu-bg-color);box-sizing:border-box}.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-menu-item,.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-menu-item-group__title,.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-sub-menu__title{white-space:nowrap;padding-left:calc(var(--el-menu-base-level-padding) + var(--el-menu-level) * var(--el-menu-level-padding))}.el-menu--horizontal{display:flex;flex-wrap:nowrap;border-bottom:solid 1px var(--el-menu-border-color);border-right:none}.el-menu--horizontal>.el-menu-item{display:inline-flex;justify-content:center;align-items:center;height:100%;margin:0;border-bottom:2px solid transparent;color:var(--el-menu-text-color)}.el-menu--horizontal>.el-menu-item a,.el-menu--horizontal>.el-menu-item a:hover{color:inherit}.el-menu--horizontal>.el-menu-item:not(.is-disabled):focus,.el-menu--horizontal>.el-menu-item:not(.is-disabled):hover{background-color:#fff}.el-menu--horizontal>.el-sub-menu:focus,.el-menu--horizontal>.el-sub-menu:hover{outline:0}.el-menu--horizontal>.el-sub-menu:hover .el-sub-menu__title{color:var(--el-menu-hover-text-color)}.el-menu--horizontal>.el-sub-menu.is-active .el-sub-menu__title{border-bottom:2px solid var(--el-menu-active-color);color:var(--el-menu-active-color)}.el-menu--horizontal>.el-sub-menu .el-sub-menu__title{height:100%;border-bottom:2px solid transparent;color:var(--el-menu-text-color)}.el-menu--horizontal>.el-sub-menu .el-sub-menu__title:hover{background-color:var(--el-bg-color-overlay)}.el-menu--horizontal>.el-sub-menu .el-sub-menu__icon-arrow{position:static;vertical-align:middle;margin-left:8px;margin-top:-3px}.el-menu--horizontal .el-menu .el-menu-item,.el-menu--horizontal .el-menu .el-sub-menu__title{background-color:var(--el-menu-bg-color);display:flex;align-items:center;height:var(--el-menu-horizontal-sub-item-height);padding:0 10px;color:var(--el-menu-text-color)}.el-menu--horizontal .el-menu .el-sub-menu__title{padding-right:40px}.el-menu--horizontal .el-menu .el-menu-item.is-active,.el-menu--horizontal .el-menu .el-sub-menu.is-active>.el-sub-menu__title{color:var(--el-menu-active-color)}.el-menu--horizontal .el-menu-item:not(.is-disabled):focus,.el-menu--horizontal .el-menu-item:not(.is-disabled):hover{outline:0;color:var(--el-menu-hover-text-color);background-color:var(--el-menu-hover-bg-color)}.el-menu--horizontal>.el-menu-item.is-active{border-bottom:2px solid var(--el-menu-active-color);color:var(--el-menu-active-color)!important}.el-menu--collapse{width:calc(var(--el-menu-icon-width) + var(--el-menu-base-level-padding) * 2)}.el-menu--collapse>.el-menu-item [class^=el-icon],.el-menu--collapse>.el-sub-menu>.el-sub-menu__title [class^=el-icon]{margin:0;vertical-align:middle;width:var(--el-menu-icon-width);text-align:center}.el-menu--collapse>.el-menu-item .el-sub-menu__icon-arrow,.el-menu--collapse>.el-sub-menu>.el-sub-menu__title .el-sub-menu__icon-arrow{display:none}.el-menu--collapse>.el-menu-item>span,.el-menu--collapse>.el-sub-menu>.el-sub-menu__title>span{height:0;width:0;overflow:hidden;visibility:hidden;display:inline-block}.el-menu--collapse>.el-menu-item.is-active i{color:inherit}.el-menu--collapse .el-menu .el-sub-menu{min-width:200px}.el-menu--collapse .el-sub-menu{position:relative}.el-menu--collapse .el-sub-menu .el-menu{position:absolute;margin-left:5px;top:0;left:100%;z-index:10;border:1px solid var(--el-border-color-light);border-radius:var(--el-border-radius-small);box-shadow:var(--el-box-shadow-light)}.el-menu--collapse .el-sub-menu.is-active .el-sub-menu__title{color:var(--el-menu-active-color)}.el-menu--popup{z-index:100;min-width:200px;border:none;padding:5px 0;border-radius:var(--el-border-radius-small);box-shadow:var(--el-box-shadow-light)}.el-menu .el-icon{flex-shrink:0}.el-menu-item{display:flex;align-items:center;height:var(--el-menu-item-height);line-height:var(--el-menu-item-height);font-size:var(--el-menu-item-font-size);color:var(--el-menu-text-color);padding:0 var(--el-menu-base-level-padding);list-style:none;cursor:pointer;position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration),color var(--el-transition-duration);box-sizing:border-box;white-space:nowrap}.el-menu-item *{vertical-align:bottom}.el-menu-item i{color:inherit}.el-menu-item:focus,.el-menu-item:hover{outline:0}.el-menu-item:hover{background-color:var(--el-menu-hover-bg-color)}.el-menu-item.is-disabled{opacity:.25;cursor:not-allowed;background:0 0!important}.el-menu-item [class^=el-icon]{margin-right:5px;width:var(--el-menu-icon-width);text-align:center;font-size:18px;vertical-align:middle}.el-menu-item.is-active{color:var(--el-menu-active-color)}.el-menu-item.is-active i{color:inherit}.el-menu-item .el-menu-tooltip__trigger{position:absolute;left:0;top:0;height:100%;width:100%;display:inline-flex;align-items:center;box-sizing:border-box;padding:0 var(--el-menu-base-level-padding)}.el-sub-menu{list-style:none;margin:0;padding-left:0}.el-sub-menu__title{display:flex;align-items:center;height:var(--el-menu-item-height);line-height:var(--el-menu-item-height);font-size:var(--el-menu-item-font-size);color:var(--el-menu-text-color);padding:0 var(--el-menu-base-level-padding);list-style:none;cursor:pointer;position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration),color var(--el-transition-duration);box-sizing:border-box;white-space:nowrap}.el-sub-menu__title *{vertical-align:bottom}.el-sub-menu__title i{color:inherit}.el-sub-menu__title:focus,.el-sub-menu__title:hover{outline:0}.el-sub-menu__title:hover{background-color:var(--el-menu-hover-bg-color)}.el-sub-menu__title.is-disabled{opacity:.25;cursor:not-allowed;background:0 0!important}.el-sub-menu__title:hover{background-color:var(--el-menu-hover-bg-color)}.el-sub-menu .el-menu{border:none}.el-sub-menu .el-menu-item{height:var(--el-menu-sub-item-height);line-height:var(--el-menu-sub-item-height);min-width:200px}.el-sub-menu__hide-arrow .el-sub-menu__icon-arrow{display:none!important}.el-sub-menu.is-active .el-sub-menu__title{border-bottom-color:var(--el-menu-active-color)}.el-sub-menu.is-disabled .el-menu-item,.el-sub-menu.is-disabled .el-sub-menu__title{opacity:.25;cursor:not-allowed;background:0 0!important}.el-sub-menu .el-icon{vertical-align:middle;margin-right:5px;width:var(--el-menu-icon-width);text-align:center;font-size:18px}.el-sub-menu .el-icon.el-sub-menu__icon-more{margin-right:0!important}.el-sub-menu .el-sub-menu__icon-arrow{position:absolute;top:50%;right:var(--el-menu-base-level-padding);margin-top:-7px;transition:transform var(--el-transition-duration);font-size:12px;margin-right:0;width:inherit}.el-menu-item-group>ul{padding:0}.el-menu-item-group__title{padding:7px 0 7px var(--el-menu-base-level-padding);line-height:normal;font-size:12px;color:var(--el-text-color-secondary)}.horizontal-collapse-transition .el-sub-menu__title .el-sub-menu__icon-arrow{transition:var(--el-transition-duration-fast);opacity:0}.el-message-box{--el-messagebox-title-color:var(--el-text-color-primary);--el-messagebox-width:420px;--el-messagebox-border-radius:4px;--el-messagebox-font-size:var(--el-font-size-large);--el-messagebox-content-font-size:var(--el-font-size-base);--el-messagebox-content-color:var(--el-text-color-regular);--el-messagebox-error-font-size:12px;--el-messagebox-padding-primary:15px}.el-message-box{display:inline-block;max-width:var(--el-messagebox-width);width:100%;padding-bottom:10px;vertical-align:middle;background-color:var(--el-bg-color);border-radius:var(--el-messagebox-border-radius);border:1px solid var(--el-border-color-lighter);font-size:var(--el-messagebox-font-size);box-shadow:var(--el-box-shadow-light);text-align:left;overflow:hidden;-webkit-backface-visibility:hidden;backface-visibility:hidden}.el-message-box:focus{outline:0!important}.el-overlay.is-message-box .el-overlay-message-box{text-align:center;position:fixed;top:0;right:0;bottom:0;left:0;padding:16px;overflow:auto}.el-overlay.is-message-box .el-overlay-message-box::after{content:"";display:inline-block;height:100%;width:0;vertical-align:middle}.el-message-box.is-draggable .el-message-box__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-message-box__header{position:relative;padding:var(--el-messagebox-padding-primary);padding-bottom:10px}.el-message-box__title{padding-left:0;margin-bottom:0;font-size:var(--el-messagebox-font-size);line-height:1;color:var(--el-messagebox-title-color)}.el-message-box__headerbtn{position:absolute;top:var(--el-messagebox-padding-primary);right:var(--el-messagebox-padding-primary);padding:0;border:none;outline:0;background:0 0;font-size:var(--el-message-close-size,16px);cursor:pointer}.el-message-box__headerbtn .el-message-box__close{color:var(--el-color-info);font-size:inherit}.el-message-box__headerbtn:focus .el-message-box__close,.el-message-box__headerbtn:hover .el-message-box__close{color:var(--el-color-primary)}.el-message-box__content{padding:10px var(--el-messagebox-padding-primary);color:var(--el-messagebox-content-color);font-size:var(--el-messagebox-content-font-size)}.el-message-box__container{position:relative}.el-message-box__input{padding-top:15px}.el-message-box__input div.invalid>input{border-color:var(--el-color-error)}.el-message-box__input div.invalid>input:focus{border-color:var(--el-color-error)}.el-message-box__status{position:absolute;top:50%;transform:translateY(-50%);font-size:24px!important}.el-message-box__status::before{padding-left:1px}.el-message-box__status.el-icon{position:absolute}.el-message-box__status+.el-message-box__message{padding-left:36px;padding-right:12px;word-break:break-word}.el-message-box__status.el-message-box-icon--success{--el-messagebox-color:var(--el-color-success);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--info{--el-messagebox-color:var(--el-color-info);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--warning{--el-messagebox-color:var(--el-color-warning);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--error{--el-messagebox-color:var(--el-color-error);color:var(--el-messagebox-color)}.el-message-box__message{margin:0}.el-message-box__message p{margin:0;line-height:24px}.el-message-box__errormsg{color:var(--el-color-error);font-size:var(--el-messagebox-error-font-size);min-height:18px;margin-top:2px}.el-message-box__btns{padding:5px 15px 0;display:flex;flex-wrap:wrap;justify-content:flex-end;align-items:center}.el-message-box__btns button:nth-child(2){margin-left:10px}.el-message-box__btns-reverse{flex-direction:row-reverse}.el-message-box--center .el-message-box__title{position:relative;display:flex;align-items:center;justify-content:center}.el-message-box--center .el-message-box__status{position:relative;top:auto;padding-right:5px;text-align:center;transform:translateY(-1px)}.el-message-box--center .el-message-box__message{margin-left:0}.el-message-box--center .el-message-box__btns{justify-content:center}.el-message-box--center .el-message-box__content{padding-left:calc(var(--el-messagebox-padding-primary) + 12px);padding-right:calc(var(--el-messagebox-padding-primary) + 12px);text-align:center}.fade-in-linear-enter-active .el-overlay-message-box{-webkit-animation:msgbox-fade-in var(--el-transition-duration);animation:msgbox-fade-in var(--el-transition-duration)}.fade-in-linear-leave-active .el-overlay-message-box{animation:msgbox-fade-in var(--el-transition-duration) reverse}@-webkit-keyframes msgbox-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@keyframes msgbox-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@-webkit-keyframes msgbox-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}@keyframes msgbox-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}.el-message{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-border-color-lighter);--el-message-padding:15px 19px;--el-message-close-size:16px;--el-message-close-icon-color:var(--el-text-color-placeholder);--el-message-close-hover-color:var(--el-text-color-secondary)}.el-message{width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;max-width:calc(100% - 32px);box-sizing:border-box;border-radius:var(--el-border-radius-base);border-width:var(--el-border-width);border-style:var(--el-border-style);border-color:var(--el-message-border-color);position:fixed;left:50%;top:20px;transform:translateX(-50%);background-color:var(--el-message-bg-color);transition:opacity var(--el-transition-duration),transform .4s,top .4s;padding:var(--el-message-padding);display:flex;align-items:center}.el-message.is-center{justify-content:center}.el-message.is-closable .el-message__content{padding-right:31px}.el-message p{margin:0}.el-message--success{--el-message-bg-color:var(--el-color-success-light-9);--el-message-border-color:var(--el-color-success-light-8);--el-message-text-color:var(--el-color-success)}.el-message--success .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--success{color:var(--el-message-text-color)}.el-message--info{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-color-info-light-8);--el-message-text-color:var(--el-color-info)}.el-message--info .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--info{color:var(--el-message-text-color)}.el-message--warning{--el-message-bg-color:var(--el-color-warning-light-9);--el-message-border-color:var(--el-color-warning-light-8);--el-message-text-color:var(--el-color-warning)}.el-message--warning .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--warning{color:var(--el-message-text-color)}.el-message--error{--el-message-bg-color:var(--el-color-error-light-9);--el-message-border-color:var(--el-color-error-light-8);--el-message-text-color:var(--el-color-error)}.el-message--error .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--error{color:var(--el-message-text-color)}.el-message__icon{margin-right:10px}.el-message .el-message__badge{position:absolute;top:-8px;right:-8px}.el-message__content{padding:0;font-size:14px;line-height:1}.el-message__content:focus{outline-width:0}.el-message .el-message__closeBtn{position:absolute;top:50%;right:19px;transform:translateY(-50%);cursor:pointer;color:var(--el-message-close-icon-color);font-size:var(--el-message-close-size)}.el-message .el-message__closeBtn:focus{outline-width:0}.el-message .el-message__closeBtn:hover{color:var(--el-message-close-hover-color)}.el-message-fade-enter-from,.el-message-fade-leave-to{opacity:0;transform:translate(-50%,-100%)}.el-notification{--el-notification-width:330px;--el-notification-padding:14px 26px 14px 13px;--el-notification-radius:8px;--el-notification-shadow:var(--el-box-shadow-light);--el-notification-border-color:var(--el-border-color-lighter);--el-notification-icon-size:24px;--el-notification-close-font-size:var(--el-message-close-size, 16px);--el-notification-group-margin-left:13px;--el-notification-group-margin-right:8px;--el-notification-content-font-size:var(--el-font-size-base);--el-notification-content-color:var(--el-text-color-regular);--el-notification-title-font-size:16px;--el-notification-title-color:var(--el-text-color-primary);--el-notification-close-color:var(--el-text-color-secondary);--el-notification-close-hover-color:var(--el-text-color-regular)}.el-notification{display:flex;width:var(--el-notification-width);padding:var(--el-notification-padding);border-radius:var(--el-notification-radius);box-sizing:border-box;border:1px solid var(--el-notification-border-color);position:fixed;background-color:var(--el-bg-color-overlay);box-shadow:var(--el-notification-shadow);transition:opacity var(--el-transition-duration),transform var(--el-transition-duration),left var(--el-transition-duration),right var(--el-transition-duration),top .4s,bottom var(--el-transition-duration);overflow-wrap:anywhere;overflow:hidden;z-index:9999}.el-notification.right{right:16px}.el-notification.left{left:16px}.el-notification__group{margin-left:var(--el-notification-group-margin-left);margin-right:var(--el-notification-group-margin-right)}.el-notification__title{font-weight:700;font-size:var(--el-notification-title-font-size);line-height:var(--el-notification-icon-size);color:var(--el-notification-title-color);margin:0}.el-notification__content{font-size:var(--el-notification-content-font-size);line-height:24px;margin:6px 0 0;color:var(--el-notification-content-color);text-align:justify}.el-notification__content p{margin:0}.el-notification .el-notification__icon{height:var(--el-notification-icon-size);width:var(--el-notification-icon-size);font-size:var(--el-notification-icon-size)}.el-notification .el-notification__closeBtn{position:absolute;top:18px;right:15px;cursor:pointer;color:var(--el-notification-close-color);font-size:var(--el-notification-close-font-size)}.el-notification .el-notification__closeBtn:hover{color:var(--el-notification-close-hover-color)}.el-notification .el-notification--success{--el-notification-icon-color:var(--el-color-success);color:var(--el-notification-icon-color)}.el-notification .el-notification--info{--el-notification-icon-color:var(--el-color-info);color:var(--el-notification-icon-color)}.el-notification .el-notification--warning{--el-notification-icon-color:var(--el-color-warning);color:var(--el-notification-icon-color)}.el-notification .el-notification--error{--el-notification-icon-color:var(--el-color-error);color:var(--el-notification-icon-color)}.el-notification-fade-enter-from.right{right:0;transform:translateX(100%)}.el-notification-fade-enter-from.left{left:0;transform:translateX(-100%)}.el-notification-fade-leave-to{opacity:0}.el-overlay{position:fixed;top:0;right:0;bottom:0;left:0;z-index:2000;height:100%;background-color:var(--el-overlay-color-lighter);overflow:auto}.el-overlay .el-overlay-root{height:0}.el-page-header.is-contentful .el-page-header__main{border-top:1px solid var(--el-border-color-light);margin-top:16px}.el-page-header__header{display:flex;align-items:center;justify-content:space-between;line-height:24px}.el-page-header__left{display:flex;align-items:center;margin-right:40px;position:relative}.el-page-header__back{display:flex;align-items:center;cursor:pointer}.el-page-header__left .el-divider--vertical{margin:0 16px}.el-page-header__icon{font-size:16px;margin-right:10px;display:flex;align-items:center}.el-page-header__icon .el-icon{font-size:inherit}.el-page-header__title{font-size:14px;font-weight:500}.el-page-header__content{font-size:18px;color:var(--el-text-color-primary)}.el-page-header__breadcrumb{margin-bottom:16px}.el-pagination{--el-pagination-font-size:14px;--el-pagination-bg-color:var(--el-fill-color-blank);--el-pagination-text-color:var(--el-text-color-primary);--el-pagination-border-radius:3px;--el-pagination-button-color:var(--el-text-color-primary);--el-pagination-button-width:32px;--el-pagination-button-height:32px;--el-pagination-button-disabled-color:var(--el-text-color-placeholder);--el-pagination-button-disabled-bg-color:var(--el-fill-color-blank);--el-pagination-button-bg-color:var(--el-fill-color);--el-pagination-hover-color:var(--el-color-primary);--el-pagination-height-extra-small:24px;--el-pagination-line-height-extra-small:var(--el-pagination-height-extra-small);white-space:nowrap;padding:2px 5px;color:var(--el-pagination-text-color);font-weight:400;display:flex;align-items:center}.el-pagination::after,.el-pagination::before{display:table;content:""}.el-pagination::after{clear:both}.el-pagination button,.el-pagination span:not([class*=suffix]){display:flex;justify-content:center;align-items:center;font-size:var(--el-pagination-font-size);min-width:var(--el-pagination-button-width);height:var(--el-pagination-button-height);line-height:var(--el-pagination-button-height);box-sizing:border-box}.el-pagination .el-input__inner{text-align:center;-moz-appearance:textfield;line-height:normal}.el-pagination .el-select .el-input{width:128px}.el-pagination button{border:none;padding:0 6px;background:0 0}.el-pagination button:focus{outline:0}.el-pagination button:hover{color:var(--el-pagination-hover-color)}.el-pagination button:disabled{color:var(--el-pagination-button-disabled-color);background-color:var(--el-pagination-button-disabled-bg-color);cursor:not-allowed}.el-pagination .btn-next,.el-pagination .btn-prev{background:center center no-repeat;background-size:16px;background-color:var(--el-pagination-bg-color);cursor:pointer;margin:0;color:var(--el-pagination-button-color)}.el-pagination .btn-next .el-icon,.el-pagination .btn-prev .el-icon{display:block;font-size:12px;font-weight:700;width:inherit}.el-pagination .btn-next:focus-visible,.el-pagination .btn-prev:focus-visible{outline:1px solid var(--el-pagination-hover-color);color:var(--el-pagination-hover-color)}.el-pagination .el-pager li.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-pagination--small .btn-next,.el-pagination--small .btn-prev,.el-pagination--small .el-pager li,.el-pagination--small .el-pager li.btn-quicknext,.el-pagination--small .el-pager li.btn-quickprev,.el-pagination--small .el-pager li:last-child{border-color:transparent;font-size:var(--el-font-size-extra-small);line-height:var(--el-pagination-line-height-extra-small);height:var(--el-pagination-height-extra-small);min-width:24px}.el-pagination--small .arrow.is-disabled{visibility:hidden}.el-pagination--small .more::before,.el-pagination--small li.more::before{line-height:var(--el-pagination-line-height-extra-small)}.el-pagination--small button,.el-pagination--small span:not([class*=suffix]){height:var(--el-pagination-height-extra-small);line-height:var(--el-pagination-line-height-extra-small);font-size:var(--el-font-size-extra-small)}.el-pagination--small .el-pagination__editor{height:var(--el-pagination-line-height-extra-small)}.el-pagination--small .el-pagination__editor.el-input .el-input__inner{height:var(--el-pagination-height-extra-small)}.el-pagination--small .el-input--small,.el-pagination--small .el-input__inner{height:var(--el-pagination-height-extra-small)!important;line-height:var(--el-pagination-line-height-extra-small)}.el-pagination--small .el-input__suffix{line-height:var(--el-pagination-line-height-extra-small)}.el-pagination--small .el-input__suffix .el-input__suffix-inner{line-height:var(--el-pagination-line-height-extra-small)}.el-pagination--small .el-input__suffix .el-input__suffix-inner i.el-select__caret{line-height:var(--el-pagination-line-height-extra-small)}.el-pagination--small .el-select .el-input{width:100px}.el-pagination__sizes{margin:0 16px 0 0;font-weight:400;color:var(--el-text-color-regular)}.el-pagination__sizes+button.btn-prev[type=button]{margin-left:0}.el-pagination__sizes+.el-pager .number:first-child{margin-left:0}.el-pagination__sizes+.el-pager .number:last-child{margin-right:0}.el-pagination__total{margin-right:16px;font-weight:400;color:var(--el-text-color-regular)}.el-pagination__total+button.btn-prev[type=button]{margin-left:0}.el-pagination__total+.el-pager .number:first-child{margin-left:0}.el-pagination__total+.el-pager .number:last-child{margin-right:0}.el-pagination__total[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__jump{margin-left:16px;font-weight:400;color:var(--el-text-color-regular)}.el-pagination__jump .el-input__inner{padding:0 3px}.el-pagination__jump[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__rightwrapper{flex:1;display:flex;align-items:center;justify-content:flex-end}.el-pagination__editor{line-height:18px;margin:0 8px;height:var(--el-pagination-button-height);min-width:56px;text-align:center;box-sizing:border-box;border-radius:var(--el-pagination-border-radius)}.el-pagination__editor.el-input{width:50px}.el-pagination__editor.el-input .el-input__inner{height:var(--el-pagination-button-height)}.el-pagination__editor .el-input__inner::-webkit-inner-spin-button,.el-pagination__editor .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-pagination.is-background .btn-next,.el-pagination.is-background .btn-prev,.el-pagination.is-background .el-pager li{margin:0 4px;background-color:var(--el-pagination-button-bg-color);color:var(--el-text-color-regular);min-width:32px;border-radius:2px}.el-pagination.is-background .btn-next.is-disabled,.el-pagination.is-background .btn-prev.is-disabled,.el-pagination.is-background .el-pager li.is-disabled{color:var(--el-text-color-placeholder);background-color:var(--el-disabled-bg-color)}.el-pagination.is-background .btn-next.is-disabled.is-active,.el-pagination.is-background .btn-prev.is-disabled.is-active,.el-pagination.is-background .el-pager li.is-disabled.is-active{color:var(--el-text-color-secondary);background-color:var(--el-fill-color-dark)}.el-pagination.is-background .btn-next.is-first,.el-pagination.is-background .btn-prev.is-first,.el-pagination.is-background .el-pager li.is-first{margin-left:0}.el-pagination.is-background .btn-next.is-last,.el-pagination.is-background .btn-prev.is-last,.el-pagination.is-background .el-pager li.is-last{margin-right:0}.el-pagination.is-background .btn-next,.el-pagination.is-background .btn-prev{padding:0}.el-pagination.is-background .btn-next:disabled,.el-pagination.is-background .btn-prev:disabled{color:var(--el-text-color-placeholder);background-color:var(--el-disabled-bg-color)}.el-pagination.is-background .btn-next:hover:not([disabled]),.el-pagination.is-background .btn-prev:hover:not([disabled]){color:var(--el-pagination-hover-color)}.el-pagination.is-background .el-pager li:not(.is-disabled):hover{color:var(--el-pagination-hover-color)}.el-pagination.is-background .el-pager li:not(.is-disabled).is-active{background-color:var(--el-color-primary);color:var(--el-color-white);font-weight:700}.el-pagination.is-background.el-pagination--small .btn-next,.el-pagination.is-background.el-pagination--small .btn-prev,.el-pagination.is-background.el-pagination--small .el-pager li{min-width:24px}.el-pagination.is-background .el-pagination__sizes.is-last{margin-left:16px}.el-pager{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;list-style:none;font-size:0;padding:0;margin:0;display:flex;align-items:center}.el-pager li{padding:0 4px;background:var(--el-pagination-bg-color);display:flex;justify-content:center;align-items:center;font-size:var(--el-pagination-font-size);min-width:var(--el-pagination-button-width);height:var(--el-pagination-button-height);line-height:var(--el-pagination-button-height);box-sizing:border-box;cursor:pointer;text-align:center;margin:0 1px}.el-pager li.btn-quickprev:hover{cursor:pointer}.el-pager li.btn-quicknext:hover{cursor:pointer}.el-pager li.btn-quicknext,.el-pager li.btn-quickprev{line-height:32px;color:var(--el-pagination-button-color)}.el-pager li.btn-quicknext.is-disabled,.el-pager li.btn-quickprev.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-pager li.btn-quicknext svg,.el-pager li.btn-quickprev svg{pointer-events:none}.el-pager li.btn-quicknext:focus-visible,.el-pager li.btn-quickprev:focus-visible{outline:1px solid var(--el-pagination-hover-color);color:var(--el-pagination-hover-color)}.el-pager li.is-active+li{border-left:0}.el-pager li:focus-visible{outline:1px solid var(--el-pagination-hover-color)}.el-pager li:hover{color:var(--el-pagination-hover-color)}.el-pager li.is-active{color:var(--el-pagination-hover-color);cursor:default}.el-pager li.is-active.is-disabled{font-weight:700;color:var(--el-text-color-secondary)}.el-pager+button.btn-next[type=button]{margin-right:0}.el-popconfirm__main{display:flex;align-items:center}.el-popconfirm__icon{margin-right:5px}.el-popconfirm__action{text-align:right;margin-top:8px}.el-popover{--el-popover-bg-color:var(--el-bg-color-overlay);--el-popover-font-size:var(--el-font-size-base);--el-popover-border-color:var(--el-border-color-lighter);--el-popover-padding:12px;--el-popover-padding-large:18px 20px;--el-popover-title-font-size:16px;--el-popover-title-text-color:var(--el-text-color-primary);--el-popover-border-radius:4px}.el-popover.el-popper{background:var(--el-popover-bg-color);min-width:150px;border-radius:var(--el-popover-border-radius);border:1px solid var(--el-popover-border-color);padding:var(--el-popover-padding);z-index:var(--el-index-popper);color:var(--el-text-color-regular);line-height:1.4;text-align:justify;font-size:var(--el-popover-font-size);box-shadow:var(--el-box-shadow-light);word-break:break-all;box-sizing:border-box}.el-popover.el-popper--plain{padding:var(--el-popover-padding-large)}.el-popover__title{color:var(--el-popover-title-text-color);font-size:var(--el-popover-title-font-size);line-height:1;margin-bottom:12px}.el-popover__reference:focus:hover,.el-popover__reference:focus:not(.focusing){outline-width:0}.el-popover.el-popper.is-dark{--el-popover-title-text-color:var(--el-bg-color)}.el-popover.el-popper:focus,.el-popover.el-popper:focus:active{outline-width:0}.el-progress{position:relative;line-height:1;display:flex;align-items:center}.el-progress__text{font-size:14px;color:var(--el-text-color-regular);margin-left:5px;min-width:50px;line-height:1}.el-progress__text i{vertical-align:middle;display:block}.el-progress--circle,.el-progress--dashboard{display:inline-block}.el-progress--circle .el-progress__text,.el-progress--dashboard .el-progress__text{position:absolute;top:50%;left:0;width:100%;text-align:center;margin:0;transform:translate(0,-50%)}.el-progress--circle .el-progress__text i,.el-progress--dashboard .el-progress__text i{vertical-align:middle;display:inline-block}.el-progress--without-text .el-progress__text{display:none}.el-progress--without-text .el-progress-bar{padding-right:0;margin-right:0;display:block}.el-progress--text-inside .el-progress-bar{padding-right:0;margin-right:0}.el-progress.is-success .el-progress-bar__inner{background-color:var(--el-color-success)}.el-progress.is-success .el-progress__text{color:var(--el-color-success)}.el-progress.is-warning .el-progress-bar__inner{background-color:var(--el-color-warning)}.el-progress.is-warning .el-progress__text{color:var(--el-color-warning)}.el-progress.is-exception .el-progress-bar__inner{background-color:var(--el-color-danger)}.el-progress.is-exception .el-progress__text{color:var(--el-color-danger)}.el-progress-bar{flex-grow:1;box-sizing:border-box}.el-progress-bar__outer{height:6px;border-radius:100px;background-color:var(--el-border-color-lighter);overflow:hidden;position:relative;vertical-align:middle}.el-progress-bar__inner{position:absolute;left:0;top:0;height:100%;background-color:var(--el-color-primary);text-align:right;border-radius:100px;line-height:1;white-space:nowrap;transition:width .6s ease}.el-progress-bar__inner::after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-progress-bar__inner--indeterminate{transform:translateZ(0);-webkit-animation:indeterminate 3s infinite;animation:indeterminate 3s infinite}.el-progress-bar__innerText{display:inline-block;vertical-align:middle;color:#fff;font-size:12px;margin:0 5px}@-webkit-keyframes progress{0%{background-position:0 0}100%{background-position:32px 0}}@keyframes progress{0%{background-position:0 0}100%{background-position:32px 0}}@-webkit-keyframes indeterminate{0%{left:-100%}100%{left:100%}}@keyframes indeterminate{0%{left:-100%}100%{left:100%}}.el-radio-button{--el-radio-button-checked-bg-color:var(--el-color-primary);--el-radio-button-checked-text-color:var(--el-color-white);--el-radio-button-checked-border-color:var(--el-color-primary);--el-radio-button-disabled-checked-fill:var(--el-border-color-extra-light)}.el-radio-button{position:relative;display:inline-block;outline:0}.el-radio-button__inner{display:inline-block;line-height:1;white-space:nowrap;vertical-align:middle;background:var(--el-button-bg-color,var(--el-fill-color-blank));border:var(--el-border);font-weight:var(--el-button-font-weight,var(--el-font-weight-primary));border-left:0;color:var(--el-button-text-color,var(--el-text-color-regular));-webkit-appearance:none;text-align:center;box-sizing:border-box;outline:0;margin:0;position:relative;cursor:pointer;transition:var(--el-transition-all);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;padding:8px 15px;font-size:var(--el-font-size-base);border-radius:0}.el-radio-button__inner.is-round{padding:8px 15px}.el-radio-button__inner:hover{color:var(--el-color-primary)}.el-radio-button__inner [class*=el-icon-]{line-height:.9}.el-radio-button__inner [class*=el-icon-]+span{margin-left:5px}.el-radio-button:first-child .el-radio-button__inner{border-left:var(--el-border);border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);box-shadow:none!important}.el-radio-button__original-radio{opacity:0;outline:0;position:absolute;z-index:-1}.el-radio-button__original-radio:checked+.el-radio-button__inner{color:var(--el-radio-button-checked-text-color,var(--el-color-white));background-color:var(--el-radio-button-checked-bg-color,var(--el-color-primary));border-color:var(--el-radio-button-checked-border-color,var(--el-color-primary));box-shadow:-1px 0 0 0 var(--el-radio-button-checked-border-color,var(--el-color-primary))}.el-radio-button__original-radio:focus-visible+.el-radio-button__inner{border-left:var(--el-border);border-left-color:var(--el-radio-button-checked-border-color,var(--el-color-primary));outline:2px solid var(--el-radio-button-checked-border-color);outline-offset:1px;z-index:2;border-radius:var(--el-border-radius-base);box-shadow:none}.el-radio-button__original-radio:disabled+.el-radio-button__inner{color:var(--el-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--el-button-disabled-bg-color,var(--el-fill-color-blank));border-color:var(--el-button-disabled-border-color,var(--el-border-color-light));box-shadow:none}.el-radio-button__original-radio:disabled:checked+.el-radio-button__inner{background-color:var(--el-radio-button-disabled-checked-fill)}.el-radio-button:last-child .el-radio-button__inner{border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0}.el-radio-button:first-child:last-child .el-radio-button__inner{border-radius:var(--el-border-radius-base)}.el-radio-button--large .el-radio-button__inner{padding:12px 19px;font-size:var(--el-font-size-base);border-radius:0}.el-radio-button--large .el-radio-button__inner.is-round{padding:12px 19px}.el-radio-button--small .el-radio-button__inner{padding:5px 11px;font-size:12px;border-radius:0}.el-radio-button--small .el-radio-button__inner.is-round{padding:5px 11px}.el-radio-group{display:inline-flex;align-items:center;flex-wrap:wrap;font-size:0}.el-radio{--el-radio-font-size:var(--el-font-size-base);--el-radio-text-color:var(--el-text-color-regular);--el-radio-font-weight:var(--el-font-weight-primary);--el-radio-input-height:14px;--el-radio-input-width:14px;--el-radio-input-border-radius:var(--el-border-radius-circle);--el-radio-input-bg-color:var(--el-fill-color-blank);--el-radio-input-border:var(--el-border);--el-radio-input-border-color:var(--el-border-color);--el-radio-input-border-color-hover:var(--el-color-primary)}.el-radio{color:var(--el-radio-text-color);font-weight:var(--el-radio-font-weight);position:relative;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;outline:0;font-size:var(--el-font-size-base);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-right:32px;height:32px}.el-radio.el-radio--large{height:40px}.el-radio.el-radio--small{height:24px}.el-radio.is-bordered{padding:0 15px 0 9px;border-radius:var(--el-border-radius-base);border:var(--el-border);box-sizing:border-box}.el-radio.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-radio.is-bordered.is-disabled{cursor:not-allowed;border-color:var(--el-border-color-lighter)}.el-radio.is-bordered.el-radio--large{padding:0 19px 0 11px;border-radius:var(--el-border-radius-base)}.el-radio.is-bordered.el-radio--large .el-radio__label{font-size:var(--el-font-size-base)}.el-radio.is-bordered.el-radio--large .el-radio__inner{height:14px;width:14px}.el-radio.is-bordered.el-radio--small{padding:0 11px 0 7px;border-radius:var(--el-border-radius-base)}.el-radio.is-bordered.el-radio--small .el-radio__label{font-size:12px}.el-radio.is-bordered.el-radio--small .el-radio__inner{height:12px;width:12px}.el-radio:last-child{margin-right:0}.el-radio__input{white-space:nowrap;cursor:pointer;outline:0;display:inline-flex;position:relative;vertical-align:middle}.el-radio__input.is-disabled .el-radio__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);cursor:not-allowed}.el-radio__input.is-disabled .el-radio__inner::after{cursor:not-allowed;background-color:var(--el-disabled-bg-color)}.el-radio__input.is-disabled .el-radio__inner+.el-radio__label{cursor:not-allowed}.el-radio__input.is-disabled.is-checked .el-radio__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color)}.el-radio__input.is-disabled.is-checked .el-radio__inner::after{background-color:var(--el-text-color-placeholder)}.el-radio__input.is-disabled+span.el-radio__label{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-radio__input.is-checked .el-radio__inner{border-color:var(--el-color-primary);background:var(--el-color-primary)}.el-radio__input.is-checked .el-radio__inner::after{transform:translate(-50%,-50%) scale(1)}.el-radio__input.is-checked+.el-radio__label{color:var(--el-color-primary)}.el-radio__input.is-focus .el-radio__inner{border-color:var(--el-radio-input-border-color-hover)}.el-radio__inner{border:var(--el-radio-input-border);border-radius:var(--el-radio-input-border-radius);width:var(--el-radio-input-width);height:var(--el-radio-input-height);background-color:var(--el-radio-input-bg-color);position:relative;cursor:pointer;display:inline-block;box-sizing:border-box}.el-radio__inner:hover{border-color:var(--el-radio-input-border-color-hover)}.el-radio__inner::after{width:4px;height:4px;border-radius:var(--el-radio-input-border-radius);background-color:var(--el-color-white);content:"";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) scale(0);transition:transform .15s ease-in}.el-radio__original{opacity:0;outline:0;position:absolute;z-index:-1;top:0;left:0;right:0;bottom:0;margin:0}.el-radio__original:focus-visible+.el-radio__inner{outline:2px solid var(--el-radio-input-border-color-hover);outline-offset:1px;border-radius:var(--el-radio-input-border-radius)}.el-radio:focus:not(:focus-visible):not(.is-focus):not(:active):not(.is-disabled) .el-radio__inner{box-shadow:0 0 2px 2px var(--el-radio-input-border-color-hover)}.el-radio__label{font-size:var(--el-radio-font-size);padding-left:8px}.el-radio.el-radio--large .el-radio__label{font-size:14px}.el-radio.el-radio--large .el-radio__inner{width:14px;height:14px}.el-radio.el-radio--small .el-radio__label{font-size:12px}.el-radio.el-radio--small .el-radio__inner{width:12px;height:12px}.el-rate{--el-rate-height:20px;--el-rate-font-size:var(--el-font-size-base);--el-rate-icon-size:18px;--el-rate-icon-margin:6px;--el-rate-void-color:var(--el-border-color-darker);--el-rate-fill-color:#f7ba2a;--el-rate-disabled-void-color:var(--el-fill-color);--el-rate-text-color:var(--el-text-color-primary)}.el-rate{display:inline-flex;align-items:center;height:32px}.el-rate:active,.el-rate:focus{outline:0}.el-rate__item{cursor:pointer;display:inline-block;position:relative;font-size:0;vertical-align:middle;color:var(--el-rate-void-color);line-height:normal}.el-rate .el-rate__icon{position:relative;display:inline-block;font-size:var(--el-rate-icon-size);margin-right:var(--el-rate-icon-margin);transition:var(--el-transition-duration)}.el-rate .el-rate__icon.hover{transform:scale(1.15)}.el-rate .el-rate__icon .path2{position:absolute;left:0;top:0}.el-rate .el-rate__icon.is-active{color:var(--el-rate-fill-color)}.el-rate__decimal{position:absolute;top:0;left:0;display:inline-block;overflow:hidden;color:var(--el-rate-fill-color)}.el-rate__text{font-size:var(--el-rate-font-size);vertical-align:middle;color:var(--el-rate-text-color)}.el-rate--large{height:40px}.el-rate--small{height:24px}.el-rate.is-disabled .el-rate__item{cursor:auto;color:var(--el-rate-disabled-void-color)}.el-result{--el-result-padding:40px 30px;--el-result-icon-font-size:64px;--el-result-title-font-size:20px;--el-result-title-margin-top:20px;--el-result-subtitle-margin-top:10px;--el-result-extra-margin-top:30px}.el-result{display:flex;justify-content:center;align-items:center;flex-direction:column;text-align:center;box-sizing:border-box;padding:var(--el-result-padding)}.el-result__icon svg{width:var(--el-result-icon-font-size);height:var(--el-result-icon-font-size)}.el-result__title{margin-top:var(--el-result-title-margin-top)}.el-result__title p{margin:0;font-size:var(--el-result-title-font-size);color:var(--el-text-color-primary);line-height:1.3}.el-result__subtitle{margin-top:var(--el-result-subtitle-margin-top)}.el-result__subtitle p{margin:0;font-size:var(--el-font-size-base);color:var(--el-text-color-regular);line-height:1.3}.el-result__extra{margin-top:var(--el-result-extra-margin-top)}.el-result .icon-primary{--el-result-color:var(--el-color-primary);color:var(--el-result-color)}.el-result .icon-success{--el-result-color:var(--el-color-success);color:var(--el-result-color)}.el-result .icon-warning{--el-result-color:var(--el-color-warning);color:var(--el-result-color)}.el-result .icon-danger{--el-result-color:var(--el-color-danger);color:var(--el-result-color)}.el-result .icon-error{--el-result-color:var(--el-color-error);color:var(--el-result-color)}.el-result .icon-info{--el-result-color:var(--el-color-info);color:var(--el-result-color)}.el-row{display:flex;flex-wrap:wrap;position:relative;box-sizing:border-box}.el-row.is-justify-center{justify-content:center}.el-row.is-justify-end{justify-content:flex-end}.el-row.is-justify-space-between{justify-content:space-between}.el-row.is-justify-space-around{justify-content:space-around}.el-row.is-justify-space-evenly{justify-content:space-evenly}.el-row.is-align-middle{align-items:center}.el-row.is-align-bottom{align-items:flex-end}.el-scrollbar{--el-scrollbar-opacity:0.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:0.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary)}.el-scrollbar{overflow:hidden;position:relative;height:100%}.el-scrollbar__wrap{overflow:auto;height:100%}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{position:relative;display:block;width:0;height:0;cursor:pointer;border-radius:inherit;background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));transition:var(--el-transition-duration) background-color;opacity:var(--el-scrollbar-opacity,.3)}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{position:absolute;right:2px;bottom:2px;z-index:1;border-radius:4px}.el-scrollbar__bar.is-vertical{width:6px;top:2px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity 340ms ease-out}.el-scrollbar-fade-leave-active{transition:opacity 120ms ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-select-dropdown{z-index:calc(var(--el-index-top) + 1);border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__option-item.is-selected:not(.is-multiple).is-disabled{color:var(--el-text-color-disabled)}.el-select-dropdown__option-item.is-selected:not(.is-multiple).is-disabled::after{background-color:var(--el-text-color-disabled)}.el-select-dropdown__option-item:hover:not(.hover){background-color:transparent}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-disabled.is-selected{color:var(--el-text-color-disabled)}.el-select-dropdown__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:var(--el-select-font-size)}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{list-style:none;margin:6px 0!important;padding:0!important;box-sizing:border-box}.el-select-dropdown__option-item{font-size:var(--el-select-font-size);padding:0 32px 0 20px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--el-text-color-regular);height:34px;line-height:34px;box-sizing:border-box;cursor:pointer}.el-select-dropdown__option-item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown__option-item.is-disabled:hover{background-color:var(--el-bg-color)}.el-select-dropdown__option-item.is-selected{background-color:var(--el-fill-color-light);font-weight:700}.el-select-dropdown__option-item.is-selected:not(.is-multiple){color:var(--el-color-primary)}.el-select-dropdown__option-item.hover{background-color:var(--el-fill-color-light)!important}.el-select-dropdown__option-item:hover{background-color:var(--el-fill-color-light)}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay)}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected .el-icon{position:absolute;right:20px;top:0;height:inherit;font-size:12px}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected .el-icon svg{height:inherit;vertical-align:middle}.el-select-group{margin:0;padding:0}.el-select-group__wrap{position:relative;list-style:none;margin:0;padding:0}.el-select-group__wrap:not(:last-of-type){padding-bottom:24px}.el-select-group__wrap:not(:last-of-type)::after{content:"";position:absolute;display:block;left:20px;right:20px;bottom:12px;height:1px;background:var(--el-border-color-light)}.el-select-group__split-dash{position:absolute;left:20px;right:20px;height:1px;background:var(--el-border-color-light)}.el-select-group__title{padding-left:20px;font-size:12px;color:var(--el-color-info);line-height:30px}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select-v2{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px}.el-select-v2{display:inline-block;position:relative;vertical-align:middle;font-size:14px}.el-select-v2__wrapper{display:flex;align-items:center;flex-wrap:wrap;box-sizing:border-box;cursor:pointer;padding:1px 30px 1px 0;border:1px solid var(--el-border-color);border-radius:var(--el-border-radius-base);transition:border-color var(--el-transition-duration-fast) var(--el-ease-in-out-bezier-function)}.el-select-v2__wrapper:hover{border-color:var(--el-text-color-placeholder)}.el-select-v2__wrapper.is-filterable{cursor:text}.el-select-v2__wrapper.is-focused{border-color:var(--el-color-primary)}.el-select-v2__wrapper.is-hovering:not(.is-focused){border-color:var(--el-text-color-placeholder)}.el-select-v2__wrapper.is-disabled{cursor:not-allowed;background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);border-color:var(--el-select-disabled-border)}.el-select-v2__wrapper.is-disabled:hover{border-color:var(--el-select-disabled-border)}.el-select-v2__wrapper.is-disabled.is-focus{border-color:var(--el-input-focus-border-color)}.el-select-v2__wrapper.is-disabled .is-transparent{opacity:1;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-select-v2__wrapper.is-disabled .el-select-v2__caret{cursor:not-allowed}.el-select-v2__wrapper.is-disabled .el-select-v2__combobox-input{cursor:not-allowed}.el-select-v2__wrapper .el-select-v2__input-wrapper{box-sizing:border-box;position:relative;-webkit-margin-start:12px;margin-inline-start:12px;max-width:100%;overflow:hidden}.el-select-v2__wrapper,.el-select-v2__wrapper .el-select-v2__input-wrapper{line-height:32px}.el-select-v2__wrapper .el-select-v2__input-wrapper input{line-height:24px;height:24px;min-width:4px;width:100%;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none;background:0 0;border:none;margin:2px 0;outline:0;padding:0}.el-select-v2 .el-select-v2__tags-text{display:inline-block;line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select-v2__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:14px}.el-select-v2__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select-v2__popper.el-popper .el-popper__arrow::before{border:1px solid var(--el-border-color-light)}.el-select-v2__popper.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent;border-left-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent;border-right-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent;border-bottom-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent;border-top-color:transparent}.el-select-v2--large .el-select-v2__wrapper .el-select-v2__combobox-input{height:32px}.el-select-v2--large .el-select-v2__caret{height:40px}.el-select-v2--large .el-select-v2__suffix{height:40px}.el-select-v2--large .el-select-v2__placeholder{font-size:14px;line-height:40px}.el-select-v2--small .el-select-v2__wrapper .el-select-v2__combobox-input{height:16px}.el-select-v2--small .el-select-v2__caret{height:24px}.el-select-v2--small .el-select-v2__suffix{height:24px}.el-select-v2--small .el-select-v2__placeholder{font-size:12px;line-height:24px}.el-select-v2 .el-select-v2__selection>span{display:inline-block}.el-select-v2:hover .el-select-v2__combobox-input{border-color:var(--el-select-border-color-hover)}.el-select-v2 .el-select__selection-text{text-overflow:ellipsis;display:inline-block;overflow-x:hidden;vertical-align:bottom}.el-select-v2 .el-select-v2__combobox-input{padding-right:35px;display:block}.el-select-v2 .el-select-v2__combobox-input:focus{border-color:var(--el-select-input-focus-border-color)}.el-select-v2__input{border:none;outline:0;padding:0;margin-left:15px;color:var(--el-select-multiple-input-color);font-size:var(--el-select-font-size);-webkit-appearance:none;-moz-appearance:none;appearance:none;height:28px}.el-select-v2__input.is-small{height:14px}.el-select-v2__close{cursor:pointer;position:absolute;top:8px;z-index:var(--el-index-top);right:25px;color:var(--el-select-input-color);line-height:18px;font-size:var(--el-select-input-font-size)}.el-select-v2__close:hover{color:var(--el-select-close-hover-color)}.el-select-v2__suffix{display:inline-flex;position:absolute;right:12px;height:32px;top:50%;transform:translateY(-50%);color:var(--el-input-icon-color,var(--el-text-color-placeholder))}.el-select-v2__suffix .el-input__icon{height:inherit}.el-select-v2__caret{color:var(--el-select-input-color);font-size:var(--el-select-input-font-size);transition:transform var(--el-transition-duration);transform:rotateZ(180deg);cursor:pointer}.el-select-v2__caret.is-reverse{transform:rotateZ(0)}.el-select-v2__caret.is-show-close{font-size:var(--el-select-font-size);text-align:center;transform:rotateZ(180deg);border-radius:var(--el-border-radius-circle);color:var(--el-select-input-color);transition:var(--el-transition-color)}.el-select-v2__caret.is-show-close:hover{color:var(--el-select-close-hover-color)}.el-select-v2__caret.el-icon{height:inherit}.el-select-v2__caret.el-icon svg{vertical-align:middle}.el-select-v2__selection{white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap}.el-select-v2__wrapper{background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:var(--el-border-radius-base);position:relative;transition:all var(--el-transition-duration) var(--el-ease-in-out-bezier-function)}.el-select-v2__input-calculator{left:0;position:absolute;top:0;visibility:hidden;white-space:pre;z-index:999}.el-select-v2__selected-item{line-height:inherit;height:inherit;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex}.el-select-v2__placeholder{position:absolute;top:50%;transform:translateY(-50%);-webkit-margin-start:12px;margin-inline-start:12px;width:calc(100% - 52px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--el-input-text-color,var(--el-text-color-regular))}.el-select-v2__placeholder.is-transparent{color:var(--el-text-color-placeholder)}.el-select-v2 .el-select-v2__selection .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 0 2px 6px;background-color:var(--el-fill-color)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;color:var(--el-color-white)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close::before{display:block;transform:translate(0,.5px)}.el-select-v2.el-select-v2--small .el-select-v2__selection .el-tag{margin:1px 0 1px 6px;height:18px}.el-select-dropdown{z-index:calc(var(--el-index-top) + 1);border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay)}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected.hover{background-color:var(--el-fill-color-light)}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected::after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected.is-disabled::after{background-color:var(--el-text-color-disabled)}.el-select-dropdown .el-select-dropdown__option-item.is-selected::after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown .el-select-dropdown__item.is-disabled:hover{background-color:unset}.el-select-dropdown .el-select-dropdown__item.is-disabled.selected{color:var(--el-text-color-disabled)}.el-select-dropdown__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:var(--el-select-font-size)}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{list-style:none;padding:6px 0;margin:0;box-sizing:border-box}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px}.el-select{display:inline-block;position:relative;vertical-align:middle;line-height:32px}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper .el-popper__arrow::before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent;border-bottom-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent;border-top-color:transparent}.el-select .el-select-tags-wrapper.has-prefix{margin-left:6px}.el-select--large{line-height:40px}.el-select--large .el-select-tags-wrapper.has-prefix{margin-left:8px}.el-select--small{line-height:24px}.el-select--small .el-select-tags-wrapper.has-prefix{margin-left:4px}.el-select .el-select__tags>span{display:inline-block}.el-select:hover:not(.el-select--disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-select-border-color-hover) inset}.el-select .el-select__tags-text{display:inline-block;line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select .el-input__wrapper{cursor:pointer}.el-select .el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-select-input-focus-border-color) inset!important}.el-select .el-input__inner{cursor:pointer}.el-select .el-input{display:flex}.el-select .el-input .el-select__caret{color:var(--el-select-input-color);font-size:var(--el-select-input-font-size);transition:transform var(--el-transition-duration);transform:rotateZ(180deg);cursor:pointer}.el-select .el-input .el-select__caret.is-reverse{transform:rotateZ(0)}.el-select .el-input .el-select__caret.is-show-close{font-size:var(--el-select-font-size);text-align:center;transform:rotateZ(180deg);border-radius:var(--el-border-radius-circle);color:var(--el-select-input-color);transition:var(--el-transition-color)}.el-select .el-input .el-select__caret.is-show-close:hover{color:var(--el-select-close-hover-color)}.el-select .el-input .el-select__caret.el-icon{position:relative;height:inherit;z-index:2}.el-select .el-input.is-disabled .el-input__wrapper{cursor:not-allowed}.el-select .el-input.is-disabled .el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select .el-input.is-disabled .el-input__inner{cursor:not-allowed}.el-select .el-input.is-disabled .el-select__caret{cursor:not-allowed}.el-select .el-input.is-focus .el-input__wrapper{box-shadow:0 0 0 1px var(--el-select-input-focus-border-color) inset!important}.el-select__input{border:none;outline:0;padding:0;margin-left:15px;color:var(--el-select-multiple-input-color);font-size:var(--el-select-font-size);-webkit-appearance:none;-moz-appearance:none;appearance:none;height:28px;background-color:transparent}.el-select__close{cursor:pointer;position:absolute;top:8px;z-index:var(--el-index-top);right:25px;color:var(--el-select-input-color);line-height:18px;font-size:var(--el-select-input-font-size)}.el-select__close:hover{color:var(--el-select-close-hover-color)}.el-select__tags{position:absolute;line-height:normal;top:50%;transform:translateY(-50%);white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap}.el-select__collapse-tags{white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap}.el-select__collapse-tag{line-height:inherit;height:inherit;display:flex}.el-select .el-select__tags .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 6px 2px 0}.el-select .el-select__tags .el-tag:last-child{margin-right:0}.el-select .el-select__tags .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;top:0;color:#fff}.el-select .el-select__tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select .el-select__tags .el-tag .el-icon-close::before{display:block;transform:translate(0,.5px)}.el-select .el-select__tags .el-tag--info{background-color:var(--el-fill-color)}.el-skeleton{--el-skeleton-circle-size:var(--el-avatar-size)}.el-skeleton__item{background:var(--el-skeleton-color);display:inline-block;height:16px;border-radius:var(--el-border-radius-base);width:100%}.el-skeleton__circle{border-radius:50%;width:var(--el-skeleton-circle-size);height:var(--el-skeleton-circle-size);line-height:var(--el-skeleton-circle-size)}.el-skeleton__button{height:40px;width:64px;border-radius:4px}.el-skeleton__p{width:100%}.el-skeleton__p.is-last{width:61%}.el-skeleton__p.is-first{width:33%}.el-skeleton__text{width:100%;height:var(--el-font-size-small)}.el-skeleton__caption{height:var(--el-font-size-extra-small)}.el-skeleton__h1{height:var(--el-font-size-extra-large)}.el-skeleton__h3{height:var(--el-font-size-large)}.el-skeleton__h5{height:var(--el-font-size-medium)}.el-skeleton__image{width:unset;display:flex;align-items:center;justify-content:center;border-radius:0}.el-skeleton__image svg{color:var(--el-svg-monochrome-grey);fill:currentColor;width:22%;height:22%}.el-skeleton{--el-skeleton-color:var(--el-fill-color);--el-skeleton-to-color:var(--el-fill-color-darker)}@-webkit-keyframes el-skeleton-loading{0%{background-position:100% 50%}100%{background-position:0 50%}}@keyframes el-skeleton-loading{0%{background-position:100% 50%}100%{background-position:0 50%}}.el-skeleton{width:100%}.el-skeleton__first-line{height:16px;margin-top:16px;background:var(--el-skeleton-color)}.el-skeleton__paragraph{height:16px;margin-top:16px;background:var(--el-skeleton-color)}.el-skeleton.is-animated .el-skeleton__item{background:linear-gradient(90deg,var(--el-skeleton-color) 25%,var(--el-skeleton-to-color) 37%,var(--el-skeleton-color) 63%);background-size:400% 100%;-webkit-animation:el-skeleton-loading 1.4s ease infinite;animation:el-skeleton-loading 1.4s ease infinite}.el-slider{--el-slider-main-bg-color:var(--el-color-primary);--el-slider-runway-bg-color:var(--el-border-color-light);--el-slider-stop-bg-color:var(--el-color-white);--el-slider-disabled-color:var(--el-text-color-placeholder);--el-slider-border-radius:3px;--el-slider-height:6px;--el-slider-button-size:20px;--el-slider-button-wrapper-size:36px;--el-slider-button-wrapper-offset:-15px}.el-slider{width:100%;height:32px;display:flex;align-items:center}.el-slider__runway{flex:1;height:var(--el-slider-height);background-color:var(--el-slider-runway-bg-color);border-radius:var(--el-slider-border-radius);position:relative;cursor:pointer}.el-slider__runway.show-input{margin-right:30px;width:auto}.el-slider__runway.is-disabled{cursor:default}.el-slider__runway.is-disabled .el-slider__bar{background-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button{border-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button-wrapper.hover,.el-slider__runway.is-disabled .el-slider__button-wrapper:hover{cursor:not-allowed}.el-slider__runway.is-disabled .el-slider__button-wrapper.dragging{cursor:not-allowed}.el-slider__runway.is-disabled .el-slider__button.dragging,.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover{transform:scale(1)}.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover{cursor:not-allowed}.el-slider__runway.is-disabled .el-slider__button.dragging{cursor:not-allowed}.el-slider__input{flex-shrink:0;width:130px}.el-slider__bar{height:var(--el-slider-height);background-color:var(--el-slider-main-bg-color);border-top-left-radius:var(--el-slider-border-radius);border-bottom-left-radius:var(--el-slider-border-radius);position:absolute}.el-slider__button-wrapper{height:var(--el-slider-button-wrapper-size);width:var(--el-slider-button-wrapper-size);position:absolute;z-index:1;top:var(--el-slider-button-wrapper-offset);transform:translateX(-50%);background-color:transparent;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;line-height:normal;outline:0}.el-slider__button-wrapper::after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-slider__button-wrapper.hover,.el-slider__button-wrapper:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button-wrapper.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__button{display:inline-block;width:var(--el-slider-button-size);height:var(--el-slider-button-size);vertical-align:middle;border:solid 2px var(--el-slider-main-bg-color);background-color:var(--el-color-white);border-radius:50%;box-sizing:border-box;transition:var(--el-transition-duration-fast);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-slider__button.dragging,.el-slider__button.hover,.el-slider__button:hover{transform:scale(1.2)}.el-slider__button.hover,.el-slider__button:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__stop{position:absolute;height:var(--el-slider-height);width:var(--el-slider-height);border-radius:var(--el-border-radius-circle);background-color:var(--el-slider-stop-bg-color);transform:translateX(-50%)}.el-slider__marks{top:0;left:12px;width:18px;height:100%}.el-slider__marks-text{position:absolute;transform:translateX(-50%);font-size:14px;color:var(--el-color-info);margin-top:15px}.el-slider.is-vertical{position:relative;display:inline-flex;width:auto;height:100%;flex:0}.el-slider.is-vertical .el-slider__runway{width:var(--el-slider-height);height:100%;margin:0 16px}.el-slider.is-vertical .el-slider__bar{width:var(--el-slider-height);height:auto;border-radius:0 0 3px 3px}.el-slider.is-vertical .el-slider__button-wrapper{top:auto;left:var(--el-slider-button-wrapper-offset);transform:translateY(50%)}.el-slider.is-vertical .el-slider__stop{transform:translateY(50%)}.el-slider.is-vertical .el-slider__marks-text{margin-top:0;left:15px;transform:translateY(50%)}.el-slider--large{height:40px}.el-slider--small{height:24px}.el-space{display:inline-flex;vertical-align:top}.el-space__item{display:flex;flex-wrap:wrap}.el-space__item>*{flex:1}.el-space--vertical{flex-direction:column}.el-time-spinner{width:100%;white-space:nowrap}.el-spinner{display:inline-block;vertical-align:middle}.el-spinner-inner{-webkit-animation:rotate 2s linear infinite;animation:rotate 2s linear infinite;width:50px;height:50px}.el-spinner-inner .path{stroke:var(--el-border-color-lighter);stroke-linecap:round;-webkit-animation:dash 1.5s ease-in-out infinite;animation:dash 1.5s ease-in-out infinite}@-webkit-keyframes rotate{100%{transform:rotate(360deg)}}@keyframes rotate{100%{transform:rotate(360deg)}}@-webkit-keyframes dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}100%{stroke-dasharray:90,150;stroke-dashoffset:-124}}@keyframes dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}100%{stroke-dasharray:90,150;stroke-dashoffset:-124}}.el-step{position:relative;flex-shrink:1}.el-step:last-of-type .el-step__line{display:none}.el-step:last-of-type.is-flex{flex-basis:auto!important;flex-shrink:0;flex-grow:0}.el-step:last-of-type .el-step__description,.el-step:last-of-type .el-step__main{padding-right:0}.el-step__head{position:relative;width:100%}.el-step__head.is-process{color:var(--el-text-color-primary);border-color:var(--el-text-color-primary)}.el-step__head.is-wait{color:var(--el-text-color-placeholder);border-color:var(--el-text-color-placeholder)}.el-step__head.is-success{color:var(--el-color-success);border-color:var(--el-color-success)}.el-step__head.is-error{color:var(--el-color-danger);border-color:var(--el-color-danger)}.el-step__head.is-finish{color:var(--el-color-primary);border-color:var(--el-color-primary)}.el-step__icon{position:relative;z-index:1;display:inline-flex;justify-content:center;align-items:center;width:24px;height:24px;font-size:14px;box-sizing:border-box;background:var(--el-bg-color);transition:.15s ease-out}.el-step__icon.is-text{border-radius:50%;border:2px solid;border-color:inherit}.el-step__icon.is-icon{width:40px}.el-step__icon-inner{display:inline-block;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;text-align:center;font-weight:700;line-height:1;color:inherit}.el-step__icon-inner[class*=el-icon]:not(.is-status){font-size:25px;font-weight:400}.el-step__icon-inner.is-status{transform:translateY(1px)}.el-step__line{position:absolute;border-color:inherit;background-color:var(--el-text-color-placeholder)}.el-step__line-inner{display:block;border-width:1px;border-style:solid;border-color:inherit;transition:.15s ease-out;box-sizing:border-box;width:0;height:0}.el-step__main{white-space:normal;text-align:left}.el-step__title{font-size:16px;line-height:38px}.el-step__title.is-process{font-weight:700;color:var(--el-text-color-primary)}.el-step__title.is-wait{color:var(--el-text-color-placeholder)}.el-step__title.is-success{color:var(--el-color-success)}.el-step__title.is-error{color:var(--el-color-danger)}.el-step__title.is-finish{color:var(--el-color-primary)}.el-step__description{padding-right:10%;margin-top:-5px;font-size:12px;line-height:20px;font-weight:400}.el-step__description.is-process{color:var(--el-text-color-primary)}.el-step__description.is-wait{color:var(--el-text-color-placeholder)}.el-step__description.is-success{color:var(--el-color-success)}.el-step__description.is-error{color:var(--el-color-danger)}.el-step__description.is-finish{color:var(--el-color-primary)}.el-step.is-horizontal{display:inline-block}.el-step.is-horizontal .el-step__line{height:2px;top:11px;left:0;right:0}.el-step.is-vertical{display:flex}.el-step.is-vertical .el-step__head{flex-grow:0;width:24px}.el-step.is-vertical .el-step__main{padding-left:10px;flex-grow:1}.el-step.is-vertical .el-step__title{line-height:24px;padding-bottom:8px}.el-step.is-vertical .el-step__line{width:2px;top:0;bottom:0;left:11px}.el-step.is-vertical .el-step__icon.is-icon{width:24px}.el-step.is-center .el-step__head{text-align:center}.el-step.is-center .el-step__main{text-align:center}.el-step.is-center .el-step__description{padding-left:20%;padding-right:20%}.el-step.is-center .el-step__line{left:50%;right:-50%}.el-step.is-simple{display:flex;align-items:center}.el-step.is-simple .el-step__head{width:auto;font-size:0;padding-right:10px}.el-step.is-simple .el-step__icon{background:0 0;width:16px;height:16px;font-size:12px}.el-step.is-simple .el-step__icon-inner[class*=el-icon]:not(.is-status){font-size:18px}.el-step.is-simple .el-step__icon-inner.is-status{transform:scale(.8) translateY(1px)}.el-step.is-simple .el-step__main{position:relative;display:flex;align-items:stretch;flex-grow:1}.el-step.is-simple .el-step__title{font-size:16px;line-height:20px}.el-step.is-simple:not(:last-of-type) .el-step__title{max-width:50%;word-break:break-all}.el-step.is-simple .el-step__arrow{flex-grow:1;display:flex;align-items:center;justify-content:center}.el-step.is-simple .el-step__arrow::after,.el-step.is-simple .el-step__arrow::before{content:"";display:inline-block;position:absolute;height:15px;width:1px;background:var(--el-text-color-placeholder)}.el-step.is-simple .el-step__arrow::before{transform:rotate(-45deg) translateY(-4px);transform-origin:0 0}.el-step.is-simple .el-step__arrow::after{transform:rotate(45deg) translateY(4px);transform-origin:100% 100%}.el-step.is-simple:last-of-type .el-step__arrow{display:none}.el-steps{display:flex}.el-steps--simple{padding:13px 8%;border-radius:4px;background:var(--el-fill-color-light)}.el-steps--horizontal{white-space:nowrap}.el-steps--vertical{height:100%;flex-flow:column}.el-switch{--el-switch-on-color:var(--el-color-primary);--el-switch-off-color:var(--el-border-color)}.el-switch{display:inline-flex;align-items:center;position:relative;font-size:14px;line-height:20px;height:32px;vertical-align:middle}.el-switch.is-disabled .el-switch__core,.el-switch.is-disabled .el-switch__label{cursor:not-allowed}.el-switch__label{transition:var(--el-transition-duration-fast);height:20px;display:inline-block;font-size:14px;font-weight:500;cursor:pointer;vertical-align:middle;color:var(--el-text-color-primary)}.el-switch__label.is-active{color:var(--el-color-primary)}.el-switch__label--left{margin-right:10px}.el-switch__label--right{margin-left:10px}.el-switch__label *{line-height:1;font-size:14px;display:inline-block}.el-switch__label .el-icon{height:inherit}.el-switch__label .el-icon svg{vertical-align:middle}.el-switch__input{position:absolute;width:0;height:0;opacity:0;margin:0}.el-switch__input:focus-visible~.el-switch__core{outline:2px solid var(--el-switch-on-color);outline-offset:1px}.el-switch__core{margin:0;display:inline-block;position:relative;width:40px;height:20px;border:1px solid var(--el-switch-border-color,var(--el-switch-off-color));outline:0;border-radius:10px;box-sizing:border-box;background:var(--el-switch-off-color);cursor:pointer;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration);vertical-align:middle}.el-switch__core .el-switch__inner{position:absolute;top:1px;left:1px;transition:all var(--el-transition-duration);width:16px;height:16px;display:flex;justify-content:center;align-items:center;left:50%;white-space:nowrap}.el-switch__core .el-switch__inner .is-icon,.el-switch__core .el-switch__inner .is-text{color:var(--el-color-white);transition:opacity var(--el-transition-duration);position:absolute;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-switch__core .el-switch__action{position:absolute;top:1px;left:1px;border-radius:var(--el-border-radius-circle);transition:all var(--el-transition-duration);width:16px;height:16px;background-color:var(--el-color-white);display:flex;justify-content:center;align-items:center;color:var(--el-switch-off-color)}.el-switch__core .el-switch__action .is-icon,.el-switch__core .el-switch__action .is-text{transition:opacity var(--el-transition-duration);position:absolute;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-switch__core .is-text{font-size:12px}.el-switch__core .is-show{opacity:1}.el-switch__core .is-hide{opacity:0}.el-switch.is-checked .el-switch__core{border-color:var(--el-switch-border-color,var(--el-switch-on-color));background-color:var(--el-switch-on-color)}.el-switch.is-checked .el-switch__core .el-switch__action{left:100%;margin-left:calc(-1px - 16px);color:var(--el-switch-on-color)}.el-switch.is-checked .el-switch__core .el-switch__inner{left:50%;white-space:nowrap;margin-left:calc(-1px - 16px)}.el-switch.is-disabled{opacity:.6}.el-switch--wide .el-switch__label.el-switch__label--left span{left:10px}.el-switch--wide .el-switch__label.el-switch__label--right span{right:10px}.el-switch .label-fade-enter-from,.el-switch .label-fade-leave-active{opacity:0}.el-switch--large{font-size:14px;line-height:24px;height:40px}.el-switch--large .el-switch__label{height:24px;font-size:14px}.el-switch--large .el-switch__label *{font-size:14px}.el-switch--large .el-switch__core{width:50px;height:24px;border-radius:12px}.el-switch--large .el-switch__core .el-switch__inner{width:20px;height:20px}.el-switch--large .el-switch__core .el-switch__action{width:20px;height:20px}.el-switch--large.is-checked .el-switch__core .el-switch__action{margin-left:calc(-1px - 20px)}.el-switch--large.is-checked .el-switch__core .el-switch__inner{margin-left:calc(-1px - 20px)}.el-switch--small{font-size:12px;line-height:16px;height:24px}.el-switch--small .el-switch__label{height:16px;font-size:12px}.el-switch--small .el-switch__label *{font-size:12px}.el-switch--small .el-switch__core{width:30px;height:16px;border-radius:8px}.el-switch--small .el-switch__core .el-switch__inner{width:12px;height:12px}.el-switch--small .el-switch__core .el-switch__action{width:12px;height:12px}.el-switch--small.is-checked .el-switch__core .el-switch__action{margin-left:calc(-1px - 12px)}.el-switch--small.is-checked .el-switch__core .el-switch__inner{margin-left:calc(-1px - 12px)}.el-table-column--selection .cell{padding-left:14px;padding-right:14px}.el-table-filter{border:solid 1px var(--el-border-color-lighter);border-radius:2px;background-color:#fff;box-shadow:var(--el-box-shadow-light);box-sizing:border-box}.el-table-filter__list{padding:5px 0;margin:0;list-style:none;min-width:100px}.el-table-filter__list-item{line-height:36px;padding:0 10px;cursor:pointer;font-size:var(--el-font-size-base)}.el-table-filter__list-item:hover{background-color:var(--el-color-primary-light-9);color:var(--el-color-primary)}.el-table-filter__list-item.is-active{background-color:var(--el-color-primary);color:#fff}.el-table-filter__content{min-width:100px}.el-table-filter__bottom{border-top:1px solid var(--el-border-color-lighter);padding:8px}.el-table-filter__bottom button{background:0 0;border:none;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-small);padding:0 3px}.el-table-filter__bottom button:hover{color:var(--el-color-primary)}.el-table-filter__bottom button:focus{outline:0}.el-table-filter__bottom button.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-table-filter__wrap{max-height:280px}.el-table-filter__checkbox-group{padding:10px}.el-table-filter__checkbox-group label.el-checkbox{display:flex;align-items:center;margin-right:5px;margin-bottom:12px;margin-left:5px;height:unset}.el-table-filter__checkbox-group .el-checkbox:last-child{margin-bottom:0}.el-table{--el-table-border-color:var(--el-border-color-lighter);--el-table-border:1px solid var(--el-table-border-color);--el-table-text-color:var(--el-text-color-regular);--el-table-header-text-color:var(--el-text-color-secondary);--el-table-row-hover-bg-color:var(--el-fill-color-light);--el-table-current-row-bg-color:var(--el-color-primary-light-9);--el-table-header-bg-color:var(--el-bg-color);--el-table-fixed-box-shadow:var(--el-box-shadow-light);--el-table-bg-color:var(--el-fill-color-blank);--el-table-tr-bg-color:var(--el-fill-color-blank);--el-table-expanded-cell-bg-color:var(--el-fill-color-blank);--el-table-fixed-left-column:inset 10px 0 10px -10px rgba(0, 0, 0, 0.15);--el-table-fixed-right-column:inset -10px 0 10px -10px rgba(0, 0, 0, 0.15)}.el-table{position:relative;overflow:hidden;box-sizing:border-box;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;width:100%;max-width:100%;background-color:var(--el-table-bg-color);font-size:14px;color:var(--el-table-text-color)}.el-table__inner-wrapper{position:relative;display:flex;flex-direction:column;height:100%}.el-table__inner-wrapper::before{left:0;bottom:0;width:100%;height:1px;z-index:3}.el-table.has-footer.el-table--fluid-height tr:last-child td.el-table__cell,.el-table.has-footer.el-table--scrollable-y tr:last-child td.el-table__cell{border-bottom-color:transparent}.el-table__empty-block{position:-webkit-sticky;position:sticky;left:0;min-height:60px;text-align:center;width:100%;display:flex;justify-content:center;align-items:center}.el-table__empty-text{line-height:60px;width:50%;color:var(--el-text-color-secondary)}.el-table__expand-column .cell{padding:0;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-table__expand-icon{position:relative;cursor:pointer;color:var(--el-text-color-regular);font-size:12px;transition:transform var(--el-transition-duration-fast) ease-in-out;height:20px}.el-table__expand-icon--expanded{transform:rotate(90deg)}.el-table__expand-icon>.el-icon{font-size:12px}.el-table__expanded-cell{background-color:var(--el-table-expanded-cell-bg-color)}.el-table__expanded-cell[class*=cell]{padding:20px 50px}.el-table__expanded-cell:hover{background-color:transparent!important}.el-table__placeholder{display:inline-block;width:20px}.el-table__append-wrapper{overflow:hidden}.el-table--fit{border-right:0;border-bottom:0}.el-table--fit .el-table__cell.gutter{border-right-width:1px}.el-table thead{color:var(--el-table-header-text-color);font-weight:500}.el-table thead.is-group th.el-table__cell{background:var(--el-fill-color-light)}.el-table .el-table__cell{padding:8px 0;min-width:0;box-sizing:border-box;text-overflow:ellipsis;vertical-align:middle;position:relative;text-align:left;z-index:1}.el-table .el-table__cell.is-center{text-align:center}.el-table .el-table__cell.is-right{text-align:right}.el-table .el-table__cell.gutter{width:15px;border-right-width:0;border-bottom-width:0;padding:0}.el-table .el-table__cell.is-hidden>*{visibility:hidden}.el-table .cell{box-sizing:border-box;overflow:hidden;text-overflow:ellipsis;white-space:normal;word-break:break-all;line-height:23px;padding:0 12px}.el-table .cell.el-tooltip{white-space:nowrap;min-width:50px}.el-table--large{font-size:var(--el-font-size-base)}.el-table--large .el-table__cell{padding:12px 0}.el-table--large .cell{padding:0 16px}.el-table--small{font-size:12px}.el-table--small .el-table__cell{padding:4px 0}.el-table--small .cell{padding:0 8px}.el-table tr{background-color:var(--el-table-tr-bg-color)}.el-table tr input[type=checkbox]{margin:0}.el-table td.el-table__cell,.el-table th.el-table__cell.is-leaf{border-bottom:var(--el-table-border)}.el-table th.el-table__cell.is-sortable{cursor:pointer}.el-table th.el-table__cell{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:var(--el-table-header-bg-color)}.el-table th.el-table__cell>.cell.highlight{color:var(--el-color-primary)}.el-table th.el-table__cell.required>div::before{display:inline-block;content:"";width:8px;height:8px;border-radius:50%;background:#ff4d51;margin-right:5px;vertical-align:middle}.el-table td.el-table__cell div{box-sizing:border-box}.el-table td.el-table__cell.gutter{width:0}.el-table__footer-wrapper{border-top:var(--el-table-border)}.el-table--border .el-table__footer-wrapper tr:first-child td:first-child,.el-table--border .el-table__footer-wrapper tr:first-child th:first-child,.el-table--border .el-table__inner-wrapper tr:first-child td:first-child,.el-table--border .el-table__inner-wrapper tr:first-child th:first-child,.el-table--group .el-table__footer-wrapper tr:first-child td:first-child,.el-table--group .el-table__footer-wrapper tr:first-child th:first-child,.el-table--group .el-table__inner-wrapper tr:first-child td:first-child,.el-table--group .el-table__inner-wrapper tr:first-child th:first-child{border-left:var(--el-table-border)}.el-table--border .el-table__inner-wrapper::after,.el-table--border::after,.el-table--border::before,.el-table__inner-wrapper::before{content:"";position:absolute;background-color:var(--el-table-border-color);z-index:3}.el-table--border .el-table__inner-wrapper::after{left:0;top:0;width:100%;height:1px;z-index:3}.el-table--border::before{top:-1px;left:0;width:1px;height:100%;z-index:3}.el-table--border::after{top:-1px;right:0;width:1px;height:100%;z-index:3}.el-table--border .el-table__inner-wrapper{border-right:none;border-bottom:none}.el-table--border .el-table__footer-wrapper{position:relative;flex-shrink:0}.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table--border th.el-table__cell.gutter:last-of-type{border-bottom:var(--el-table-border);border-bottom-width:1px}.el-table--border th.el-table__cell{border-bottom:var(--el-table-border)}.el-table--hidden{visibility:hidden}.el-table__body-wrapper,.el-table__footer-wrapper,.el-table__header-wrapper{width:100%}.el-table__body-wrapper tr td.el-table-fixed-column--left,.el-table__body-wrapper tr td.el-table-fixed-column--right,.el-table__body-wrapper tr th.el-table-fixed-column--left,.el-table__body-wrapper tr th.el-table-fixed-column--right,.el-table__footer-wrapper tr td.el-table-fixed-column--left,.el-table__footer-wrapper tr td.el-table-fixed-column--right,.el-table__footer-wrapper tr th.el-table-fixed-column--left,.el-table__footer-wrapper tr th.el-table-fixed-column--right,.el-table__header-wrapper tr td.el-table-fixed-column--left,.el-table__header-wrapper tr td.el-table-fixed-column--right,.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{position:-webkit-sticky!important;position:sticky!important;z-index:2;background:var(--el-bg-color)}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column::before{content:"";position:absolute;top:0;width:10px;bottom:-1px;overflow-x:hidden;overflow-y:hidden;box-shadow:none;touch-action:none;pointer-events:none}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column::before{left:-10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column::before{right:-10px;box-shadow:none}.el-table__body-wrapper tr td.el-table__fixed-right-patch,.el-table__body-wrapper tr th.el-table__fixed-right-patch,.el-table__footer-wrapper tr td.el-table__fixed-right-patch,.el-table__footer-wrapper tr th.el-table__fixed-right-patch,.el-table__header-wrapper tr td.el-table__fixed-right-patch,.el-table__header-wrapper tr th.el-table__fixed-right-patch{position:-webkit-sticky!important;position:sticky!important;z-index:2;background:#fff;right:0}.el-table__header-wrapper{flex-shrink:0}.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body,.el-table__footer,.el-table__header{table-layout:fixed;border-collapse:separate}.el-table__footer-wrapper,.el-table__header-wrapper{overflow:hidden}.el-table__footer-wrapper tbody td.el-table__cell,.el-table__header-wrapper tbody td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__body-wrapper .el-table-column--selection>.cell,.el-table__header-wrapper .el-table-column--selection>.cell{display:inline-flex;align-items:center;height:23px}.el-table__body-wrapper .el-table-column--selection .el-checkbox,.el-table__header-wrapper .el-table-column--selection .el-checkbox{height:unset}.el-table.is-scrolling-left .el-table-fixed-column--right.is-first-column::before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-left.el-table--border .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:var(--el-table-border)}.el-table.is-scrolling-left th.el-table-fixed-column--left{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column::before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-right th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-middle .el-table-fixed-column--right.is-first-column::before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column::before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-none .el-table-fixed-column--left.is-first-column::before,.el-table.is-scrolling-none .el-table-fixed-column--left.is-last-column::before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-first-column::before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-last-column::before{box-shadow:none}.el-table.is-scrolling-none th.el-table-fixed-column--left,.el-table.is-scrolling-none th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body-wrapper{overflow:hidden;position:relative;flex:1}.el-table__body-wrapper .el-scrollbar__bar{z-index:2}.el-table .caret-wrapper{display:inline-flex;flex-direction:column;align-items:center;height:14px;width:24px;vertical-align:middle;cursor:pointer;overflow:initial;position:relative}.el-table .sort-caret{width:0;height:0;border:solid 5px transparent;position:absolute;left:7px}.el-table .sort-caret.ascending{border-bottom-color:var(--el-text-color-placeholder);top:-5px}.el-table .sort-caret.descending{border-top-color:var(--el-text-color-placeholder);bottom:-3px}.el-table .ascending .sort-caret.ascending{border-bottom-color:var(--el-color-primary)}.el-table .descending .sort-caret.descending{border-top-color:var(--el-color-primary)}.el-table .hidden-columns{visibility:hidden;position:absolute;z-index:-1}.el-table--striped .el-table__body tr.el-table__row--striped td.el-table__cell{background:var(--el-fill-color-lighter)}.el-table--striped .el-table__body tr.el-table__row--striped.current-row td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table__body tr.hover-row.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped>td.el-table__cell,.el-table__body tr.hover-row>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table__body tr.current-row>td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table__column-resize-proxy{position:absolute;left:200px;top:0;bottom:0;width:0;border-left:var(--el-table-border);z-index:10}.el-table__column-filter-trigger{display:inline-block;cursor:pointer}.el-table__column-filter-trigger i{color:var(--el-color-info);font-size:14px;vertical-align:middle}.el-table__border-left-patch{top:0;left:0;width:1px;height:100%;z-index:3;position:absolute;background-color:var(--el-table-border-color)}.el-table__border-bottom-patch{left:0;height:1px;z-index:3;position:absolute;background-color:var(--el-table-border-color)}.el-table__border-right-patch{top:0;height:100%;width:1px;z-index:3;position:absolute;background-color:var(--el-table-border-color)}.el-table--enable-row-transition .el-table__body td.el-table__cell{transition:background-color .25s ease}.el-table--enable-row-hover .el-table__body tr:hover>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table [class*=el-table__row--level] .el-table__expand-icon{display:inline-block;width:12px;line-height:12px;height:12px;text-align:center;margin-right:8px}.el-table .el-table.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table:not(.el-table--border) .el-table__cell{border-right:none}.el-table:not(.el-table--border)>.el-table__inner-wrapper::after{content:none}.el-table:not(.el-table--border) .el-table__footer-wrapper tr:first-child td:first-child,.el-table:not(.el-table--border) .el-table__footer-wrapper tr:first-child th:first-child,.el-table:not(.el-table--border) .el-table__inner-wrapper tr:first-child td:first-child,.el-table:not(.el-table--border) .el-table__inner-wrapper tr:first-child th:first-child{border-left:none}.el-table-v2{--el-table-border-color:var(--el-border-color-lighter);--el-table-border:1px solid var(--el-table-border-color);--el-table-text-color:var(--el-text-color-regular);--el-table-header-text-color:var(--el-text-color-secondary);--el-table-row-hover-bg-color:var(--el-fill-color-light);--el-table-current-row-bg-color:var(--el-color-primary-light-9);--el-table-header-bg-color:var(--el-bg-color);--el-table-fixed-box-shadow:var(--el-box-shadow-light);--el-table-bg-color:var(--el-fill-color-blank);--el-table-tr-bg-color:var(--el-fill-color-blank);--el-table-expanded-cell-bg-color:var(--el-fill-color-blank);--el-table-fixed-left-column:inset 10px 0 10px -10px rgba(0, 0, 0, 0.15);--el-table-fixed-right-column:inset -10px 0 10px -10px rgba(0, 0, 0, 0.15)}.el-table-v2{font-size:14px}.el-table-v2 *{box-sizing:border-box}.el-table-v2__root{position:relative}.el-table-v2__root:hover .el-table-v2__main .el-virtual-scrollbar{opacity:1}.el-table-v2__main{display:flex;flex-direction:column-reverse;position:absolute;overflow:hidden;top:0;background-color:var(--el-bg-color);left:0}.el-table-v2__main .el-vl__horizontal,.el-table-v2__main .el-vl__vertical{z-index:2}.el-table-v2__left{display:flex;flex-direction:column-reverse;position:absolute;overflow:hidden;top:0;background-color:var(--el-bg-color);left:0;box-shadow:2px 0 4px 0 rgba(0,0,0,.06)}.el-table-v2__left .el-virtual-scrollbar{opacity:0}.el-table-v2__left .el-vl__horizontal,.el-table-v2__left .el-vl__vertical{z-index:-1}.el-table-v2__right{display:flex;flex-direction:column-reverse;position:absolute;overflow:hidden;top:0;background-color:var(--el-bg-color);right:0;box-shadow:-2px 0 4px 0 rgba(0,0,0,.06)}.el-table-v2__right .el-virtual-scrollbar{opacity:0}.el-table-v2__right .el-vl__horizontal,.el-table-v2__right .el-vl__vertical{z-index:-1}.el-table-v2__header-row{-webkit-padding-end:var(--el-table-scrollbar-size);padding-inline-end:var(--el-table-scrollbar-size)}.el-table-v2__row{-webkit-padding-end:var(--el-table-scrollbar-size);padding-inline-end:var(--el-table-scrollbar-size)}.el-table-v2__header-wrapper{overflow:hidden}.el-table-v2__header{position:relative;overflow:hidden}.el-table-v2__footer{position:absolute;left:0;right:0;bottom:0;overflow:hidden}.el-table-v2__empty{position:absolute;left:0}.el-table-v2__overlay{position:absolute;left:0;right:0;top:0;bottom:0;z-index:9999}.el-table-v2__header-row{display:flex;border-bottom:var(--el-table-border)}.el-table-v2__header-cell{display:flex;align-items:center;padding:0 8px;height:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden;background-color:var(--el-table-header-bg-color);color:var(--el-table-header-text-color);font-weight:700}.el-table-v2__header-cell.is-align-center{justify-content:center;text-align:center}.el-table-v2__header-cell.is-align-right{justify-content:flex-end;text-align:right}.el-table-v2__header-cell.is-sortable{cursor:pointer}.el-table-v2__header-cell:hover .el-icon{display:block}.el-table-v2__sort-icon{transition:opacity,display var(--el-transition-duration);opacity:.6;display:none}.el-table-v2__sort-icon.is-sorting{display:block;opacity:1}.el-table-v2__row{border-bottom:var(--el-table-border);display:flex;align-items:center;transition:background-color var(--el-transition-duration)}.el-table-v2__row.is-hovered{background-color:var(--el-table-row-hover-bg-color)}.el-table-v2__row:hover{background-color:var(--el-table-row-hover-bg-color)}.el-table-v2__row-cell{height:100%;overflow:hidden;display:flex;align-items:center;padding:0 8px}.el-table-v2__row-cell.is-align-center{justify-content:center;text-align:center}.el-table-v2__row-cell.is-align-right{justify-content:flex-end;text-align:right}.el-table-v2__expand-icon{margin:0 4px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-table-v2__expand-icon svg{transition:transform var(--el-transition-duration)}.el-table-v2__expand-icon.is-expanded svg{transform:rotate(90deg)}.el-table-v2:not(.is-dynamic) .el-table-v2__cell-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-table-v2.is-dynamic .el-table-v2__row{overflow:hidden;align-items:stretch}.el-table-v2.is-dynamic .el-table-v2__row .el-table-v2__row-cell{word-break:break-all}.el-tabs{--el-tabs-header-height:40px}.el-tabs__header{padding:0;position:relative;margin:0 0 15px}.el-tabs__active-bar{position:absolute;bottom:0;left:0;height:2px;background-color:var(--el-color-primary);z-index:1;transition:width var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),transform var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);list-style:none}.el-tabs__new-tab{display:flex;align-items:center;justify-content:center;float:right;border:1px solid var(--el-border-color);height:20px;width:20px;line-height:20px;margin:10px 0 10px 10px;border-radius:3px;text-align:center;font-size:12px;color:var(--el-text-color-primary);cursor:pointer;transition:all .15s}.el-tabs__new-tab .is-icon-plus{height:inherit;width:inherit;transform:scale(.8,.8)}.el-tabs__new-tab .is-icon-plus svg{vertical-align:middle}.el-tabs__new-tab:hover{color:var(--el-color-primary)}.el-tabs__nav-wrap{overflow:hidden;margin-bottom:-1px;position:relative}.el-tabs__nav-wrap::after{content:"";position:absolute;left:0;bottom:0;width:100%;height:2px;background-color:var(--el-border-color-light);z-index:var(--el-index-normal)}.el-tabs__nav-wrap.is-scrollable{padding:0 20px;box-sizing:border-box}.el-tabs__nav-scroll{overflow:hidden}.el-tabs__nav-next,.el-tabs__nav-prev{position:absolute;cursor:pointer;line-height:44px;font-size:12px;color:var(--el-text-color-secondary)}.el-tabs__nav-next{right:0}.el-tabs__nav-prev{left:0}.el-tabs__nav{white-space:nowrap;position:relative;transition:transform var(--el-transition-duration);float:left;z-index:calc(var(--el-index-normal) + 1)}.el-tabs__nav.is-stretch{min-width:100%;display:flex}.el-tabs__nav.is-stretch>*{flex:1;text-align:center}.el-tabs__item{padding:0 20px;height:var(--el-tabs-header-height);box-sizing:border-box;line-height:var(--el-tabs-header-height);display:inline-block;list-style:none;font-size:var(--el-font-size-base);font-weight:500;color:var(--el-text-color-primary);position:relative}.el-tabs__item:focus,.el-tabs__item:focus:active{outline:0}.el-tabs__item:focus-visible{box-shadow:0 0 2px 2px var(--el-color-primary) inset;border-radius:3px}.el-tabs__item .is-icon-close{border-radius:50%;text-align:center;transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);margin-left:5px}.el-tabs__item .is-icon-close:before{transform:scale(.9);display:inline-block}.el-tabs__item .is-icon-close:hover{background-color:var(--el-text-color-placeholder);color:#fff}.el-tabs__item .is-icon-close svg{margin-top:1px}.el-tabs__item.is-active{color:var(--el-color-primary)}.el-tabs__item:hover{color:var(--el-color-primary);cursor:pointer}.el-tabs__item.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-tabs__content{overflow:hidden;position:relative}.el-tabs--card>.el-tabs__header{border-bottom:1px solid var(--el-border-color-light);height:var(--el-tabs-header-height)}.el-tabs--card>.el-tabs__header .el-tabs__nav-wrap::after{content:none}.el-tabs--card>.el-tabs__header .el-tabs__nav{border:1px solid var(--el-border-color-light);border-bottom:none;border-radius:4px 4px 0 0;box-sizing:border-box}.el-tabs--card>.el-tabs__header .el-tabs__active-bar{display:none}.el-tabs--card>.el-tabs__header .el-tabs__item .is-icon-close{position:relative;font-size:12px;width:0;height:14px;vertical-align:middle;line-height:15px;overflow:hidden;top:-1px;right:-2px;transform-origin:100% 50%}.el-tabs--card>.el-tabs__header .el-tabs__item{border-bottom:1px solid transparent;border-left:1px solid var(--el-border-color-light);transition:color var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),padding var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs--card>.el-tabs__header .el-tabs__item:first-child{border-left:none}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover{padding-left:13px;padding-right:13px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover .is-icon-close{width:14px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active{border-bottom-color:var(--el-bg-color)}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable{padding-left:20px;padding-right:20px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable .is-icon-close{width:14px}.el-tabs--border-card{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color)}.el-tabs--border-card>.el-tabs__content{padding:15px}.el-tabs--border-card>.el-tabs__header{background-color:var(--el-fill-color-light);border-bottom:1px solid var(--el-border-color-light);margin:0}.el-tabs--border-card>.el-tabs__header .el-tabs__nav-wrap::after{content:none}.el-tabs--border-card>.el-tabs__header .el-tabs__item{transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);border:1px solid transparent;margin-top:-1px;color:var(--el-text-color-secondary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:first-child{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item+.el-tabs__item{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-active{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay);border-right-color:var(--el-border-color);border-left-color:var(--el-border-color)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:not(.is-disabled):hover{color:var(--el-color-primary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-disabled{color:var(--el-disabled-text-color)}.el-tabs--border-card>.el-tabs__header .is-scrollable .el-tabs__item:first-child{margin-left:0}.el-tabs--bottom .el-tabs__item.is-bottom:nth-child(2),.el-tabs--bottom .el-tabs__item.is-top:nth-child(2),.el-tabs--top .el-tabs__item.is-bottom:nth-child(2),.el-tabs--top .el-tabs__item.is-top:nth-child(2){padding-left:0}.el-tabs--bottom .el-tabs__item.is-bottom:last-child,.el-tabs--bottom .el-tabs__item.is-top:last-child,.el-tabs--top .el-tabs__item.is-bottom:last-child,.el-tabs--top .el-tabs__item.is-top:last-child{padding-right:0}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2){padding-left:20px}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:last-child{padding-right:20px}.el-tabs--bottom .el-tabs__header.is-bottom{margin-bottom:0;margin-top:10px}.el-tabs--bottom.el-tabs--border-card .el-tabs__header.is-bottom{border-bottom:0;border-top:1px solid var(--el-border-color)}.el-tabs--bottom.el-tabs--border-card .el-tabs__nav-wrap.is-bottom{margin-top:-1px;margin-bottom:0}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom:not(.is-active){border:1px solid transparent}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom{margin:0 -1px -1px}.el-tabs--left,.el-tabs--right{overflow:hidden}.el-tabs--left .el-tabs__header.is-left,.el-tabs--left .el-tabs__header.is-right,.el-tabs--left .el-tabs__nav-scroll,.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__header.is-left,.el-tabs--right .el-tabs__header.is-right,.el-tabs--right .el-tabs__nav-scroll,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{height:100%}.el-tabs--left .el-tabs__active-bar.is-left,.el-tabs--left .el-tabs__active-bar.is-right,.el-tabs--right .el-tabs__active-bar.is-left,.el-tabs--right .el-tabs__active-bar.is-right{top:0;bottom:auto;width:2px;height:auto}.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{margin-bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{height:30px;line-height:30px;width:100%;text-align:center;cursor:pointer}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i{transform:rotateZ(90deg)}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{left:auto;top:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next{right:auto;bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--left .el-tabs__nav-wrap.is-right.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-right.is-scrollable{padding:30px 0}.el-tabs--left .el-tabs__nav-wrap.is-left::after,.el-tabs--left .el-tabs__nav-wrap.is-right::after,.el-tabs--right .el-tabs__nav-wrap.is-left::after,.el-tabs--right .el-tabs__nav-wrap.is-right::after{height:100%;width:2px;bottom:auto;top:0}.el-tabs--left .el-tabs__nav.is-left,.el-tabs--left .el-tabs__nav.is-right,.el-tabs--right .el-tabs__nav.is-left,.el-tabs--right .el-tabs__nav.is-right{float:none}.el-tabs--left .el-tabs__item.is-left,.el-tabs--left .el-tabs__item.is-right,.el-tabs--right .el-tabs__item.is-left,.el-tabs--right .el-tabs__item.is-right{display:block}.el-tabs--left .el-tabs__header.is-left{float:left;margin-bottom:0;margin-right:10px}.el-tabs--left .el-tabs__nav-wrap.is-left{margin-right:-1px}.el-tabs--left .el-tabs__nav-wrap.is-left::after{left:auto;right:0}.el-tabs--left .el-tabs__active-bar.is-left{right:0;left:auto}.el-tabs--left .el-tabs__item.is-left{text-align:right}.el-tabs--left.el-tabs--card .el-tabs__active-bar.is-left{display:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left{border-left:none;border-right:1px solid var(--el-border-color-light);border-bottom:none;border-top:1px solid var(--el-border-color-light);text-align:left}.el-tabs--left.el-tabs--card .el-tabs__item.is-left:first-child{border-right:1px solid var(--el-border-color-light);border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active{border:1px solid var(--el-border-color-light);border-right-color:#fff;border-left:none;border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:first-child{border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:last-child{border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__nav{border-radius:4px 0 0 4px;border-bottom:1px solid var(--el-border-color-light);border-right:none}.el-tabs--left.el-tabs--card .el-tabs__new-tab{float:none}.el-tabs--left.el-tabs--border-card .el-tabs__header.is-left{border-right:1px solid var(--el-border-color)}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left{border:1px solid transparent;margin:-1px 0 -1px -1px}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left.is-active{border-color:transparent;border-top-color:#d1dbe5;border-bottom-color:#d1dbe5}.el-tabs--right .el-tabs__header.is-right{float:right;margin-bottom:0;margin-left:10px}.el-tabs--right .el-tabs__nav-wrap.is-right{margin-left:-1px}.el-tabs--right .el-tabs__nav-wrap.is-right::after{left:0;right:auto}.el-tabs--right .el-tabs__active-bar.is-right{left:0}.el-tabs--right.el-tabs--card .el-tabs__active-bar.is-right{display:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right{border-bottom:none;border-top:1px solid var(--el-border-color-light)}.el-tabs--right.el-tabs--card .el-tabs__item.is-right:first-child{border-left:1px solid var(--el-border-color-light);border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active{border:1px solid var(--el-border-color-light);border-left-color:#fff;border-right:none;border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:first-child{border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:last-child{border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__nav{border-radius:0 4px 4px 0;border-bottom:1px solid var(--el-border-color-light);border-left:none}.el-tabs--right.el-tabs--border-card .el-tabs__header.is-right{border-left:1px solid var(--el-border-color)}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right{border:1px solid transparent;margin:-1px -1px -1px 0}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right.is-active{border-color:transparent;border-top-color:#d1dbe5;border-bottom-color:#d1dbe5}.slideInLeft-transition,.slideInRight-transition{display:inline-block}.slideInRight-enter{-webkit-animation:slideInRight-enter var(--el-transition-duration);animation:slideInRight-enter var(--el-transition-duration)}.slideInRight-leave{position:absolute;left:0;right:0;-webkit-animation:slideInRight-leave var(--el-transition-duration);animation:slideInRight-leave var(--el-transition-duration)}.slideInLeft-enter{-webkit-animation:slideInLeft-enter var(--el-transition-duration);animation:slideInLeft-enter var(--el-transition-duration)}.slideInLeft-leave{position:absolute;left:0;right:0;-webkit-animation:slideInLeft-leave var(--el-transition-duration);animation:slideInLeft-leave var(--el-transition-duration)}@-webkit-keyframes slideInRight-enter{0%{opacity:0;transform-origin:0 0;transform:translateX(100%)}to{opacity:1;transform-origin:0 0;transform:translateX(0)}}@keyframes slideInRight-enter{0%{opacity:0;transform-origin:0 0;transform:translateX(100%)}to{opacity:1;transform-origin:0 0;transform:translateX(0)}}@-webkit-keyframes slideInRight-leave{0%{transform-origin:0 0;transform:translateX(0);opacity:1}100%{transform-origin:0 0;transform:translateX(100%);opacity:0}}@keyframes slideInRight-leave{0%{transform-origin:0 0;transform:translateX(0);opacity:1}100%{transform-origin:0 0;transform:translateX(100%);opacity:0}}@-webkit-keyframes slideInLeft-enter{0%{opacity:0;transform-origin:0 0;transform:translateX(-100%)}to{opacity:1;transform-origin:0 0;transform:translateX(0)}}@keyframes slideInLeft-enter{0%{opacity:0;transform-origin:0 0;transform:translateX(-100%)}to{opacity:1;transform-origin:0 0;transform:translateX(0)}}@-webkit-keyframes slideInLeft-leave{0%{transform-origin:0 0;transform:translateX(0);opacity:1}100%{transform-origin:0 0;transform:translateX(-100%);opacity:0}}@keyframes slideInLeft-leave{0%{transform-origin:0 0;transform:translateX(0);opacity:1}100%{transform-origin:0 0;transform:translateX(-100%);opacity:0}}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px}.el-tag{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary);--el-tag-text-color:var(--el-color-primary);background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);color:var(--el-tag-text-color);display:inline-flex;justify-content:center;align-items:center;height:24px;padding:0 9px;font-size:var(--el-tag-font-size);line-height:1;border-width:1px;border-style:solid;border-radius:var(--el-tag-border-radius);box-sizing:border-box;white-space:nowrap;--el-icon-size:14px}.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{color:var(--el-tag-text-color)}.el-tag .el-tag__close:hover{color:var(--el-color-white);background-color:var(--el-tag-hover-color)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3);--el-tag-text-color:var(--el-color-white);--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--primary{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--success{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--warning{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--danger{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--error{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--info{--el-tag-text-color:var(--el-color-white)}.el-tag--plain{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary);--el-tag-bg-color:var(--el-fill-color-blank)}.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{padding:0 11px;height:32px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{padding:0 7px;height:20px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.time-select{margin:5px 0;min-width:0}.time-select .el-picker-panel__content{max-height:200px;margin:0}.time-select-item{padding:8px 10px;font-size:14px;line-height:20px}.time-select-item.disabled{color:var(--el-datepicker-border-color);cursor:not-allowed}.time-select-item:hover{background-color:var(--el-fill-color-light);font-weight:700;cursor:pointer}.time-select .time-select-item.selected:not(.disabled){color:var(--el-color-primary);font-weight:700}.el-timeline-item{position:relative;padding-bottom:20px}.el-timeline-item__wrapper{position:relative;padding-left:28px;top:-3px}.el-timeline-item__tail{position:absolute;left:4px;height:100%;border-left:2px solid var(--el-timeline-node-color)}.el-timeline-item .el-timeline-item__icon{color:var(--el-color-white);font-size:var(--el-font-size-small)}.el-timeline-item__node{position:absolute;background-color:var(--el-timeline-node-color);border-color:var(--el-timeline-node-color);border-radius:50%;box-sizing:border-box;display:flex;justify-content:center;align-items:center}.el-timeline-item__node--normal{left:-1px;width:var(--el-timeline-node-size-normal);height:var(--el-timeline-node-size-normal)}.el-timeline-item__node--large{left:-2px;width:var(--el-timeline-node-size-large);height:var(--el-timeline-node-size-large)}.el-timeline-item__node.is-hollow{background:var(--el-color-white);border-style:solid;border-width:2px}.el-timeline-item__node--primary{background-color:var(--el-color-primary);border-color:var(--el-color-primary)}.el-timeline-item__node--success{background-color:var(--el-color-success);border-color:var(--el-color-success)}.el-timeline-item__node--warning{background-color:var(--el-color-warning);border-color:var(--el-color-warning)}.el-timeline-item__node--danger{background-color:var(--el-color-danger);border-color:var(--el-color-danger)}.el-timeline-item__node--info{background-color:var(--el-color-info);border-color:var(--el-color-info)}.el-timeline-item__dot{position:absolute;display:flex;justify-content:center;align-items:center}.el-timeline-item__content{color:var(--el-text-color-primary)}.el-timeline-item__timestamp{color:var(--el-text-color-secondary);line-height:1;font-size:var(--el-font-size-small)}.el-timeline-item__timestamp.is-top{margin-bottom:8px;padding-top:4px}.el-timeline-item__timestamp.is-bottom{margin-top:8px}.el-timeline{--el-timeline-node-size-normal:12px;--el-timeline-node-size-large:14px;--el-timeline-node-color:var(--el-border-color-light)}.el-timeline{margin:0;font-size:var(--el-font-size-base);list-style:none}.el-timeline .el-timeline-item:last-child .el-timeline-item__tail{display:none}.el-timeline .el-timeline-item__center{display:flex;align-items:center}.el-timeline .el-timeline-item__center .el-timeline-item__wrapper{width:100%}.el-timeline .el-timeline-item__center .el-timeline-item__tail{top:0}.el-timeline .el-timeline-item__center:first-child .el-timeline-item__tail{height:calc(50% + 10px);top:calc(50% - 10px)}.el-timeline .el-timeline-item__center:last-child .el-timeline-item__tail{display:block;height:calc(50% - 10px)}.el-tooltip-v2__content{--el-tooltip-v2-padding:5px 10px;--el-tooltip-v2-border-radius:4px;--el-tooltip-v2-border-color:var(--el-border-color);border-radius:var(--el-tooltip-v2-border-radius);color:var(--el-color-black);background-color:var(--el-color-white);padding:var(--el-tooltip-v2-padding);border:1px solid var(--el-border-color)}.el-tooltip-v2__arrow{position:absolute;color:var(--el-color-white);width:var(--el-tooltip-v2-arrow-width);height:var(--el-tooltip-v2-arrow-height);pointer-events:none;left:var(--el-tooltip-v2-arrow-x);top:var(--el-tooltip-v2-arrow-y)}.el-tooltip-v2__arrow::before{content:"";width:0;height:0;border:var(--el-tooltip-v2-arrow-border-width) solid transparent;position:absolute}.el-tooltip-v2__arrow::after{content:"";width:0;height:0;border:var(--el-tooltip-v2-arrow-border-width) solid transparent;position:absolute}.el-tooltip-v2__content[data-side^=top] .el-tooltip-v2__arrow{bottom:0}.el-tooltip-v2__content[data-side^=top] .el-tooltip-v2__arrow::before{border-top-color:var(--el-color-white);border-top-width:var(--el-tooltip-v2-arrow-border-width);border-bottom:0;top:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=top] .el-tooltip-v2__arrow::after{border-top-color:var(--el-border-color);border-top-width:var(--el-tooltip-v2-arrow-border-width);border-bottom:0;top:100%;z-index:-1}.el-tooltip-v2__content[data-side^=bottom] .el-tooltip-v2__arrow{top:0}.el-tooltip-v2__content[data-side^=bottom] .el-tooltip-v2__arrow::before{border-bottom-color:var(--el-color-white);border-bottom-width:var(--el-tooltip-v2-arrow-border-width);border-top:0;bottom:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=bottom] .el-tooltip-v2__arrow::after{border-bottom-color:var(--el-border-color);border-bottom-width:var(--el-tooltip-v2-arrow-border-width);border-top:0;bottom:100%;z-index:-1}.el-tooltip-v2__content[data-side^=left] .el-tooltip-v2__arrow{right:0}.el-tooltip-v2__content[data-side^=left] .el-tooltip-v2__arrow::before{border-left-color:var(--el-color-white);border-left-width:var(--el-tooltip-v2-arrow-border-width);border-right:0;left:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=left] .el-tooltip-v2__arrow::after{border-left-color:var(--el-border-color);border-left-width:var(--el-tooltip-v2-arrow-border-width);border-right:0;left:100%;z-index:-1}.el-tooltip-v2__content[data-side^=right] .el-tooltip-v2__arrow{left:0}.el-tooltip-v2__content[data-side^=right] .el-tooltip-v2__arrow::before{border-right-color:var(--el-color-white);border-right-width:var(--el-tooltip-v2-arrow-border-width);border-left:0;right:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=right] .el-tooltip-v2__arrow::after{border-right-color:var(--el-border-color);border-right-width:var(--el-tooltip-v2-arrow-border-width);border-left:0;right:100%;z-index:-1}.el-tooltip-v2__content.is-dark{--el-tooltip-v2-border-color:transparent;background-color:var(--el-color-black);color:var(--el-color-white);border-color:transparent}.el-tooltip-v2__content.is-dark .el-tooltip-v2__arrow{background-color:var(--el-color-black);border-color:transparent}.el-transfer{--el-transfer-border-color:var(--el-border-color-lighter);--el-transfer-border-radius:var(--el-border-radius-base);--el-transfer-panel-width:200px;--el-transfer-panel-header-height:40px;--el-transfer-panel-header-bg-color:var(--el-fill-color-light);--el-transfer-panel-footer-height:40px;--el-transfer-panel-body-height:278px;--el-transfer-item-height:30px;--el-transfer-filter-height:32px}.el-transfer{font-size:var(--el-font-size-base)}.el-transfer__buttons{display:inline-block;vertical-align:middle;padding:0 30px}.el-transfer__button{vertical-align:top}.el-transfer__button:nth-child(2){margin:0 0 0 10px}.el-transfer__button i,.el-transfer__button span{font-size:14px}.el-transfer__button .el-icon+span{margin-left:0}.el-transfer-panel{overflow:hidden;background:var(--el-bg-color-overlay);display:inline-block;text-align:left;vertical-align:middle;width:var(--el-transfer-panel-width);max-height:100%;box-sizing:border-box;position:relative}.el-transfer-panel__body{height:var(--el-transfer-panel-body-height);border-left:1px solid var(--el-transfer-border-color);border-right:1px solid var(--el-transfer-border-color);border-bottom:1px solid var(--el-transfer-border-color);border-bottom-left-radius:var(--el-transfer-border-radius);border-bottom-right-radius:var(--el-transfer-border-radius);overflow:hidden}.el-transfer-panel__body.is-with-footer{border-bottom:none;border-bottom-left-radius:0;border-bottom-right-radius:0}.el-transfer-panel__list{margin:0;padding:6px 0;list-style:none;height:var(--el-transfer-panel-body-height);overflow:auto;box-sizing:border-box}.el-transfer-panel__list.is-filterable{height:calc(100% - var(--el-transfer-filter-height) - 30px);padding-top:0}.el-transfer-panel__item{height:var(--el-transfer-item-height);line-height:var(--el-transfer-item-height);padding-left:15px;display:block!important}.el-transfer-panel__item+.el-transfer-panel__item{margin-left:0}.el-transfer-panel__item.el-checkbox{color:var(--el-text-color-regular)}.el-transfer-panel__item:hover{color:var(--el-color-primary)}.el-transfer-panel__item.el-checkbox .el-checkbox__label{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:block;box-sizing:border-box;padding-left:22px;line-height:var(--el-transfer-item-height)}.el-transfer-panel__item .el-checkbox__input{position:absolute;top:8px}.el-transfer-panel__filter{text-align:center;margin:15px;box-sizing:border-box;width:auto}.el-transfer-panel__filter .el-input__inner{height:var(--el-transfer-filter-height);width:100%;font-size:12px;display:inline-block;box-sizing:border-box;border-radius:calc(var(--el-transfer-filter-height)/ 2)}.el-transfer-panel__filter .el-icon-circle-close{cursor:pointer}.el-transfer-panel .el-transfer-panel__header{display:flex;align-items:center;height:var(--el-transfer-panel-header-height);background:var(--el-transfer-panel-header-bg-color);margin:0;padding-left:15px;border:1px solid var(--el-transfer-border-color);border-top-left-radius:var(--el-transfer-border-radius);border-top-right-radius:var(--el-transfer-border-radius);box-sizing:border-box;color:var(--el-color-black)}.el-transfer-panel .el-transfer-panel__header .el-checkbox{position:relative;display:flex;width:100%;align-items:center}.el-transfer-panel .el-transfer-panel__header .el-checkbox .el-checkbox__label{font-size:16px;color:var(--el-text-color-primary);font-weight:400}.el-transfer-panel .el-transfer-panel__header .el-checkbox .el-checkbox__label span{position:absolute;right:15px;top:50%;transform:translate3d(0,-50%,0);color:var(--el-text-color-secondary);font-size:12px;font-weight:400}.el-transfer-panel .el-transfer-panel__footer{height:var(--el-transfer-panel-footer-height);background:var(--el-bg-color-overlay);margin:0;padding:0;border:1px solid var(--el-transfer-border-color);border-bottom-left-radius:var(--el-transfer-border-radius);border-bottom-right-radius:var(--el-transfer-border-radius)}.el-transfer-panel .el-transfer-panel__footer::after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-transfer-panel .el-transfer-panel__footer .el-checkbox{padding-left:20px;color:var(--el-text-color-regular)}.el-transfer-panel .el-transfer-panel__empty{margin:0;height:var(--el-transfer-item-height);line-height:var(--el-transfer-item-height);padding:6px 15px 0;color:var(--el-text-color-secondary);text-align:center}.el-transfer-panel .el-checkbox__label{padding-left:8px}.el-transfer-panel .el-checkbox__inner{height:14px;width:14px;border-radius:3px}.el-transfer-panel .el-checkbox__inner::after{height:6px;width:3px;left:4px}.el-tree{--el-tree-node-hover-bg-color:var(--el-fill-color-light);--el-tree-text-color:var(--el-text-color-regular);--el-tree-expand-icon-color:var(--el-text-color-placeholder)}.el-tree{position:relative;cursor:default;background:var(--el-fill-color-blank);color:var(--el-tree-text-color)}.el-tree__empty-block{position:relative;min-height:60px;text-align:center;width:100%;height:100%}.el-tree__empty-text{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:var(--el-text-color-secondary);font-size:var(--el-font-size-base)}.el-tree__drop-indicator{position:absolute;left:0;right:0;height:1px;background-color:var(--el-color-primary)}.el-tree-node{white-space:nowrap;outline:0}.el-tree-node:focus>.el-tree-node__content{background-color:var(--el-tree-node-hover-bg-color)}.el-tree-node.is-drop-inner>.el-tree-node__content .el-tree-node__label{background-color:var(--el-color-primary);color:#fff}.el-tree-node__content{display:flex;align-items:center;height:26px;cursor:pointer}.el-tree-node__content>.el-tree-node__expand-icon{padding:6px;box-sizing:content-box}.el-tree-node__content>label.el-checkbox{margin-right:8px}.el-tree-node__content:hover{background-color:var(--el-tree-node-hover-bg-color)}.el-tree.is-dragging .el-tree-node__content{cursor:move}.el-tree.is-dragging .el-tree-node__content *{pointer-events:none}.el-tree.is-dragging.is-drop-not-allow .el-tree-node__content{cursor:not-allowed}.el-tree-node__expand-icon{cursor:pointer;color:var(--el-tree-expand-icon-color);font-size:12px;transform:rotate(0);transition:transform var(--el-transition-duration) ease-in-out}.el-tree-node__expand-icon.expanded{transform:rotate(90deg)}.el-tree-node__expand-icon.is-leaf{color:transparent;cursor:default}.el-tree-node__expand-icon.is-hidden{visibility:hidden}.el-tree-node__label{font-size:var(--el-font-size-base)}.el-tree-node__loading-icon{margin-right:8px;font-size:var(--el-font-size-base);color:var(--el-tree-expand-icon-color)}.el-tree-node>.el-tree-node__children{overflow:hidden;background-color:transparent}.el-tree-node.is-expanded>.el-tree-node__children{display:block}.el-tree--highlight-current .el-tree-node.is-current>.el-tree-node__content{background-color:var(--el-color-primary-light-9)}.el-tree-select{--el-tree-node-hover-bg-color:var(--el-fill-color-light);--el-tree-text-color:var(--el-text-color-regular);--el-tree-expand-icon-color:var(--el-text-color-placeholder)}.el-tree-select__popper .el-tree-node__expand-icon{margin-left:8px}.el-tree-select__popper .el-tree-node.is-checked>.el-tree-node__content .el-select-dropdown__item.selected::after{content:none}.el-tree-select__popper .el-select-dropdown__item{flex:1;background:0 0!important;padding-left:0;height:20px;line-height:20px}.el-upload{--el-upload-dragger-padding-horizontal:40px;--el-upload-dragger-padding-vertical:10px}.el-upload{display:inline-flex;justify-content:center;align-items:center;cursor:pointer;outline:0}.el-upload__input{display:none}.el-upload__tip{font-size:12px;color:var(--el-text-color-regular);margin-top:7px}.el-upload iframe{position:absolute;z-index:-1;top:0;left:0;opacity:0}.el-upload--picture-card{--el-upload-picture-card-size:148px;background-color:var(--el-fill-color-lighter);border:1px dashed var(--el-border-color-darker);border-radius:6px;box-sizing:border-box;width:var(--el-upload-picture-card-size);height:var(--el-upload-picture-card-size);cursor:pointer;vertical-align:top;display:inline-flex;justify-content:center;align-items:center}.el-upload--picture-card i{font-size:28px;color:var(--el-text-color-secondary)}.el-upload--picture-card:hover{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-upload.is-drag{display:block}.el-upload:focus{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-upload:focus .el-upload-dragger{border-color:var(--el-color-primary)}.el-upload-dragger{padding:var(--el-upload-dragger-padding-horizontal) var(--el-upload-dragger-padding-vertical);background-color:var(--el-fill-color-blank);border:1px dashed var(--el-border-color);border-radius:6px;box-sizing:border-box;text-align:center;cursor:pointer;position:relative;overflow:hidden}.el-upload-dragger .el-icon--upload{font-size:67px;color:var(--el-text-color-placeholder);margin-bottom:16px;line-height:50px}.el-upload-dragger+.el-upload__tip{text-align:center}.el-upload-dragger~.el-upload__files{border-top:var(--el-border);margin-top:7px;padding-top:5px}.el-upload-dragger .el-upload__text{color:var(--el-text-color-regular);font-size:14px;text-align:center}.el-upload-dragger .el-upload__text em{color:var(--el-color-primary);font-style:normal}.el-upload-dragger:hover{border-color:var(--el-color-primary)}.el-upload-dragger.is-dragover{padding:calc(var(--el-upload-dragger-padding-horizontal) - 1px) calc(var(--el-upload-dragger-padding-vertical) - 1px);background-color:var(--el-color-primary-light-9);border:2px dashed var(--el-color-primary)}.el-upload-list{margin:10px 0 0;padding:0;list-style:none;position:relative}.el-upload-list__item{transition:all .5s cubic-bezier(.55,0,.1,1);font-size:14px;color:var(--el-text-color-regular);margin-bottom:5px;position:relative;box-sizing:border-box;border-radius:4px;width:100%}.el-upload-list__item .el-progress{position:absolute;top:20px;width:100%}.el-upload-list__item .el-progress__text{position:absolute;right:0;top:-13px}.el-upload-list__item .el-progress-bar{margin-right:0;padding-right:0}.el-upload-list__item .el-icon--upload-success{color:var(--el-color-success)}.el-upload-list__item .el-icon--close{display:none;position:absolute;right:5px;top:50%;cursor:pointer;opacity:.75;color:var(--el-text-color-regular);transition:opacity var(--el-transition-duration);transform:translateY(-50%)}.el-upload-list__item .el-icon--close:hover{opacity:1;color:var(--el-color-primary)}.el-upload-list__item .el-icon--close-tip{display:none;position:absolute;top:1px;right:5px;font-size:12px;cursor:pointer;opacity:1;color:var(--el-color-primary);font-style:normal}.el-upload-list__item:hover{background-color:var(--el-fill-color-light)}.el-upload-list__item:hover .el-icon--close{display:inline-flex}.el-upload-list__item:hover .el-progress__text{display:none}.el-upload-list__item .el-upload-list__item-info{display:inline-flex;justify-content:center;flex-direction:column;width:calc(100% - 30px);margin-left:4px}.el-upload-list__item.is-success .el-upload-list__item-status-label{display:inline-flex}.el-upload-list__item.is-success .el-upload-list__item-name:focus,.el-upload-list__item.is-success .el-upload-list__item-name:hover{color:var(--el-color-primary);cursor:pointer}.el-upload-list__item.is-success:focus:not(:hover) .el-icon--close-tip{display:inline-block}.el-upload-list__item.is-success:active,.el-upload-list__item.is-success:not(.focusing):focus{outline-width:0}.el-upload-list__item.is-success:active .el-icon--close-tip,.el-upload-list__item.is-success:not(.focusing):focus .el-icon--close-tip{display:none}.el-upload-list__item.is-success:focus .el-upload-list__item-status-label,.el-upload-list__item.is-success:hover .el-upload-list__item-status-label{display:none;opacity:0}.el-upload-list.is-disabled .el-upload-list__item-status-label,.el-upload-list.is-disabled .el-upload-list__item:hover{display:block}.el-upload-list__item-name{color:var(--el-text-color-regular);display:inline-flex;text-align:center;align-items:center;padding:0 4px;transition:color var(--el-transition-duration);font-size:var(--el-font-size-base)}.el-upload-list__item-name .el-icon{margin-right:6px;color:var(--el-text-color-secondary)}.el-upload-list__item-file-name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-upload-list__item-status-label{position:absolute;right:5px;top:0;line-height:inherit;display:none;height:100%;justify-content:center;align-items:center;transition:opacity var(--el-transition-duration)}.el-upload-list__item-delete{position:absolute;right:10px;top:0;font-size:12px;color:var(--el-text-color-regular);display:none}.el-upload-list__item-delete:hover{color:var(--el-color-primary)}.el-upload-list--picture-card{--el-upload-list-picture-card-size:148px;display:inline-flex;flex-wrap:wrap;margin:0}.el-upload-list--picture-card .el-upload-list__item{overflow:hidden;background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;width:var(--el-upload-list-picture-card-size);height:var(--el-upload-list-picture-card-size);margin:0 8px 8px 0;padding:0;display:inline-flex}.el-upload-list--picture-card .el-upload-list__item .el-icon--check,.el-upload-list--picture-card .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture-card .el-upload-list__item .el-icon--close{display:none}.el-upload-list--picture-card .el-upload-list__item:hover .el-upload-list__item-status-label{opacity:0;display:block}.el-upload-list--picture-card .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture-card .el-upload-list__item .el-upload-list__item-name{display:none}.el-upload-list--picture-card .el-upload-list__item-thumbnail{width:100%;height:100%;-o-object-fit:contain;object-fit:contain}.el-upload-list--picture-card .el-upload-list__item-status-label{right:-15px;top:-6px;width:40px;height:24px;background:var(--el-color-success);text-align:center;transform:rotate(45deg)}.el-upload-list--picture-card .el-upload-list__item-status-label i{font-size:12px;margin-top:11px;transform:rotate(-45deg)}.el-upload-list--picture-card .el-upload-list__item-actions{position:absolute;width:100%;height:100%;left:0;top:0;cursor:default;display:inline-flex;justify-content:center;align-items:center;color:#fff;opacity:0;font-size:20px;background-color:var(--el-overlay-color-lighter);transition:opacity var(--el-transition-duration)}.el-upload-list--picture-card .el-upload-list__item-actions span{display:none;cursor:pointer}.el-upload-list--picture-card .el-upload-list__item-actions span+span{margin-left:1rem}.el-upload-list--picture-card .el-upload-list__item-actions .el-upload-list__item-delete{position:static;font-size:inherit;color:inherit}.el-upload-list--picture-card .el-upload-list__item-actions:hover{opacity:1}.el-upload-list--picture-card .el-upload-list__item-actions:hover span{display:inline-flex}.el-upload-list--picture-card .el-progress{top:50%;left:50%;transform:translate(-50%,-50%);bottom:auto;width:126px}.el-upload-list--picture-card .el-progress .el-progress__text{top:50%}.el-upload-list--picture .el-upload-list__item{overflow:hidden;z-index:0;background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;margin-top:10px;padding:10px;display:flex;align-items:center}.el-upload-list--picture .el-upload-list__item .el-icon--check,.el-upload-list--picture .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture .el-upload-list__item:hover .el-upload-list__item-status-label{opacity:0;display:block}.el-upload-list--picture .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture .el-upload-list__item.is-success .el-upload-list__item-name i{display:none}.el-upload-list--picture .el-upload-list__item .el-icon--close{top:5px;transform:translateY(0)}.el-upload-list--picture .el-upload-list__item-thumbnail{display:inline-flex;justify-content:center;align-items:center;width:70px;height:70px;-o-object-fit:contain;object-fit:contain;position:relative;z-index:1;background-color:var(--el-color-white)}.el-upload-list--picture .el-upload-list__item-status-label{position:absolute;right:-17px;top:-7px;width:46px;height:26px;background:var(--el-color-success);text-align:center;transform:rotate(45deg)}.el-upload-list--picture .el-upload-list__item-status-label i{font-size:12px;margin-top:12px;transform:rotate(-45deg)}.el-upload-list--picture .el-progress{position:relative;top:-7px}.el-upload-cover{position:absolute;left:0;top:0;width:100%;height:100%;overflow:hidden;z-index:10;cursor:default}.el-upload-cover::after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-upload-cover img{display:block;width:100%;height:100%}.el-upload-cover__label{right:-15px;top:-6px;width:40px;height:24px;background:var(--el-color-success);text-align:center;transform:rotate(45deg)}.el-upload-cover__label i{font-size:12px;margin-top:11px;transform:rotate(-45deg);color:#fff}.el-upload-cover__progress{display:inline-block;vertical-align:middle;position:static;width:243px}.el-upload-cover__progress+.el-upload__inner{opacity:0}.el-upload-cover__content{position:absolute;top:0;left:0;width:100%;height:100%}.el-upload-cover__interact{position:absolute;bottom:0;left:0;width:100%;height:100%;background-color:var(--el-overlay-color-light);text-align:center}.el-upload-cover__interact .btn{display:inline-block;color:#fff;font-size:14px;cursor:pointer;vertical-align:middle;transition:var(--el-transition-md-fade);margin-top:60px}.el-upload-cover__interact .btn i{margin-top:0}.el-upload-cover__interact .btn span{opacity:0;transition:opacity .15s linear}.el-upload-cover__interact .btn:not(:first-child){margin-left:35px}.el-upload-cover__interact .btn:hover{transform:translateY(-13px)}.el-upload-cover__interact .btn:hover span{opacity:1}.el-upload-cover__interact .btn i{color:#fff;display:block;font-size:24px;line-height:inherit;margin:0 auto 5px}.el-upload-cover__title{position:absolute;bottom:0;left:0;background-color:#fff;height:36px;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:400;text-align:left;padding:0 10px;margin:0;line-height:36px;font-size:14px;color:var(--el-text-color-primary)}.el-upload-cover+.el-upload__inner{opacity:0;position:relative;z-index:1}.el-vl__wrapper{position:relative}.el-vl__wrapper:hover .el-virtual-scrollbar{opacity:1}.el-vl__wrapper.always-on .el-virtual-scrollbar{opacity:1}.el-vl__window{scrollbar-width:none}.el-vl__window::-webkit-scrollbar{display:none}.el-virtual-scrollbar{opacity:0;transition:opacity 340ms ease-out}.el-virtual-scrollbar.always-on{opacity:1}.el-vg__wrapper{position:relative}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius, 4px)}.el-popper{position:absolute;border-radius:var(--el-popper-border-radius);padding:5px 11px;z-index:2000;font-size:12px;line-height:20px;min-width:10px;word-wrap:break-word;visibility:visible}.el-popper.is-dark{color:var(--el-bg-color);background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark .el-popper__arrow::before{border:1px solid var(--el-text-color-primary);background:var(--el-text-color-primary);right:0}.el-popper.is-light{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light .el-popper__arrow::before{border:1px solid var(--el-border-color-light);background:var(--el-bg-color-overlay);right:0}.el-popper.is-pure{padding:0}.el-popper__arrow{position:absolute;width:10px;height:10px;z-index:-1}.el-popper__arrow::before{position:absolute;width:10px;height:10px;z-index:-1;content:" ";transform:rotate(45deg);background:var(--el-text-color-primary);box-sizing:border-box}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow::before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow::before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow::before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow::before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent!important;border-bottom-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent!important;border-top-color:transparent!important}.el-select-dropdown__item{font-size:var(--el-font-size-base);padding:0 32px 0 20px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--el-text-color-regular);height:34px;line-height:34px;box-sizing:border-box;cursor:pointer}.el-select-dropdown__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown__item.hover,.el-select-dropdown__item:hover{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.selected{color:var(--el-color-primary);font-weight:700}:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:'Helvetica Neue',Helvetica,'PingFang SC','Hiragino Sans GB','Microsoft YaHei','微软雅黑',Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:0.3s;--el-transition-duration-fast:0.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(0.645, 0.045, 0.355, 1);--el-transition-function-fast-bezier:cubic-bezier(0.23, 1, 0.32, 1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0, 0, 0, 0.04),0px 8px 20px rgba(0, 0, 0, 0.08);--el-box-shadow-light:0px 0px 12px rgba(0, 0, 0, 0.12);--el-box-shadow-lighter:0px 0px 6px rgba(0, 0, 0, 0.12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0, 0, 0, 0.08),0px 12px 32px rgba(0, 0, 0, 0.12),0px 8px 16px -8px rgba(0, 0, 0, 0.16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0, 0, 0, 0.8);--el-overlay-color-light:rgba(0, 0, 0, 0.7);--el-overlay-color-lighter:rgba(0, 0, 0, 0.5);--el-mask-color:rgba(255, 255, 255, 0.9);--el-mask-color-extra-light:rgba(255, 255, 255, 0.3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center top}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center bottom}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1,1);transition:var(--el-transition-md-fade);transform-origin:top left}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45,.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-icon-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@-webkit-keyframes rotating{0%{transform:rotateZ(0)}100%{transform:rotateZ(360deg)}}@keyframes rotating{0%{transform:rotateZ(0)}100%{transform:rotateZ(360deg)}}.el-icon{--color:inherit;height:1em;width:1em;line-height:1em;display:inline-flex;justify-content:center;align-items:center;position:relative;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.el-radio-group{display:inline-flex;align-items:center;flex-wrap:wrap;font-size:0}.el-radio{--el-radio-font-size:var(--el-font-size-base);--el-radio-text-color:var(--el-text-color-regular);--el-radio-font-weight:var(--el-font-weight-primary);--el-radio-input-height:14px;--el-radio-input-width:14px;--el-radio-input-border-radius:var(--el-border-radius-circle);--el-radio-input-bg-color:var(--el-fill-color-blank);--el-radio-input-border:var(--el-border);--el-radio-input-border-color:var(--el-border-color);--el-radio-input-border-color-hover:var(--el-color-primary)}.el-radio{color:var(--el-radio-text-color);font-weight:var(--el-radio-font-weight);position:relative;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;outline:0;font-size:var(--el-font-size-base);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-right:32px;height:32px}.el-radio.el-radio--large{height:40px}.el-radio.el-radio--small{height:24px}.el-radio.is-bordered{padding:0 15px 0 9px;border-radius:var(--el-border-radius-base);border:var(--el-border);box-sizing:border-box}.el-radio.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-radio.is-bordered.is-disabled{cursor:not-allowed;border-color:var(--el-border-color-lighter)}.el-radio.is-bordered.el-radio--large{padding:0 19px 0 11px;border-radius:var(--el-border-radius-base)}.el-radio.is-bordered.el-radio--large .el-radio__label{font-size:var(--el-font-size-base)}.el-radio.is-bordered.el-radio--large .el-radio__inner{height:14px;width:14px}.el-radio.is-bordered.el-radio--small{padding:0 11px 0 7px;border-radius:var(--el-border-radius-base)}.el-radio.is-bordered.el-radio--small .el-radio__label{font-size:12px}.el-radio.is-bordered.el-radio--small .el-radio__inner{height:12px;width:12px}.el-radio:last-child{margin-right:0}.el-radio__input{white-space:nowrap;cursor:pointer;outline:0;display:inline-flex;position:relative;vertical-align:middle}.el-radio__input.is-disabled .el-radio__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);cursor:not-allowed}.el-radio__input.is-disabled .el-radio__inner::after{cursor:not-allowed;background-color:var(--el-disabled-bg-color)}.el-radio__input.is-disabled .el-radio__inner+.el-radio__label{cursor:not-allowed}.el-radio__input.is-disabled.is-checked .el-radio__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color)}.el-radio__input.is-disabled.is-checked .el-radio__inner::after{background-color:var(--el-text-color-placeholder)}.el-radio__input.is-disabled+span.el-radio__label{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-radio__input.is-checked .el-radio__inner{border-color:var(--el-color-primary);background:var(--el-color-primary)}.el-radio__input.is-checked .el-radio__inner::after{transform:translate(-50%,-50%) scale(1)}.el-radio__input.is-checked+.el-radio__label{color:var(--el-color-primary)}.el-radio__input.is-focus .el-radio__inner{border-color:var(--el-radio-input-border-color-hover)}.el-radio__inner{border:var(--el-radio-input-border);border-radius:var(--el-radio-input-border-radius);width:var(--el-radio-input-width);height:var(--el-radio-input-height);background-color:var(--el-radio-input-bg-color);position:relative;cursor:pointer;display:inline-block;box-sizing:border-box}.el-radio__inner:hover{border-color:var(--el-radio-input-border-color-hover)}.el-radio__inner::after{width:4px;height:4px;border-radius:var(--el-radio-input-border-radius);background-color:var(--el-color-white);content:"";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) scale(0);transition:transform .15s ease-in}.el-radio__original{opacity:0;outline:0;position:absolute;z-index:-1;top:0;left:0;right:0;bottom:0;margin:0}.el-radio__original:focus-visible+.el-radio__inner{outline:2px solid var(--el-radio-input-border-color-hover);outline-offset:1px;border-radius:var(--el-radio-input-border-radius)}.el-radio:focus:not(:focus-visible):not(.is-focus):not(:active):not(.is-disabled) .el-radio__inner{box-shadow:0 0 2px 2px var(--el-radio-input-border-color-hover)}.el-radio__label{font-size:var(--el-radio-font-size);padding-left:8px}.el-radio.el-radio--large .el-radio__label{font-size:14px}.el-radio.el-radio--large .el-radio__inner{width:14px;height:14px}.el-radio.el-radio--small .el-radio__label{font-size:12px}.el-radio.el-radio--small .el-radio__inner{width:12px;height:12px}.el-divider{position:relative}.el-divider--horizontal{display:block;height:1px;width:100%;margin:24px 0;border-top:1px var(--el-border-color) var(--el-border-style)}.el-divider--vertical{display:inline-block;width:1px;height:1em;margin:0 8px;vertical-align:middle;position:relative;border-left:1px var(--el-border-color) var(--el-border-style)}.el-divider__text{position:absolute;background-color:var(--el-bg-color);padding:0 20px;font-weight:500;color:var(--el-text-color-primary);font-size:14px}.el-divider__text.is-left{left:20px;transform:translateY(-50%)}.el-divider__text.is-center{left:50%;transform:translateX(-50%) translateY(-50%)}.el-divider__text.is-right{right:20px;transform:translateY(-50%)}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary)}.el-textarea{position:relative;display:inline-block;width:100%;vertical-align:bottom;font-size:var(--el-font-size-base)}.el-textarea__inner{position:relative;display:block;resize:vertical;padding:5px 11px;line-height:1.5;box-sizing:border-box;width:100%;font-size:inherit;font-family:inherit;color:var(--el-input-text-color,var(--el-text-color-regular));background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;-webkit-appearance:none;box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);border:none}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{outline:0;box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-textarea .el-input__count{color:var(--el-color-info);background:var(--el-fill-color-blank);position:absolute;font-size:12px;line-height:14px;bottom:5px;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{border-color:var(--el-color-danger)}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary)}.el-input{--el-input-height:var(--el-component-size);position:relative;font-size:var(--el-font-size-base);display:inline-flex;width:100%;line-height:var(--el-input-height);box-sizing:border-box}.el-input::-webkit-scrollbar{z-index:11;width:6px}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{border-radius:5px;width:6px;background:var(--el-text-color-disabled)}.el-input::-webkit-scrollbar-corner{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);font-size:14px;cursor:pointer}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{height:100%;display:inline-flex;align-items:center;color:var(--el-color-info);font-size:12px}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);line-height:initial;display:inline-block;padding-left:8px}.el-input__wrapper{display:inline-flex;flex-grow:1;align-items:center;justify-content:center;padding:1px 11px;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);width:100%;flex-grow:1;-webkit-appearance:none;color:var(--el-input-text-color,var(--el-text-color-regular));font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);padding:0;outline:0;border:none;background:0 0;box-sizing:border-box}.el-input__inner:focus{outline:0}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__prefix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__prefix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__suffix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{height:inherit;line-height:inherit;display:flex;justify-content:center;align-items:center;transition:all var(--el-transition-duration);margin-left:8px}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color,) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{display:inline-flex;width:100%;align-items:stretch}.el-input-group__append,.el-input-group__prepend{background-color:var(--el-fill-color-light);color:var(--el-color-info);position:relative;display:inline-flex;align-items:center;justify-content:center;min-height:100%;border-radius:var(--el-input-border-radius);padding:0 20px;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:0}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-input__wrapper,.el-input-group__append div.el-select:hover .el-input__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-input__wrapper,.el-input-group__prepend div.el-select:hover .el-input__wrapper{border-color:transparent;background-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-right:0;border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper{box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important;z-index:2}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper:focus{outline:0;z-index:2;box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__wrapper{z-index:1;box-shadow:1px 0 0 0 var(--el-input-hover-border-color) inset,1px 0 0 0 var(--el-input-hover-border-color),0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}.el-input-group--append>.el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__wrapper{z-index:2;box-shadow:-1px 0 0 0 var(--el-input-focus-border-color),-1px 0 0 0 var(--el-input-focus-border-color) inset,0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__wrapper{z-index:1;box-shadow:-1px 0 0 0 var(--el-input-hover-border-color),-1px 0 0 0 var(--el-input-hover-border-color) inset,0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:0.5}.v-modal-enter{-webkit-animation:v-modal-in var(--el-transition-duration-fast) ease;animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{-webkit-animation:v-modal-out var(--el-transition-duration-fast) ease forwards;animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@-webkit-keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-in{0%{opacity:0}}@-webkit-keyframes v-modal-out{100%{opacity:0}}@keyframes v-modal-out{100%{opacity:0}}.v-modal{position:fixed;left:0;top:0;width:100%;height:100%;opacity:var(--el-popup-modal-opacity);background:var(--el-popup-modal-bg-color)}.el-popup-parent--hidden{overflow:hidden}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:20px;--el-dialog-border-radius:var(--el-border-radius-small);position:relative;margin:var(--el-dialog-margin-top,15vh) auto 50px;background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:0!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;margin-bottom:0;height:100%;overflow:auto}.el-dialog__wrapper{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto;margin:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-dialog__header{padding:var(--el-dialog-padding-primary);padding-bottom:10px;margin-right:16px;word-break:break-all}.el-dialog__headerbtn{position:absolute;top:6px;right:0;padding:0;width:54px;height:54px;background:0 0;border:none;outline:0;cursor:pointer;font-size:var(--el-message-close-size,16px)}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{line-height:var(--el-dialog-font-line-height);font-size:var(--el-dialog-title-font-size);color:var(--el-text-color-primary)}.el-dialog__body{padding:calc(var(--el-dialog-padding-primary) + 10px) var(--el-dialog-padding-primary);color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size);word-break:break-all}.el-dialog__footer{padding:var(--el-dialog-padding-primary);padding-top:10px;text-align:right;box-sizing:border-box}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial;padding:25px calc(var(--el-dialog-padding-primary) + 5px) 30px}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto}.dialog-fade-enter-active{-webkit-animation:modal-fade-in var(--el-transition-duration);animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{-webkit-animation:dialog-fade-in var(--el-transition-duration);animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{-webkit-animation:modal-fade-out var(--el-transition-duration);animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{-webkit-animation:dialog-fade-out var(--el-transition-duration);animation:dialog-fade-out var(--el-transition-duration)}@-webkit-keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@-webkit-keyframes dialog-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}@keyframes dialog-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}@-webkit-keyframes modal-fade-in{0%{opacity:0}100%{opacity:1}}@keyframes modal-fade-in{0%{opacity:0}100%{opacity:1}}@-webkit-keyframes modal-fade-out{0%{opacity:1}100%{opacity:0}}@keyframes modal-fade-out{0%{opacity:1}100%{opacity:0}}.el-overlay{position:fixed;top:0;right:0;bottom:0;left:0;z-index:2000;height:100%;background-color:var(--el-overlay-color-lighter);overflow:auto}.el-overlay .el-overlay-root{height:0}.el-container{display:flex;flex-direction:row;flex:1;flex-basis:auto;box-sizing:border-box;min-width:0}.el-container.is-vertical{flex-direction:column}.el-aside{overflow:auto;box-sizing:border-box;flex-shrink:0;width:var(--el-aside-width,300px)}.el-footer{--el-footer-padding:0 20px;--el-footer-height:60px;padding:var(--el-footer-padding);box-sizing:border-box;flex-shrink:0;height:var(--el-footer-height)}.el-header{--el-header-padding:0 20px;--el-header-height:60px;padding:var(--el-header-padding);box-sizing:border-box;flex-shrink:0;height:var(--el-header-height)}.el-main{--el-main-padding:20px;display:block;flex:1;flex-basis:auto;overflow:auto;box-sizing:border-box;padding:var(--el-main-padding)}.el-table{--el-table-border-color:var(--el-border-color-lighter);--el-table-border:1px solid var(--el-table-border-color);--el-table-text-color:var(--el-text-color-regular);--el-table-header-text-color:var(--el-text-color-secondary);--el-table-row-hover-bg-color:var(--el-fill-color-light);--el-table-current-row-bg-color:var(--el-color-primary-light-9);--el-table-header-bg-color:var(--el-bg-color);--el-table-fixed-box-shadow:var(--el-box-shadow-light);--el-table-bg-color:var(--el-fill-color-blank);--el-table-tr-bg-color:var(--el-fill-color-blank);--el-table-expanded-cell-bg-color:var(--el-fill-color-blank);--el-table-fixed-left-column:inset 10px 0 10px -10px rgba(0, 0, 0, 0.15);--el-table-fixed-right-column:inset -10px 0 10px -10px rgba(0, 0, 0, 0.15)}.el-table{position:relative;overflow:hidden;box-sizing:border-box;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;width:100%;max-width:100%;background-color:var(--el-table-bg-color);font-size:14px;color:var(--el-table-text-color)}.el-table__inner-wrapper{position:relative;display:flex;flex-direction:column;height:100%}.el-table__inner-wrapper::before{left:0;bottom:0;width:100%;height:1px;z-index:3}.el-table.has-footer.el-table--fluid-height tr:last-child td.el-table__cell,.el-table.has-footer.el-table--scrollable-y tr:last-child td.el-table__cell{border-bottom-color:transparent}.el-table__empty-block{position:-webkit-sticky;position:sticky;left:0;min-height:60px;text-align:center;width:100%;display:flex;justify-content:center;align-items:center}.el-table__empty-text{line-height:60px;width:50%;color:var(--el-text-color-secondary)}.el-table__expand-column .cell{padding:0;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-table__expand-icon{position:relative;cursor:pointer;color:var(--el-text-color-regular);font-size:12px;transition:transform var(--el-transition-duration-fast) ease-in-out;height:20px}.el-table__expand-icon--expanded{transform:rotate(90deg)}.el-table__expand-icon>.el-icon{font-size:12px}.el-table__expanded-cell{background-color:var(--el-table-expanded-cell-bg-color)}.el-table__expanded-cell[class*=cell]{padding:20px 50px}.el-table__expanded-cell:hover{background-color:transparent!important}.el-table__placeholder{display:inline-block;width:20px}.el-table__append-wrapper{overflow:hidden}.el-table--fit{border-right:0;border-bottom:0}.el-table--fit .el-table__cell.gutter{border-right-width:1px}.el-table thead{color:var(--el-table-header-text-color);font-weight:500}.el-table thead.is-group th.el-table__cell{background:var(--el-fill-color-light)}.el-table .el-table__cell{padding:8px 0;min-width:0;box-sizing:border-box;text-overflow:ellipsis;vertical-align:middle;position:relative;text-align:left;z-index:1}.el-table .el-table__cell.is-center{text-align:center}.el-table .el-table__cell.is-right{text-align:right}.el-table .el-table__cell.gutter{width:15px;border-right-width:0;border-bottom-width:0;padding:0}.el-table .el-table__cell.is-hidden>*{visibility:hidden}.el-table .cell{box-sizing:border-box;overflow:hidden;text-overflow:ellipsis;white-space:normal;word-break:break-all;line-height:23px;padding:0 12px}.el-table .cell.el-tooltip{white-space:nowrap;min-width:50px}.el-table--large{font-size:var(--el-font-size-base)}.el-table--large .el-table__cell{padding:12px 0}.el-table--large .cell{padding:0 16px}.el-table--small{font-size:12px}.el-table--small .el-table__cell{padding:4px 0}.el-table--small .cell{padding:0 8px}.el-table tr{background-color:var(--el-table-tr-bg-color)}.el-table tr input[type=checkbox]{margin:0}.el-table td.el-table__cell,.el-table th.el-table__cell.is-leaf{border-bottom:var(--el-table-border)}.el-table th.el-table__cell.is-sortable{cursor:pointer}.el-table th.el-table__cell{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:var(--el-table-header-bg-color)}.el-table th.el-table__cell>.cell.highlight{color:var(--el-color-primary)}.el-table th.el-table__cell.required>div::before{display:inline-block;content:"";width:8px;height:8px;border-radius:50%;background:#ff4d51;margin-right:5px;vertical-align:middle}.el-table td.el-table__cell div{box-sizing:border-box}.el-table td.el-table__cell.gutter{width:0}.el-table__footer-wrapper{border-top:var(--el-table-border)}.el-table--border .el-table__footer-wrapper tr:first-child td:first-child,.el-table--border .el-table__footer-wrapper tr:first-child th:first-child,.el-table--border .el-table__inner-wrapper tr:first-child td:first-child,.el-table--border .el-table__inner-wrapper tr:first-child th:first-child,.el-table--group .el-table__footer-wrapper tr:first-child td:first-child,.el-table--group .el-table__footer-wrapper tr:first-child th:first-child,.el-table--group .el-table__inner-wrapper tr:first-child td:first-child,.el-table--group .el-table__inner-wrapper tr:first-child th:first-child{border-left:var(--el-table-border)}.el-table--border .el-table__inner-wrapper::after,.el-table--border::after,.el-table--border::before,.el-table__inner-wrapper::before{content:"";position:absolute;background-color:var(--el-table-border-color);z-index:3}.el-table--border .el-table__inner-wrapper::after{left:0;top:0;width:100%;height:1px;z-index:3}.el-table--border::before{top:-1px;left:0;width:1px;height:100%;z-index:3}.el-table--border::after{top:-1px;right:0;width:1px;height:100%;z-index:3}.el-table--border .el-table__inner-wrapper{border-right:none;border-bottom:none}.el-table--border .el-table__footer-wrapper{position:relative;flex-shrink:0}.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table--border th.el-table__cell.gutter:last-of-type{border-bottom:var(--el-table-border);border-bottom-width:1px}.el-table--border th.el-table__cell{border-bottom:var(--el-table-border)}.el-table--hidden{visibility:hidden}.el-table__body-wrapper,.el-table__footer-wrapper,.el-table__header-wrapper{width:100%}.el-table__body-wrapper tr td.el-table-fixed-column--left,.el-table__body-wrapper tr td.el-table-fixed-column--right,.el-table__body-wrapper tr th.el-table-fixed-column--left,.el-table__body-wrapper tr th.el-table-fixed-column--right,.el-table__footer-wrapper tr td.el-table-fixed-column--left,.el-table__footer-wrapper tr td.el-table-fixed-column--right,.el-table__footer-wrapper tr th.el-table-fixed-column--left,.el-table__footer-wrapper tr th.el-table-fixed-column--right,.el-table__header-wrapper tr td.el-table-fixed-column--left,.el-table__header-wrapper tr td.el-table-fixed-column--right,.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{position:-webkit-sticky!important;position:sticky!important;z-index:2;background:var(--el-bg-color)}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column::before{content:"";position:absolute;top:0;width:10px;bottom:-1px;overflow-x:hidden;overflow-y:hidden;box-shadow:none;touch-action:none;pointer-events:none}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column::before{left:-10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column::before{right:-10px;box-shadow:none}.el-table__body-wrapper tr td.el-table__fixed-right-patch,.el-table__body-wrapper tr th.el-table__fixed-right-patch,.el-table__footer-wrapper tr td.el-table__fixed-right-patch,.el-table__footer-wrapper tr th.el-table__fixed-right-patch,.el-table__header-wrapper tr td.el-table__fixed-right-patch,.el-table__header-wrapper tr th.el-table__fixed-right-patch{position:-webkit-sticky!important;position:sticky!important;z-index:2;background:#fff;right:0}.el-table__header-wrapper{flex-shrink:0}.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body,.el-table__footer,.el-table__header{table-layout:fixed;border-collapse:separate}.el-table__footer-wrapper,.el-table__header-wrapper{overflow:hidden}.el-table__footer-wrapper tbody td.el-table__cell,.el-table__header-wrapper tbody td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__body-wrapper .el-table-column--selection>.cell,.el-table__header-wrapper .el-table-column--selection>.cell{display:inline-flex;align-items:center;height:23px}.el-table__body-wrapper .el-table-column--selection .el-checkbox,.el-table__header-wrapper .el-table-column--selection .el-checkbox{height:unset}.el-table.is-scrolling-left .el-table-fixed-column--right.is-first-column::before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-left.el-table--border .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:var(--el-table-border)}.el-table.is-scrolling-left th.el-table-fixed-column--left{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column::before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-right th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-middle .el-table-fixed-column--right.is-first-column::before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column::before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-none .el-table-fixed-column--left.is-first-column::before,.el-table.is-scrolling-none .el-table-fixed-column--left.is-last-column::before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-first-column::before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-last-column::before{box-shadow:none}.el-table.is-scrolling-none th.el-table-fixed-column--left,.el-table.is-scrolling-none th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body-wrapper{overflow:hidden;position:relative;flex:1}.el-table__body-wrapper .el-scrollbar__bar{z-index:2}.el-table .caret-wrapper{display:inline-flex;flex-direction:column;align-items:center;height:14px;width:24px;vertical-align:middle;cursor:pointer;overflow:initial;position:relative}.el-table .sort-caret{width:0;height:0;border:solid 5px transparent;position:absolute;left:7px}.el-table .sort-caret.ascending{border-bottom-color:var(--el-text-color-placeholder);top:-5px}.el-table .sort-caret.descending{border-top-color:var(--el-text-color-placeholder);bottom:-3px}.el-table .ascending .sort-caret.ascending{border-bottom-color:var(--el-color-primary)}.el-table .descending .sort-caret.descending{border-top-color:var(--el-color-primary)}.el-table .hidden-columns{visibility:hidden;position:absolute;z-index:-1}.el-table--striped .el-table__body tr.el-table__row--striped td.el-table__cell{background:var(--el-fill-color-lighter)}.el-table--striped .el-table__body tr.el-table__row--striped.current-row td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table__body tr.hover-row.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped>td.el-table__cell,.el-table__body tr.hover-row>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table__body tr.current-row>td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table__column-resize-proxy{position:absolute;left:200px;top:0;bottom:0;width:0;border-left:var(--el-table-border);z-index:10}.el-table__column-filter-trigger{display:inline-block;cursor:pointer}.el-table__column-filter-trigger i{color:var(--el-color-info);font-size:14px;vertical-align:middle}.el-table__border-left-patch{top:0;left:0;width:1px;height:100%;z-index:3;position:absolute;background-color:var(--el-table-border-color)}.el-table__border-bottom-patch{left:0;height:1px;z-index:3;position:absolute;background-color:var(--el-table-border-color)}.el-table__border-right-patch{top:0;height:100%;width:1px;z-index:3;position:absolute;background-color:var(--el-table-border-color)}.el-table--enable-row-transition .el-table__body td.el-table__cell{transition:background-color .25s ease}.el-table--enable-row-hover .el-table__body tr:hover>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table [class*=el-table__row--level] .el-table__expand-icon{display:inline-block;width:12px;line-height:12px;height:12px;text-align:center;margin-right:8px}.el-table .el-table.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table:not(.el-table--border) .el-table__cell{border-right:none}.el-table:not(.el-table--border)>.el-table__inner-wrapper::after{content:none}.el-table:not(.el-table--border) .el-table__footer-wrapper tr:first-child td:first-child,.el-table:not(.el-table--border) .el-table__footer-wrapper tr:first-child th:first-child,.el-table:not(.el-table--border) .el-table__inner-wrapper tr:first-child td:first-child,.el-table:not(.el-table--border) .el-table__inner-wrapper tr:first-child th:first-child{border-left:none}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary)}.el-checkbox{color:var(--el-checkbox-text-color);font-weight:var(--el-checkbox-font-weight);font-size:var(--el-font-size-base);position:relative;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-right:30px;height:32px}.el-checkbox.is-bordered{padding:0 15px 0 9px;border-radius:var(--el-border-radius-base);border:var(--el-border);box-sizing:border-box}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter);cursor:not-allowed}.el-checkbox.is-bordered.el-checkbox--large{padding:0 19px 0 11px;border-radius:var(--el-border-radius-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{padding:0 11px 0 7px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner::after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px;border-radius:var(--el-checkbox-border-radius)}.el-checkbox__input{white-space:nowrap;cursor:pointer;outline:0;display:inline-flex;position:relative}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner::after{cursor:not-allowed;border-color:var(--el-checkbox-disabled-icon-color)}.el-checkbox__input.is-disabled .el-checkbox__inner+.el-checkbox__label{cursor:not-allowed}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner::after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner::before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner::after{transform:rotate(45deg) scaleY(1)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner::before{content:"";position:absolute;display:block;background-color:var(--el-checkbox-checked-icon-color);height:2px;transform:scale(.5);left:0;right:0;top:5px}.el-checkbox__input.is-indeterminate .el-checkbox__inner::after{display:none}.el-checkbox__inner{display:inline-block;position:relative;border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;width:var(--el-checkbox-input-width);height:var(--el-checkbox-input-height);background-color:var(--el-checkbox-bg-color);z-index:var(--el-index-normal);transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner::after{box-sizing:content-box;content:"";border:1px solid var(--el-checkbox-checked-icon-color);border-left:0;border-top:0;height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);width:3px;transition:transform .15s ease-in 50ms;transform-origin:center}.el-checkbox__original{opacity:0;outline:0;position:absolute;margin:0;width:0;height:0;z-index:-1}.el-checkbox__label{display:inline-block;padding-left:8px;line-height:1;font-size:var(--el-checkbox-font-size)}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{width:14px;height:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{width:12px;height:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner::before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner::after{width:2px;height:6px}.el-checkbox:last-of-type{margin-right:0}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px}.el-tag{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary);--el-tag-text-color:var(--el-color-primary);background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);color:var(--el-tag-text-color);display:inline-flex;justify-content:center;align-items:center;height:24px;padding:0 9px;font-size:var(--el-tag-font-size);line-height:1;border-width:1px;border-style:solid;border-radius:var(--el-tag-border-radius);box-sizing:border-box;white-space:nowrap;--el-icon-size:14px}.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{color:var(--el-tag-text-color)}.el-tag .el-tag__close:hover{color:var(--el-color-white);background-color:var(--el-tag-hover-color)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3);--el-tag-text-color:var(--el-color-white);--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--primary{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--success{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--warning{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--danger{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--error{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--info{--el-tag-text-color:var(--el-color-white)}.el-tag--plain{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary);--el-tag-bg-color:var(--el-fill-color-blank)}.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{padding:0 11px;height:32px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{padding:0 7px;height:20px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius, 4px)}.el-popper{position:absolute;border-radius:var(--el-popper-border-radius);padding:5px 11px;z-index:2000;font-size:12px;line-height:20px;min-width:10px;word-wrap:break-word;visibility:visible}.el-popper.is-dark{color:var(--el-bg-color);background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark .el-popper__arrow::before{border:1px solid var(--el-text-color-primary);background:var(--el-text-color-primary);right:0}.el-popper.is-light{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light .el-popper__arrow::before{border:1px solid var(--el-border-color-light);background:var(--el-bg-color-overlay);right:0}.el-popper.is-pure{padding:0}.el-popper__arrow{position:absolute;width:10px;height:10px;z-index:-1}.el-popper__arrow::before{position:absolute;width:10px;height:10px;z-index:-1;content:" ";transform:rotate(45deg);background:var(--el-text-color-primary);box-sizing:border-box}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow::before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow::before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow::before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow::before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent!important;border-bottom-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent!important;border-top-color:transparent!important}.el-scrollbar{--el-scrollbar-opacity:0.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:0.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary)}.el-scrollbar{overflow:hidden;position:relative;height:100%}.el-scrollbar__wrap{overflow:auto;height:100%}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{position:relative;display:block;width:0;height:0;cursor:pointer;border-radius:inherit;background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));transition:var(--el-transition-duration) background-color;opacity:var(--el-scrollbar-opacity,.3)}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{position:absolute;right:2px;bottom:2px;z-index:1;border-radius:4px}.el-scrollbar__bar.is-vertical{width:6px;top:2px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity 340ms ease-out}.el-scrollbar-fade-leave-active{transition:opacity 120ms ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-table-column--selection .cell{padding-left:14px;padding-right:14px}.el-table-filter{border:solid 1px var(--el-border-color-lighter);border-radius:2px;background-color:#fff;box-shadow:var(--el-box-shadow-light);box-sizing:border-box}.el-table-filter__list{padding:5px 0;margin:0;list-style:none;min-width:100px}.el-table-filter__list-item{line-height:36px;padding:0 10px;cursor:pointer;font-size:var(--el-font-size-base)}.el-table-filter__list-item:hover{background-color:var(--el-color-primary-light-9);color:var(--el-color-primary)}.el-table-filter__list-item.is-active{background-color:var(--el-color-primary);color:#fff}.el-table-filter__content{min-width:100px}.el-table-filter__bottom{border-top:1px solid var(--el-border-color-lighter);padding:8px}.el-table-filter__bottom button{background:0 0;border:none;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-small);padding:0 3px}.el-table-filter__bottom button:hover{color:var(--el-color-primary)}.el-table-filter__bottom button:focus{outline:0}.el-table-filter__bottom button.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-table-filter__wrap{max-height:280px}.el-table-filter__checkbox-group{padding:10px}.el-table-filter__checkbox-group label.el-checkbox{display:flex;align-items:center;margin-right:5px;margin-bottom:12px;margin-left:5px;height:unset}.el-table-filter__checkbox-group .el-checkbox:last-child{margin-bottom:0}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255, 255, 255, 0.5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-color-info);--el-button-active-color:var(--el-text-color-primary)}.el-button{display:inline-flex;justify-content:center;align-items:center;line-height:1;height:32px;white-space:nowrap;cursor:pointer;color:var(--el-button-text-color);text-align:center;box-sizing:border-box;outline:0;transition:.1s;font-weight:var(--el-button-font-weight);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);padding:8px 15px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button:focus,.el-button:hover{color:var(--el-button-hover-text-color);border-color:var(--el-button-hover-border-color);background-color:var(--el-button-hover-bg-color);outline:0}.el-button:active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button>span{display:inline-flex;align-items:center}.el-button+.el-button{margin-left:12px}.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button.is-disabled,.el-button.is-disabled:focus,.el-button.is-disabled:hover{color:var(--el-button-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--el-button-disabled-bg-color);border-color:var(--el-button-disabled-border-color)}.el-button.is-loading{position:relative;pointer-events:none}.el-button.is-loading:before{z-index:1;pointer-events:none;content:"";position:absolute;left:-1px;top:-1px;right:-1px;bottom:-1px;border-radius:inherit;background-color:var(--el-mask-color-extra-light)}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px}.el-button.is-text{color:var(--el-button-text-color);border:0 solid transparent;background-color:transparent}.el-button.is-text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important}.el-button.is-text:not(.is-disabled):focus,.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:focus,.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{border-color:transparent;color:var(--el-button-text-color);background:0 0;padding:2px;height:auto}.el-button.is-link:focus,.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button.is-link:not(.is-disabled):focus,.el-button.is-link:not(.is-disabled):hover{border-color:transparent;background-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color);border-color:transparent;background-color:transparent}.el-button--text{border-color:transparent;background:0 0;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button--text:not(.is-disabled):focus,.el-button--text:not(.is-disabled):hover{color:var(--el-color-primary-light-3);border-color:transparent;background-color:transparent}.el-button--text:not(.is-disabled):active{color:var(--el-color-primary-dark-2);border-color:transparent;background-color:transparent}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{color:var(--el-color-primary-light-5);background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{color:var(--el-color-success-light-5);background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{color:var(--el-color-warning-light-5);background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{color:var(--el-color-danger-light-5);background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{color:var(--el-color-info-light-5);background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8)}.el-button--large{--el-button-size:40px;height:var(--el-button-size);padding:12px 19px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{width:var(--el-button-size);padding:12px}.el-button--small{--el-button-size:24px;height:var(--el-button-size);padding:5px 11px;font-size:12px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{width:var(--el-button-size);padding:5px}.el-icon-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@-webkit-keyframes rotating{0%{transform:rotateZ(0)}100%{transform:rotateZ(360deg)}}@keyframes rotating{0%{transform:rotateZ(0)}100%{transform:rotateZ(360deg)}}.el-icon{--color:inherit;height:1em;width:1em;line-height:1em;display:inline-flex;justify-content:center;align-items:center;position:relative;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.el-link{--el-link-font-size:var(--el-font-size-base);--el-link-font-weight:var(--el-font-weight-primary);--el-link-text-color:var(--el-text-color-regular);--el-link-hover-text-color:var(--el-color-primary);--el-link-disabled-text-color:var(--el-text-color-placeholder)}.el-link{display:inline-flex;flex-direction:row;align-items:center;justify-content:center;vertical-align:middle;position:relative;text-decoration:none;outline:0;cursor:pointer;padding:0;font-size:var(--el-link-font-size);font-weight:var(--el-link-font-weight);color:var(--el-link-text-color)}.el-link:hover{color:var(--el-link-hover-text-color)}.el-link.is-underline:hover:after{content:"";position:absolute;left:0;right:0;height:0;bottom:0;border-bottom:1px solid var(--el-link-hover-text-color)}.el-link.is-disabled{color:var(--el-link-disabled-text-color);cursor:not-allowed}.el-link [class*=el-icon-]+span{margin-left:5px}.el-link.el-link--default:after{border-color:var(--el-link-hover-text-color)}.el-link__inner{display:inline-flex;justify-content:center;align-items:center}.el-link.el-link--primary{--el-link-text-color:var(--el-color-primary);--el-link-hover-text-color:var(--el-color-primary-light-3);--el-link-disabled-text-color:var(--el-color-primary-light-5)}.el-link.el-link--primary:after{border-color:var(--el-link-text-color)}.el-link.el-link--primary.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--success{--el-link-text-color:var(--el-color-success);--el-link-hover-text-color:var(--el-color-success-light-3);--el-link-disabled-text-color:var(--el-color-success-light-5)}.el-link.el-link--success:after{border-color:var(--el-link-text-color)}.el-link.el-link--success.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--warning{--el-link-text-color:var(--el-color-warning);--el-link-hover-text-color:var(--el-color-warning-light-3);--el-link-disabled-text-color:var(--el-color-warning-light-5)}.el-link.el-link--warning:after{border-color:var(--el-link-text-color)}.el-link.el-link--warning.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--danger{--el-link-text-color:var(--el-color-danger);--el-link-hover-text-color:var(--el-color-danger-light-3);--el-link-disabled-text-color:var(--el-color-danger-light-5)}.el-link.el-link--danger:after{border-color:var(--el-link-text-color)}.el-link.el-link--danger.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--error{--el-link-text-color:var(--el-color-error);--el-link-hover-text-color:var(--el-color-error-light-3);--el-link-disabled-text-color:var(--el-color-error-light-5)}.el-link.el-link--error:after{border-color:var(--el-link-text-color)}.el-link.el-link--error.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--info{--el-link-text-color:var(--el-color-info);--el-link-hover-text-color:var(--el-color-info-light-3);--el-link-disabled-text-color:var(--el-color-info-light-5)}.el-link.el-link--info:after{border-color:var(--el-link-text-color)}.el-link.el-link--info.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-avatar{--el-avatar-text-color:var(--el-color-white);--el-avatar-bg-color:var(--el-text-color-disabled);--el-avatar-text-size:14px;--el-avatar-icon-size:18px;--el-avatar-border-radius:var(--el-border-radius-base);--el-avatar-size-large:56px;--el-avatar-size:40px;--el-avatar-size-small:24px;--el-avatar-size:40px;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;text-align:center;overflow:hidden;color:var(--el-avatar-text-color);background:var(--el-avatar-bg-color);width:var(--el-avatar-size);height:var(--el-avatar-size);font-size:var(--el-avatar-text-size)}.el-avatar>img{display:block;height:100%}.el-avatar--circle{border-radius:50%}.el-avatar--square{border-radius:var(--el-avatar-border-radius)}.el-avatar--icon{font-size:var(--el-avatar-icon-size)}.el-avatar--small{--el-avatar-size:24px}.el-avatar--large{--el-avatar-size:56px}
.el-table .warning-row {
  --el-table-tr-bg-color: var(--el-color-warning-light-9);
}
.el-table .success-row {
  --el-table-tr-bg-color: var(--el-color-success-light-9);
}
.el-table .info-row {
  --el-table-tr-bg-color: var(--el-color-info-light-9);
}
.el-table .danger-row {
  --el-table-tr-bg-color: var(--el-color-danger-light-9);
}
.el-table .primary-row {
  --el-table-tr-bg-color: var(--el-color-primary-light-9);
}

/*鼠标悬停文章效果*/
.opt-icon {
  cursor: pointer;
}
.opt-icon :first-child {
  max-height: 150px;
}
.my-col :first-child {
  max-height: 150px;
}
.dialog-div .el-dialog__body {
  font-size: var(--el-dialog-content-font-size);
  word-break: break-all;
  color: #333333;
  background-color: #f5f5f5;
  padding: 20px;
}
.el-dialog__body {
  color: #333333;
  background-color: #f5f5f5;
}
.status {
  color: #ffffff;
  display: inline-block;
  max-width: 80%;
  padding-left: 10px;
  padding-right: 10px;
}
.data-col .cell {
  color: rgb(121, 121, 121);
  font-size: 13px;
}
.un-release-status {
  background-color: #f0ad4e;
}
.release-status {
  background-color: #a4a4a4;
}
.edit-container {
  display: flex;
  flex-direction: column;
}
.edit-container > div {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
}
.edit-container > div > span {
  min-width: 100px; /* 设置文本的最小宽度 */
  margin-right: 10px; /* 设置文本和输入框之间的间距 */
}
.my-link {
  margin: 15px;
}
.export-container {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px;
}

* {
  margin: 0;
  padding: 0;
}
html {
  height: 100%;
}
body {
  height: 100%;
}
.container {
  /* 使用视口高度作为最小高度 */
  min-height: 100vh;
  background-image: linear-gradient(to right, #999999, #330867);
}
.login-wrapper {
  background-color: bisque;
  width: 358px;
  height: 480px;
  border-radius: 15px;
  padding: 0 50px;
  position: relative;
  left: 50%;
  top: 50%;
  transform: translate(-50%, 25%);
}
.header {
  font-size: 35px;
  font-weight: bold;
  text-align: center;
  line-height: 120px;
}
.input-item {
  margin-bottom: 20px;
  border: 0;
  padding: 10px;
  font-size: 15px;
  height: 60px;
}
.input-item::placeholder {
  text-transform: uppercase;
}
.btn {
  text-align: center;
  padding: 10px;
  width: 100%;
  margin-top: 40px;
  background-image: linear-gradient(to right, #a6c1ee, #fbc2eb);
  color: #fff;
}
.msg {
  text-align: center;
  line-height: 88px;
}
a {
  text-decoration-line: none;
  color: #abc1ee;
}
.el-switch{--el-switch-on-color:var(--el-color-primary);--el-switch-off-color:var(--el-border-color)}.el-switch{display:inline-flex;align-items:center;position:relative;font-size:14px;line-height:20px;height:32px;vertical-align:middle}.el-switch.is-disabled .el-switch__core,.el-switch.is-disabled .el-switch__label{cursor:not-allowed}.el-switch__label{transition:var(--el-transition-duration-fast);height:20px;display:inline-block;font-size:14px;font-weight:500;cursor:pointer;vertical-align:middle;color:var(--el-text-color-primary)}.el-switch__label.is-active{color:var(--el-color-primary)}.el-switch__label--left{margin-right:10px}.el-switch__label--right{margin-left:10px}.el-switch__label *{line-height:1;font-size:14px;display:inline-block}.el-switch__label .el-icon{height:inherit}.el-switch__label .el-icon svg{vertical-align:middle}.el-switch__input{position:absolute;width:0;height:0;opacity:0;margin:0}.el-switch__input:focus-visible~.el-switch__core{outline:2px solid var(--el-switch-on-color);outline-offset:1px}.el-switch__core{margin:0;display:inline-block;position:relative;width:40px;height:20px;border:1px solid var(--el-switch-border-color,var(--el-switch-off-color));outline:0;border-radius:10px;box-sizing:border-box;background:var(--el-switch-off-color);cursor:pointer;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration);vertical-align:middle}.el-switch__core .el-switch__inner{position:absolute;top:1px;left:1px;transition:all var(--el-transition-duration);width:16px;height:16px;display:flex;justify-content:center;align-items:center;left:50%;white-space:nowrap}.el-switch__core .el-switch__inner .is-icon,.el-switch__core .el-switch__inner .is-text{color:var(--el-color-white);transition:opacity var(--el-transition-duration);position:absolute;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-switch__core .el-switch__action{position:absolute;top:1px;left:1px;border-radius:var(--el-border-radius-circle);transition:all var(--el-transition-duration);width:16px;height:16px;background-color:var(--el-color-white);display:flex;justify-content:center;align-items:center;color:var(--el-switch-off-color)}.el-switch__core .el-switch__action .is-icon,.el-switch__core .el-switch__action .is-text{transition:opacity var(--el-transition-duration);position:absolute;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-switch__core .is-text{font-size:12px}.el-switch__core .is-show{opacity:1}.el-switch__core .is-hide{opacity:0}.el-switch.is-checked .el-switch__core{border-color:var(--el-switch-border-color,var(--el-switch-on-color));background-color:var(--el-switch-on-color)}.el-switch.is-checked .el-switch__core .el-switch__action{left:100%;margin-left:calc(-1px - 16px);color:var(--el-switch-on-color)}.el-switch.is-checked .el-switch__core .el-switch__inner{left:50%;white-space:nowrap;margin-left:calc(-1px - 16px)}.el-switch.is-disabled{opacity:.6}.el-switch--wide .el-switch__label.el-switch__label--left span{left:10px}.el-switch--wide .el-switch__label.el-switch__label--right span{right:10px}.el-switch .label-fade-enter-from,.el-switch .label-fade-leave-active{opacity:0}.el-switch--large{font-size:14px;line-height:24px;height:40px}.el-switch--large .el-switch__label{height:24px;font-size:14px}.el-switch--large .el-switch__label *{font-size:14px}.el-switch--large .el-switch__core{width:50px;height:24px;border-radius:12px}.el-switch--large .el-switch__core .el-switch__inner{width:20px;height:20px}.el-switch--large .el-switch__core .el-switch__action{width:20px;height:20px}.el-switch--large.is-checked .el-switch__core .el-switch__action{margin-left:calc(-1px - 20px)}.el-switch--large.is-checked .el-switch__core .el-switch__inner{margin-left:calc(-1px - 20px)}.el-switch--small{font-size:12px;line-height:16px;height:24px}.el-switch--small .el-switch__label{height:16px;font-size:12px}.el-switch--small .el-switch__label *{font-size:12px}.el-switch--small .el-switch__core{width:30px;height:16px;border-radius:8px}.el-switch--small .el-switch__core .el-switch__inner{width:12px;height:12px}.el-switch--small .el-switch__core .el-switch__action{width:12px;height:12px}.el-switch--small.is-checked .el-switch__core .el-switch__action{margin-left:calc(-1px - 12px)}.el-switch--small.is-checked .el-switch__core .el-switch__inner{margin-left:calc(-1px - 12px)}</style>
</head>
<body>
<div id="app"></div>

</body>
</html>
